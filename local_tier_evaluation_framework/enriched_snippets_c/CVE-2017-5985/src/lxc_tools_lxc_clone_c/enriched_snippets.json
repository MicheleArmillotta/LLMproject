[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_clone.c",
    "lines": "112-217",
    "snippet": "int main(int argc, char *argv[])\n{\n\tstruct lxc_container *c1 = NULL, *c2 = NULL;\n\tint snapshot = 0, keepname = 0, keepmac = 0, rename = 0;\n\tint flags = 0, option_index;\n\tuint64_t newsize = 0;\n\tchar *bdevtype = NULL, *lxcpath = NULL, *newpath = NULL, *fstype = NULL;\n\tchar *orig = NULL, *new = NULL, *vgname = NULL;\n\tchar **args = NULL;\n\tint c;\n\tbool ret;\n\n\tfprintf(stderr, \"lxc-clone is deprecated in favor of lxc-copy.\\n\\n\");\n\n\tif (argc < 3)\n\t\tusage(argv[0]);\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"sB:L:o:n:v:KMHp:P:Rt:h\", options, &option_index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 's': snapshot = 1; break;\n\t\tcase 'B': bdevtype = optarg; break;\n\t\tcase 'L': newsize = get_fssize(optarg); break;\n\t\tcase 'o': orig = optarg; break;\n\t\tcase 'n': new = optarg; break;\n\t\tcase 'v': vgname = optarg; break;\n\t\tcase 'K': keepname = 1; break;\n\t\tcase 'M': keepmac = 1; break;\n\t\tcase 'p': lxcpath = optarg; break;\n\t\tcase 'P': newpath = optarg; break;\n\t\tcase 'R': rename = 1; break;\n\t\tcase 't': fstype = optarg; break;\n\t\tcase 'h': usage(argv[0]);\n\t\tdefault: break;\n\t\t}\n\t}\n    if (optind < argc && !orig)\n\t\torig = argv[optind++];\n    if (optind < argc && !new)\n\t\tnew = argv[optind++];\n\tif (optind < argc)\n\t\t/* arguments for the clone hook */\n\t\targs = &argv[optind];\n\tif (!new || !orig) {\n\t\tprintf(\"Error: you must provide orig and new names\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tif (snapshot)  flags |= LXC_CLONE_SNAPSHOT;\n\tif (keepname)  flags |= LXC_CLONE_KEEPNAME;\n\tif (keepmac)   flags |= LXC_CLONE_KEEPMACADDR;\n\n\t// vgname and fstype could be supported by sending them through the\n\t// bdevdata.  However, they currently are not yet.  I'm not convinced\n\t// they are worthwhile.\n\tif (vgname) {\n\t\tprintf(\"Error: vgname not supported\\n\");\n\t\tusage(argv[0]);\n\t}\n\tif (fstype) {\n\t\tprintf(\"Error: fstype not supported\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tc1 = lxc_container_new(orig, lxcpath);\n\tif (!c1)\n\t\texit(EXIT_FAILURE);\n\n\tif (!c1->may_control(c1)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", orig);\n\t\tlxc_container_put(c1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!c1->is_defined(c1)) {\n\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", orig);\n\t\tlxc_container_put(c1);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (rename) {\n\t\tret = c1->rename(c1, new);\n\t\tif (!ret) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Error: Renaming container %s to %s failed\\n\",\n\t\t\t\tc1->name, new);\n\t\t\tlxc_container_put(c1);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\tc2 = c1->clone(c1, new, newpath, flags, bdevtype, NULL, newsize,\n\t\t\t       args);\n\t\tif (c2 == NULL) {\n\t\t\tlxc_container_put(c1);\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tprintf(\"Created container %s as %s of %s\\n\", new,\n\t\t       snapshot ? \"snapshot\" : \"copy\", orig);\n\t\tlxc_container_put(c2);\n\t}\n\tlxc_container_put(c1);\n\n\texit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"config.h\"",
      "#include \"log.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct option options[] = {\n\t{ \"snapshot\", no_argument, 0, 's'},\n\t{ \"backingstore\", required_argument, 0, 'B'},\n\t{ \"size\", required_argument, 0, 'L'},\n\t{ \"orig\", required_argument, 0, 'o'},\n\t{ \"new\", required_argument, 0, 'n'},\n\t{ \"vgname\", required_argument, 0, 'v'},\n\t{ \"rename\", no_argument, 0, 'R'},\n\t{ \"keepname\", no_argument, 0, 'K'},\n\t{ \"keepmac\", no_argument, 0, 'M'},\n\t{ \"lxcpath\", required_argument, 0, 'p'},\n\t{ \"newpath\", required_argument, 0, 'P'},\n\t{ \"fstype\", required_argument, 0, 't'},\n\t{ \"help\", no_argument, 0, 'h'},\n\t{ 0, 0, 0, 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c1"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Created container %s as %s of %s\\n\"",
            "new",
            "snapshot ? \"snapshot\" : \"copy\"",
            "orig"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clone failed\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c1->clone",
          "args": [
            "c1",
            "new",
            "newpath",
            "flags",
            "bdevtype",
            "NULL",
            "newsize",
            "args"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: Renaming container %s to %s failed\\n\"",
            "c1->name",
            "new"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c1->rename",
          "args": [
            "c1",
            "new"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: container %s is not defined\\n\"",
            "orig"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c1->is_defined",
          "args": [
            "c1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Insufficent privileges to control %s\\n\"",
            "orig"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c1->may_control",
          "args": [
            "c1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "orig",
            "lxcpath"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "argv[0]"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_clone.c",
          "lines": "75-93",
          "snippet": "static void usage(const char *me)\n{\n\tprintf(\"Usage: %s [-s] [-B backingstore] [-L size[unit]] [-K] [-M] [-H]\\n\", me);\n\tprintf(\"          [-p lxcpath] [-P newlxcpath] orig new\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -s: snapshot rather than copy\\n\");\n\tprintf(\"  -B: use specified new backingstore.  Default is the same as\\n\");\n\tprintf(\"      the original.  Options include aufs, btrfs, lvm, overlayfs, \\n\");\n\tprintf(\"      dir and loop\\n\");\n\tprintf(\"  -L: for blockdev-backed backingstore, use specified size * specified\\n\");\n\tprintf(\"      unit. Default size is the size of the source blockdev, default\\n\");\n\tprintf(\"      unit is MB\\n\");\n\tprintf(\"  -K: Keep name - do not change the container name\\n\");\n\tprintf(\"  -M: Keep macaddr - do not choose a random new mac address\\n\");\n\tprintf(\"  -p: use container orig from custom lxcpath\\n\");\n\tprintf(\"  -P: create container new in custom lxcpath\\n\");\n\tprintf(\"  -R: rename existing container\\n\");\n\texit(EXIT_SUCCESS);\n}",
          "includes": [
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"config.h\"",
            "#include \"log.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"config.h\"\n#include \"log.h\"\n#include <lxc/lxccontainer.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n\nstatic void usage(const char *me)\n{\n\tprintf(\"Usage: %s [-s] [-B backingstore] [-L size[unit]] [-K] [-M] [-H]\\n\", me);\n\tprintf(\"          [-p lxcpath] [-P newlxcpath] orig new\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -s: snapshot rather than copy\\n\");\n\tprintf(\"  -B: use specified new backingstore.  Default is the same as\\n\");\n\tprintf(\"      the original.  Options include aufs, btrfs, lvm, overlayfs, \\n\");\n\tprintf(\"      dir and loop\\n\");\n\tprintf(\"  -L: for blockdev-backed backingstore, use specified size * specified\\n\");\n\tprintf(\"      unit. Default size is the size of the source blockdev, default\\n\");\n\tprintf(\"      unit is MB\\n\");\n\tprintf(\"  -K: Keep name - do not change the container name\\n\");\n\tprintf(\"  -M: Keep macaddr - do not choose a random new mac address\\n\");\n\tprintf(\"  -p: use container orig from custom lxcpath\\n\");\n\tprintf(\"  -P: create container new in custom lxcpath\\n\");\n\tprintf(\"  -R: rename existing container\\n\");\n\texit(EXIT_SUCCESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: fstype not supported\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: vgname not supported\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: you must provide orig and new names\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fssize",
          "args": [
            "optarg"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "get_fssize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_clone.c",
          "lines": "42-73",
          "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"config.h\"",
            "#include \"log.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"config.h\"\n#include \"log.h\"\n#include <lxc/lxccontainer.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"sB:L:o:n:v:KMHp:P:Rt:h\"",
            "options",
            "&option_index"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lxc-clone is deprecated in favor of lxc-copy.\\n\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"config.h\"\n#include \"log.h\"\n#include <lxc/lxccontainer.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n\nstatic struct option options[] = {\n\t{ \"snapshot\", no_argument, 0, 's'},\n\t{ \"backingstore\", required_argument, 0, 'B'},\n\t{ \"size\", required_argument, 0, 'L'},\n\t{ \"orig\", required_argument, 0, 'o'},\n\t{ \"new\", required_argument, 0, 'n'},\n\t{ \"vgname\", required_argument, 0, 'v'},\n\t{ \"rename\", no_argument, 0, 'R'},\n\t{ \"keepname\", no_argument, 0, 'K'},\n\t{ \"keepmac\", no_argument, 0, 'M'},\n\t{ \"lxcpath\", required_argument, 0, 'p'},\n\t{ \"newpath\", required_argument, 0, 'P'},\n\t{ \"fstype\", required_argument, 0, 't'},\n\t{ \"help\", no_argument, 0, 'h'},\n\t{ 0, 0, 0, 0 },\n};\n\nint main(int argc, char *argv[])\n{\n\tstruct lxc_container *c1 = NULL, *c2 = NULL;\n\tint snapshot = 0, keepname = 0, keepmac = 0, rename = 0;\n\tint flags = 0, option_index;\n\tuint64_t newsize = 0;\n\tchar *bdevtype = NULL, *lxcpath = NULL, *newpath = NULL, *fstype = NULL;\n\tchar *orig = NULL, *new = NULL, *vgname = NULL;\n\tchar **args = NULL;\n\tint c;\n\tbool ret;\n\n\tfprintf(stderr, \"lxc-clone is deprecated in favor of lxc-copy.\\n\\n\");\n\n\tif (argc < 3)\n\t\tusage(argv[0]);\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"sB:L:o:n:v:KMHp:P:Rt:h\", options, &option_index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 's': snapshot = 1; break;\n\t\tcase 'B': bdevtype = optarg; break;\n\t\tcase 'L': newsize = get_fssize(optarg); break;\n\t\tcase 'o': orig = optarg; break;\n\t\tcase 'n': new = optarg; break;\n\t\tcase 'v': vgname = optarg; break;\n\t\tcase 'K': keepname = 1; break;\n\t\tcase 'M': keepmac = 1; break;\n\t\tcase 'p': lxcpath = optarg; break;\n\t\tcase 'P': newpath = optarg; break;\n\t\tcase 'R': rename = 1; break;\n\t\tcase 't': fstype = optarg; break;\n\t\tcase 'h': usage(argv[0]);\n\t\tdefault: break;\n\t\t}\n\t}\n    if (optind < argc && !orig)\n\t\torig = argv[optind++];\n    if (optind < argc && !new)\n\t\tnew = argv[optind++];\n\tif (optind < argc)\n\t\t/* arguments for the clone hook */\n\t\targs = &argv[optind];\n\tif (!new || !orig) {\n\t\tprintf(\"Error: you must provide orig and new names\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tif (snapshot)  flags |= LXC_CLONE_SNAPSHOT;\n\tif (keepname)  flags |= LXC_CLONE_KEEPNAME;\n\tif (keepmac)   flags |= LXC_CLONE_KEEPMACADDR;\n\n\t// vgname and fstype could be supported by sending them through the\n\t// bdevdata.  However, they currently are not yet.  I'm not convinced\n\t// they are worthwhile.\n\tif (vgname) {\n\t\tprintf(\"Error: vgname not supported\\n\");\n\t\tusage(argv[0]);\n\t}\n\tif (fstype) {\n\t\tprintf(\"Error: fstype not supported\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tc1 = lxc_container_new(orig, lxcpath);\n\tif (!c1)\n\t\texit(EXIT_FAILURE);\n\n\tif (!c1->may_control(c1)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", orig);\n\t\tlxc_container_put(c1);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!c1->is_defined(c1)) {\n\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", orig);\n\t\tlxc_container_put(c1);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (rename) {\n\t\tret = c1->rename(c1, new);\n\t\tif (!ret) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Error: Renaming container %s to %s failed\\n\",\n\t\t\t\tc1->name, new);\n\t\t\tlxc_container_put(c1);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\tc2 = c1->clone(c1, new, newpath, flags, bdevtype, NULL, newsize,\n\t\t\t       args);\n\t\tif (c2 == NULL) {\n\t\t\tlxc_container_put(c1);\n\t\t\tfprintf(stderr, \"clone failed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tprintf(\"Created container %s as %s of %s\\n\", new,\n\t\t       snapshot ? \"snapshot\" : \"copy\", orig);\n\t\tlxc_container_put(c2);\n\t}\n\tlxc_container_put(c1);\n\n\texit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_clone.c",
    "lines": "75-93",
    "snippet": "static void usage(const char *me)\n{\n\tprintf(\"Usage: %s [-s] [-B backingstore] [-L size[unit]] [-K] [-M] [-H]\\n\", me);\n\tprintf(\"          [-p lxcpath] [-P newlxcpath] orig new\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -s: snapshot rather than copy\\n\");\n\tprintf(\"  -B: use specified new backingstore.  Default is the same as\\n\");\n\tprintf(\"      the original.  Options include aufs, btrfs, lvm, overlayfs, \\n\");\n\tprintf(\"      dir and loop\\n\");\n\tprintf(\"  -L: for blockdev-backed backingstore, use specified size * specified\\n\");\n\tprintf(\"      unit. Default size is the size of the source blockdev, default\\n\");\n\tprintf(\"      unit is MB\\n\");\n\tprintf(\"  -K: Keep name - do not change the container name\\n\");\n\tprintf(\"  -M: Keep macaddr - do not choose a random new mac address\\n\");\n\tprintf(\"  -p: use container orig from custom lxcpath\\n\");\n\tprintf(\"  -P: create container new in custom lxcpath\\n\");\n\tprintf(\"  -R: rename existing container\\n\");\n\texit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"config.h\"",
      "#include \"log.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -R: rename existing container\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -P: create container new in custom lxcpath\\n\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -p: use container orig from custom lxcpath\\n\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -M: Keep macaddr - do not choose a random new mac address\\n\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -K: Keep name - do not change the container name\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"      unit is MB\\n\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"      unit. Default size is the size of the source blockdev, default\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -L: for blockdev-backed backingstore, use specified size * specified\\n\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"      dir and loop\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"      the original.  Options include aufs, btrfs, lvm, overlayfs, \\n\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -B: use specified new backingstore.  Default is the same as\\n\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -s: snapshot rather than copy\\n\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"          [-p lxcpath] [-P newlxcpath] orig new\\n\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [-s] [-B backingstore] [-L size[unit]] [-K] [-M] [-H]\\n\"",
            "me"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"config.h\"\n#include \"log.h\"\n#include <lxc/lxccontainer.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n\nstatic void usage(const char *me)\n{\n\tprintf(\"Usage: %s [-s] [-B backingstore] [-L size[unit]] [-K] [-M] [-H]\\n\", me);\n\tprintf(\"          [-p lxcpath] [-P newlxcpath] orig new\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -s: snapshot rather than copy\\n\");\n\tprintf(\"  -B: use specified new backingstore.  Default is the same as\\n\");\n\tprintf(\"      the original.  Options include aufs, btrfs, lvm, overlayfs, \\n\");\n\tprintf(\"      dir and loop\\n\");\n\tprintf(\"  -L: for blockdev-backed backingstore, use specified size * specified\\n\");\n\tprintf(\"      unit. Default size is the size of the source blockdev, default\\n\");\n\tprintf(\"      unit is MB\\n\");\n\tprintf(\"  -K: Keep name - do not change the container name\\n\");\n\tprintf(\"  -M: Keep macaddr - do not choose a random new mac address\\n\");\n\tprintf(\"  -p: use container orig from custom lxcpath\\n\");\n\tprintf(\"  -P: create container new in custom lxcpath\\n\");\n\tprintf(\"  -R: rename existing container\\n\");\n\texit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "get_fssize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_clone.c",
    "lines": "42-73",
    "snippet": "static uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"state.h\"",
      "#include \"conf.h\"",
      "#include \"lxc.h\"",
      "#include \"config.h\"",
      "#include \"log.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <stdint.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <getopt.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev unit size '%c' in '%s', using default size\\n\"",
            "*end",
            "s"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isblank",
          "args": [
            "*end"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid blockdev size '%s', using default size\\n\"",
            "s"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "s",
            "&end",
            "0"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"config.h\"\n#include \"log.h\"\n#include <lxc/lxccontainer.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n\nstatic uint64_t get_fssize(char *s)\n{\n\tuint64_t ret;\n\tchar *end;\n\n\tret = strtoull(s, &end, 0);\n\tif (end == s)\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev size '%s', using default size\\n\", s);\n\t\treturn 0;\n\t}\n\twhile (isblank(*end))\n\t\tend++;\n\tif (*end == '\\0')\n\t\tret *= 1024ULL * 1024ULL; // MB by default\n\telse if (*end == 'b' || *end == 'B')\n\t\tret *= 1ULL;\n\telse if (*end == 'k' || *end == 'K')\n\t\tret *= 1024ULL;\n\telse if (*end == 'm' || *end == 'M')\n\t\tret *= 1024ULL * 1024ULL;\n\telse if (*end == 'g' || *end == 'G')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL;\n\telse if (*end == 't' || *end == 'T')\n\t\tret *= 1024ULL * 1024ULL * 1024ULL * 1024ULL;\n\telse\n\t{\n\t\tfprintf(stderr, \"Invalid blockdev unit size '%c' in '%s', using default size\\n\", *end, s);\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
  }
]