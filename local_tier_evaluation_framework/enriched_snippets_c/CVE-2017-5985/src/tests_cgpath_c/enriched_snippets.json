[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
    "lines": "169-207",
    "snippet": "int main()\n{\n\tint ret = EXIT_FAILURE;\n\n\t/* won't require privilege necessarily once users are classified by\n\t * pam_cgroup */\n\tif (geteuid() != 0) {\n\t\tTSTERR(\"requires privilege\");\n\t\texit(0);\n\t}\n\n\t#if TEST_ALREADY_RUNNING_CT\n\n\t/*\n\t * This is useful for running with valgrind to test for memory\n\t * leaks. The container should already be running, we can't start\n\t * the container ourselves because valgrind gets confused by lxc's\n\t * internal calls to clone.\n\t */\n\tif (test_running_container(NULL, NULL, \"bb01\") < 0)\n\t\tgoto out;\n\tprintf(\"Running container cgroup tests...Passed\\n\");\n\n\t#else\n\n\tif (test_container(NULL, NULL, MYNAME, \"busybox\") < 0)\n\t\tgoto out;\n\tprintf(\"Container creation tests...Passed\\n\");\n\n\tif (test_container(\"/var/lib/lxctest2\", NULL, MYNAME, \"busybox\") < 0)\n\t\tgoto out;\n\tprintf(\"Container creation with LXCPATH tests...Passed\\n\");\n\n\t#endif\n\n\tret = EXIT_SUCCESS;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"commands.h\"",
      "#include \"lxc.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"lxctest1\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Container creation with LXCPATH tests...Passed\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_container",
          "args": [
            "\"/var/lib/lxctest2\"",
            "NULL",
            "MYNAME",
            "\"busybox\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "test_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
          "lines": "121-167",
          "snippet": "static int test_container(const char *lxcpath,\n\t\t\t  const char *group, const char *name,\n\t\t\t  const char *template)\n{\n\tint ret;\n\tstruct lxc_container *c = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\tret = -1;\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (c->is_defined(c)) {\n\t\tc->stop(c);\n\t\tc->destroy(c);\n\t\tc = lxc_container_new(name, lxcpath);\n\t}\n\tc->set_config_item(c, \"lxc.network.type\", \"empty\");\n\tif (!c->createl(c, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\tc->load_config(c, NULL);\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out3;\n\t}\n\n\tret = test_running_container(lxcpath, group, name);\n\n\tc->stop(c);\nout3:\n\tc->destroy(c);\nout2:\n\tlxc_container_put(c);\nout1:\n\treturn ret;\n}",
          "includes": [
            "#include \"commands.h\"",
            "#include \"lxc.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\nstatic int test_container(const char *lxcpath,\n\t\t\t  const char *group, const char *name,\n\t\t\t  const char *template)\n{\n\tint ret;\n\tstruct lxc_container *c = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\tret = -1;\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (c->is_defined(c)) {\n\t\tc->stop(c);\n\t\tc->destroy(c);\n\t\tc = lxc_container_new(name, lxcpath);\n\t}\n\tc->set_config_item(c, \"lxc.network.type\", \"empty\");\n\tif (!c->createl(c, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\tc->load_config(c, NULL);\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out3;\n\t}\n\n\tret = test_running_container(lxcpath, group, name);\n\n\tc->stop(c);\nout3:\n\tc->destroy(c);\nout2:\n\tlxc_container_put(c);\nout1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Container creation tests...Passed\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Running container cgroup tests...Passed\\n\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_running_container",
          "args": [
            "NULL",
            "NULL",
            "\"bb01\""
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "test_running_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
          "lines": "48-119",
          "snippet": "static int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}",
          "includes": [
            "#include \"commands.h\"",
            "#include \"lxc.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\nstatic int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"requires privilege\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"lxctest1\"\n\nint main()\n{\n\tint ret = EXIT_FAILURE;\n\n\t/* won't require privilege necessarily once users are classified by\n\t * pam_cgroup */\n\tif (geteuid() != 0) {\n\t\tTSTERR(\"requires privilege\");\n\t\texit(0);\n\t}\n\n\t#if TEST_ALREADY_RUNNING_CT\n\n\t/*\n\t * This is useful for running with valgrind to test for memory\n\t * leaks. The container should already be running, we can't start\n\t * the container ourselves because valgrind gets confused by lxc's\n\t * internal calls to clone.\n\t */\n\tif (test_running_container(NULL, NULL, \"bb01\") < 0)\n\t\tgoto out;\n\tprintf(\"Running container cgroup tests...Passed\\n\");\n\n\t#else\n\n\tif (test_container(NULL, NULL, MYNAME, \"busybox\") < 0)\n\t\tgoto out;\n\tprintf(\"Container creation tests...Passed\\n\");\n\n\tif (test_container(\"/var/lib/lxctest2\", NULL, MYNAME, \"busybox\") < 0)\n\t\tgoto out;\n\tprintf(\"Container creation with LXCPATH tests...Passed\\n\");\n\n\t#endif\n\n\tret = EXIT_SUCCESS;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "test_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
    "lines": "121-167",
    "snippet": "static int test_container(const char *lxcpath,\n\t\t\t  const char *group, const char *name,\n\t\t\t  const char *template)\n{\n\tint ret;\n\tstruct lxc_container *c = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\tret = -1;\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (c->is_defined(c)) {\n\t\tc->stop(c);\n\t\tc->destroy(c);\n\t\tc = lxc_container_new(name, lxcpath);\n\t}\n\tc->set_config_item(c, \"lxc.network.type\", \"empty\");\n\tif (!c->createl(c, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\tc->load_config(c, NULL);\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out3;\n\t}\n\n\tret = test_running_container(lxcpath, group, name);\n\n\tc->stop(c);\nout3:\n\tc->destroy(c);\nout2:\n\tlxc_container_put(c);\nout1:\n\treturn ret;\n}",
    "includes": [
      "#include \"commands.h\"",
      "#include \"lxc.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->destroy",
          "args": [
            "c"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_running_container",
          "args": [
            "lxcpath",
            "group",
            "name"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "test_running_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
          "lines": "48-119",
          "snippet": "static int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}",
          "includes": [
            "#include \"commands.h\"",
            "#include \"lxc.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\nstatic int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"starting container %s\"",
            "name"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->startl",
          "args": [
            "c",
            "0",
            "NULL"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->want_daemonize",
          "args": [
            "c",
            "true"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"creating container %s\"",
            "name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->createl",
          "args": [
            "c",
            "template",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.network.type\"",
            "\"empty\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->destroy",
          "args": [
            "c"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"instantiating container %s\"",
            "name"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"failed to mkdir %s %s\"",
            "lxcpath",
            "strerror(errno)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "lxcpath",
            "0755"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\nstatic int test_container(const char *lxcpath,\n\t\t\t  const char *group, const char *name,\n\t\t\t  const char *template)\n{\n\tint ret;\n\tstruct lxc_container *c = NULL;\n\n\tif (lxcpath) {\n\t\tret = mkdir(lxcpath, 0755);\n\t\tif (ret < 0 && errno != EEXIST) {\n\t\t\tTSTERR(\"failed to mkdir %s %s\", lxcpath, strerror(errno));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\tret = -1;\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"instantiating container %s\", name);\n\t\tgoto out1;\n\t}\n\tif (c->is_defined(c)) {\n\t\tc->stop(c);\n\t\tc->destroy(c);\n\t\tc = lxc_container_new(name, lxcpath);\n\t}\n\tc->set_config_item(c, \"lxc.network.type\", \"empty\");\n\tif (!c->createl(c, template, NULL, NULL, 0, NULL)) {\n\t\tTSTERR(\"creating container %s\", name);\n\t\tgoto out2;\n\t}\n\tc->load_config(c, NULL);\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tTSTERR(\"starting container %s\", name);\n\t\tgoto out3;\n\t}\n\n\tret = test_running_container(lxcpath, group, name);\n\n\tc->stop(c);\nout3:\n\tc->destroy(c);\nout2:\n\tlxc_container_put(c);\nout1:\n\treturn ret;\n}"
  },
  {
    "function_name": "test_running_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/cgpath.c",
    "lines": "48-119",
    "snippet": "static int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}",
    "includes": [
      "#include \"commands.h\"",
      "#include \"lxc.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgrelpath"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cgroup_set failed\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_set",
          "args": [
            "\"memory.soft_limit_in_bytes\"",
            "value_save",
            "c->name",
            "c->config_path"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "186-191",
          "snippet": "int lxc_cgroup_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tif (ops)\n\t\treturn ops->set(filename, value, name, lxcpath);\n\treturn -1;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nint lxc_cgroup_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tif (ops)\n\t\treturn ops->set(filename, value, name, lxcpath);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cgroup_set_bypath failed to set value >%s<\"",
            "value"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"536870912\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cgroup_get failed\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_get",
          "args": [
            "\"memory.soft_limit_in_bytes\"",
            "value",
            "sizeof(value)",
            "c->name",
            "c->config_path"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "193-198",
          "snippet": "int lxc_cgroup_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tif (ops)\n\t\treturn ops->get(filename, value, len, name, lxcpath);\n\treturn -1;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nint lxc_cgroup_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tif (ops)\n\t\treturn ops->get(filename, value, len, name, lxcpath);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cgroup_set failed %d %d\"",
            "ret",
            "errno"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "value_save",
            "value"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cgroup_get failed\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cmd_get_cgroup_path %s not in %s\"",
            "relpath",
            "cgrelpath"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cgrelpath",
            "relpath"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"lxc_cmd_get_cgroup_path returned NULL\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "c->name",
            "c->config_path",
            "\"freezer\""
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"container %s does not exist\"",
            "name"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSTERR",
          "args": [
            "\"container %s couldn't instantiate\"",
            "name"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "relpath",
            "\"%s/%s\"",
            "group ? group : \"lxc\"",
            "name"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"commands.h\"\n#include \"lxc.h\"\n#include \"cgroup.h\"\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <lxc/lxccontainer.h>\n\nstatic int test_running_container(const char *lxcpath,\n\t\t\t\t  const char *group, const char *name)\n{\n\tint ret = -1;\n\tstruct lxc_container *c = NULL;\n\tchar *cgrelpath;\n\tchar  relpath[PATH_MAX+1];\n\tchar  value[NAME_MAX], value_save[NAME_MAX];\n\n\tsprintf(relpath, \"%s/%s\", group ? group : \"lxc\", name);\n\n\tif ((c = lxc_container_new(name, lxcpath)) == NULL) {\n\t\tTSTERR(\"container %s couldn't instantiate\", name);\n\t\tgoto err1;\n\t}\n\tif (!c->is_defined(c)) {\n\t\tTSTERR(\"container %s does not exist\", name);\n\t\tgoto err2;\n\t}\n\n\tcgrelpath = lxc_cmd_get_cgroup_path(c->name, c->config_path, \"freezer\");\n\tif (!cgrelpath) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path returned NULL\");\n\t\tgoto err2;\n\t}\n\tif (!strstr(cgrelpath, relpath)) {\n\t\tTSTERR(\"lxc_cmd_get_cgroup_path %s not in %s\", relpath, cgrelpath);\n\t\tgoto err3;\n\t}\n\n\t/* test get/set value using memory.soft_limit_in_bytes file */\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tstrcpy(value_save, value);\n\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", \"512M\", c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed %d %d\", ret, errno);\n\t\tgoto err3;\n\t}\n\tret = lxc_cgroup_get(\"memory.soft_limit_in_bytes\", value, sizeof(value),\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_get failed\");\n\t\tgoto err3;\n\t}\n\tif (strcmp(value, \"536870912\\n\")) {\n\t\tTSTERR(\"lxc_cgroup_set_bypath failed to set value >%s<\", value);\n\t\tgoto err3;\n\t}\n\n\t/* restore original value */\n\tret = lxc_cgroup_set(\"memory.soft_limit_in_bytes\", value_save,\n\t\t\t     c->name, c->config_path);\n\tif (ret < 0) {\n\t\tTSTERR(\"lxc_cgroup_set failed\");\n\t\tgoto err3;\n\t}\n\n\tret = 0;\n\nerr3:\n\tfree(cgrelpath);\nerr2:\n\tlxc_container_put(c);\nerr1:\n\treturn ret;\n}"
  }
]