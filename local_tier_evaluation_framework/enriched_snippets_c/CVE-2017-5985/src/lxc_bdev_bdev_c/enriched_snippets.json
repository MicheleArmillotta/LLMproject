[
  {
    "function_name": "is_valid_bdev_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "975-988",
    "snippet": "bool is_valid_bdev_type(const char *type)\n{\n\tif (strcmp(type, \"dir\") == 0 ||\n\t\t\tstrcmp(type, \"btrfs\") == 0 ||\n\t\t\tstrcmp(type, \"aufs\") == 0 ||\n\t\t\tstrcmp(type, \"loop\") == 0 ||\n\t\t\tstrcmp(type, \"lvm\") == 0 ||\n\t\t\tstrcmp(type, \"nbd\") == 0 ||\n\t\t\tstrcmp(type, \"overlayfs\") == 0 ||\n\t\t\tstrcmp(type, \"rbd\") == 0 ||\n\t\t\tstrcmp(type, \"zfs\") == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"zfs\""
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"rbd\""
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"overlayfs\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"nbd\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"lvm\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"loop\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"aufs\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"btrfs\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"dir\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nbool is_valid_bdev_type(const char *type)\n{\n\tif (strcmp(type, \"dir\") == 0 ||\n\t\t\tstrcmp(type, \"btrfs\") == 0 ||\n\t\t\tstrcmp(type, \"aufs\") == 0 ||\n\t\t\tstrcmp(type, \"loop\") == 0 ||\n\t\t\tstrcmp(type, \"lvm\") == 0 ||\n\t\t\tstrcmp(type, \"nbd\") == 0 ||\n\t\t\tstrcmp(type, \"overlayfs\") == 0 ||\n\t\t\tstrcmp(type, \"rbd\") == 0 ||\n\t\t\tstrcmp(type, \"zfs\") == 0)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "unpriv_snap_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "948-973",
    "snippet": "static bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap)\n{\n\tif (!t) {\n\t\t// new type will be same as original\n\t\t// (unless snap && b->type == dir, in which case it will be\n\t\t// overlayfs -- which is also allowed)\n\t\tif (strcmp(b->type, \"dir\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"aufs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"overlayfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"btrfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"loop\") == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t// unprivileged users can copy and snapshot dir, overlayfs,\n\t// and loop.  In particular, not zfs, btrfs, or lvm.\n\tif (strcmp(t, \"dir\") == 0 ||\n\t\tstrcmp(t, \"aufs\") == 0 ||\n\t\tstrcmp(t, \"overlayfs\") == 0 ||\n\t\tstrcmp(t, \"btrfs\") == 0 ||\n\t\tstrcmp(t, \"loop\") == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);",
      "static bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t",
            "\"loop\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t",
            "\"btrfs\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t",
            "\"overlayfs\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t",
            "\"aufs\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t",
            "\"dir\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"loop\""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"btrfs\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"overlayfs\""
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"aufs\""
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"dir\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\nstatic bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap);\n\nstatic bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap)\n{\n\tif (!t) {\n\t\t// new type will be same as original\n\t\t// (unless snap && b->type == dir, in which case it will be\n\t\t// overlayfs -- which is also allowed)\n\t\tif (strcmp(b->type, \"dir\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"aufs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"overlayfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"btrfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"loop\") == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t// unprivileged users can copy and snapshot dir, overlayfs,\n\t// and loop.  In particular, not zfs, btrfs, or lvm.\n\tif (strcmp(t, \"dir\") == 0 ||\n\t\tstrcmp(t, \"aufs\") == 0 ||\n\t\tstrcmp(t, \"overlayfs\") == 0 ||\n\t\tstrcmp(t, \"btrfs\") == 0 ||\n\t\tstrcmp(t, \"loop\") == 0)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "linkderef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "923-943",
    "snippet": "static char *linkderef(char *path, char *dest)\n{\n\tstruct stat sbuf;\n\tssize_t ret;\n\n\tret = stat(path, &sbuf);\n\tif (ret < 0)\n\t\treturn NULL;\n\tif (!S_ISLNK(sbuf.st_mode))\n\t\treturn path;\n\tret = readlink(path, dest, MAXPATHLEN);\n\tif (ret < 0) {\n\t\tSYSERROR(\"error reading link %s\", path);\n\t\treturn NULL;\n\t} else if (ret >= MAXPATHLEN) {\n\t\tERROR(\"link in %s too long\", path);\n\t\treturn NULL;\n\t}\n\tdest[ret] = '\\0';\n\treturn dest;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"link in %s too long\"",
            "path"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error reading link %s\"",
            "path"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "path",
            "dest",
            "MAXPATHLEN"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sbuf"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *linkderef(char *path, char *dest);\n\nstatic char *linkderef(char *path, char *dest)\n{\n\tstruct stat sbuf;\n\tssize_t ret;\n\n\tret = stat(path, &sbuf);\n\tif (ret < 0)\n\t\treturn NULL;\n\tif (!S_ISLNK(sbuf.st_mode))\n\t\treturn path;\n\tret = readlink(path, dest, MAXPATHLEN);\n\tif (ret < 0) {\n\t\tSYSERROR(\"error reading link %s\", path);\n\t\treturn NULL;\n\t} else if (ret >= MAXPATHLEN) {\n\t\tERROR(\"link in %s too long\", path);\n\t\treturn NULL;\n\t}\n\tdest[ret] = '\\0';\n\treturn dest;\n}"
  },
  {
    "function_name": "find_fstype_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "881-921",
    "snippet": "static int find_fstype_cb(char* buffer, void *data)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} *cbarg = data;\n\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tchar *fstype;\n\n\t/* we don't try 'nodev' entries */\n\tif (strstr(buffer, \"nodev\"))\n\t\treturn 0;\n\n\tfstype = buffer;\n\tfstype += lxc_char_left_gc(fstype, strlen(fstype));\n\tfstype[lxc_char_right_gc(fstype, strlen(fstype))] = '\\0';\n\n\tDEBUG(\"trying to mount '%s'->'%s' with fstype '%s'\",\n\t      cbarg->rootfs, cbarg->target, fstype);\n\n\tif (parse_mntopts(cbarg->options, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn 0;\n\t}\n\n\tif (mount(cbarg->rootfs, cbarg->target, fstype, mntflags, mntdata)) {\n\t\tDEBUG(\"mount failed with error: %s\", strerror(errno));\n\t\tfree(mntdata);\n\t\treturn 0;\n\t}\n\n\tfree(mntdata);\n\n\tINFO(\"mounted '%s' on '%s', with fstype '%s'\",\n\t     cbarg->rootfs, cbarg->target, fstype);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int find_fstype_cb(char *buffer, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"mounted '%s' on '%s', with fstype '%s'\"",
            "cbarg->rootfs",
            "cbarg->target",
            "fstype"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"mount failed with error: %s\"",
            "strerror(errno)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "cbarg->rootfs",
            "cbarg->target",
            "fstype",
            "mntflags",
            "mntdata"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "cbarg->options",
            "&mntflags",
            "&mntdata"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"trying to mount '%s'->'%s' with fstype '%s'\"",
            "cbarg->rootfs",
            "cbarg->target",
            "fstype"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_char_right_gc",
          "args": [
            "fstype",
            "strlen(fstype)"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_char_right_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
          "lines": "79-91",
          "snippet": "int lxc_char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' '  ||\n\t\t    buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' ||\n\t\t    buffer[i] == '\\0')\n\t\t\tcontinue;\n\t\treturn i + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' '  ||\n\t\t    buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' ||\n\t\t    buffer[i] == '\\0')\n\t\t\tcontinue;\n\t\treturn i + 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fstype"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_char_left_gc",
          "args": [
            "fstype",
            "strlen(fstype)"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_char_left_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
          "lines": "67-77",
          "snippet": "int lxc_char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' ||\n\t\t    buffer[i] == '\\t')\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' ||\n\t\t    buffer[i] == '\\t')\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fstype"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buffer",
            "\"nodev\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int find_fstype_cb(char *buffer, void *data);\n\nstatic int find_fstype_cb(char* buffer, void *data)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} *cbarg = data;\n\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tchar *fstype;\n\n\t/* we don't try 'nodev' entries */\n\tif (strstr(buffer, \"nodev\"))\n\t\treturn 0;\n\n\tfstype = buffer;\n\tfstype += lxc_char_left_gc(fstype, strlen(fstype));\n\tfstype[lxc_char_right_gc(fstype, strlen(fstype))] = '\\0';\n\n\tDEBUG(\"trying to mount '%s'->'%s' with fstype '%s'\",\n\t      cbarg->rootfs, cbarg->target, fstype);\n\n\tif (parse_mntopts(cbarg->options, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn 0;\n\t}\n\n\tif (mount(cbarg->rootfs, cbarg->target, fstype, mntflags, mntdata)) {\n\t\tDEBUG(\"mount failed with error: %s\", strerror(errno));\n\t\tfree(mntdata);\n\t\treturn 0;\n\t}\n\n\tfree(mntdata);\n\n\tINFO(\"mounted '%s' on '%s', with fstype '%s'\",\n\t     cbarg->rootfs, cbarg->target, fstype);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "bdev_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "857-874",
    "snippet": "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
      "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdevs[i].ops->detect",
          "args": [
            "src"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bdev_by_name",
          "args": [
            "conf->rootfs.bdev_type"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "get_bdev_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "844-855",
          "snippet": "static const struct bdev_type *get_bdev_by_name(const char *name)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, name) == 0)\n\t\t\treturn &bdevs[i];\n\t}\n\n\tERROR(\"Backing store %s unknown but not caught earlier\\n\", name);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
            "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\n\nstatic const struct bdev_type *get_bdev_by_name(const char *name)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, name) == 0)\n\t\t\treturn &bdevs[i];\n\t}\n\n\tERROR(\"Backing store %s unknown but not caught earlier\\n\", name);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}"
  },
  {
    "function_name": "get_bdev_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "844-855",
    "snippet": "static const struct bdev_type *get_bdev_by_name(const char *name)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, name) == 0)\n\t\t\treturn &bdevs[i];\n\t}\n\n\tERROR(\"Backing store %s unknown but not caught earlier\\n\", name);\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
      "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Backing store %s unknown but not caught earlier\\n\"",
            "name"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdevs[i].name",
            "name"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\n\nstatic const struct bdev_type *get_bdev_by_name(const char *name)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, name) == 0)\n\t\t\treturn &bdevs[i];\n\t}\n\n\tERROR(\"Backing store %s unknown but not caught earlier\\n\", name);\n\treturn NULL;\n}"
  },
  {
    "function_name": "bdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "824-842",
    "snippet": "static struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
      "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bdev",
            "0",
            "sizeof(struct bdev)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct bdev)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdevs[i].name",
            "type"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic struct bdev *bdev_get(const char *type);\n\nstatic struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}"
  },
  {
    "function_name": "do_bdev_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "807-822",
    "snippet": "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs)\n{\n\n\tstruct bdev *bdev = bdev_get(type);\n\tif (!bdev) {\n\t\treturn NULL;\n\t}\n\n\tif (bdev->ops->create(bdev, dest, cname, specs) < 0) {\n\t\t bdev_put(bdev);\n\t\t return NULL;\n\t}\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);",
      "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev->ops->create",
          "args": [
            "bdev",
            "dest",
            "cname",
            "specs"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get",
          "args": [
            "type"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "824-842",
          "snippet": "static struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
            "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic struct bdev *bdev_get(const char *type);\n\nstatic struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\nstatic struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);\nstatic char *linkderef(char *path, char *dest);\n\nstatic struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs)\n{\n\n\tstruct bdev *bdev = bdev_get(type);\n\tif (!bdev) {\n\t\treturn NULL;\n\t}\n\n\tif (bdev->ops->create(bdev, dest, cname, specs) < 0) {\n\t\t bdev_put(bdev);\n\t\t return NULL;\n\t}\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "rootfs_is_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "784-805",
    "snippet": "bool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q->name",
            "\"nbd\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q->name",
            "\"loop\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q->name",
            "\"lvm\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_query",
          "args": [
            "conf",
            "conf->rootfs.path"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "857-874",
          "snippet": "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
            "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "st.st_mode"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "conf->rootfs.path",
            "&st"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "conf->rootfs.path"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "conf->rootfs.path",
            "\"/\""
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "mount_unknown_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "739-782",
    "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to determine fs type for '%s'\"",
            "rootfs"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to parse '%s'\"",
            "fsfile[i]"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_file_for_each_line",
          "args": [
            "fsfile[i]",
            "find_fstype_cb",
            "&cbarg"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_file_for_each_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/parse.c",
          "lines": "38-65",
          "snippet": "int lxc_file_for_each_line(const char *file, lxc_file_cb callback, void *data)\n{\n\tFILE *f;\n\tint err = 0;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", file);\n\t\treturn -1;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\terr = callback(line, data);\n\t\tif (err) {\n\t\t\t// callback rv > 0 means stop here\n\t\t\t// callback rv < 0 means error\n\t\t\tif (err < 0)\n\t\t\t\tERROR(\"Failed to parse config: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\treturn err;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_file_for_each_line(const char *file, lxc_file_cb callback, void *data)\n{\n\tFILE *f;\n\tint err = 0;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", file);\n\t\treturn -1;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\terr = callback(line, data);\n\t\tif (err) {\n\t\t\t// callback rv > 0 means stop here\n\t\t\t// callback rv < 0 means error\n\t\t\tif (err < 0)\n\t\t\t\tERROR(\"Failed to parse config: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fsfile[i]",
            "F_OK"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
  },
  {
    "function_name": "is_blktype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "732-737",
    "snippet": "int is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "b->type",
            "\"lvm\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_mkfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "709-726",
    "snippet": "int do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"mkfs\"",
            "\"mkfs\"",
            "\"-t\"",
            "fstype",
            "path",
            "(char *)NULL"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "null_stdfds",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "null_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1828-1839",
          "snippet": "int null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error forking\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}"
  },
  {
    "function_name": "detect_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "621-707",
    "snippet": "int detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
      "static struct bdev *bdev_get(const char *type);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sp2"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "p[1]",
            "sp2",
            "strlen(sp2)"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sp2"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sp2 + 1",
            "' '"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "l"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&linelen",
            "f"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mounts\"",
            "\"r\""
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linkderef",
          "args": [
            "srcdev",
            "devpath"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "linkderef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "923-943",
          "snippet": "static char *linkderef(char *path, char *dest)\n{\n\tstruct stat sbuf;\n\tssize_t ret;\n\n\tret = stat(path, &sbuf);\n\tif (ret < 0)\n\t\treturn NULL;\n\tif (!S_ISLNK(sbuf.st_mode))\n\t\treturn path;\n\tret = readlink(path, dest, MAXPATHLEN);\n\tif (ret < 0) {\n\t\tSYSERROR(\"error reading link %s\", path);\n\t\treturn NULL;\n\t} else if (ret >= MAXPATHLEN) {\n\t\tERROR(\"link in %s too long\", path);\n\t\treturn NULL;\n\t}\n\tdest[ret] = '\\0';\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *linkderef(char *path, char *dest);\n\nstatic char *linkderef(char *path, char *dest)\n{\n\tstruct stat sbuf;\n\tssize_t ret;\n\n\tret = stat(path, &sbuf);\n\tif (ret < 0)\n\t\treturn NULL;\n\tif (!S_ISLNK(sbuf.st_mode))\n\t\treturn path;\n\tret = readlink(path, dest, MAXPATHLEN);\n\tif (ret < 0) {\n\t\tSYSERROR(\"error reading link %s\", path);\n\t\treturn NULL;\n\t} else if (ret >= MAXPATHLEN) {\n\t\tERROR(\"link in %s too long\", path);\n\t\treturn NULL;\n\t}\n\tdest[ret] = '\\0';\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed mounting %s onto %s to detect fstype\"",
            "srcdev",
            "bdev->dest"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "srcdev",
            "bdev->dest",
            "bdev->mntopts"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"detected fstype %s for %s\"",
            "type",
            "srcdev"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "300-311",
          "snippet": "static bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool wait_for_partition(const char *path)\n{\n\tint count = 0;\n\twhile (count < 5) {\n\t\tif (file_exists(path))\n\t\t\treturn true;\n\t\tsleep(1);\n\t\tcount++;\n\t}\n\tERROR(\"Device %s did not show up after 5 seconds\", path);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"child exited early - fstype not found\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error reading from pipe\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[0]"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "p[0]",
            "type",
            "len - 1"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "type",
            "0",
            "len"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"loop\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nint detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}"
  },
  {
    "function_name": "detach_block_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "607-611",
    "snippet": "void detach_block_device(struct lxc_conf *conf)\n{\n\tif (conf->nbd_idx != -1)\n\t\tdetach_nbd_idx(conf->nbd_idx);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "detach_nbd_idx",
          "args": [
            "conf->nbd_idx"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "detach_nbd_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "78-88",
          "snippet": "void detach_nbd_idx(int idx)\n{\n\tint ret;\n\tchar path[50];\n\n\tret = snprintf(path, 50, \"/dev/nbd%d\", idx);\n\tif (ret < 0 || ret >= 50)\n\t\treturn;\n\n\tnbd_detach(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static int do_attach_nbd(void *d);",
            "static bool nbd_busy(int idx);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic int do_attach_nbd(void *d);\nstatic bool nbd_busy(int idx);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nvoid detach_nbd_idx(int idx)\n{\n\tint ret;\n\tchar path[50];\n\n\tret = snprintf(path, 50, \"/dev/nbd%d\", idx);\n\tif (ret < 0 || ret >= 50)\n\t\treturn;\n\n\tnbd_detach(path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nvoid detach_block_device(struct lxc_conf *conf)\n{\n\tif (conf->nbd_idx != -1)\n\t\tdetach_nbd_idx(conf->nbd_idx);\n}"
  },
  {
    "function_name": "blk_getsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "590-605",
    "snippet": "int blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [
      "#define BLKGETSIZE64 _IOR(0x12, 114, size_t)"
    ],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "BLKGETSIZE64",
            "size"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"loop\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define BLKGETSIZE64 _IOR(0x12, 114, size_t)\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\n\nint blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}"
  },
  {
    "function_name": "bdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "579-585",
    "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bdev"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
  },
  {
    "function_name": "bdev_is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "567-577",
    "snippet": "bool bdev_is_dir(struct lxc_conf *conf, const char *path)\n{\n\tstruct bdev *orig = bdev_init(conf, path, NULL, NULL);\n\tbool ret = false;\n\tif (!orig)\n\t\treturn ret;\n\tif (strcmp(orig->type, \"dir\") == 0)\n\t\tret = true;\n\tbdev_put(orig);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "orig"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"dir\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "conf",
            "path",
            "NULL",
            "NULL"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nbool bdev_is_dir(struct lxc_conf *conf, const char *path)\n{\n\tstruct bdev *orig = bdev_init(conf, path, NULL, NULL);\n\tbool ret = false;\n\tif (!orig)\n\t\treturn ret;\n\tif (strcmp(orig->type, \"dir\") == 0)\n\t\tret = true;\n\tbdev_put(orig);\n\treturn ret;\n}"
  },
  {
    "function_name": "bdev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "533-565",
    "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
      "static struct bdev *bdev_get(const char *type);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"nbd\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dst"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "src"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "mntopts"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bdev",
            "0",
            "sizeof(struct bdev)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct bdev)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_query",
          "args": [
            "conf",
            "src"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "857-874",
          "snippet": "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
            "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src)\n{\n\tsize_t i;\n\n\tif (conf->rootfs.bdev_type)\n\t\treturn get_bdev_by_name(conf->rootfs.bdev_type);\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tint r;\n\t\tr = bdevs[i].ops->detect(src);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\n\tif (i == numbdevs)\n\t\treturn NULL;\n\treturn &bdevs[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdev_destroy_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "513-531",
    "snippet": "int bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int find_fstype_cb(char *buffer, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_destroy",
          "args": [
            "conf"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_destroy_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "513-531",
          "snippet": "int bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "0"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int find_fstype_cb(char *buffer, void *data);\n\nint bdev_destroy_wrapper(void *data)\n{\n\tstruct lxc_conf *conf = data;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\tif (!bdev_destroy(conf))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "bdev_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "497-511",
    "snippet": "bool bdev_destroy(struct lxc_conf *conf)\n{\n\tstruct bdev *r;\n\tbool ret = false;\n\n\tr = bdev_init(conf, conf->rootfs.path, conf->rootfs.mount, NULL);\n\tif (!r)\n\t\treturn ret;\n\n\tif (r->ops->destroy(r) == 0)\n\t\tret = true;\n\tbdev_put(r);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "r"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "r->ops->destroy",
          "args": [
            "r"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "conf",
            "conf->rootfs.path",
            "conf->rootfs.mount",
            "NULL"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool bdev_destroy(struct lxc_conf *conf)\n{\n\tstruct bdev *r;\n\tbool ret = false;\n\n\tr = bdev_init(conf, conf->rootfs.path, conf->rootfs.mount, NULL);\n\tif (!r)\n\t\treturn ret;\n\n\tif (r->ops->destroy(r) == 0)\n\t\tret = true;\n\tbdev_put(r);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bdev_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "463-495",
    "snippet": "struct bdev *bdev_create(const char *dest, const char *type, const char *cname,\n\t\tstruct bdev_specs *specs)\n{\n\tstruct bdev *bdev;\n\tchar *best_options[] = {\"btrfs\", \"zfs\", \"lvm\", \"dir\", \"rbd\", NULL};\n\n\tif (!type)\n\t\treturn do_bdev_create(dest, \"dir\", cname, specs);\n\n\tif (strcmp(type, \"best\") == 0) {\n\t\tint i;\n\t\t// try for the best backing store type, according to our\n\t\t// opinionated preferences\n\t\tfor (i = 0; best_options[i]; i++) {\n\t\t\tif ((bdev = do_bdev_create(dest, best_options[i], cname, specs)))\n\t\t\t\treturn bdev;\n\t\t}\n\t\treturn NULL;  // 'dir' should never fail, so this shouldn't happen\n\t}\n\n\t// -B lvm,dir\n\tif (strchr(type, ',') != NULL) {\n\t\tchar *dup = alloca(strlen(type) + 1), *saveptr = NULL, *token;\n\t\tstrcpy(dup, type);\n\t\tfor (token = strtok_r(dup, \",\", &saveptr); token;\n\t\t\t\ttoken = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif ((bdev = do_bdev_create(dest, token, cname, specs)))\n\t\t\t\treturn bdev;\n\t\t}\n\t}\n\n\treturn do_bdev_create(dest, type, cname, specs);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bdev *bdev_get(const char *type);",
      "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_bdev_create",
          "args": [
            "dest",
            "type",
            "cname",
            "specs"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "do_bdev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "807-822",
          "snippet": "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs)\n{\n\n\tstruct bdev *bdev = bdev_get(type);\n\tif (!bdev) {\n\t\treturn NULL;\n\t}\n\n\tif (bdev->ops->create(bdev, dest, cname, specs) < 0) {\n\t\t bdev_put(bdev);\n\t\t return NULL;\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);",
            "static struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\nstatic struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);\nstatic char *linkderef(char *path, char *dest);\n\nstatic struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs)\n{\n\n\tstruct bdev *bdev = bdev_get(type);\n\tif (!bdev) {\n\t\treturn NULL;\n\t}\n\n\tif (bdev->ops->create(bdev, dest, cname, specs) < 0) {\n\t\t bdev_put(bdev);\n\t\t return NULL;\n\t}\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "dup",
            "\",\"",
            "&saveptr"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dup",
            "type"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(type) + 1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "type"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "','"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"best\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\nstatic struct bdev *do_bdev_create(const char *dest, const char *type,\n\t\tconst char *cname, struct bdev_specs *specs);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_create(const char *dest, const char *type, const char *cname,\n\t\tstruct bdev_specs *specs)\n{\n\tstruct bdev *bdev;\n\tchar *best_options[] = {\"btrfs\", \"zfs\", \"lvm\", \"dir\", \"rbd\", NULL};\n\n\tif (!type)\n\t\treturn do_bdev_create(dest, \"dir\", cname, specs);\n\n\tif (strcmp(type, \"best\") == 0) {\n\t\tint i;\n\t\t// try for the best backing store type, according to our\n\t\t// opinionated preferences\n\t\tfor (i = 0; best_options[i]; i++) {\n\t\t\tif ((bdev = do_bdev_create(dest, best_options[i], cname, specs)))\n\t\t\t\treturn bdev;\n\t\t}\n\t\treturn NULL;  // 'dir' should never fail, so this shouldn't happen\n\t}\n\n\t// -B lvm,dir\n\tif (strchr(type, ',') != NULL) {\n\t\tchar *dup = alloca(strlen(type) + 1), *saveptr = NULL, *token;\n\t\tstrcpy(dup, type);\n\t\tfor (token = strtok_r(dup, \",\", &saveptr); token;\n\t\t\t\ttoken = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif ((bdev = do_bdev_create(dest, token, cname, specs)))\n\t\t\t\treturn bdev;\n\t\t}\n\t}\n\n\treturn do_bdev_create(dest, type, cname, specs);\n}"
  },
  {
    "function_name": "bdev_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "295-450",
    "snippet": "struct bdev *bdev_copy(struct lxc_container *c0, const char *cname,\n\t\tconst char *lxcpath, const char *bdevtype, int flags,\n\t\tconst char *bdevdata, uint64_t newsize, int *needs_rdep)\n{\n\tstruct bdev *orig, *new;\n\tpid_t pid;\n\tint ret;\n\tbool snap = flags & LXC_CLONE_SNAPSHOT;\n\tbool maybe_snap = flags & LXC_CLONE_MAYBE_SNAPSHOT;\n\tbool keepbdevtype = flags & LXC_CLONE_KEEPBDEVTYPE;\n\tconst char *src = c0->lxc_conf->rootfs.path;\n\tconst char *oldname = c0->name;\n\tconst char *oldpath = c0->config_path;\n\tstruct rsync_data data;\n\n\t/* if the container name doesn't show up in the rootfs path, then\n\t * we don't know how to come up with a new name\n\t */\n\tif (strstr(src, oldname) == NULL) {\n\t\tERROR(\"original rootfs path %s doesn't include container name %s\",\n\t\t\tsrc, oldname);\n\t\treturn NULL;\n\t}\n\n\torig = bdev_init(c0->lxc_conf, src, NULL, NULL);\n\tif (!orig) {\n\t\tERROR(\"failed to detect blockdev type for %s\", src);\n\t\treturn NULL;\n\t}\n\n\tif (!orig->dest) {\n\t\tint ret;\n\t\tsize_t len;\n\t\tstruct stat sb;\n\n\t\tlen = strlen(oldpath) + strlen(oldname) + strlen(\"/rootfs\") + 2;\n\t\torig->dest = malloc(len);\n\t\tif (!orig->dest) {\n\t\t\tERROR(\"out of memory\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(orig->dest, len, \"%s/%s/rootfs\", oldpath, oldname);\n\t\tif (ret < 0 || (size_t)ret >= len) {\n\t\t\tERROR(\"rootfs path too long\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = stat(orig->dest, &sb);\n\t\tif (ret < 0 && errno == ENOENT)\n\t\t\tif (mkdir_p(orig->dest, 0755) < 0)\n\t\t\t\tWARN(\"Error creating '%s', continuing.\", orig->dest);\n\t}\n\n\t/*\n\t * special case for snapshot - if caller requested maybe_snapshot and\n\t * keepbdevtype and backing store is directory, then proceed with a copy\n\t * clone rather than returning error\n\t */\n\tif (maybe_snap && keepbdevtype && !bdevtype && !orig->ops->can_snapshot)\n\t\tsnap = false;\n\n\t/*\n\t * If newtype is NULL and snapshot is set, then use overlayfs\n\t */\n\tif (!bdevtype && !keepbdevtype && snap && strcmp(orig->type , \"dir\") == 0)\n\t\tbdevtype = \"overlayfs\";\n\n\tif (am_unpriv() && !unpriv_snap_allowed(orig, bdevtype, snap, maybe_snap)) {\n\t\tERROR(\"Unsupported snapshot type for unprivileged users\");\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\t*needs_rdep = 0;\n\tif (bdevtype && strcmp(orig->type, \"dir\") == 0 &&\n\t\t\t(strcmp(bdevtype, \"aufs\") == 0 ||\n\t\t\t strcmp(bdevtype, \"overlayfs\") == 0)) {\n\t\t*needs_rdep = 1;\n\t} else if (snap && strcmp(orig->type, \"lvm\") == 0 &&\n\t\t\t!lvm_is_thin_volume(orig->src)) {\n\t\t*needs_rdep = 1;\n\t}\n\n\tnew = bdev_get(bdevtype ? bdevtype : orig->type);\n\tif (!new) {\n\t\tERROR(\"no such block device type: %s\", bdevtype ? bdevtype : orig->type);\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\tif (new->ops->clone_paths(orig, new, oldname, cname, oldpath, lxcpath,\n\t\t\t\tsnap, newsize, c0->lxc_conf) < 0) {\n\t\tERROR(\"failed getting pathnames for cloned storage: %s\", src);\n\t\tgoto err;\n\t}\n\n\tif (am_unpriv() && chown_mapped_root(new->src, c0->lxc_conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (snap)\n\t\treturn new;\n\n\t/*\n\t * https://github.com/lxc/lxc/issues/131\n\t * Use btrfs snapshot feature instead of rsync to restore if both orig and new are btrfs\n\t */\n\tif (bdevtype &&\n\t\t\tstrcmp(orig->type, \"btrfs\") == 0 && strcmp(new->type, \"btrfs\") == 0 &&\n\t\t\tbtrfs_same_fs(orig->dest, new->dest) == 0) {\n\t\tif (btrfs_destroy(new) < 0) {\n\t\t\tERROR(\"Error destroying %s subvolume\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (mkdir_p(new->dest, 0755) < 0) {\n\t\t\tERROR(\"Error creating %s directory\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (btrfs_snapshot(orig->dest, new->dest) < 0) {\n\t\t\tERROR(\"Error restoring %s to %s\", orig->dest, new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tbdev_put(orig);\n\t\treturn new;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto err;\n\t}\n\n\tif (pid > 0) {\n\t\tint ret = wait_for_pid(pid);\n\t\tbdev_put(orig);\n\t\tif (ret < 0) {\n\t\t\tbdev_put(new);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn new;\n\t}\n\n\tdata.orig = orig;\n\tdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c0->lxc_conf, rsync_rootfs_wrapper, &data);\n\telse\n\t\tret = rsync_rootfs(&data);\n\n\texit(ret == 0 ? 0 : 1);\n\nerr:\n\tbdev_put(orig);\n\tbdev_put(new);\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
      "static struct bdev *bdev_get(const char *type);",
      "static int find_fstype_cb(char *buffer, void *data);",
      "static char *linkderef(char *path, char *dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "new"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret == 0 ? 0 : 1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsync_rootfs",
          "args": [
            "&data"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rsync_rootfs_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrsync.c",
          "lines": "137-141",
          "snippet": "int rsync_rootfs_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn rsync_rootfs(arg);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <grp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <grp.h>\n\nint rsync_rootfs_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn rsync_rootfs(arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "c0->lxc_conf",
            "rsync_rootfs_wrapper",
            "&data"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"fork\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error restoring %s to %s\"",
            "orig->dest",
            "new->dest"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_snapshot",
          "args": [
            "orig->dest",
            "new->dest"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "299-342",
          "snippet": "int btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_snapshot(const char *orig, const char *new)\n{\n\tint fd = -1, fddst = -1, ret = -1;\n\tstruct btrfs_ioctl_vol_args_v2  args;\n\tchar *newdir, *newname, *newfull = NULL;\n\n\tnewfull = strdup(new);\n\tif (!newfull) {\n\t\tERROR(\"Error: out of memory\");\n\t\tgoto out;\n\t}\n\t// make sure the directory doesn't already exist\n\tif (rmdir(newfull) < 0 && errno != ENOENT) {\n\t\tSYSERROR(\"Error removing empty new rootfs\");\n\t\tgoto out;\n\t}\n\tnewname = basename(newfull);\n\tnewdir = dirname(newfull);\n\tfd = open(orig, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tfddst = open(newdir, O_RDONLY);\n\tif (fddst < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", newdir);\n\t\tgoto out;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\targs.fd = fd;\n\tstrncpy(args.name, newname, BTRFS_SUBVOL_NAME_MAX);\n\targs.name[BTRFS_SUBVOL_NAME_MAX-1] = 0;\n\tret = ioctl(fddst, BTRFS_IOC_SNAP_CREATE_V2, &args);\n\tINFO(\"btrfs: snapshot create ioctl returned %d\", ret);\n\nout:\n\tif (fddst != -1)\n\t\tclose(fddst);\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(newfull);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s directory\"",
            "new->dest"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "new->dest",
            "0755"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying %s subvolume\"",
            "new->dest"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_destroy",
          "args": [
            "new"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "736-739",
          "snippet": "int btrfs_destroy(struct bdev *orig)\n{\n\treturn btrfs_recursive_destroy(orig->src);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_destroy(struct bdev *orig)\n{\n\treturn btrfs_recursive_destroy(orig->src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_same_fs",
          "args": [
            "orig->dest",
            "new->dest"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_same_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "258-297",
          "snippet": "int btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint btrfs_same_fs(const char *orig, const char *new)\n{\n\tint fd_orig = -1, fd_new = -1, ret = -1;\n\tstruct btrfs_ioctl_fs_info_args orig_args, new_args;\n\n\tfd_orig = open(orig, O_RDONLY);\n\tif (fd_orig < 0) {\n\t\tSYSERROR(\"Error opening original rootfs %s\", orig);\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_orig, BTRFS_IOC_FS_INFO, &orig_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", orig);\n\t\tgoto out;\n\t}\n\n\tfd_new = open(new, O_RDONLY);\n\tif (fd_new < 0) {\n\t\tSYSERROR(\"Error opening new container dir %s\", new);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = ioctl(fd_new, BTRFS_IOC_FS_INFO, &new_args);\n\tif (ret < 0) {\n\t\tSYSERROR(\"BTRFS_IOC_FS_INFO %s\", new);\n\t\tgoto out;\n\t}\n\n\tif (strncmp(orig_args.fsid, new_args.fsid, BTRFS_FSID_SIZE) != 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (fd_new != -1)\n\t\tclose(fd_new);\n\tif (fd_orig != -1)\n\t\tclose(fd_orig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new->type",
            "\"btrfs\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"btrfs\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "new->dest"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "new->src",
            "c0->lxc_conf"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed getting pathnames for cloned storage: %s\"",
            "src"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new->ops->clone_paths",
          "args": [
            "orig",
            "new",
            "oldname",
            "cname",
            "oldpath",
            "lxcpath",
            "snap",
            "newsize",
            "c0->lxc_conf"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no such block device type: %s\"",
            "bdevtype ? bdevtype : orig->type"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get",
          "args": [
            "bdevtype ? bdevtype : orig->type"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "824-842",
          "snippet": "static struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};",
            "static const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);",
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type bdevs[] = {\n\t{.name = \"zfs\", .ops = &zfs_ops,},\n\t{.name = \"lvm\", .ops = &lvm_ops,},\n\t{.name = \"rbd\", .ops = &rbd_ops,},\n\t{.name = \"btrfs\", .ops = &btrfs_ops,},\n\t{.name = \"dir\", .ops = &dir_ops,},\n\t{.name = \"aufs\", .ops = &aufs_ops,},\n\t{.name = \"overlayfs\", .ops = &ovl_ops,},\n\t{.name = \"loop\", .ops = &loop_ops,},\n\t{.name = \"nbd\", .ops = &nbd_ops,},\n};\nstatic const size_t numbdevs = sizeof(bdevs) / sizeof(struct bdev_type);\nstatic struct bdev *bdev_get(const char *type);\n\nstatic struct bdev *bdev_get(const char *type)\n{\n\tsize_t i;\n\tstruct bdev *bdev;\n\n\tfor (i = 0; i < numbdevs; i++) {\n\t\tif (strcmp(bdevs[i].name, type) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == numbdevs)\n\t\treturn NULL;\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = bdevs[i].ops;\n\tbdev->type = bdevs[i].name;\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lvm_is_thin_volume",
          "args": [
            "orig->src"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_is_thin_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "223-226",
          "snippet": "int lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"lvm\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdevtype",
            "\"overlayfs\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdevtype",
            "\"aufs\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"dir\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unsupported snapshot type for unprivileged users\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpriv_snap_allowed",
          "args": [
            "orig",
            "bdevtype",
            "snap",
            "maybe_snap"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "unpriv_snap_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "948-973",
          "snippet": "static bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap)\n{\n\tif (!t) {\n\t\t// new type will be same as original\n\t\t// (unless snap && b->type == dir, in which case it will be\n\t\t// overlayfs -- which is also allowed)\n\t\tif (strcmp(b->type, \"dir\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"aufs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"overlayfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"btrfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"loop\") == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t// unprivileged users can copy and snapshot dir, overlayfs,\n\t// and loop.  In particular, not zfs, btrfs, or lvm.\n\tif (strcmp(t, \"dir\") == 0 ||\n\t\tstrcmp(t, \"aufs\") == 0 ||\n\t\tstrcmp(t, \"overlayfs\") == 0 ||\n\t\tstrcmp(t, \"btrfs\") == 0 ||\n\t\tstrcmp(t, \"loop\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);",
            "static bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\nstatic bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap);\n\nstatic bool unpriv_snap_allowed(struct bdev *b, const char *t, bool snap,\n\t\tbool maybesnap)\n{\n\tif (!t) {\n\t\t// new type will be same as original\n\t\t// (unless snap && b->type == dir, in which case it will be\n\t\t// overlayfs -- which is also allowed)\n\t\tif (strcmp(b->type, \"dir\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"aufs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"overlayfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"btrfs\") == 0 ||\n\t\t\t\tstrcmp(b->type, \"loop\") == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t// unprivileged users can copy and snapshot dir, overlayfs,\n\t// and loop.  In particular, not zfs, btrfs, or lvm.\n\tif (strcmp(t, \"dir\") == 0 ||\n\t\tstrcmp(t, \"aufs\") == 0 ||\n\t\tstrcmp(t, \"overlayfs\") == 0 ||\n\t\tstrcmp(t, \"btrfs\") == 0 ||\n\t\tstrcmp(t, \"loop\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"dir\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error creating '%s', continuing.\"",
            "orig->dest"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "orig->dest",
            "&sb"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"rootfs path too long\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "orig->dest",
            "len",
            "\"%s/%s/rootfs\"",
            "oldpath",
            "oldname"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/rootfs\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldname"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldpath"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to detect blockdev type for %s\"",
            "src"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "c0->lxc_conf",
            "src",
            "NULL",
            "NULL"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"original rootfs path %s doesn't include container name %s\"",
            "src",
            "oldname"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "src",
            "oldname"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic int find_fstype_cb(char *buffer, void *data);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_copy(struct lxc_container *c0, const char *cname,\n\t\tconst char *lxcpath, const char *bdevtype, int flags,\n\t\tconst char *bdevdata, uint64_t newsize, int *needs_rdep)\n{\n\tstruct bdev *orig, *new;\n\tpid_t pid;\n\tint ret;\n\tbool snap = flags & LXC_CLONE_SNAPSHOT;\n\tbool maybe_snap = flags & LXC_CLONE_MAYBE_SNAPSHOT;\n\tbool keepbdevtype = flags & LXC_CLONE_KEEPBDEVTYPE;\n\tconst char *src = c0->lxc_conf->rootfs.path;\n\tconst char *oldname = c0->name;\n\tconst char *oldpath = c0->config_path;\n\tstruct rsync_data data;\n\n\t/* if the container name doesn't show up in the rootfs path, then\n\t * we don't know how to come up with a new name\n\t */\n\tif (strstr(src, oldname) == NULL) {\n\t\tERROR(\"original rootfs path %s doesn't include container name %s\",\n\t\t\tsrc, oldname);\n\t\treturn NULL;\n\t}\n\n\torig = bdev_init(c0->lxc_conf, src, NULL, NULL);\n\tif (!orig) {\n\t\tERROR(\"failed to detect blockdev type for %s\", src);\n\t\treturn NULL;\n\t}\n\n\tif (!orig->dest) {\n\t\tint ret;\n\t\tsize_t len;\n\t\tstruct stat sb;\n\n\t\tlen = strlen(oldpath) + strlen(oldname) + strlen(\"/rootfs\") + 2;\n\t\torig->dest = malloc(len);\n\t\tif (!orig->dest) {\n\t\t\tERROR(\"out of memory\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(orig->dest, len, \"%s/%s/rootfs\", oldpath, oldname);\n\t\tif (ret < 0 || (size_t)ret >= len) {\n\t\t\tERROR(\"rootfs path too long\");\n\t\t\tbdev_put(orig);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = stat(orig->dest, &sb);\n\t\tif (ret < 0 && errno == ENOENT)\n\t\t\tif (mkdir_p(orig->dest, 0755) < 0)\n\t\t\t\tWARN(\"Error creating '%s', continuing.\", orig->dest);\n\t}\n\n\t/*\n\t * special case for snapshot - if caller requested maybe_snapshot and\n\t * keepbdevtype and backing store is directory, then proceed with a copy\n\t * clone rather than returning error\n\t */\n\tif (maybe_snap && keepbdevtype && !bdevtype && !orig->ops->can_snapshot)\n\t\tsnap = false;\n\n\t/*\n\t * If newtype is NULL and snapshot is set, then use overlayfs\n\t */\n\tif (!bdevtype && !keepbdevtype && snap && strcmp(orig->type , \"dir\") == 0)\n\t\tbdevtype = \"overlayfs\";\n\n\tif (am_unpriv() && !unpriv_snap_allowed(orig, bdevtype, snap, maybe_snap)) {\n\t\tERROR(\"Unsupported snapshot type for unprivileged users\");\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\t*needs_rdep = 0;\n\tif (bdevtype && strcmp(orig->type, \"dir\") == 0 &&\n\t\t\t(strcmp(bdevtype, \"aufs\") == 0 ||\n\t\t\t strcmp(bdevtype, \"overlayfs\") == 0)) {\n\t\t*needs_rdep = 1;\n\t} else if (snap && strcmp(orig->type, \"lvm\") == 0 &&\n\t\t\t!lvm_is_thin_volume(orig->src)) {\n\t\t*needs_rdep = 1;\n\t}\n\n\tnew = bdev_get(bdevtype ? bdevtype : orig->type);\n\tif (!new) {\n\t\tERROR(\"no such block device type: %s\", bdevtype ? bdevtype : orig->type);\n\t\tbdev_put(orig);\n\t\treturn NULL;\n\t}\n\n\tif (new->ops->clone_paths(orig, new, oldname, cname, oldpath, lxcpath,\n\t\t\t\tsnap, newsize, c0->lxc_conf) < 0) {\n\t\tERROR(\"failed getting pathnames for cloned storage: %s\", src);\n\t\tgoto err;\n\t}\n\n\tif (am_unpriv() && chown_mapped_root(new->src, c0->lxc_conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (snap)\n\t\treturn new;\n\n\t/*\n\t * https://github.com/lxc/lxc/issues/131\n\t * Use btrfs snapshot feature instead of rsync to restore if both orig and new are btrfs\n\t */\n\tif (bdevtype &&\n\t\t\tstrcmp(orig->type, \"btrfs\") == 0 && strcmp(new->type, \"btrfs\") == 0 &&\n\t\t\tbtrfs_same_fs(orig->dest, new->dest) == 0) {\n\t\tif (btrfs_destroy(new) < 0) {\n\t\t\tERROR(\"Error destroying %s subvolume\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (mkdir_p(new->dest, 0755) < 0) {\n\t\t\tERROR(\"Error creating %s directory\", new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tif (btrfs_snapshot(orig->dest, new->dest) < 0) {\n\t\t\tERROR(\"Error restoring %s to %s\", orig->dest, new->dest);\n\t\t\tgoto err;\n\t\t}\n\t\tbdev_put(orig);\n\t\treturn new;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tgoto err;\n\t}\n\n\tif (pid > 0) {\n\t\tint ret = wait_for_pid(pid);\n\t\tbdev_put(orig);\n\t\tif (ret < 0) {\n\t\t\tbdev_put(new);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn new;\n\t}\n\n\tdata.orig = orig;\n\tdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(c0->lxc_conf, rsync_rootfs_wrapper, &data);\n\telse\n\t\tret = rsync_rootfs(&data);\n\n\texit(ret == 0 ? 0 : 1);\n\nerr:\n\tbdev_put(orig);\n\tbdev_put(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "bdev_can_backup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "279-289",
    "snippet": "bool bdev_can_backup(struct lxc_conf *conf)\n{\n\tstruct bdev *bdev = bdev_init(conf, NULL, NULL, NULL);\n\tbool ret;\n\n\tif (!bdev)\n\t\treturn false;\n\tret = bdev->ops->can_backup;\n\tbdev_put(bdev);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_put",
          "args": [
            "bdev"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "579-585",
          "snippet": "void bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic char *linkderef(char *path, char *dest);\n\nvoid bdev_put(struct bdev *bdev)\n{\n\tfree(bdev->mntopts);\n\tfree(bdev->src);\n\tfree(bdev->dest);\n\tfree(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_init",
          "args": [
            "conf",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "533-565",
          "snippet": "struct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nstruct bdev *bdev_init(struct lxc_conf *conf, const char *src, const char *dst,\n\t\tconst char *mntopts)\n{\n\tstruct bdev *bdev;\n\tconst struct bdev_type *q;\n\n\tif (!src)\n\t\tsrc = conf->rootfs.path;\n\n\tif (!src)\n\t\treturn NULL;\n\n\tq = bdev_query(conf, src);\n\tif (!q)\n\t\treturn NULL;\n\n\tbdev = malloc(sizeof(struct bdev));\n\tif (!bdev)\n\t\treturn NULL;\n\tmemset(bdev, 0, sizeof(struct bdev));\n\tbdev->ops = q->ops;\n\tbdev->type = q->name;\n\tif (mntopts)\n\t\tbdev->mntopts = strdup(mntopts);\n\tif (src)\n\t\tbdev->src = strdup(src);\n\tif (dst)\n\t\tbdev->dest = strdup(dst);\n\tif (strcmp(bdev->type, \"nbd\") == 0)\n\t\tbdev->nbd_idx = conf->nbd_idx;\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool bdev_can_backup(struct lxc_conf *conf)\n{\n\tstruct bdev *bdev = bdev_init(conf, NULL, NULL, NULL);\n\tbool ret;\n\n\tif (!bdev)\n\t\treturn false;\n\tret = bdev->ops->can_backup;\n\tbdev_put(bdev);\n\treturn ret;\n}"
  },
  {
    "function_name": "attach_block_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "261-277",
    "snippet": "bool attach_block_device(struct lxc_conf *conf)\n{\n\tchar *path;\n\n\tif (!conf->rootfs.path)\n\t\treturn true;\n\tpath = conf->rootfs.path;\n\tif (!requires_nbd(path))\n\t\treturn true;\n\tpath = strchr(path, ':');\n\tif (!path)\n\t\treturn false;\n\tpath++;\n\tif (!attach_nbd(path, conf))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_nbd",
          "args": [
            "path",
            "conf"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "clone_attach_nbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "236-248",
          "snippet": "static bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path)\n{\n\tpid_t pid;\n\tstruct nbd_attach_data data;\n\n\tdata.nbd = nbd;\n\tdata.path = path;\n\n\tpid = lxc_clone(do_attach_nbd, &data, CLONE_NEWPID);\n\tif (pid < 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "':'"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "requires_nbd",
          "args": [
            "path"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "requires_nbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcnbd.c",
          "lines": "163-168",
          "snippet": "bool requires_nbd(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/prctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdbool.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool clone_attach_nbd(const char *nbd, const char *path);",
            "static void nbd_detach(const char *path);",
            "static bool wait_for_partition(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcnbd.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <errno.h>\n\nstatic bool clone_attach_nbd(const char *nbd, const char *path);\nstatic void nbd_detach(const char *path);\nstatic bool wait_for_partition(const char *path);\n\nbool requires_nbd(const char *path)\n{\n\tif (strncmp(path, \"nbd:\", 4) == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool attach_block_device(struct lxc_conf *conf)\n{\n\tchar *path;\n\n\tif (!conf->rootfs.path)\n\t\treturn true;\n\tpath = conf->rootfs.path;\n\tif (!requires_nbd(path))\n\t\treturn true;\n\tpath = strchr(path, ':');\n\tif (!path)\n\t\treturn false;\n\tpath++;\n\tif (!attach_nbd(path, conf))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "dir_new_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
    "lines": "214-253",
    "snippet": "char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"parse.h\"",
      "#include \"namespace.h\"",
      "#include \"lxczfs.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcrbd.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxcnbd.h\"",
      "#include \"lxcloop.h\"",
      "#include \"lxclvm.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxcdir.h\"",
      "#include \"lxcbtrfs.h\"",
      "#include \"lxcaufs.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"config.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <sched.h>",
      "#include <libgen.h>",
      "#include <inttypes.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%s\"",
            "src"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%s\"",
            "name"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p",
            "src",
            "p2 - src"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "src",
            "oldname"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%s\"",
            "lxcpath"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "src",
            "oldpath",
            "l1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nlen"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "oldname"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldname"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "src",
            "oldpath",
            "l1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldpath"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "src"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nchar *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}"
  }
]