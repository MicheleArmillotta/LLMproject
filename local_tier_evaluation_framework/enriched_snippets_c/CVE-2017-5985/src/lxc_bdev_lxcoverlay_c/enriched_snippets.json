[
  {
    "function_name": "ovl_rsync_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "762-766",
    "snippet": "static int ovl_rsync_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn ovl_rsync(arg);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ovl_rsync(struct rsync_data *data);",
      "static int ovl_rsync_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_rsync",
          "args": [
            "arg"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_rsync_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "762-766",
          "snippet": "static int ovl_rsync_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn ovl_rsync(arg);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int ovl_rsync(struct rsync_data *data);\nstatic int ovl_rsync_wrapper(void *data);\n\nstatic int ovl_rsync_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn ovl_rsync(arg);\n}"
  },
  {
    "function_name": "ovl_do_rsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "745-760",
    "snippet": "static int ovl_do_rsync(struct bdev *orig, struct bdev *new, struct lxc_conf *conf)\n{\n\tint ret = -1;\n\tstruct rsync_data rdata;\n\n\trdata.orig = orig;\n\trdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, ovl_rsync_wrapper, &rdata);\n\telse\n\t\tret = ovl_rsync(&rdata);\n\tif (ret)\n\t\tERROR(\"copying overlayfs delta\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"copying overlayfs delta\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_rsync",
          "args": [
            "&rdata"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_rsync_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "762-766",
          "snippet": "static int ovl_rsync_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn ovl_rsync(arg);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ovl_rsync(struct rsync_data *data);",
            "static int ovl_rsync_wrapper(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int ovl_rsync(struct rsync_data *data);\nstatic int ovl_rsync_wrapper(void *data);\n\nstatic int ovl_rsync_wrapper(void *data)\n{\n\tstruct rsync_data *arg = data;\n\treturn ovl_rsync(arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "ovl_rsync_wrapper",
            "&rdata"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);\n\nstatic int ovl_do_rsync(struct bdev *orig, struct bdev *new, struct lxc_conf *conf)\n{\n\tint ret = -1;\n\tstruct rsync_data rdata;\n\n\trdata.orig = orig;\n\trdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, ovl_rsync_wrapper, &rdata);\n\telse\n\t\tret = ovl_rsync(&rdata);\n\tif (ret)\n\t\tERROR(\"copying overlayfs delta\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ovl_detect_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "724-743",
    "snippet": "static char *ovl_detect_name(void)\n{\n\tchar *v = ovl_version[0];\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tFILE *f = fopen(\"/proc/filesystems\", \"r\");\n\tif (!f)\n\t\treturn v;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tif (strcmp(line, \"nodev\\toverlayfs\\n\") == 0) {\n\t\t\tv = ovl_version[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n\treturn v;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
      "static char *ovl_detect_name(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "line",
            "\"nodev\\toverlayfs\\n\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/filesystems\"",
            "\"r\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic char *ovl_detect_name(void);\n\nstatic char *ovl_detect_name(void)\n{\n\tchar *v = ovl_version[0];\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tFILE *f = fopen(\"/proc/filesystems\", \"r\");\n\tif (!f)\n\t\treturn v;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tif (strcmp(line, \"nodev\\toverlayfs\\n\") == 0) {\n\t\t\tv = ovl_version[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n\treturn v;\n}"
  },
  {
    "function_name": "ovl_rsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "678-722",
    "snippet": "static int ovl_rsync(struct rsync_data *data)\n{\n\tint ret;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tSYSERROR(\"Unable to unshare mounts ns\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tif (ovl_mount(data->orig) < 0) {\n\t\tERROR(\"Failed mounting original container fs\");\n\t\treturn -1;\n\t}\n\tif (ovl_mount(data->new) < 0) {\n\t\tERROR(\"Failed mounting new container fs\");\n\t\treturn -1;\n\t}\n\tret = do_rsync(data->orig->dest, data->new->dest);\n\n\tovl_umount(data->new);\n\tovl_umount(data->orig);\n\n\tif (ret < 0) {\n\t\tERROR(\"rsyncing %s to %s\", data->orig->dest, data->new->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ovl_rsync(struct rsync_data *data);",
      "static int ovl_rsync_wrapper(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"rsyncing %s to %s\"",
            "data->orig->dest",
            "data->new->dest"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_umount",
          "args": [
            "data->orig"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "441-448",
          "snippet": "int ovl_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_rsync",
          "args": [
            "data->orig->dest",
            "data->new->dest"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "do_rsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrsync.c",
          "lines": "43-66",
          "snippet": "int do_rsync(const char *src, const char *dest)\n{\n\t// call out to rsync\n\tpid_t pid;\n\tchar *s;\n\tsize_t l;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\tl = strlen(src) + 2;\n\ts = malloc(l);\n\tif (!s)\n\t\texit(1);\n\tstrcpy(s, src);\n\ts[l-2] = '/';\n\ts[l-1] = '\\0';\n\n\texeclp(\"rsync\", \"rsync\", \"-aHXS\", \"--delete\", s, dest, (char *)NULL);\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <grp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <grp.h>\n\nint do_rsync(const char *src, const char *dest)\n{\n\t// call out to rsync\n\tpid_t pid;\n\tchar *s;\n\tsize_t l;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\tl = strlen(src) + 2;\n\ts = malloc(l);\n\tif (!s)\n\t\texit(1);\n\tstrcpy(s, src);\n\ts[l-2] = '/';\n\ts[l-1] = '\\0';\n\n\texeclp(\"rsync\", \"rsync\", \"-aHXS\", \"--delete\", s, dest, (char *)NULL);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed mounting new container fs\""
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_mount",
          "args": [
            "data->new"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "314-439",
          "snippet": "int ovl_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tchar *options_work, *work, *lastslash;\n\tint lastslashidx;\n\tint len, len2;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret, ret2;\n\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (!ovl_name)\n\t\tovl_name = ovl_detect_name();\n\n\t/*\n\t * separately mount it first:\n\t * mount -t overlayfs * -oupperdir=${upper},lowerdir=${lower} lower dest\n\t */\n\tdup = alloca(strlen(bdev->src) + 1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\t// if delta doesn't yet exist, create it\n\tif (mkdir_p(upper, 0755) < 0 && errno != EEXIST)\n\t\treturn -22;\n\n\t/*\n\t * overlayfs.v22 or higher needs workdir option:\n\t * if upper is\n\t *\t/var/lib/lxc/c2/delta0\n\t * then workdir is\n\t *\t/var/lib/lxc/c2/olwork\n\t */\n\tlastslash = strrchr(upper, '/');\n\tif (!lastslash)\n\t\treturn -22;\n\tlastslash++;\n\tlastslashidx = lastslash - upper;\n\n\twork = alloca(lastslashidx + 7);\n\tstrncpy(work, upper, lastslashidx + 7);\n\tstrcpy(work + lastslashidx, \"olwork\");\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tif (mkdir_p(work, 0755) < 0 && errno != EEXIST) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t/*\n\t * TODO:\n\t * We should check whether bdev->src is a blockdev but for now only\n\t * support overlays of a basic directory\n\t */\n\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=,\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s,%s\", upper, lower, mntdata);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + strlen(mntdata) + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options, len2, \"upperdir=%s,lowerdir=%s,workdir=%s,%s\",\n\t\t\t\tupper, lower, work, mntdata);\n\t} else {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s\", upper, lower);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options_work, len2, \"upperdir=%s,lowerdir=%s,workdir=%s\",\n\t\t\tupper, lower, work);\n\t}\n\n\tif (ret < 0 || ret >= len || ret2 < 0 || ret2 >= len2) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n        /* Assume we need a workdir as we are on a overlay version >= v22. */\n\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t    MS_MGC_VAL | mntflags, options_work);\n\tif (ret < 0) {\n\t\tINFO(\"Overlayfs: Error mounting %s onto %s with options %s. \"\n\t\t     \"Retrying without workdir: %s.\",\n\t\t     lower, bdev->dest, options_work, strerror(errno));\n\n                /* Assume we cannot use a workdir as we are on a version <= v21. */\n\t\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t\t  MS_MGC_VAL | mntflags, options);\n\t\tif (ret < 0)\n\t\t\tSYSERROR(\"Overlayfs: Error mounting %s onto %s with \"\n\t\t\t\t \"options %s: %s.\",\n\t\t\t\t lower, bdev->dest, options,\n\t\t\t\t strerror(errno));\n\t\telse\n\t\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\",\n\t\t\t     lower, bdev->dest, options);\n\t} else {\n\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\", lower,\n\t\t     bdev->dest, options_work);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_detect_name(void);",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_detect_name(void);\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nint ovl_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tchar *options_work, *work, *lastslash;\n\tint lastslashidx;\n\tint len, len2;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret, ret2;\n\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (!ovl_name)\n\t\tovl_name = ovl_detect_name();\n\n\t/*\n\t * separately mount it first:\n\t * mount -t overlayfs * -oupperdir=${upper},lowerdir=${lower} lower dest\n\t */\n\tdup = alloca(strlen(bdev->src) + 1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\t// if delta doesn't yet exist, create it\n\tif (mkdir_p(upper, 0755) < 0 && errno != EEXIST)\n\t\treturn -22;\n\n\t/*\n\t * overlayfs.v22 or higher needs workdir option:\n\t * if upper is\n\t *\t/var/lib/lxc/c2/delta0\n\t * then workdir is\n\t *\t/var/lib/lxc/c2/olwork\n\t */\n\tlastslash = strrchr(upper, '/');\n\tif (!lastslash)\n\t\treturn -22;\n\tlastslash++;\n\tlastslashidx = lastslash - upper;\n\n\twork = alloca(lastslashidx + 7);\n\tstrncpy(work, upper, lastslashidx + 7);\n\tstrcpy(work + lastslashidx, \"olwork\");\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tif (mkdir_p(work, 0755) < 0 && errno != EEXIST) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t/*\n\t * TODO:\n\t * We should check whether bdev->src is a blockdev but for now only\n\t * support overlays of a basic directory\n\t */\n\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=,\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s,%s\", upper, lower, mntdata);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + strlen(mntdata) + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options, len2, \"upperdir=%s,lowerdir=%s,workdir=%s,%s\",\n\t\t\t\tupper, lower, work, mntdata);\n\t} else {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s\", upper, lower);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options_work, len2, \"upperdir=%s,lowerdir=%s,workdir=%s\",\n\t\t\tupper, lower, work);\n\t}\n\n\tif (ret < 0 || ret >= len || ret2 < 0 || ret2 >= len2) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n        /* Assume we need a workdir as we are on a overlay version >= v22. */\n\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t    MS_MGC_VAL | mntflags, options_work);\n\tif (ret < 0) {\n\t\tINFO(\"Overlayfs: Error mounting %s onto %s with options %s. \"\n\t\t     \"Retrying without workdir: %s.\",\n\t\t     lower, bdev->dest, options_work, strerror(errno));\n\n                /* Assume we cannot use a workdir as we are on a version <= v21. */\n\t\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t\t  MS_MGC_VAL | mntflags, options);\n\t\tif (ret < 0)\n\t\t\tSYSERROR(\"Overlayfs: Error mounting %s onto %s with \"\n\t\t\t\t \"options %s: %s.\",\n\t\t\t\t lower, bdev->dest, options,\n\t\t\t\t strerror(errno));\n\t\telse\n\t\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\",\n\t\t\t     lower, bdev->dest, options);\n\t} else {\n\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\", lower,\n\t\t     bdev->dest, options_work);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed mounting original container fs\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Continuing...\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to make / rslave\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to unshare mounts ns\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "0"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int ovl_rsync(struct rsync_data *data);\nstatic int ovl_rsync_wrapper(void *data);\n\nstatic int ovl_rsync(struct rsync_data *data)\n{\n\tint ret;\n\n\tif (setgid(0) < 0) {\n\t\tERROR(\"Failed to setgid to 0\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0)\n\t\tWARN(\"Failed to clear groups\");\n\tif (setuid(0) < 0) {\n\t\tERROR(\"Failed to setuid to 0\");\n\t\treturn -1;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tSYSERROR(\"Unable to unshare mounts ns\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tif (ovl_mount(data->orig) < 0) {\n\t\tERROR(\"Failed mounting original container fs\");\n\t\treturn -1;\n\t}\n\tif (ovl_mount(data->new) < 0) {\n\t\tERROR(\"Failed mounting new container fs\");\n\t\treturn -1;\n\t}\n\tret = do_rsync(data->orig->dest, data->new->dest);\n\n\tovl_umount(data->new);\n\tovl_umount(data->orig);\n\n\tif (ret < 0) {\n\t\tERROR(\"rsyncing %s to %s\", data->orig->dest, data->new->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_remount_on_enodev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "664-676",
    "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *ovl_name;",
      "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
      "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "lower",
            "target",
            "ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0]",
            "MS_MGC_VAL | mountflags",
            "options"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
  },
  {
    "function_name": "ovl_update_abs_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "572-662",
    "snippet": "int ovl_update_abs_paths(struct lxc_conf *lxc_conf, const char *lxc_path,\n\t\t\t const char *lxc_name, const char *newpath,\n\t\t\t const char *newname)\n{\n\tchar new_upper[MAXPATHLEN];\n\tchar new_work[MAXPATHLEN];\n\tchar old_upper[MAXPATHLEN];\n\tchar old_work[MAXPATHLEN];\n\tchar *cleanpath = NULL;\n\tsize_t i;\n\tint fret = -1;\n\tint ret = 0;\n\tstruct lxc_list *iterator;\n\tconst char *ovl_dirs[] = {\"br\", \"upperdir\", \"workdir\"};\n\n\tcleanpath = strdup(newpath);\n\tif (!cleanpath)\n\t\tgoto err;\n\n\tremove_trailing_slashes(cleanpath);\n\n\t/*\n\t * We have to update lxc_conf->unexpanded_config separately from\n\t * lxc_conf->mount_list.\n\t */\n\tfor (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {\n\t\tif (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,\n\t\t\t\t\t\t  lxc_name, newname,\n\t\t\t\t\t\t  ovl_dirs[i]))\n\t\t\tgoto err;\n\t}\n\n\tret = snprintf(old_work, MAXPATHLEN, \"workdir=%s/%s\", lxc_path, lxc_name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tret = snprintf(new_work, MAXPATHLEN, \"workdir=%s/%s\", cleanpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tlxc_list_for_each(iterator, &lxc_conf->mount_list) {\n\t\tchar *mnt_entry = NULL;\n\t\tchar *new_mnt_entry = NULL;\n\t\tchar *tmp = NULL;\n\t\tchar *tmp_mnt_entry = NULL;\n\t\tmnt_entry = iterator->elem;\n\n\t\tif (strstr(mnt_entry, \"overlay\"))\n\t\t\ttmp = \"upperdir\";\n\t\telse if (strstr(mnt_entry, \"aufs\"))\n\t\t\ttmp = \"br\";\n\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tret = snprintf(old_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tret = snprintf(new_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, cleanpath, newname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tif (strstr(mnt_entry, old_upper)) {\n\t\t\ttmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);\n\t\t}\n\n\t\tif (strstr(mnt_entry, old_work)) {\n\t\t\tif (tmp_mnt_entry)\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);\n\t\t\telse\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);\n\t\t}\n\n\t\tif (new_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(new_mnt_entry);\n\t\t} else if (tmp_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(tmp_mnt_entry);\n\t\t}\n\n\t\tfree(new_mnt_entry);\n\t\tfree(tmp_mnt_entry);\n\t}\n\n\tfret = 0;\nerr:\n\tfree(cleanpath);\n\treturn fret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cleanpath"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp_mnt_entry"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "new_mnt_entry"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "old_work",
            "new_work",
            "mnt_entry"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mnt_entry",
            "old_work"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mnt_entry",
            "old_upper"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new_upper",
            "MAXPATHLEN",
            "\"%s=%s/%s\"",
            "tmp",
            "cleanpath",
            "newname"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "old_upper",
            "MAXPATHLEN",
            "\"%s=%s/%s\"",
            "tmp",
            "lxc_path",
            "lxc_name"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mnt_entry",
            "\"aufs\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "mnt_entry",
            "\"overlay\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "&lxc_conf->mount_list"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new_work",
            "MAXPATHLEN",
            "\"workdir=%s/%s\"",
            "cleanpath",
            "newname"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "old_work",
            "MAXPATHLEN",
            "\"workdir=%s/%s\"",
            "lxc_path",
            "lxc_name"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_update_unexp_ovl_paths",
          "args": [
            "lxc_conf",
            "lxc_path",
            "newpath",
            "lxc_name",
            "newname",
            "ovl_dirs[i]"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "clone_update_unexp_ovl_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2782-2876",
          "snippet": "bool clone_update_unexp_ovl_paths(struct lxc_conf *conf, const char *oldpath,\n\t\t\t\t  const char *newpath, const char *oldname,\n\t\t\t\t  const char *newname, const char *ovldir)\n{\n\tconst char *key = \"lxc.mount.entry\";\n\tint ret;\n\tchar *lstart = conf->unexpanded_config;\n\tchar *lend;\n\tchar *p;\n\tchar *q;\n\tsize_t newdirlen = strlen(ovldir) + strlen(newpath) + strlen(newname) + 2;\n\tsize_t olddirlen = strlen(ovldir) + strlen(oldpath) + strlen(oldname) + 2;\n\tchar *olddir = alloca(olddirlen + 1);\n\tchar *newdir = alloca(newdirlen + 1);\n\n\tret = snprintf(olddir, olddirlen + 1, \"%s=%s/%s\", ovldir, oldpath, oldname);\n\tif (ret < 0 || ret >= olddirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tret = snprintf(newdir, newdirlen + 1, \"%s=%s/%s\", ovldir, newpath, newname);\n\tif (ret < 0 || ret >= newdirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0)\n                        goto next;\n\t\tp = strchr(lstart + strlen(key), '=');\n\t\tif (!p)\n                        goto next;\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n\t\tif (p >= lend)\n                        goto next;\n                /* Whenever an lxc.mount.entry entry is found in a line we check\n                *  if the substring \" overlay\" or the substring \" aufs\" is\n                *  present before doing any further work. We check for \"\n                *  overlay\" and \" aufs\" since both substrings need to have at\n                *  least one space before them in a valid overlay\n                *  lxc.mount.entry (/A B overlay).  When the space before is\n                *  missing it is very likely that these substrings are part of a\n                *  path or something else. (Checking q >= lend ensures that we\n                *  only count matches in the current line.) */\n\t\tif ((!(q = strstr(p, \" overlay\")) || q >= lend) && (!(q = strstr(p, \" aufs\")) || q >= lend))\n                        goto next;\n\t\tif (!(q = strstr(p, olddir)) || (q >= lend))\n                        goto next;\n\n\t\t/* replace the olddir with newdir */\n\t\tif (olddirlen >= newdirlen) {\n\t\t\tsize_t diff = olddirlen - newdirlen;\n\t\t\tmemcpy(q, newdir, newdirlen);\n\t\t\tif (olddirlen != newdirlen) {\n\t\t\t\tmemmove(q + newdirlen, q + newdirlen + diff,\n\t\t\t\t\tstrlen(q) - newdirlen - diff + 1);\n\t\t\t\tlend -= diff;\n\t\t\t\tconf->unexpanded_len -= diff;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *new;\n\t\t\tsize_t diff = newdirlen - olddirlen;\n\t\t\tsize_t oldlen = conf->unexpanded_len;\n\t\t\tsize_t newlen = oldlen + diff;\n\t\t\tsize_t poffset = q - conf->unexpanded_config;\n\t\t\tnew = realloc(conf->unexpanded_config, newlen + 1);\n\t\t\tif (!new) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconf->unexpanded_len = newlen;\n\t\t\tconf->unexpanded_alloced = newlen + 1;\n\t\t\tnew[newlen - 1] = '\\0';\n\t\t\tlend = new + (lend - conf->unexpanded_config);\n\t\t\t/* move over the remainder to make room for the newdir */\n\t\t\tmemmove(new + poffset + newdirlen,\n\t\t\t\tnew + poffset + olddirlen,\n\t\t\t\toldlen - poffset - olddirlen + 1);\n\t\t\tconf->unexpanded_config = new;\n\t\t\tmemcpy(new + poffset, newdir, newdirlen);\n\t\t\tlend += diff;\n\t\t}\nnext:\n\t\t\tlstart = lend;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int config_personality(const char *, const char *, struct lxc_conf *);",
            "static int config_pts(const char *, const char *, struct lxc_conf *);",
            "static int config_tty(const char *, const char *, struct lxc_conf *);",
            "static int config_ttydir(const char *, const char *, struct lxc_conf *);",
            "static int config_kmsg(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);",
            "static int config_lsm_se_context(const char *, const char *, struct lxc_conf *);",
            "static int config_cgroup(const char *, const char *, struct lxc_conf *);",
            "static int config_idmap(const char *, const char *, struct lxc_conf *);",
            "static int config_loglevel(const char *, const char *, struct lxc_conf *);",
            "static int config_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_mount_auto(const char *, const char *, struct lxc_conf *);",
            "static int config_fstab(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_mount(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_options(const char *, const char *, struct lxc_conf *);",
            "static int config_rootfs_backend(const char *, const char *, struct lxc_conf *);",
            "static int config_pivotdir(const char *, const char *, struct lxc_conf *);",
            "static int config_utsname(const char *, const char *, struct lxc_conf *);",
            "static int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);",
            "static int config_network(const char *, const char *, struct lxc_conf *);",
            "static int config_network_type(const char *, const char *, struct lxc_conf *);",
            "static int config_network_flags(const char *, const char *, struct lxc_conf *);",
            "static int config_network_link(const char *, const char *, struct lxc_conf *);",
            "static int config_network_name(const char *, const char *, struct lxc_conf *);",
            "static int config_network_veth_pair(const char *, const char *, struct lxc_conf *);",
            "static int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);",
            "static int config_network_hwaddr(const char *, const char *, struct lxc_conf *);",
            "static int config_network_vlan_id(const char *, const char *, struct lxc_conf *);",
            "static int config_network_mtu(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_up(const char *, const char *, struct lxc_conf *);",
            "static int config_network_script_down(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6(const char *, const char *, struct lxc_conf *);",
            "static int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_drop(const char *, const char *, struct lxc_conf *);",
            "static int config_cap_keep(const char *, const char *, struct lxc_conf *);",
            "static int config_console(const char *, const char *, struct lxc_conf *);",
            "static int config_console_logfile(const char *, const char *, struct lxc_conf *);",
            "static int config_seccomp(const char *, const char *, struct lxc_conf *);",
            "static int config_includefile(const char *, const char *, struct lxc_conf *);",
            "static int config_network_nic(const char *, const char *, struct lxc_conf *);",
            "static int config_autodev(const char *, const char *, struct lxc_conf *);",
            "static int config_haltsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_rebootsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_stopsignal(const char *, const char *, struct lxc_conf *);",
            "static int config_start(const char *, const char *, struct lxc_conf *);",
            "static int config_syslog(const char *, const char *, struct lxc_conf *);",
            "static int config_monitor(const char *, const char *, struct lxc_conf *);",
            "static int config_group(const char *, const char *, struct lxc_conf *);",
            "static int config_environment(const char *, const char *, struct lxc_conf *);",
            "static int config_init_cmd(const char *, const char *, struct lxc_conf *);",
            "static int config_init_uid(const char *, const char *, struct lxc_conf *);",
            "static int config_init_gid(const char *, const char *, struct lxc_conf *);",
            "static int config_ephemeral(const char *, const char *, struct lxc_conf *);",
            "static int config_no_new_privs(const char *, const char *, struct lxc_conf *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int config_personality(const char *, const char *, struct lxc_conf *);\nstatic int config_pts(const char *, const char *, struct lxc_conf *);\nstatic int config_tty(const char *, const char *, struct lxc_conf *);\nstatic int config_ttydir(const char *, const char *, struct lxc_conf *);\nstatic int config_kmsg(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_profile(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_aa_incomplete(const char *, const char *, struct lxc_conf *);\nstatic int config_lsm_se_context(const char *, const char *, struct lxc_conf *);\nstatic int config_cgroup(const char *, const char *, struct lxc_conf *);\nstatic int config_idmap(const char *, const char *, struct lxc_conf *);\nstatic int config_loglevel(const char *, const char *, struct lxc_conf *);\nstatic int config_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_mount_auto(const char *, const char *, struct lxc_conf *);\nstatic int config_fstab(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_mount(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_options(const char *, const char *, struct lxc_conf *);\nstatic int config_rootfs_backend(const char *, const char *, struct lxc_conf *);\nstatic int config_pivotdir(const char *, const char *, struct lxc_conf *);\nstatic int config_utsname(const char *, const char *, struct lxc_conf *);\nstatic int config_hook(const char *, const char *, struct lxc_conf *lxc_conf);\nstatic int config_network(const char *, const char *, struct lxc_conf *);\nstatic int config_network_type(const char *, const char *, struct lxc_conf *);\nstatic int config_network_flags(const char *, const char *, struct lxc_conf *);\nstatic int config_network_link(const char *, const char *, struct lxc_conf *);\nstatic int config_network_name(const char *, const char *, struct lxc_conf *);\nstatic int config_network_veth_pair(const char *, const char *, struct lxc_conf *);\nstatic int config_network_macvlan_mode(const char *, const char *, struct lxc_conf *);\nstatic int config_network_hwaddr(const char *, const char *, struct lxc_conf *);\nstatic int config_network_vlan_id(const char *, const char *, struct lxc_conf *);\nstatic int config_network_mtu(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv4_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_up(const char *, const char *, struct lxc_conf *);\nstatic int config_network_script_down(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6(const char *, const char *, struct lxc_conf *);\nstatic int config_network_ipv6_gateway(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_drop(const char *, const char *, struct lxc_conf *);\nstatic int config_cap_keep(const char *, const char *, struct lxc_conf *);\nstatic int config_console(const char *, const char *, struct lxc_conf *);\nstatic int config_console_logfile(const char *, const char *, struct lxc_conf *);\nstatic int config_seccomp(const char *, const char *, struct lxc_conf *);\nstatic int config_includefile(const char *, const char *, struct lxc_conf *);\nstatic int config_network_nic(const char *, const char *, struct lxc_conf *);\nstatic int config_autodev(const char *, const char *, struct lxc_conf *);\nstatic int config_haltsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_rebootsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_stopsignal(const char *, const char *, struct lxc_conf *);\nstatic int config_start(const char *, const char *, struct lxc_conf *);\nstatic int config_syslog(const char *, const char *, struct lxc_conf *);\nstatic int config_monitor(const char *, const char *, struct lxc_conf *);\nstatic int config_group(const char *, const char *, struct lxc_conf *);\nstatic int config_environment(const char *, const char *, struct lxc_conf *);\nstatic int config_init_cmd(const char *, const char *, struct lxc_conf *);\nstatic int config_init_uid(const char *, const char *, struct lxc_conf *);\nstatic int config_init_gid(const char *, const char *, struct lxc_conf *);\nstatic int config_ephemeral(const char *, const char *, struct lxc_conf *);\nstatic int config_no_new_privs(const char *, const char *, struct lxc_conf *);\n\nbool clone_update_unexp_ovl_paths(struct lxc_conf *conf, const char *oldpath,\n\t\t\t\t  const char *newpath, const char *oldname,\n\t\t\t\t  const char *newname, const char *ovldir)\n{\n\tconst char *key = \"lxc.mount.entry\";\n\tint ret;\n\tchar *lstart = conf->unexpanded_config;\n\tchar *lend;\n\tchar *p;\n\tchar *q;\n\tsize_t newdirlen = strlen(ovldir) + strlen(newpath) + strlen(newname) + 2;\n\tsize_t olddirlen = strlen(ovldir) + strlen(oldpath) + strlen(oldname) + 2;\n\tchar *olddir = alloca(olddirlen + 1);\n\tchar *newdir = alloca(newdirlen + 1);\n\n\tret = snprintf(olddir, olddirlen + 1, \"%s=%s/%s\", ovldir, oldpath, oldname);\n\tif (ret < 0 || ret >= olddirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tret = snprintf(newdir, newdirlen + 1, \"%s=%s/%s\", ovldir, newpath, newname);\n\tif (ret < 0 || ret >= newdirlen + 1) {\n\t\tERROR(\"Bug in %s\", __func__);\n\t\treturn false;\n\t}\n\tif (!conf->unexpanded_config)\n\t\treturn true;\n\twhile (*lstart) {\n\t\tlend = strchr(lstart, '\\n');\n\t\tif (!lend)\n\t\t\tlend = lstart + strlen(lstart);\n\t\telse\n\t\t\tlend++;\n\t\tif (strncmp(lstart, key, strlen(key)) != 0)\n                        goto next;\n\t\tp = strchr(lstart + strlen(key), '=');\n\t\tif (!p)\n                        goto next;\n\t\tp++;\n\t\twhile (isblank(*p))\n\t\t\tp++;\n\t\tif (p >= lend)\n                        goto next;\n                /* Whenever an lxc.mount.entry entry is found in a line we check\n                *  if the substring \" overlay\" or the substring \" aufs\" is\n                *  present before doing any further work. We check for \"\n                *  overlay\" and \" aufs\" since both substrings need to have at\n                *  least one space before them in a valid overlay\n                *  lxc.mount.entry (/A B overlay).  When the space before is\n                *  missing it is very likely that these substrings are part of a\n                *  path or something else. (Checking q >= lend ensures that we\n                *  only count matches in the current line.) */\n\t\tif ((!(q = strstr(p, \" overlay\")) || q >= lend) && (!(q = strstr(p, \" aufs\")) || q >= lend))\n                        goto next;\n\t\tif (!(q = strstr(p, olddir)) || (q >= lend))\n                        goto next;\n\n\t\t/* replace the olddir with newdir */\n\t\tif (olddirlen >= newdirlen) {\n\t\t\tsize_t diff = olddirlen - newdirlen;\n\t\t\tmemcpy(q, newdir, newdirlen);\n\t\t\tif (olddirlen != newdirlen) {\n\t\t\t\tmemmove(q + newdirlen, q + newdirlen + diff,\n\t\t\t\t\tstrlen(q) - newdirlen - diff + 1);\n\t\t\t\tlend -= diff;\n\t\t\t\tconf->unexpanded_len -= diff;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *new;\n\t\t\tsize_t diff = newdirlen - olddirlen;\n\t\t\tsize_t oldlen = conf->unexpanded_len;\n\t\t\tsize_t newlen = oldlen + diff;\n\t\t\tsize_t poffset = q - conf->unexpanded_config;\n\t\t\tnew = realloc(conf->unexpanded_config, newlen + 1);\n\t\t\tif (!new) {\n\t\t\t\tERROR(\"Out of memory\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconf->unexpanded_len = newlen;\n\t\t\tconf->unexpanded_alloced = newlen + 1;\n\t\t\tnew[newlen - 1] = '\\0';\n\t\t\tlend = new + (lend - conf->unexpanded_config);\n\t\t\t/* move over the remainder to make room for the newdir */\n\t\t\tmemmove(new + poffset + newdirlen,\n\t\t\t\tnew + poffset + olddirlen,\n\t\t\t\toldlen - poffset - olddirlen + 1);\n\t\t\tconf->unexpanded_config = new;\n\t\t\tmemcpy(new + poffset, newdir, newdirlen);\n\t\t\tlend += diff;\n\t\t}\nnext:\n\t\t\tlstart = lend;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_trailing_slashes",
          "args": [
            "cleanpath"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "remove_trailing_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "249-254",
          "snippet": "extern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void remove_trailing_slashes(char *p)\n{\n\tint l = strlen(p);\n\twhile (--l >= 0 && (p[l] == '/' || p[l] == '\\n'))\n\t\tp[l] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "newpath"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_update_abs_paths(struct lxc_conf *lxc_conf, const char *lxc_path,\n\t\t\t const char *lxc_name, const char *newpath,\n\t\t\t const char *newname)\n{\n\tchar new_upper[MAXPATHLEN];\n\tchar new_work[MAXPATHLEN];\n\tchar old_upper[MAXPATHLEN];\n\tchar old_work[MAXPATHLEN];\n\tchar *cleanpath = NULL;\n\tsize_t i;\n\tint fret = -1;\n\tint ret = 0;\n\tstruct lxc_list *iterator;\n\tconst char *ovl_dirs[] = {\"br\", \"upperdir\", \"workdir\"};\n\n\tcleanpath = strdup(newpath);\n\tif (!cleanpath)\n\t\tgoto err;\n\n\tremove_trailing_slashes(cleanpath);\n\n\t/*\n\t * We have to update lxc_conf->unexpanded_config separately from\n\t * lxc_conf->mount_list.\n\t */\n\tfor (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {\n\t\tif (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,\n\t\t\t\t\t\t  lxc_name, newname,\n\t\t\t\t\t\t  ovl_dirs[i]))\n\t\t\tgoto err;\n\t}\n\n\tret = snprintf(old_work, MAXPATHLEN, \"workdir=%s/%s\", lxc_path, lxc_name);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tret = snprintf(new_work, MAXPATHLEN, \"workdir=%s/%s\", cleanpath, newname);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\tgoto err;\n\n\tlxc_list_for_each(iterator, &lxc_conf->mount_list) {\n\t\tchar *mnt_entry = NULL;\n\t\tchar *new_mnt_entry = NULL;\n\t\tchar *tmp = NULL;\n\t\tchar *tmp_mnt_entry = NULL;\n\t\tmnt_entry = iterator->elem;\n\n\t\tif (strstr(mnt_entry, \"overlay\"))\n\t\t\ttmp = \"upperdir\";\n\t\telse if (strstr(mnt_entry, \"aufs\"))\n\t\t\ttmp = \"br\";\n\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tret = snprintf(old_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tret = snprintf(new_upper, MAXPATHLEN, \"%s=%s/%s\", tmp, cleanpath, newname);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\tif (strstr(mnt_entry, old_upper)) {\n\t\t\ttmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);\n\t\t}\n\n\t\tif (strstr(mnt_entry, old_work)) {\n\t\t\tif (tmp_mnt_entry)\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);\n\t\t\telse\n\t\t\t\tnew_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);\n\t\t}\n\n\t\tif (new_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(new_mnt_entry);\n\t\t} else if (tmp_mnt_entry) {\n\t\t\tfree(iterator->elem);\n\t\t\titerator->elem = strdup(tmp_mnt_entry);\n\t\t}\n\n\t\tfree(new_mnt_entry);\n\t\tfree(tmp_mnt_entry);\n\t}\n\n\tfret = 0;\nerr:\n\tfree(cleanpath);\n\treturn fret;\n}"
  },
  {
    "function_name": "ovl_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "485-562",
    "snippet": "int ovl_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t      const char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *upperdir = NULL;\n\tchar *workdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t dirlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"upperdir=\") && (strlen(opts[i]) > (len = strlen(\"upperdir=\"))))\n\t\t\tupperdir = opts[i] + len;\n\t\telse if (strstr(opts[i], \"workdir=\") && (strlen(opts[i]) > (len = strlen(\"workdir=\"))))\n\t\t\tworkdir = opts[i] + len;\n\t}\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = ovl_get_rootfs(rootfs_path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\n\t\tdirlen = strlen(lxcpath);\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (upperdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\telse if ((strncmp(upperdir, lxcpath, dirlen) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create upperdir\");\n\t}\n\n\tret = 0;\n\tif (workdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\telse if ((strncmp(workdir, lxcpath, dirlen) == 0) && (strncmp(workdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create workdir\");\n\t}\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)opts",
            "free"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rootfsdir"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create workdir\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "workdir",
            "0755"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "workdir",
            "rootfsdir",
            "rootfslen"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "workdir",
            "lxcpath",
            "dirlen"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to create upperdir\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upperdir",
            "rootfsdir",
            "rootfslen"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upperdir",
            "lxcpath",
            "dirlen"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_get_rootfs",
          "args": [
            "rootfs_path",
            "&rootfslen"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_get_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "450-483",
          "snippet": "char *ovl_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *ovl_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lxcpath",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "lxc_path",
            "lxc_name"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"workdir=\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts[i]"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "opts[i]",
            "\"workdir=\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"upperdir=\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts[i]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "opts[i]",
            "\"upperdir=\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)opts"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "mntent->mnt_opts",
            "','"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);\n\nint ovl_mkdir(const struct mntent *mntent, const struct lxc_rootfs *rootfs,\n\t      const char *lxc_name, const char *lxc_path)\n{\n\tchar lxcpath[MAXPATHLEN];\n\tchar *rootfs_path = NULL;\n\tchar *rootfsdir = NULL;\n\tchar *upperdir = NULL;\n\tchar *workdir = NULL;\n\tchar **opts = NULL;\n\tint fret = -1;\n\tint ret = 0;\n\tsize_t arrlen = 0;\n\tsize_t dirlen = 0;\n\tsize_t i;\n\tsize_t len = 0;\n\tsize_t rootfslen = 0;\n\n\t/* When rootfs == NULL we have a container without a rootfs. */\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->path;\n\n\topts = lxc_string_split(mntent->mnt_opts, ',');\n\tif (opts)\n\t\tarrlen = lxc_array_len((void **)opts);\n\telse\n\t\tgoto err;\n\n\tfor (i = 0; i < arrlen; i++) {\n\t\tif (strstr(opts[i], \"upperdir=\") && (strlen(opts[i]) > (len = strlen(\"upperdir=\"))))\n\t\t\tupperdir = opts[i] + len;\n\t\telse if (strstr(opts[i], \"workdir=\") && (strlen(opts[i]) > (len = strlen(\"workdir=\"))))\n\t\t\tworkdir = opts[i] + len;\n\t}\n\n\tif (rootfs_path) {\n\t\tret = snprintf(lxcpath, MAXPATHLEN, \"%s/%s\", lxc_path, lxc_name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto err;\n\n\t\trootfsdir = ovl_get_rootfs(rootfs_path, &rootfslen);\n\t\tif (!rootfsdir)\n\t\t\tgoto err;\n\n\t\tdirlen = strlen(lxcpath);\n\t}\n\n\t/*\n\t * We neither allow users to create upperdirs and workdirs outside the\n\t * containerdir nor inside the rootfs. The latter might be debatable.\n\t * When we have a container without a rootfs we skip the checks.\n\t */\n\tret = 0;\n\tif (upperdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\telse if ((strncmp(upperdir, lxcpath, dirlen) == 0) && (strncmp(upperdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(upperdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create upperdir\");\n\t}\n\n\tret = 0;\n\tif (workdir) {\n\t\tif (!rootfs_path)\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\telse if ((strncmp(workdir, lxcpath, dirlen) == 0) && (strncmp(workdir, rootfsdir, rootfslen) != 0))\n\t\t\tret = mkdir_p(workdir, 0755);\n\t\tif (ret < 0)\n\t\t\tWARN(\"Failed to create workdir\");\n\t}\n\n\tfret = 0;\n\nerr:\n\tfree(rootfsdir);\n\tlxc_free_array((void **)opts, free);\n\treturn fret;\n}"
  },
  {
    "function_name": "ovl_get_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "450-483",
    "snippet": "char *ovl_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootfsdir"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s1"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s2"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s2",
            "\":/\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s1",
            "\":/\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rootfs_path"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *ovl_get_rootfs(const char *rootfs_path, size_t *rootfslen)\n{\n\tchar *rootfsdir = NULL;\n\tchar *s1 = NULL;\n\tchar *s2 = NULL;\n\tchar *s3 = NULL;\n\n\tif (!rootfs_path || !rootfslen)\n\t\treturn NULL;\n\n\ts1 = strdup(rootfs_path);\n\tif (!s1)\n\t\treturn NULL;\n\n\tif ((s2 = strstr(s1, \":/\"))) {\n\t\ts2 = s2 + 1;\n\t\tif ((s3 = strstr(s2, \":/\")))\n\t\t\t*s3 = '\\0';\n\t\trootfsdir = strdup(s2);\n\t\tif (!rootfsdir) {\n\t\t\tfree(s1);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!rootfsdir)\n\t\trootfsdir = s1;\n\telse\n\t\tfree(s1);\n\n\t*rootfslen = strlen(rootfsdir);\n\n\treturn rootfsdir;\n}"
  },
  {
    "function_name": "ovl_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "441-448",
    "snippet": "int ovl_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "441-448",
          "snippet": "int ovl_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"overlayfs\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
  },
  {
    "function_name": "ovl_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "314-439",
    "snippet": "int ovl_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tchar *options_work, *work, *lastslash;\n\tint lastslashidx;\n\tint len, len2;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret, ret2;\n\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (!ovl_name)\n\t\tovl_name = ovl_detect_name();\n\n\t/*\n\t * separately mount it first:\n\t * mount -t overlayfs * -oupperdir=${upper},lowerdir=${lower} lower dest\n\t */\n\tdup = alloca(strlen(bdev->src) + 1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\t// if delta doesn't yet exist, create it\n\tif (mkdir_p(upper, 0755) < 0 && errno != EEXIST)\n\t\treturn -22;\n\n\t/*\n\t * overlayfs.v22 or higher needs workdir option:\n\t * if upper is\n\t *\t/var/lib/lxc/c2/delta0\n\t * then workdir is\n\t *\t/var/lib/lxc/c2/olwork\n\t */\n\tlastslash = strrchr(upper, '/');\n\tif (!lastslash)\n\t\treturn -22;\n\tlastslash++;\n\tlastslashidx = lastslash - upper;\n\n\twork = alloca(lastslashidx + 7);\n\tstrncpy(work, upper, lastslashidx + 7);\n\tstrcpy(work + lastslashidx, \"olwork\");\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tif (mkdir_p(work, 0755) < 0 && errno != EEXIST) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t/*\n\t * TODO:\n\t * We should check whether bdev->src is a blockdev but for now only\n\t * support overlays of a basic directory\n\t */\n\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=,\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s,%s\", upper, lower, mntdata);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + strlen(mntdata) + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options, len2, \"upperdir=%s,lowerdir=%s,workdir=%s,%s\",\n\t\t\t\tupper, lower, work, mntdata);\n\t} else {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s\", upper, lower);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options_work, len2, \"upperdir=%s,lowerdir=%s,workdir=%s\",\n\t\t\tupper, lower, work);\n\t}\n\n\tif (ret < 0 || ret >= len || ret2 < 0 || ret2 >= len2) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n        /* Assume we need a workdir as we are on a overlay version >= v22. */\n\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t    MS_MGC_VAL | mntflags, options_work);\n\tif (ret < 0) {\n\t\tINFO(\"Overlayfs: Error mounting %s onto %s with options %s. \"\n\t\t     \"Retrying without workdir: %s.\",\n\t\t     lower, bdev->dest, options_work, strerror(errno));\n\n                /* Assume we cannot use a workdir as we are on a version <= v21. */\n\t\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t\t  MS_MGC_VAL | mntflags, options);\n\t\tif (ret < 0)\n\t\t\tSYSERROR(\"Overlayfs: Error mounting %s onto %s with \"\n\t\t\t\t \"options %s: %s.\",\n\t\t\t\t lower, bdev->dest, options,\n\t\t\t\t strerror(errno));\n\t\telse\n\t\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\",\n\t\t\t     lower, bdev->dest, options);\n\t} else {\n\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\", lower,\n\t\t     bdev->dest, options_work);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *ovl_name;",
      "static char *ovl_detect_name(void);",
      "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Overlayfs: Mounted %s onto %s with options %s.\"",
            "lower",
            "bdev->dest",
            "options_work"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Overlayfs: Mounted %s onto %s with options %s.\"",
            "lower",
            "bdev->dest",
            "options"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Overlayfs: Error mounting %s onto %s with \"\n\t\t\t\t \"options %s: %s.\"",
            "lower",
            "bdev->dest",
            "options",
            "strerror(errno)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_remount_on_enodev",
          "args": [
            "lower",
            "bdev->dest",
            "ovl_name",
            "MS_MGC_VAL | mntflags",
            "options"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_remount_on_enodev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "664-676",
          "snippet": "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_name;",
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options)\n{\n        int ret;\n        ret = mount(lower, target, ovl_name, MS_MGC_VAL | mountflags, options);\n        if (ret < 0 && errno == ENODEV) /* Try other module name. */\n\t\tret = mount(lower, target,\n\t\t\t    ovl_name == ovl_version[0] ? ovl_version[1]\n\t\t\t\t\t\t       : ovl_version[0],\n\t\t\t    MS_MGC_VAL | mountflags, options);\n        return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Overlayfs: Error mounting %s onto %s with options %s. \"\n\t\t     \"Retrying without workdir: %s.\"",
            "lower",
            "bdev->dest",
            "options_work",
            "strerror(errno)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdata"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options_work",
            "len2",
            "\"upperdir=%s,lowerdir=%s,workdir=%s\"",
            "upper",
            "lower",
            "work"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len2"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"upperdir=,lowerdir=,workdir=\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "work"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options",
            "len",
            "\"upperdir=%s,lowerdir=%s\"",
            "upper",
            "lower"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"upperdir=,lowerdir=\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options",
            "len2",
            "\"upperdir=%s,lowerdir=%s,workdir=%s,%s\"",
            "upper",
            "lower",
            "work",
            "mntdata"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len2"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mntdata"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"upperdir=,lowerdir=,workdir=\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "work"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "options",
            "len",
            "\"upperdir=%s,lowerdir=%s,%s\"",
            "upper",
            "lower",
            "mntdata"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mntdata"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"upperdir=,lowerdir=,\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "upper"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lower"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "work",
            "0755"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "bdev->mntopts",
            "&mntflags",
            "&mntdata"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "work + lastslashidx",
            "\"olwork\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "work",
            "upper",
            "lastslashidx + 7"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "lastslashidx + 7"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "upper",
            "'/'"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "++upper",
            "\":/\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dup",
            "\":/\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dup",
            "bdev->src"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(bdev->src) + 1"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bdev->src"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_detect_name",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_detect_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "724-743",
          "snippet": "static char *ovl_detect_name(void)\n{\n\tchar *v = ovl_version[0];\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tFILE *f = fopen(\"/proc/filesystems\", \"r\");\n\tif (!f)\n\t\treturn v;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tif (strcmp(line, \"nodev\\toverlayfs\\n\") == 0) {\n\t\t\tv = ovl_version[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n\treturn v;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ovl_version[] = {\"overlay\", \"overlayfs\"};",
            "static char *ovl_detect_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_version[] = {\"overlay\", \"overlayfs\"};\nstatic char *ovl_detect_name(void);\n\nstatic char *ovl_detect_name(void)\n{\n\tchar *v = ovl_version[0];\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tFILE *f = fopen(\"/proc/filesystems\", \"r\");\n\tif (!f)\n\t\treturn v;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tif (strcmp(line, \"nodev\\toverlayfs\\n\") == 0) {\n\t\t\tv = ovl_version[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\tfree(line);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"overlayfs\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic char *ovl_name;\nstatic char *ovl_detect_name(void);\nstatic int ovl_remount_on_enodev(const char *lower, const char *target,\n\t\t\t\t const char *name, unsigned long mountflags,\n\t\t\t\t const void *options);\n\nint ovl_mount(struct bdev *bdev)\n{\n\tchar *tmp, *options, *dup, *lower, *upper;\n\tchar *options_work, *work, *lastslash;\n\tint lastslashidx;\n\tint len, len2;\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret, ret2;\n\n\tif (strcmp(bdev->type, \"overlayfs\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\n\tif (!ovl_name)\n\t\tovl_name = ovl_detect_name();\n\n\t/*\n\t * separately mount it first:\n\t * mount -t overlayfs * -oupperdir=${upper},lowerdir=${lower} lower dest\n\t */\n\tdup = alloca(strlen(bdev->src) + 1);\n\tstrcpy(dup, bdev->src);\n\t/* support multiple lower layers */\n\tif (!(lower = strstr(dup, \":/\")))\n\t\t\treturn -22;\n\tlower++;\n\tupper = lower;\n\twhile ((tmp = strstr(++upper, \":/\"))) {\n\t\tupper = tmp;\n\t}\n\tif (--upper == lower)\n\t\treturn -22;\n\t*upper = '\\0';\n\tupper++;\n\n\t// if delta doesn't yet exist, create it\n\tif (mkdir_p(upper, 0755) < 0 && errno != EEXIST)\n\t\treturn -22;\n\n\t/*\n\t * overlayfs.v22 or higher needs workdir option:\n\t * if upper is\n\t *\t/var/lib/lxc/c2/delta0\n\t * then workdir is\n\t *\t/var/lib/lxc/c2/olwork\n\t */\n\tlastslash = strrchr(upper, '/');\n\tif (!lastslash)\n\t\treturn -22;\n\tlastslash++;\n\tlastslashidx = lastslash - upper;\n\n\twork = alloca(lastslashidx + 7);\n\tstrncpy(work, upper, lastslashidx + 7);\n\tstrcpy(work + lastslashidx, \"olwork\");\n\n\tif (parse_mntopts(bdev->mntopts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\tif (mkdir_p(work, 0755) < 0 && errno != EEXIST) {\n\t\tfree(mntdata);\n\t\treturn -22;\n\t}\n\n\t/*\n\t * TODO:\n\t * We should check whether bdev->src is a blockdev but for now only\n\t * support overlays of a basic directory\n\t */\n\n\tif (mntdata) {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=,\") + strlen(mntdata) + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s,%s\", upper, lower, mntdata);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + strlen(mntdata) + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options, len2, \"upperdir=%s,lowerdir=%s,workdir=%s,%s\",\n\t\t\t\tupper, lower, work, mntdata);\n\t} else {\n\t\tlen = strlen(lower) + strlen(upper) + strlen(\"upperdir=,lowerdir=\") + 1;\n\t\toptions = alloca(len);\n\t\tret = snprintf(options, len, \"upperdir=%s,lowerdir=%s\", upper, lower);\n\n\t\tlen2 = strlen(lower) + strlen(upper) + strlen(work)\n\t\t\t+ strlen(\"upperdir=,lowerdir=,workdir=\") + 1;\n\t\toptions_work = alloca(len2);\n\t\tret2 = snprintf(options_work, len2, \"upperdir=%s,lowerdir=%s,workdir=%s\",\n\t\t\tupper, lower, work);\n\t}\n\n\tif (ret < 0 || ret >= len || ret2 < 0 || ret2 >= len2) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n        /* Assume we need a workdir as we are on a overlay version >= v22. */\n\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t    MS_MGC_VAL | mntflags, options_work);\n\tif (ret < 0) {\n\t\tINFO(\"Overlayfs: Error mounting %s onto %s with options %s. \"\n\t\t     \"Retrying without workdir: %s.\",\n\t\t     lower, bdev->dest, options_work, strerror(errno));\n\n                /* Assume we cannot use a workdir as we are on a version <= v21. */\n\t\tret = ovl_remount_on_enodev(lower, bdev->dest, ovl_name,\n\t\t\t\t\t  MS_MGC_VAL | mntflags, options);\n\t\tif (ret < 0)\n\t\t\tSYSERROR(\"Overlayfs: Error mounting %s onto %s with \"\n\t\t\t\t \"options %s: %s.\",\n\t\t\t\t lower, bdev->dest, options,\n\t\t\t\t strerror(errno));\n\t\telse\n\t\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\",\n\t\t\t     lower, bdev->dest, options);\n\t} else {\n\t\tINFO(\"Overlayfs: Mounted %s onto %s with options %s.\", lower,\n\t\t     bdev->dest, options_work);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ovl_getlower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "306-312",
    "snippet": "char *ovl_getlower(char *p)\n{\n\tchar *p1 = strchr(p, ':');\n\tif (p1)\n\t\t*p1 = '\\0';\n\treturn p;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nchar *ovl_getlower(char *p)\n{\n\tchar *p1 = strchr(p, ':');\n\tif (p1)\n\t\t*p1 = '\\0';\n\treturn p;\n}"
  },
  {
    "function_name": "ovl_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "299-304",
    "snippet": "int ovl_detect(const char *path)\n{\n\tif (strncmp(path, \"overlayfs:\", 10) == 0)\n\t\treturn 1; // take their word for it\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"overlayfs:\"",
            "10"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_detect(const char *path)\n{\n\tif (strncmp(path, \"overlayfs:\", 10) == 0)\n\t\treturn 1; // take their word for it\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "286-297",
    "snippet": "int ovl_destroy(struct bdev *orig)\n{\n\tchar *upper;\n\n\tif (strncmp(orig->src, \"overlayfs:\", 10) != 0)\n\t\treturn -22;\n\tupper = strchr(orig->src + 10, ':');\n\tif (!upper)\n\t\treturn -22;\n\tupper++;\n\treturn lxc_rmdir_onedev(upper, NULL);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "upper",
            "NULL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig->src + 10",
            "':'"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "orig->src",
            "\"overlayfs:\"",
            "10"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_destroy(struct bdev *orig)\n{\n\tchar *upper;\n\n\tif (strncmp(orig->src, \"overlayfs:\", 10) != 0)\n\t\treturn -22;\n\tupper = strchr(orig->src + 10, ':');\n\tif (!upper)\n\t\treturn -22;\n\tupper++;\n\treturn lxc_rmdir_onedev(upper, NULL);\n}"
  },
  {
    "function_name": "ovl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "244-284",
    "snippet": "int ovl_create(struct bdev *bdev, const char *dest, const char *n,\n\t\t\tstruct bdev_specs *specs)\n{\n\tchar *delta;\n\tint ret, len = strlen(dest), newlen;\n\n\tif (len < 8 || strcmp(dest + len - 7, \"/rootfs\") != 0)\n\t\treturn -1;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdelta = alloca(strlen(dest) + 1);\n\tstrcpy(delta, dest);\n\tstrcpy(delta + len - 6, \"delta0\");\n\n\tif (mkdir_p(delta, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", delta);\n\t\treturn -1;\n\t}\n\n\t// overlayfs:lower:upper\n\tnewlen = (2 * len) + strlen(\"overlayfs:\") + 2;\n\tbdev->src = malloc(newlen);\n\tif (!bdev->src) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tret = snprintf(bdev->src, newlen, \"overlayfs:%s:%s\", dest, delta);\n\tif (ret < 0 || ret >= newlen)\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "bdev->dest"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "bdev->dest",
            "0755"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "bdev->src",
            "newlen",
            "\"overlayfs:%s:%s\"",
            "dest",
            "delta"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "newlen"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"overlayfs:\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "delta"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta + len - 6",
            "\"delta0\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta",
            "dest"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(dest) + 1"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dest + len - 7",
            "\"/rootfs\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint ovl_create(struct bdev *bdev, const char *dest, const char *n,\n\t\t\tstruct bdev_specs *specs)\n{\n\tchar *delta;\n\tint ret, len = strlen(dest), newlen;\n\n\tif (len < 8 || strcmp(dest + len - 7, \"/rootfs\") != 0)\n\t\treturn -1;\n\n\tif (!(bdev->dest = strdup(dest))) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdelta = alloca(strlen(dest) + 1);\n\tstrcpy(delta, dest);\n\tstrcpy(delta + len - 6, \"delta0\");\n\n\tif (mkdir_p(delta, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", delta);\n\t\treturn -1;\n\t}\n\n\t// overlayfs:lower:upper\n\tnewlen = (2 * len) + strlen(\"overlayfs:\") + 2;\n\tbdev->src = malloc(newlen);\n\tif (!bdev->src) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tret = snprintf(bdev->src, newlen, \"overlayfs:%s:%s\", dest, delta);\n\tif (ret < 0 || ret >= newlen)\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
    "lines": "57-236",
    "snippet": "int ovl_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\t   const char *cname, const char *oldpath, const char *lxcpath,\n\t\t   int snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tif (!snap) {\n\t\tERROR(\"overlayfs is only for snapshot clones\");\n\t\treturn -22;\n\t}\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tnew->dest = dir_new_path(orig->dest, oldname, cname, oldpath, lxcpath);\n\tif (!new->dest)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (am_unpriv() && chown_mapped_root(new->dest, conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (strcmp(orig->type, \"dir\") == 0) {\n\t\tchar *delta, *lastslash;\n\t\tchar *work;\n\t\tint ret, len, lastslashidx;\n\n\t\t/*\n\t\t * if we have\n\t\t *\t/var/lib/lxc/c2/rootfs\n\t\t * then delta will be\n\t\t *\t/var/lib/lxc/c2/delta0\n\t\t */\n\t\tlastslash = strrchr(new->dest, '/');\n\t\tif (!lastslash)\n\t\t\treturn -22;\n\t\tif (strlen(lastslash) < 7)\n\t\t\treturn -22;\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - new->dest;\n\n\t\tdelta = malloc(lastslashidx + 7);\n\t\tif (!delta)\n\t\t\treturn -1;\n\t\tstrncpy(delta, new->dest, lastslashidx + 1);\n\t\tstrcpy(delta + lastslashidx, \"delta0\");\n\t\tif ((ret = mkdir(delta, 0755)) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", delta);\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(delta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", delta);\n\n\t\t/*\n\t\t * Make workdir for overlayfs.v22 or higher:\n\t\t * The workdir will be\n\t\t *\t/var/lib/lxc/c2/olwork\n\t\t * and is used to prepare files before they are atomically\n\t\t * switched to the overlay destination. Workdirs need to be on\n\t\t * the same filesystem as the upperdir so it's OK for it to be\n\t\t * empty.\n\t\t */\n\t\twork = malloc(lastslashidx + 7);\n\t\tif (!work) {\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(work, new->dest, lastslashidx + 1);\n\t\tstrcpy(work + lastslashidx, \"olwork\");\n\t\tif (mkdir(work, 0755) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", work);\n\t\t\tfree(delta);\n\t\t\tfree(work);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(work, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", work);\n\t\tfree(work);\n\n\t\t// the src will be 'overlayfs:lowerdir:upperdir'\n\t\tlen = strlen(delta) + strlen(orig->src) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(delta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"overlayfs:%s:%s\", orig->src, delta);\n\t\tfree(delta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else if (strcmp(orig->type, \"overlayfs\") == 0) {\n\t\t/*\n\t\t * What exactly do we want to do here?  I think we want to use\n\t\t * the original lowerdir, with a private delta which is\n\t\t * originally rsynced from the original delta\n\t\t */\n\t\tchar *osrc, *odelta, *nsrc, *ndelta, *work;\n\t\tchar *lastslash;\n\t\tint len, ret, lastslashidx;\n\t\tif (!(osrc = strdup(orig->src)))\n\t\t\treturn -22;\n\t\tnsrc = strchr(osrc, ':') + 1;\n\t\tif (nsrc != osrc + 10 || (odelta = strchr(nsrc, ':')) == NULL) {\n\t\t\tfree(osrc);\n\t\t\treturn -22;\n\t\t}\n\t\t*odelta = '\\0';\n\t\todelta++;\n\t\tndelta = dir_new_path(odelta, oldname, cname, oldpath, lxcpath);\n\t\tif (!ndelta) {\n\t\t\tfree(osrc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif ((ret = mkdir(ndelta, 0755)) < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", ndelta);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(ndelta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", ndelta);\n\n\t\t/*\n\t\t * make workdir for overlayfs.v22 or higher (see comment further\n\t\t * up)\n\t\t */\n\t\tlastslash = strrchr(ndelta, '/');\n\t\tif (!lastslash) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - ndelta;\n\n\t\twork = malloc(lastslashidx + 7);\n\t\tif (!work) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(work, ndelta, lastslashidx + 1);\n\t\tstrcpy(work + lastslashidx, \"olwork\");\n\t\tif ((mkdir(work, 0755) < 0) && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", work);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\tfree(work);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(work, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", work);\n\t\tfree(work);\n\n\t\tlen = strlen(nsrc) + strlen(ndelta) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"overlayfs:%s:%s\", nsrc, ndelta);\n\t\tfree(osrc);\n\t\tfree(ndelta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\n\t\treturn ovl_do_rsync(orig, new, conf);\n\t} else {\n\t\tERROR(\"overlayfs clone of %s container is not yet supported\",\n\t\t      orig->type);\n\t\t/*\n\t\t * Note, supporting this will require ovl_mount supporting\n\t\t * mounting of the underlay. No big deal, just needs to be done.\n\t\t */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxcrsync.h\"",
      "#include \"lxcoverlay.h\"",
      "#include \"lxccontainer.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"bdev.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);",
      "static int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"overlayfs clone of %s container is not yet supported\"",
            "orig->type"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_do_rsync",
          "args": [
            "orig",
            "new",
            "conf"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcoverlay.c",
          "lines": "745-760",
          "snippet": "static int ovl_do_rsync(struct bdev *orig, struct bdev *new, struct lxc_conf *conf)\n{\n\tint ret = -1;\n\tstruct rsync_data rdata;\n\n\trdata.orig = orig;\n\trdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, ovl_rsync_wrapper, &rdata);\n\telse\n\t\tret = ovl_rsync(&rdata);\n\tif (ret)\n\t\tERROR(\"copying overlayfs delta\");\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nstatic int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);\n\nstatic int ovl_do_rsync(struct bdev *orig, struct bdev *new, struct lxc_conf *conf)\n{\n\tint ret = -1;\n\tstruct rsync_data rdata;\n\n\trdata.orig = orig;\n\trdata.new = new;\n\tif (am_unpriv())\n\t\tret = userns_exec_1(conf, ovl_rsync_wrapper, &rdata);\n\telse\n\t\tret = ovl_rsync(&rdata);\n\tif (ret)\n\t\tERROR(\"copying overlayfs delta\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ndelta"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"overlayfs:%s:%s\"",
            "nsrc",
            "ndelta"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ndelta"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsrc"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "work"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown_mapped_root",
          "args": [
            "work",
            "conf"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "chown_mapped_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3482-3618",
          "snippet": "int chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint chown_mapped_root(char *path, struct lxc_conf *conf)\n{\n\tuid_t rootuid;\n\tgid_t rootgid;\n\tpid_t pid;\n\tunsigned long val;\n\tchar *chownpath = path;\n\n\tif (!get_mapped_rootid(conf, ID_TYPE_UID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootuid = (uid_t) val;\n\tif (!get_mapped_rootid(conf, ID_TYPE_GID, &val)) {\n\t\tERROR(\"No mapping for container root\");\n\t\treturn -1;\n\t}\n\trootgid = (gid_t) val;\n\n\t/*\n\t * In case of overlay, we want only the writeable layer\n\t * to be chowned\n\t */\n\tif (strncmp(path, \"overlayfs:\", 10) == 0 || strncmp(path, \"aufs:\", 5) == 0) {\n\t\tchownpath = strchr(path, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath = strchr(chownpath+1, ':');\n\t\tif (!chownpath) {\n\t\t\tERROR(\"Bad overlay path: %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\tchownpath++;\n\t}\n\tpath = chownpath;\n\tif (geteuid() == 0) {\n\t\tif (chown(path, rootuid, rootgid) < 0) {\n\t\t\tERROR(\"Error chowning %s\", path);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (rootuid == geteuid()) {\n\t\t// nothing to do\n\t\tINFO(\"%s: container root is our uid;  no need to chown\" ,__func__);\n\t\treturn 0;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"Failed forking\");\n\t\treturn -1;\n\t}\n\tif (!pid) {\n\t\tint hostuid = geteuid(), hostgid = getegid(), ret;\n\t\tstruct stat sb;\n\t\tchar map1[100], map2[100], map3[100], map4[100], map5[100];\n\t\tchar ugid[100];\n\t\tchar *args1[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\t\tchar *args2[] = { \"lxc-usernsexec\", \"-m\", map1, \"-m\", map2,\n\t\t\t\t\"-m\", map3, \"-m\", map4, \"-m\", map5,\n\t\t\t\t\"--\", \"chown\", ugid, path, NULL };\n\n\t\t// save the current gid of \"path\"\n\t\tif (stat(path, &sb) < 0) {\n\t\t\tERROR(\"Error stat %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * A file has to be group-owned by a gid mapped into the\n\t\t * container, or the container won't be privileged over it.\n\t\t */\n\t\tif (sb.st_uid == geteuid() &&\n\t\t\t\tmapped_hostid(sb.st_gid, conf, ID_TYPE_GID) < 0 &&\n\t\t\t\tchown(path, -1, hostgid) < 0) {\n\t\t\tERROR(\"Failed chgrping %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:0:rootuid:1\"\n\t\tret = snprintf(map1, 100, \"u:0:%d:1\", rootuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"u:hostuid:hostuid:1\"\n\t\tret = snprintf(map2, 100, \"u:%d:%d:1\", hostuid, hostuid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error uid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:0:rootgid:1\"\n\t\tret = snprintf(map3, 100, \"g:0:%d:1\", rootgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:pathgid:rootgid+pathgid:1\"\n\t\tret = snprintf(map4, 100, \"g:%d:%d:1\", (gid_t)sb.st_gid,\n\t\t\t\trootgid + (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"g:hostgid:hostgid:1\"\n\t\tret = snprintf(map5, 100, \"g:%d:%d:1\", hostgid, hostgid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error gid printing map string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t// \"0:pathgid\" (chown)\n\t\tret = snprintf(ugid, 100, \"0:%d\", (gid_t)sb.st_gid);\n\t\tif (ret < 0 || ret >= 100) {\n\t\t\tERROR(\"Error owner printing format string for chown\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (hostgid == sb.st_gid)\n\t\t\tret = execvp(\"lxc-usernsexec\", args1);\n\t\telse\n\t\t\tret = execvp(\"lxc-usernsexec\", args2);\n\t\tSYSERROR(\"Failed executing usernsexec\");\n\t\texit(1);\n\t}\n\treturn wait_for_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "am_unpriv",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "am_unpriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "288-290",
          "snippet": "inline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\ninline static bool am_unpriv(void) {\n\treturn geteuid() != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "work"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "work",
            "0755"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "work + lastslashidx",
            "\"olwork\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "work",
            "ndelta",
            "lastslashidx + 1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "lastslashidx + 7"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "ndelta",
            "'/'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "ndelta"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "ndelta"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_new_path",
          "args": [
            "odelta",
            "oldname",
            "cname",
            "oldpath",
            "lxcpath"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "dir_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "214-253",
          "snippet": "char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nchar *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nsrc",
            "':'"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "orig->src"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"overlayfs\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"overlayfs:%s:%s\"",
            "orig->src",
            "delta"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig->src"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "delta"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "work"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "work"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "work + lastslashidx",
            "\"olwork\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "work",
            "new->dest",
            "lastslashidx + 1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "lastslashidx + 7"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "delta"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"error: mkdir %s\"",
            "delta"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "delta + lastslashidx",
            "\"delta0\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "delta",
            "new->dest",
            "lastslashidx + 1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "lastslashidx + 7"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lastslash"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "new->dest",
            "'/'"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"dir\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to update ownership of %s\"",
            "new->dest"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"overlayfs is only for snapshot clones\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcoverlay.h\"\n#include \"lxccontainer.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\t\t  const char *oldpath, const char *lxcpath);\nstatic int ovl_do_rsync(struct bdev *orig, struct bdev *new,\n\t\t\tstruct lxc_conf *conf);\n\nint ovl_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\t   const char *cname, const char *oldpath, const char *lxcpath,\n\t\t   int snap, uint64_t newsize, struct lxc_conf *conf)\n{\n\tif (!snap) {\n\t\tERROR(\"overlayfs is only for snapshot clones\");\n\t\treturn -22;\n\t}\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tnew->dest = dir_new_path(orig->dest, oldname, cname, oldpath, lxcpath);\n\tif (!new->dest)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (am_unpriv() && chown_mapped_root(new->dest, conf) < 0)\n\t\tWARN(\"Failed to update ownership of %s\", new->dest);\n\n\tif (strcmp(orig->type, \"dir\") == 0) {\n\t\tchar *delta, *lastslash;\n\t\tchar *work;\n\t\tint ret, len, lastslashidx;\n\n\t\t/*\n\t\t * if we have\n\t\t *\t/var/lib/lxc/c2/rootfs\n\t\t * then delta will be\n\t\t *\t/var/lib/lxc/c2/delta0\n\t\t */\n\t\tlastslash = strrchr(new->dest, '/');\n\t\tif (!lastslash)\n\t\t\treturn -22;\n\t\tif (strlen(lastslash) < 7)\n\t\t\treturn -22;\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - new->dest;\n\n\t\tdelta = malloc(lastslashidx + 7);\n\t\tif (!delta)\n\t\t\treturn -1;\n\t\tstrncpy(delta, new->dest, lastslashidx + 1);\n\t\tstrcpy(delta + lastslashidx, \"delta0\");\n\t\tif ((ret = mkdir(delta, 0755)) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", delta);\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(delta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", delta);\n\n\t\t/*\n\t\t * Make workdir for overlayfs.v22 or higher:\n\t\t * The workdir will be\n\t\t *\t/var/lib/lxc/c2/olwork\n\t\t * and is used to prepare files before they are atomically\n\t\t * switched to the overlay destination. Workdirs need to be on\n\t\t * the same filesystem as the upperdir so it's OK for it to be\n\t\t * empty.\n\t\t */\n\t\twork = malloc(lastslashidx + 7);\n\t\tif (!work) {\n\t\t\tfree(delta);\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(work, new->dest, lastslashidx + 1);\n\t\tstrcpy(work + lastslashidx, \"olwork\");\n\t\tif (mkdir(work, 0755) < 0) {\n\t\t\tSYSERROR(\"error: mkdir %s\", work);\n\t\t\tfree(delta);\n\t\t\tfree(work);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(work, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", work);\n\t\tfree(work);\n\n\t\t// the src will be 'overlayfs:lowerdir:upperdir'\n\t\tlen = strlen(delta) + strlen(orig->src) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(delta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"overlayfs:%s:%s\", orig->src, delta);\n\t\tfree(delta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\t} else if (strcmp(orig->type, \"overlayfs\") == 0) {\n\t\t/*\n\t\t * What exactly do we want to do here?  I think we want to use\n\t\t * the original lowerdir, with a private delta which is\n\t\t * originally rsynced from the original delta\n\t\t */\n\t\tchar *osrc, *odelta, *nsrc, *ndelta, *work;\n\t\tchar *lastslash;\n\t\tint len, ret, lastslashidx;\n\t\tif (!(osrc = strdup(orig->src)))\n\t\t\treturn -22;\n\t\tnsrc = strchr(osrc, ':') + 1;\n\t\tif (nsrc != osrc + 10 || (odelta = strchr(nsrc, ':')) == NULL) {\n\t\t\tfree(osrc);\n\t\t\treturn -22;\n\t\t}\n\t\t*odelta = '\\0';\n\t\todelta++;\n\t\tndelta = dir_new_path(odelta, oldname, cname, oldpath, lxcpath);\n\t\tif (!ndelta) {\n\t\t\tfree(osrc);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif ((ret = mkdir(ndelta, 0755)) < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", ndelta);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(ndelta, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", ndelta);\n\n\t\t/*\n\t\t * make workdir for overlayfs.v22 or higher (see comment further\n\t\t * up)\n\t\t */\n\t\tlastslash = strrchr(ndelta, '/');\n\t\tif (!lastslash) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tlastslash++;\n\t\tlastslashidx = lastslash - ndelta;\n\n\t\twork = malloc(lastslashidx + 7);\n\t\tif (!work) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(work, ndelta, lastslashidx + 1);\n\t\tstrcpy(work + lastslashidx, \"olwork\");\n\t\tif ((mkdir(work, 0755) < 0) && errno != EEXIST) {\n\t\t\tSYSERROR(\"error: mkdir %s\", work);\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\tfree(work);\n\t\t\treturn -1;\n\t\t}\n\t\tif (am_unpriv() && chown_mapped_root(work, conf) < 0)\n\t\t\tWARN(\"Failed to update ownership of %s\", work);\n\t\tfree(work);\n\n\t\tlen = strlen(nsrc) + strlen(ndelta) + 12;\n\t\tnew->src = malloc(len);\n\t\tif (!new->src) {\n\t\t\tfree(osrc);\n\t\t\tfree(ndelta);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = snprintf(new->src, len, \"overlayfs:%s:%s\", nsrc, ndelta);\n\t\tfree(osrc);\n\t\tfree(ndelta);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -ENOMEM;\n\n\t\treturn ovl_do_rsync(orig, new, conf);\n\t} else {\n\t\tERROR(\"overlayfs clone of %s container is not yet supported\",\n\t\t      orig->type);\n\t\t/*\n\t\t * Note, supporting this will require ovl_mount supporting\n\t\t * mounting of the underlay. No big deal, just needs to be done.\n\t\t */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  }
]