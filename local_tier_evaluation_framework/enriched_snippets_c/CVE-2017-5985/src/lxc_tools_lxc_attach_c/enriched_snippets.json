[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "373-489",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret = -1, r;\n\tint wexit = 0;\n\tpid_t pid;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tlxc_attach_command_t command = (lxc_attach_command_t){.program = NULL};\n\n\tr = lxc_caps_init();\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\n\tr = lxc_arguments_parse(&my_args, argc, argv);\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tr = lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t   my_args.progname, my_args.quiet, my_args.lxcpath[0]);\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (geteuid()) {\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tif (!my_args.quiet)\n\t\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tstruct lxc_container *c = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c)\n\t\texit(EXIT_FAILURE);\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tERROR(\"Failed to load rcfile\");\n\t\t\tlxc_container_put(c);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tERROR(\"Out of memory setting new config filename\");\n\t\t\tlxc_container_put(c);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!c->is_defined(c)) {\n\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (remount_sys_proc)\n\t\tattach_options.attach_flags |= LXC_ATTACH_REMOUNT_PROC_SYS;\n\tif (elevated_privileges)\n\t\tattach_options.attach_flags &= ~(elevated_privileges);\n\tattach_options.namespaces = namespace_flags;\n\tattach_options.personality = new_personality;\n\tattach_options.env_policy = env_policy;\n\tattach_options.extra_env_vars = extra_env;\n\tattach_options.extra_keep_env = extra_keep;\n\n\tif (my_args.argc > 0) {\n\t\tcommand.program = my_args.argv[0];\n\t\tcommand.argv = (char**)my_args.argv;\n\t}\n\n\tstruct wrapargs wrap = (struct wrapargs){\n\t\t.command = &command,\n\t\t\t.options = &attach_options\n\t};\n\n\twrap.ptyfd = stdfd_is_pty();\n\tif (wrap.ptyfd >= 0) {\n\t\tif ((!isatty(STDOUT_FILENO) || !isatty(STDERR_FILENO)) && my_args.console_log) {\n\t\t\tfprintf(stderr, \"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_pty_on_host(c, &wrap, &pid);\n\t} else {\n\t\tif (my_args.console_log) {\n\t\t\tfprintf(stderr, \"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (command.program)\n\t\t\tret = c->attach(c, lxc_attach_run_command, &command, &attach_options, &pid);\n\t\telse\n\t\t\tret = c->attach(c, lxc_attach_run_shell, NULL, &attach_options, &pid);\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = lxc_wait_for_pid_status(pid);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (WIFEXITED(ret))\n\t\twexit = WEXITSTATUS(ret);\nout:\n\tlxc_container_put(c);\n\tif (ret >= 0)\n\t\texit(wexit);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int elevated_privileges = 0;",
      "static signed long new_personality = -1;",
      "static int namespace_flags = -1;",
      "static int remount_sys_proc = 0;",
      "static lxc_attach_env_policy_t env_policy = LXC_ATTACH_KEEP_ENV;",
      "static char **extra_env = NULL;",
      "static char **extra_keep = NULL;",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "wexit"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "ret"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "ret"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_wait_for_pid_status",
          "args": [
            "pid"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->attach",
          "args": [
            "c",
            "lxc_attach_run_shell",
            "NULL",
            "&attach_options",
            "&pid"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->attach",
          "args": [
            "c",
            "lxc_attach_run_command",
            "&command",
            "&attach_options",
            "&pid"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pty_on_host",
          "args": [
            "c",
            "&wrap",
            "&pid"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "get_pty_on_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
          "lines": "280-359",
          "snippet": "static int get_pty_on_host(struct lxc_container *c, struct wrapargs *wrap, int *pid)\n{\n\tint ret = -1;\n\tstruct wrapargs *args = wrap;\n\tstruct lxc_epoll_descr descr;\n\tstruct lxc_conf *conf;\n\tstruct lxc_tty_state *ts;\n\n\tINFO(\"Trying to allocate a pty on the host\");\n\n\tif (!isatty(args->ptyfd)) {\n\t\tERROR(\"Standard file descriptor does not refer to a pty\\n.\");\n\t\treturn -1;\n\t}\n\n\tconf = c->lxc_conf;\n\tfree(conf->console.log_path);\n\tif (my_args.console_log)\n\t\tconf->console.log_path = strdup(my_args.console_log);\n\telse\n\t\tconf->console.log_path = NULL;\n\n\t/* In the case of lxc-attach our peer pty will always be the current\n\t * controlling terminal. We clear whatever was set by the user for\n\t * lxc.console.path here and set it to \"/dev/tty\". Doing this will (a)\n\t * prevent segfaults when the container has been setup with\n\t * lxc.console = none and (b) provide an easy way to ensure that we\n\t * always do the correct thing. strdup() must be used since console.path\n\t * is free()ed when we call lxc_container_put(). */\n\tfree(conf->console.path);\n\tconf->console.path = strdup(\"/dev/tty\");\n\tif (!conf->console.path)\n\t\treturn -1;\n\n\t/* Create pty on the host. */\n\tif (lxc_console_create(conf) < 0)\n\t\treturn -1;\n\tts = conf->console.tty_state;\n\tconf->console.descr = &descr;\n\n\t/* Shift ttys to container. */\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container\");\n\t\tgoto err1;\n\t}\n\n\t/* Send wrapper function on its way. */\n\twrap->console = &conf->console;\n\tif (c->attach(c, get_pty_on_host_callback, wrap, wrap->options, pid) < 0)\n\t\tgoto err1;\n\tclose(conf->console.slave); /* Close slave side. */\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err2;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, conf) < 0) {\n\t\tERROR(\"Failed to add handlers to lxc mainloop.\");\n\t\tgoto err3;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err3;\n\t}\n\tret = 0;\n\nerr3:\n\tlxc_mainloop_close(&descr);\nerr2:\n\tif (ts && ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr1:\n\tlxc_console_delete(&conf->console);\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"mainloop.h\"",
            "#include \"list.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"caps.h\"",
            "#include \"arguments.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nstatic int get_pty_on_host(struct lxc_container *c, struct wrapargs *wrap, int *pid)\n{\n\tint ret = -1;\n\tstruct wrapargs *args = wrap;\n\tstruct lxc_epoll_descr descr;\n\tstruct lxc_conf *conf;\n\tstruct lxc_tty_state *ts;\n\n\tINFO(\"Trying to allocate a pty on the host\");\n\n\tif (!isatty(args->ptyfd)) {\n\t\tERROR(\"Standard file descriptor does not refer to a pty\\n.\");\n\t\treturn -1;\n\t}\n\n\tconf = c->lxc_conf;\n\tfree(conf->console.log_path);\n\tif (my_args.console_log)\n\t\tconf->console.log_path = strdup(my_args.console_log);\n\telse\n\t\tconf->console.log_path = NULL;\n\n\t/* In the case of lxc-attach our peer pty will always be the current\n\t * controlling terminal. We clear whatever was set by the user for\n\t * lxc.console.path here and set it to \"/dev/tty\". Doing this will (a)\n\t * prevent segfaults when the container has been setup with\n\t * lxc.console = none and (b) provide an easy way to ensure that we\n\t * always do the correct thing. strdup() must be used since console.path\n\t * is free()ed when we call lxc_container_put(). */\n\tfree(conf->console.path);\n\tconf->console.path = strdup(\"/dev/tty\");\n\tif (!conf->console.path)\n\t\treturn -1;\n\n\t/* Create pty on the host. */\n\tif (lxc_console_create(conf) < 0)\n\t\treturn -1;\n\tts = conf->console.tty_state;\n\tconf->console.descr = &descr;\n\n\t/* Shift ttys to container. */\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container\");\n\t\tgoto err1;\n\t}\n\n\t/* Send wrapper function on its way. */\n\twrap->console = &conf->console;\n\tif (c->attach(c, get_pty_on_host_callback, wrap, wrap->options, pid) < 0)\n\t\tgoto err1;\n\tclose(conf->console.slave); /* Close slave side. */\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err2;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, conf) < 0) {\n\t\tERROR(\"Failed to add handlers to lxc mainloop.\");\n\t\tgoto err3;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err3;\n\t}\n\tret = 0;\n\nerr3:\n\tlxc_mainloop_close(&descr);\nerr2:\n\tif (ts && ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr1:\n\tlxc_console_delete(&conf->console);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdfd_is_pty",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "stdfd_is_pty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
          "lines": "361-371",
          "snippet": "static int stdfd_is_pty(void)\n{\n\tif (isatty(STDIN_FILENO))\n\t\treturn STDIN_FILENO;\n\tif (isatty(STDOUT_FILENO))\n\t\treturn STDOUT_FILENO;\n\tif (isatty(STDERR_FILENO))\n\t\treturn STDERR_FILENO;\n\n\treturn -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"mainloop.h\"",
            "#include \"list.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"caps.h\"",
            "#include \"arguments.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int stdfd_is_pty(void)\n{\n\tif (isatty(STDIN_FILENO))\n\t\treturn STDIN_FILENO;\n\tif (isatty(STDOUT_FILENO))\n\t\treturn STDOUT_FILENO;\n\tif (isatty(STDERR_FILENO))\n\t\treturn STDERR_FILENO;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: container %s is not defined\\n\"",
            "c->name"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Insufficent privileges to control %s\\n\"",
            "c->name"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->may_control",
          "args": [
            "c"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory setting new config filename\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "my_args.rcfile"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to load rcfile\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load_config",
          "args": [
            "c",
            "my_args.rcfile"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clear_config",
          "args": [
            "c"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "my_args.name",
            "my_args.lxcpath[0]"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You lack access to %s\\n\"",
            "my_args.lxcpath[0]"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "my_args.lxcpath[0]",
            "O_RDONLY"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "my_args.name",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_caps_init",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "47-49",
          "snippet": "static inline int lxc_caps_init(void) {\n\treturn 0;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline int lxc_caps_init(void) {\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int elevated_privileges = 0;\nstatic signed long new_personality = -1;\nstatic int namespace_flags = -1;\nstatic int remount_sys_proc = 0;\nstatic lxc_attach_env_policy_t env_policy = LXC_ATTACH_KEEP_ENV;\nstatic char **extra_env = NULL;\nstatic char **extra_keep = NULL;\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nint main(int argc, char *argv[])\n{\n\tint ret = -1, r;\n\tint wexit = 0;\n\tpid_t pid;\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\tlxc_attach_command_t command = (lxc_attach_command_t){.program = NULL};\n\n\tr = lxc_caps_init();\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\n\tr = lxc_arguments_parse(&my_args, argc, argv);\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\tr = lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,\n\t\t\t   my_args.progname, my_args.quiet, my_args.lxcpath[0]);\n\tif (r)\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tif (geteuid()) {\n\t\tif (access(my_args.lxcpath[0], O_RDONLY) < 0) {\n\t\t\tif (!my_args.quiet)\n\t\t\t\tfprintf(stderr, \"You lack access to %s\\n\", my_args.lxcpath[0]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tstruct lxc_container *c = lxc_container_new(my_args.name, my_args.lxcpath[0]);\n\tif (!c)\n\t\texit(EXIT_FAILURE);\n\n\tif (my_args.rcfile) {\n\t\tc->clear_config(c);\n\t\tif (!c->load_config(c, my_args.rcfile)) {\n\t\t\tERROR(\"Failed to load rcfile\");\n\t\t\tlxc_container_put(c);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tc->configfile = strdup(my_args.rcfile);\n\t\tif (!c->configfile) {\n\t\t\tERROR(\"Out of memory setting new config filename\");\n\t\t\tlxc_container_put(c);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!c->may_control(c)) {\n\t\tfprintf(stderr, \"Insufficent privileges to control %s\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!c->is_defined(c)) {\n\t\tfprintf(stderr, \"Error: container %s is not defined\\n\", c->name);\n\t\tlxc_container_put(c);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (remount_sys_proc)\n\t\tattach_options.attach_flags |= LXC_ATTACH_REMOUNT_PROC_SYS;\n\tif (elevated_privileges)\n\t\tattach_options.attach_flags &= ~(elevated_privileges);\n\tattach_options.namespaces = namespace_flags;\n\tattach_options.personality = new_personality;\n\tattach_options.env_policy = env_policy;\n\tattach_options.extra_env_vars = extra_env;\n\tattach_options.extra_keep_env = extra_keep;\n\n\tif (my_args.argc > 0) {\n\t\tcommand.program = my_args.argv[0];\n\t\tcommand.argv = (char**)my_args.argv;\n\t}\n\n\tstruct wrapargs wrap = (struct wrapargs){\n\t\t.command = &command,\n\t\t\t.options = &attach_options\n\t};\n\n\twrap.ptyfd = stdfd_is_pty();\n\tif (wrap.ptyfd >= 0) {\n\t\tif ((!isatty(STDOUT_FILENO) || !isatty(STDERR_FILENO)) && my_args.console_log) {\n\t\t\tfprintf(stderr, \"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_pty_on_host(c, &wrap, &pid);\n\t} else {\n\t\tif (my_args.console_log) {\n\t\t\tfprintf(stderr, \"-L/--pty-log can only be used when stdout and stderr refer to a pty.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (command.program)\n\t\t\tret = c->attach(c, lxc_attach_run_command, &command, &attach_options, &pid);\n\t\telse\n\t\t\tret = c->attach(c, lxc_attach_run_shell, NULL, &attach_options, &pid);\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = lxc_wait_for_pid_status(pid);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (WIFEXITED(ret))\n\t\twexit = WEXITSTATUS(ret);\nout:\n\tlxc_container_put(c);\n\tif (ret >= 0)\n\t\texit(wexit);\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "stdfd_is_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "361-371",
    "snippet": "static int stdfd_is_pty(void)\n{\n\tif (isatty(STDIN_FILENO))\n\t\treturn STDIN_FILENO;\n\tif (isatty(STDOUT_FILENO))\n\t\treturn STDOUT_FILENO;\n\tif (isatty(STDERR_FILENO))\n\t\treturn STDERR_FILENO;\n\n\treturn -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int stdfd_is_pty(void)\n{\n\tif (isatty(STDIN_FILENO))\n\t\treturn STDIN_FILENO;\n\tif (isatty(STDOUT_FILENO))\n\t\treturn STDOUT_FILENO;\n\tif (isatty(STDERR_FILENO))\n\t\treturn STDERR_FILENO;\n\n\treturn -1;\n}"
  },
  {
    "function_name": "get_pty_on_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "280-359",
    "snippet": "static int get_pty_on_host(struct lxc_container *c, struct wrapargs *wrap, int *pid)\n{\n\tint ret = -1;\n\tstruct wrapargs *args = wrap;\n\tstruct lxc_epoll_descr descr;\n\tstruct lxc_conf *conf;\n\tstruct lxc_tty_state *ts;\n\n\tINFO(\"Trying to allocate a pty on the host\");\n\n\tif (!isatty(args->ptyfd)) {\n\t\tERROR(\"Standard file descriptor does not refer to a pty\\n.\");\n\t\treturn -1;\n\t}\n\n\tconf = c->lxc_conf;\n\tfree(conf->console.log_path);\n\tif (my_args.console_log)\n\t\tconf->console.log_path = strdup(my_args.console_log);\n\telse\n\t\tconf->console.log_path = NULL;\n\n\t/* In the case of lxc-attach our peer pty will always be the current\n\t * controlling terminal. We clear whatever was set by the user for\n\t * lxc.console.path here and set it to \"/dev/tty\". Doing this will (a)\n\t * prevent segfaults when the container has been setup with\n\t * lxc.console = none and (b) provide an easy way to ensure that we\n\t * always do the correct thing. strdup() must be used since console.path\n\t * is free()ed when we call lxc_container_put(). */\n\tfree(conf->console.path);\n\tconf->console.path = strdup(\"/dev/tty\");\n\tif (!conf->console.path)\n\t\treturn -1;\n\n\t/* Create pty on the host. */\n\tif (lxc_console_create(conf) < 0)\n\t\treturn -1;\n\tts = conf->console.tty_state;\n\tconf->console.descr = &descr;\n\n\t/* Shift ttys to container. */\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container\");\n\t\tgoto err1;\n\t}\n\n\t/* Send wrapper function on its way. */\n\twrap->console = &conf->console;\n\tif (c->attach(c, get_pty_on_host_callback, wrap, wrap->options, pid) < 0)\n\t\tgoto err1;\n\tclose(conf->console.slave); /* Close slave side. */\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err2;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, conf) < 0) {\n\t\tERROR(\"Failed to add handlers to lxc mainloop.\");\n\t\tgoto err3;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err3;\n\t}\n\tret = 0;\n\nerr3:\n\tlxc_mainloop_close(&descr);\nerr2:\n\tif (ts && ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr1:\n\tlxc_console_delete(&conf->console);\n\n\treturn ret;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_console_delete",
          "args": [
            "&conf->console"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "480-498",
          "snippet": "void lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_delete(struct lxc_console *console)\n{\n\tif (console->tios && console->peer >= 0 &&\n\t    tcsetattr(console->peer, TCSAFLUSH, console->tios))\n\t\tWARN(\"failed to set old terminal settings\");\n\tfree(console->tios);\n\tconsole->tios = NULL;\n\n\tclose(console->peer);\n\tclose(console->master);\n\tclose(console->slave);\n\tif (console->log_fd >= 0)\n\t\tclose(console->log_fd);\n\n\tconsole->peer = -1;\n\tconsole->master = -1;\n\tconsole->slave = -1;\n\tconsole->log_fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_sigwinch_fini",
          "args": [
            "ts"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_sigwinch_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "148-156",
          "snippet": "void lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_console_sigwinch_fini(struct lxc_tty_state *ts)\n{\n\tif (ts->sigfd >= 0)\n\t\tclose(ts->sigfd);\n\n\tlxc_list_del(&ts->node);\n\tsigprocmask(SIG_SETMASK, &ts->oldmask, NULL);\n\tfree(ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_close",
          "args": [
            "&descr"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "148-163",
          "snippet": "int lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"mainloop returned an error\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop",
          "args": [
            "&descr",
            "-1"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add handlers to lxc mainloop.\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_console_mainloop_add",
          "args": [
            "&descr",
            "conf"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_mainloop_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "209-243",
          "snippet": "extern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_console_mainloop_add(struct lxc_epoll_descr *descr,\n\t\t\t\t    struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path) {\n\t\tINFO(\"no rootfs, no console.\");\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (lxc_mainloop_add_handler(descr, console->master,\n\t\t\t\t     lxc_console_cb_con, console)) {\n\t\tERROR(\"failed to add to mainloop console handler for '%d'\",\n\t\t      console->master);\n\t\treturn -1;\n\t}\n\n\t/* we cache the descr so that we can add an fd to it when someone\n\t * does attach to it in lxc_console_allocate()\n\t */\n\tconsole->descr = descr;\n\tlxc_console_mainloop_add_peer(console);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create mainloop\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_open",
          "args": [
            "&descr"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "132-146",
          "snippet": "int lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "conf->console.slave"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->attach",
          "args": [
            "c",
            "get_pty_on_host_callback",
            "wrap",
            "wrap->options",
            "pid"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to shift tty into container\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttys_shift_ids",
          "args": [
            "conf"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ttys_shift_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3620-3631",
          "snippet": "int ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint ttys_shift_ids(struct lxc_conf *c)\n{\n\tif (lxc_list_empty(&c->id_map))\n\t\treturn 0;\n\n\tif (strcmp(c->console.name, \"\") !=0 && chown_mapped_root(c->console.name, c) < 0) {\n\t\tERROR(\"Failed to chown %s\", c->console.name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_create",
          "args": [
            "conf"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "500-553",
          "snippet": "int lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_create(struct lxc_conf *conf)\n{\n\tstruct lxc_console *console = &conf->console;\n\tint ret;\n\n\tif (conf->is_execute) {\n\t\tINFO(\"no console for lxc-execute.\");\n\t\treturn 0;\n\t}\n\n\tif (!conf->rootfs.path)\n\t\treturn 0;\n\n\tif (console->path && !strcmp(console->path, \"none\"))\n\t\treturn 0;\n\n\tprocess_lock();\n\tret = openpty(&console->master, &console->slave,\n\t\t    console->name, NULL, NULL);\n\tprocess_unlock();\n\tif (ret) {\n\t\tSYSERROR(\"failed to allocate a pty\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(console->master, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console master to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(console->slave, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"failed to set console slave to close-on-exec\");\n\t\tgoto err;\n\t}\n\n\tlxc_console_peer_default(console);\n\n\tif (console->log_path) {\n\t\tconsole->log_fd = lxc_unpriv(open(console->log_path,\n\t\t\t\t\t\t  O_CLOEXEC | O_RDWR |\n\t\t\t\t\t\t  O_CREAT | O_APPEND, 0600));\n\t\tif (console->log_fd < 0) {\n\t\t\tSYSERROR(\"failed to open '%s'\", console->log_path);\n\t\t\tgoto err;\n\t\t}\n\t\tDEBUG(\"using '%s' as console log\", console->log_path);\n\t}\n\n\treturn 0;\n\nerr:\n\tlxc_console_delete(console);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/dev/tty\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "conf->console.path"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "my_args.console_log"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Standard file descriptor does not refer to a pty\\n.\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "args->ptyfd"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Trying to allocate a pty on the host\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-attach\",\n\t.help     = \"\\\n--name=NAME [-- COMMAND]\\n\\\n\\n\\\nExecute the specified COMMAND - enter the container NAME\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME   NAME of the container\\n\\\n  -e, --elevated-privileges=PRIVILEGES\\n\\\n                    Use elevated privileges instead of those of the\\n\\\n                    container. If you don't specify privileges to be\\n\\\n                    elevated as OR'd list: CAP, CGROUP and LSM (capabilities,\\n\\\n                    cgroup and restrictions, respectively) then all of them\\n\\\n                    will be elevated.\\n\\\n                    WARNING: This may leak privileges into the container.\\n\\\n                    Use with care.\\n\\\n  -a, --arch=ARCH   Use ARCH for program instead of container's own\\n\\\n                    architecture.\\n\\\n  -s, --namespaces=FLAGS\\n\\\n                    Don't attach to all the namespaces of the container\\n\\\n                    but just to the following OR'd list of flags:\\n\\\n                    MOUNT, PID, UTSNAME, IPC, USER or NETWORK.\\n\\\n                    WARNING: Using -s implies -e with all privileges\\n\\\n                    elevated, it may therefore leak privileges into the\\n\\\n                    container. Use with care.\\n\\\n  -R, --remount-sys-proc\\n\\\n                    Remount /sys and /proc if not attaching to the\\n\\\n                    mount namespace when using -s in order to properly\\n\\\n                    reflect the correct namespace context. See the\\n\\\n                    lxc-attach(1) manual page for details.\\n\\\n      --clear-env   Clear all environment variables before attaching.\\n\\\n                    The attached shell/program will start with only\\n\\\n                    container=lxc set.\\n\\\n      --keep-env    Keep all current environment variables. This\\n\\\n                    is the current default behaviour, but is likely to\\n\\\n                    change in the future.\\n\\\n  -L, --pty-log=FILE\\n\\\n                    Log pty output to FILE\\n\\\n  -v, --set-var     Set an additional variable that is seen by the\\n\\\n                    attached program in the container. May be specified\\n\\\n                    multiple times.\\n\\\n      --keep-var    Keep an additional environment variable. Only\\n\\\n                    applicable if --clear-env is specified. May be used\\n\\\n                    multiple times.\\n\\\n  -f, --rcfile=FILE\\n\\\n                    Load configuration file FILE\\n\\\n\",\n\t.options  = my_longopts,\n\t.parser   = my_parser,\n\t.checker  = NULL,\n};\n\nstatic int get_pty_on_host(struct lxc_container *c, struct wrapargs *wrap, int *pid)\n{\n\tint ret = -1;\n\tstruct wrapargs *args = wrap;\n\tstruct lxc_epoll_descr descr;\n\tstruct lxc_conf *conf;\n\tstruct lxc_tty_state *ts;\n\n\tINFO(\"Trying to allocate a pty on the host\");\n\n\tif (!isatty(args->ptyfd)) {\n\t\tERROR(\"Standard file descriptor does not refer to a pty\\n.\");\n\t\treturn -1;\n\t}\n\n\tconf = c->lxc_conf;\n\tfree(conf->console.log_path);\n\tif (my_args.console_log)\n\t\tconf->console.log_path = strdup(my_args.console_log);\n\telse\n\t\tconf->console.log_path = NULL;\n\n\t/* In the case of lxc-attach our peer pty will always be the current\n\t * controlling terminal. We clear whatever was set by the user for\n\t * lxc.console.path here and set it to \"/dev/tty\". Doing this will (a)\n\t * prevent segfaults when the container has been setup with\n\t * lxc.console = none and (b) provide an easy way to ensure that we\n\t * always do the correct thing. strdup() must be used since console.path\n\t * is free()ed when we call lxc_container_put(). */\n\tfree(conf->console.path);\n\tconf->console.path = strdup(\"/dev/tty\");\n\tif (!conf->console.path)\n\t\treturn -1;\n\n\t/* Create pty on the host. */\n\tif (lxc_console_create(conf) < 0)\n\t\treturn -1;\n\tts = conf->console.tty_state;\n\tconf->console.descr = &descr;\n\n\t/* Shift ttys to container. */\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container\");\n\t\tgoto err1;\n\t}\n\n\t/* Send wrapper function on its way. */\n\twrap->console = &conf->console;\n\tif (c->attach(c, get_pty_on_host_callback, wrap, wrap->options, pid) < 0)\n\t\tgoto err1;\n\tclose(conf->console.slave); /* Close slave side. */\n\n\tret = lxc_mainloop_open(&descr);\n\tif (ret) {\n\t\tERROR(\"failed to create mainloop\");\n\t\tgoto err2;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, conf) < 0) {\n\t\tERROR(\"Failed to add handlers to lxc mainloop.\");\n\t\tgoto err3;\n\t}\n\n\tret = lxc_mainloop(&descr, -1);\n\tif (ret) {\n\t\tERROR(\"mainloop returned an error\");\n\t\tgoto err3;\n\t}\n\tret = 0;\n\nerr3:\n\tlxc_mainloop_close(&descr);\nerr2:\n\tif (ts && ts->sigfd != -1)\n\t\tlxc_console_sigwinch_fini(ts);\nerr1:\n\tlxc_console_delete(&conf->console);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_pty_on_host_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "265-278",
    "snippet": "static int get_pty_on_host_callback(void *p)\n{\n\tstruct wrapargs *wrap = p;\n\n\tclose(wrap->console->master);\n\tif (login_pty(wrap->console->slave) < 0)\n\t\treturn -1;\n\n\tif (wrap->command->program)\n\t\tlxc_attach_run_command(wrap->command);\n\telse\n\t\tlxc_attach_run_shell(NULL);\n\treturn -1;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_attach_run_shell",
          "args": [
            "NULL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_run_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "1350-1382",
          "snippet": "int lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_shell(void* payload)\n{\n\tuid_t uid;\n\tstruct passwd *passwd;\n\tchar *user_shell;\n\n\t/* Ignore payload parameter. */\n\t(void)payload;\n\n\tuid = getuid();\n\tpasswd = getpwuid(uid);\n\n\t/* This probably happens because of incompatible nss implementations in\n\t * host and container (remember, this code is still using the host's\n\t * glibc but our mount namespace is in the container) we may try to get\n\t * the information by spawning a [getent passwd uid] process and parsing\n\t * the result.\n\t */\n\tif (!passwd)\n\t\tuser_shell = lxc_attach_getpwshell(uid);\n\telse\n\t\tuser_shell = passwd->pw_shell;\n\n\tif (user_shell)\n\t\texeclp(user_shell, user_shell, (char *)NULL);\n\n\t/* Executed if either no passwd entry or execvp fails, we will fall back\n\t * on /bin/sh as a default shell.\n\t */\n\texeclp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);\n\tSYSERROR(\"Failed to exec shell.\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_attach_run_command",
          "args": [
            "wrap->command"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_attach_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "1341-1348",
          "snippet": "int lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint lxc_attach_run_command(void* payload)\n{\n\tlxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;\n\n\texecvp(cmd->program, cmd->argv);\n\tSYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "login_pty",
          "args": [
            "wrap->console->slave"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "login_pty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
          "lines": "253-263",
          "snippet": "static int login_pty(int fd)\n{\n\tsetsid();\n\tif (ioctl(fd, TIOCSCTTY, NULL) < 0)\n\t\treturn -1;\n\tif (lxc_console_set_stdfds(fd) < 0)\n\t\treturn -1;\n\tif (fd > STDERR_FILENO)\n\t\tclose(fd);\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"mainloop.h\"",
            "#include \"list.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"caps.h\"",
            "#include \"arguments.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int login_pty(int fd)\n{\n\tsetsid();\n\tif (ioctl(fd, TIOCSCTTY, NULL) < 0)\n\t\treturn -1;\n\tif (lxc_console_set_stdfds(fd) < 0)\n\t\treturn -1;\n\tif (fd > STDERR_FILENO)\n\t\tclose(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "wrap->console->master"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int get_pty_on_host_callback(void *p)\n{\n\tstruct wrapargs *wrap = p;\n\n\tclose(wrap->console->master);\n\tif (login_pty(wrap->console->slave) < 0)\n\t\treturn -1;\n\n\tif (wrap->command->program)\n\t\tlxc_attach_run_command(wrap->command);\n\telse\n\t\tlxc_attach_run_shell(NULL);\n\treturn -1;\n}"
  },
  {
    "function_name": "login_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "253-263",
    "snippet": "static int login_pty(int fd)\n{\n\tsetsid();\n\tif (ioctl(fd, TIOCSCTTY, NULL) < 0)\n\t\treturn -1;\n\tif (lxc_console_set_stdfds(fd) < 0)\n\t\treturn -1;\n\tif (fd > STDERR_FILENO)\n\t\tclose(fd);\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_console_set_stdfds",
          "args": [
            "fd"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_console_set_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/console.c",
          "lines": "555-579",
          "snippet": "int lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"start.h\" \t/* for struct lxc_handler */",
            "#include \"mainloop.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"caps.h\"",
            "#include \"af_unix.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"start.h\" \t/* for struct lxc_handler */\n#include \"mainloop.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"caps.h\"\n#include \"af_unix.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_console_set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (isatty(STDIN_FILENO))\n\t\tif (dup2(fd, STDIN_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdin.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDOUT_FILENO))\n\t\tif (dup2(fd, STDOUT_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stdout.\");\n\t\t\treturn -1;\n\t\t}\n\n\tif (isatty(STDERR_FILENO))\n\t\tif (dup2(fd, STDERR_FILENO) < 0) {\n\t\t\tSYSERROR(\"failed to duplicate stderr.\");\n\t\t\treturn -1;\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCSCTTY",
            "NULL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int login_pty(int fd)\n{\n\tsetsid();\n\tif (ioctl(fd, TIOCSCTTY, NULL) < 0)\n\t\treturn -1;\n\tif (lxc_console_set_stdfds(fd) < 0)\n\t\treturn -1;\n\tif (fd > STDERR_FILENO)\n\t\tclose(fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "109-190",
    "snippet": "static int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tchar **it;\n\tchar *del;\n\tint ret;\n\n\tswitch (c) {\n\tcase 'e':\n\t\tret = lxc_fill_elevated_privileges(arg, &elevated_privileges);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 'R': remount_sys_proc = 1; break;\n\tcase 'a':\n\t\tnew_personality = lxc_config_parse_arch(arg);\n\t\tif (new_personality < 0) {\n\t\t\tlxc_error(args, \"invalid architecture specified: %s\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tnamespace_flags = 0;\n\n\t\t/* The identifiers for namespaces used with lxc-attach as given\n\t\t * on the manpage do not align with the standard identifiers.\n\t\t * This affects network, mount, and uts namespaces. The standard\n\t\t * identifiers are: \"mnt\", \"uts\", and \"net\" whereas lxc-attach\n\t\t * uses \"MOUNT\", \"UTSNAME\", and \"NETWORK\". So let's use some\n\t\t * cheap memmove()s to replace them by their standard\n\t\t * identifiers. Let's illustrate this with an example:\n\t\t * Assume the string:\n\t\t *\n\t\t *\t\"IPC|MOUNT|PID\"\n\t\t *\n\t\t * then we memmove()\n\t\t *\n\t\t *\tdest: del + 1 == ONT|PID\n\t\t *\tsrc:  del + 3 == NT|PID\n\t\t */\n\t\twhile ((del = strstr(arg, \"MOUNT\")))\n\t\t\tmemmove(del + 1, del + 3, strlen(del) - 2);\n\n\t\tfor (it = (char *[]){\"NETWORK\", \"UTSNAME\", NULL}; it && *it; it++)\n\t\t\twhile ((del = strstr(arg, *it)))\n\t\t\t\tmemmove(del + 3, del + 7, strlen(del) - 6);\n\n\t\tret = lxc_fill_namespace_flags(arg, &namespace_flags);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\t/* -s implies -e */\n\t\tlxc_fill_elevated_privileges(NULL, &elevated_privileges);\n\t\tbreak;\n\tcase 500: /* clear-env */\n\t\tenv_policy = LXC_ATTACH_CLEAR_ENV;\n\t\tbreak;\n\tcase 501: /* keep-env */\n\t\tenv_policy = LXC_ATTACH_KEEP_ENV;\n\t\tbreak;\n\tcase 502: /* keep-var */\n\t\tret = add_to_simple_array(&extra_keep, &extra_keep_size, arg);\n\t\tif (ret < 0) {\n\t\t\tlxc_error(args, \"memory allocation error\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tret = add_to_simple_array(&extra_env, &extra_env_size, arg);\n\t\tif (ret < 0) {\n\t\t\tlxc_error(args, \"memory allocation error\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\targs->console_log = arg;\n\t\tbreak;\n\tcase 'f':\n\t\targs->rcfile = arg;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int elevated_privileges = 0;",
      "static signed long new_personality = -1;",
      "static int namespace_flags = -1;",
      "static int remount_sys_proc = 0;",
      "static lxc_attach_env_policy_t env_policy = LXC_ATTACH_KEEP_ENV;",
      "static char **extra_env = NULL;",
      "static ssize_t extra_env_size = 0;",
      "static char **extra_keep = NULL;",
      "static ssize_t extra_keep_size = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"memory allocation error\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_simple_array",
          "args": [
            "&extra_env",
            "&extra_env_size",
            "arg"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_simple_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
          "lines": "81-107",
          "snippet": "static int add_to_simple_array(char ***array, ssize_t *capacity, char *value)\n{\n\tssize_t count = 0;\n\n\tif (!array)\n\t\treturn -1;\n\n\tif (*array)\n\t\tfor (; (*array)[count]; count++);\n\n\t/* we have to reallocate */\n\tif (count >= *capacity - 1) {\n\t\tssize_t new_capacity = ((count + 1) / 32 + 1) * 32;\n\t\tchar **new_array = realloc((void*)*array, sizeof(char *) * new_capacity);\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[count], 0, sizeof(char*)*(new_capacity - count));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\tif (!(*array))\n\t\treturn -1;\n\n\t(*array)[count] = value;\n\treturn 0;\n}",
          "includes": [
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include \"utils.h\"",
            "#include \"mainloop.h\"",
            "#include \"list.h\"",
            "#include \"log.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"caps.h\"",
            "#include \"arguments.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/ioctl.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int add_to_simple_array(char ***array, ssize_t *capacity, char *value)\n{\n\tssize_t count = 0;\n\n\tif (!array)\n\t\treturn -1;\n\n\tif (*array)\n\t\tfor (; (*array)[count]; count++);\n\n\t/* we have to reallocate */\n\tif (count >= *capacity - 1) {\n\t\tssize_t new_capacity = ((count + 1) / 32 + 1) * 32;\n\t\tchar **new_array = realloc((void*)*array, sizeof(char *) * new_capacity);\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[count], 0, sizeof(char*)*(new_capacity - count));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\tif (!(*array))\n\t\treturn -1;\n\n\t(*array)[count] = value;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_fill_elevated_privileges",
          "args": [
            "NULL",
            "&elevated_privileges"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_fill_elevated_privileges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/confile.c",
          "lines": "2213-2248",
          "snippet": "int lxc_fill_elevated_privileges(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint i, aflag;\n\tstruct { const char *token; int flag; } all_privs[] = {\n\t\t{ \"CGROUP\",\t\tLXC_ATTACH_MOVE_TO_CGROUP \t},\n\t\t{ \"CAP\",\t\tLXC_ATTACH_DROP_CAPABILITIES \t},\n\t\t{ \"LSM\",\t\tLXC_ATTACH_LSM_EXEC \t\t},\n\t\t{ NULL, 0 }\n\t};\n\n\tif (!flaglist) {\n\t\t/* for the sake of backward compatibility, drop all privileges\n\t\t   if none is specified */\n\t\tfor (i = 0; all_privs[i].token; i++) {\n\t\t\t*flags |= all_privs[i].flag;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\t\taflag = -1;\n\t\tfor (i = 0; all_privs[i].token; i++) {\n\t\t\tif (!strcmp(all_privs[i].token, token))\n\t\t\t\taflag = all_privs[i].flag;\n\t\t}\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"network.h\"",
            "#include \"conf.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"confile.h\"",
            "#include \"config.h\"",
            "#include \"parse.h\"",
            "#include \"bdev.h\"",
            "#include <syslog.h>",
            "#include <dirent.h>",
            "#include <time.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <sys/utsname.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"lxcseccomp.h\"\n#include \"network.h\"\n#include \"conf.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"confile.h\"\n#include \"config.h\"\n#include \"parse.h\"\n#include \"bdev.h\"\n#include <syslog.h>\n#include <dirent.h>\n#include <time.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_fill_elevated_privileges(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint i, aflag;\n\tstruct { const char *token; int flag; } all_privs[] = {\n\t\t{ \"CGROUP\",\t\tLXC_ATTACH_MOVE_TO_CGROUP \t},\n\t\t{ \"CAP\",\t\tLXC_ATTACH_DROP_CAPABILITIES \t},\n\t\t{ \"LSM\",\t\tLXC_ATTACH_LSM_EXEC \t\t},\n\t\t{ NULL, 0 }\n\t};\n\n\tif (!flaglist) {\n\t\t/* for the sake of backward compatibility, drop all privileges\n\t\t   if none is specified */\n\t\tfor (i = 0; all_privs[i].token; i++) {\n\t\t\t*flags |= all_privs[i].flag;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\t\taflag = -1;\n\t\tfor (i = 0; all_privs[i].token; i++) {\n\t\t\tif (!strcmp(all_privs[i].token, token))\n\t\t\t\taflag = all_privs[i].flag;\n\t\t}\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_fill_namespace_flags",
          "args": [
            "arg",
            "&namespace_flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_fill_namespace_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "109-131",
          "snippet": "int lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nint lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "del + 3",
            "del + 7",
            "strlen(del) - 6"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "del"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "*it"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "del + 1",
            "del + 3",
            "strlen(del) - 2"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "del"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "arg",
            "\"MOUNT\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error",
          "args": [
            "args",
            "\"invalid architecture specified: %s\"",
            "arg"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_config_parse_arch",
          "args": [
            "arg"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_config_parse_arch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "84-111",
          "snippet": "signed long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [
            "#define PER_LINUX32 0x0008",
            "#define PER_LINUX 0x0000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\n#define PER_LINUX32 0x0008\n#define PER_LINUX 0x0000\n\nsigned long lxc_config_parse_arch(const char *arch)\n{\n    struct per_name {\n        char *name;\n        unsigned long per;\n    } pername[] = {\n        { \"x86\", PER_LINUX32 },\n        { \"linux32\", PER_LINUX32 },\n        { \"i386\", PER_LINUX32 },\n        { \"i486\", PER_LINUX32 },\n        { \"i586\", PER_LINUX32 },\n        { \"i686\", PER_LINUX32 },\n        { \"athlon\", PER_LINUX32 },\n        { \"linux64\", PER_LINUX },\n        { \"x86_64\", PER_LINUX },\n        { \"amd64\", PER_LINUX },\n    };\n    size_t len = sizeof(pername) / sizeof(pername[0]);\n\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (!strcmp(pername[i].name, arch))\n            return pername[i].per;\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int elevated_privileges = 0;\nstatic signed long new_personality = -1;\nstatic int namespace_flags = -1;\nstatic int remount_sys_proc = 0;\nstatic lxc_attach_env_policy_t env_policy = LXC_ATTACH_KEEP_ENV;\nstatic char **extra_env = NULL;\nstatic ssize_t extra_env_size = 0;\nstatic char **extra_keep = NULL;\nstatic ssize_t extra_keep_size = 0;\n\nstatic int my_parser(struct lxc_arguments* args, int c, char* arg)\n{\n\tchar **it;\n\tchar *del;\n\tint ret;\n\n\tswitch (c) {\n\tcase 'e':\n\t\tret = lxc_fill_elevated_privileges(arg, &elevated_privileges);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 'R': remount_sys_proc = 1; break;\n\tcase 'a':\n\t\tnew_personality = lxc_config_parse_arch(arg);\n\t\tif (new_personality < 0) {\n\t\t\tlxc_error(args, \"invalid architecture specified: %s\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tnamespace_flags = 0;\n\n\t\t/* The identifiers for namespaces used with lxc-attach as given\n\t\t * on the manpage do not align with the standard identifiers.\n\t\t * This affects network, mount, and uts namespaces. The standard\n\t\t * identifiers are: \"mnt\", \"uts\", and \"net\" whereas lxc-attach\n\t\t * uses \"MOUNT\", \"UTSNAME\", and \"NETWORK\". So let's use some\n\t\t * cheap memmove()s to replace them by their standard\n\t\t * identifiers. Let's illustrate this with an example:\n\t\t * Assume the string:\n\t\t *\n\t\t *\t\"IPC|MOUNT|PID\"\n\t\t *\n\t\t * then we memmove()\n\t\t *\n\t\t *\tdest: del + 1 == ONT|PID\n\t\t *\tsrc:  del + 3 == NT|PID\n\t\t */\n\t\twhile ((del = strstr(arg, \"MOUNT\")))\n\t\t\tmemmove(del + 1, del + 3, strlen(del) - 2);\n\n\t\tfor (it = (char *[]){\"NETWORK\", \"UTSNAME\", NULL}; it && *it; it++)\n\t\t\twhile ((del = strstr(arg, *it)))\n\t\t\t\tmemmove(del + 3, del + 7, strlen(del) - 6);\n\n\t\tret = lxc_fill_namespace_flags(arg, &namespace_flags);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\t/* -s implies -e */\n\t\tlxc_fill_elevated_privileges(NULL, &elevated_privileges);\n\t\tbreak;\n\tcase 500: /* clear-env */\n\t\tenv_policy = LXC_ATTACH_CLEAR_ENV;\n\t\tbreak;\n\tcase 501: /* keep-env */\n\t\tenv_policy = LXC_ATTACH_KEEP_ENV;\n\t\tbreak;\n\tcase 502: /* keep-var */\n\t\tret = add_to_simple_array(&extra_keep, &extra_keep_size, arg);\n\t\tif (ret < 0) {\n\t\t\tlxc_error(args, \"memory allocation error\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 'v':\n\t\tret = add_to_simple_array(&extra_env, &extra_env_size, arg);\n\t\tif (ret < 0) {\n\t\t\tlxc_error(args, \"memory allocation error\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\targs->console_log = arg;\n\t\tbreak;\n\tcase 'f':\n\t\targs->rcfile = arg;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_to_simple_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_attach.c",
    "lines": "81-107",
    "snippet": "static int add_to_simple_array(char ***array, ssize_t *capacity, char *value)\n{\n\tssize_t count = 0;\n\n\tif (!array)\n\t\treturn -1;\n\n\tif (*array)\n\t\tfor (; (*array)[count]; count++);\n\n\t/* we have to reallocate */\n\tif (count >= *capacity - 1) {\n\t\tssize_t new_capacity = ((count + 1) / 32 + 1) * 32;\n\t\tchar **new_array = realloc((void*)*array, sizeof(char *) * new_capacity);\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[count], 0, sizeof(char*)*(new_capacity - count));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\tif (!(*array))\n\t\treturn -1;\n\n\t(*array)[count] = value;\n\treturn 0;\n}",
    "includes": [
      "#include <../include/openpty.h>",
      "#include <pty.h>",
      "#include \"utils.h\"",
      "#include \"mainloop.h\"",
      "#include \"list.h\"",
      "#include \"log.h\"",
      "#include \"console.h\"",
      "#include \"confile.h\"",
      "#include \"caps.h\"",
      "#include \"arguments.h\"",
      "#include \"attach.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/ioctl.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_array[count]",
            "0",
            "sizeof(char*)*(new_capacity - count)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "(void*)*array",
            "sizeof(char *) * new_capacity"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <../include/openpty.h>\n#include <pty.h>\n#include \"utils.h\"\n#include \"mainloop.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"caps.h\"\n#include \"arguments.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int add_to_simple_array(char ***array, ssize_t *capacity, char *value)\n{\n\tssize_t count = 0;\n\n\tif (!array)\n\t\treturn -1;\n\n\tif (*array)\n\t\tfor (; (*array)[count]; count++);\n\n\t/* we have to reallocate */\n\tif (count >= *capacity - 1) {\n\t\tssize_t new_capacity = ((count + 1) / 32 + 1) * 32;\n\t\tchar **new_array = realloc((void*)*array, sizeof(char *) * new_capacity);\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[count], 0, sizeof(char*)*(new_capacity - count));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\tif (!(*array))\n\t\treturn -1;\n\n\t(*array)[count] = value;\n\treturn 0;\n}"
  }
]