[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "345-440",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret, pipefd;\n\tchar logpath[PATH_MAX];\n\tsigset_t mask;\n\tchar *lxcpath = argv[1];\n\tbool mainloop_opened = false;\n\tbool monitord_created = false;\n\n\tif (argc != 3) {\n\t\tfprintf(stderr,\n\t\t\t\"Usage: lxc-monitord lxcpath sync-pipe-fd\\n\\n\"\n\t\t\t\"NOTE: lxc-monitord is intended for use by lxc internally\\n\"\n\t\t\t\"      and does not need to be run by hand\\n\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = snprintf(logpath, sizeof(logpath), \"%s/lxc-monitord.log\",\n\t\t       (strcmp(LXCPATH, lxcpath) ? lxcpath : LOGPATH ));\n\tif (ret < 0 || ret >= sizeof(logpath))\n\t\texit(EXIT_FAILURE);\n\n\tret = lxc_log_init(NULL, logpath, \"DEBUG\", \"lxc-monitord\", 0, lxcpath);\n\tif (ret)\n\t\tINFO(\"Failed to open log file %s, log will be lost.\", lxcpath);\n\tlxc_log_options_no_override();\n\n\tif (lxc_safe_int(argv[2], &pipefd) < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL)  ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS)  ||\n\t    sigdelset(&mask, SIGTERM) ||\n\t    sigprocmask(SIG_BLOCK, &mask, NULL)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsignal(SIGILL,  lxc_monitord_sig_handler);\n\tsignal(SIGSEGV, lxc_monitord_sig_handler);\n\tsignal(SIGBUS,  lxc_monitord_sig_handler);\n\tsignal(SIGTERM, lxc_monitord_sig_handler);\n\n\tif (sigsetjmp(mark, 1) != 0)\n\t\tgoto on_signal;\n\n\tret = EXIT_FAILURE;\n\tmemset(&mon, 0, sizeof(mon));\n\tmon.lxcpath = lxcpath;\n\tif (lxc_mainloop_open(&mon.descr)) {\n\t\tERROR(\"Failed to create mainloop.\");\n\t\tgoto on_error;\n\t}\n\tmainloop_opened = true;\n\n\tif (lxc_monitord_create(&mon))\n\t\tgoto on_error;\n\tmonitord_created = true;\n\n\t/* sync with parent, we're ignoring the return from write\n\t * because regardless if it works or not, the following\n\t * close will sync us with the parent process. the\n\t * if-empty-statement construct is to quiet the\n\t * warn-unused-result warning.\n\t */\n\tif (write(pipefd, \"S\", 1))\n\t\t;\n\tclose(pipefd);\n\n\tif (lxc_monitord_mainloop_add(&mon)) {\n\t\tERROR(\"Failed to add mainloop handlers.\");\n\t\tgoto on_error;\n\t}\n\n\tNOTICE(\"lxc-monitord with pid %d is now monitoring lxcpath %s.\",\n\t       getpid(), mon.lxcpath);\n\tfor (;;) {\n\t\tret = lxc_mainloop(&mon.descr, 1000 * 30);\n\t\tif (mon.clientfds_cnt <= 0) {\n\t\t\tNOTICE(\"No remaining clients. lxc-monitord is exiting.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\non_signal:\n\tret = EXIT_SUCCESS;\non_error:\n\tif (monitord_created)\n\t\tlxc_monitord_cleanup();\n\tif (mainloop_opened)\n\t\tlxc_mainloop_close(&mon.descr);\n\n\texit(ret);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sigjmp_buf mark;",
      "static void lxc_monitord_cleanup(void);",
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_close",
          "args": [
            "&mon.descr"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "148-163",
          "snippet": "int lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_close(struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_list *iterator, *next;\n\n\titerator = descr->handlers.next;\n\twhile (iterator != &descr->handlers) {\n\t\tnext = iterator->next;\n\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator->elem);\n\t\tfree(iterator);\n\t\titerator = next;\n\t}\n\n\treturn close(descr->epfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_cleanup",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "335-338",
          "snippet": "static void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_monitord_cleanup(void);",
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"No remaining clients. lxc-monitord is exiting.\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop",
          "args": [
            "&mon.descr",
            "1000 * 30"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"lxc-monitord with pid %d is now monitoring lxcpath %s.\"",
            "getpid()",
            "mon.lxcpath"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add mainloop handlers.\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitord_mainloop_add",
          "args": [
            "&mon"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_mainloop_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "314-333",
          "snippet": "static int lxc_monitord_mainloop_add(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->fifofd,\n\t\t\t\t       lxc_monitord_fifo_handler, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for fifo.\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->listenfd,\n\t\t\t\t       lxc_monitord_sock_accept, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for listen socket.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_mainloop_add(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->fifofd,\n\t\t\t\t       lxc_monitord_fifo_handler, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for fifo.\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->listenfd,\n\t\t\t\t       lxc_monitord_sock_accept, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for listen socket.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefd",
            "\"S\"",
            "1"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_create",
          "args": [
            "&mon"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "260-270",
          "snippet": "static int lxc_monitord_create(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_monitord_fifo_create(mon);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lxc_monitord_sock_create(mon);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_create(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_monitord_fifo_create(mon);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lxc_monitord_sock_create(mon);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create mainloop.\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_open",
          "args": [
            "&mon.descr"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "132-146",
          "snippet": "int lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_open(struct lxc_epoll_descr *descr)\n{\n\t/* hint value passed to epoll create */\n\tdescr->epfd = epoll_create(2);\n\tif (descr->epfd < 0)\n\t\treturn -1;\n\n\tif (fcntl(descr->epfd, F_SETFD, FD_CLOEXEC)) {\n\t\tclose(descr->epfd);\n\t\treturn -1;\n\t}\n\n\tlxc_list_init(&descr->handlers);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mon",
            "0",
            "sizeof(mon)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigsetjmp",
          "args": [
            "mark",
            "1"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "lxc_monitord_sig_handler"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "task_blocking_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1893-1925",
          "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set signal mask.\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "NULL"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGTERM"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGBUS"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGSEGV"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&mask",
            "SIGILL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&mask"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_int",
          "args": [
            "argv[2]",
            "&pipefd"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2005-2023",
          "snippet": "int lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to open log file %s, log will be lost.\"",
            "lxcpath"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "NULL",
            "logpath",
            "\"DEBUG\"",
            "\"lxc-monitord\"",
            "0",
            "lxcpath"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "logpath",
            "sizeof(logpath)",
            "\"%s/lxc-monitord.log\"",
            "(strcmp(LXCPATH, lxcpath) ? lxcpath : LOGPATH )"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "LXCPATH",
            "lxcpath"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: lxc-monitord lxcpath sync-pipe-fd\\n\\n\"\n\t\t\t\"NOTE: lxc-monitord is intended for use by lxc internally\\n\"\n\t\t\t\"      and does not need to be run by hand\\n\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nsigjmp_buf mark;\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nint main(int argc, char *argv[])\n{\n\tint ret, pipefd;\n\tchar logpath[PATH_MAX];\n\tsigset_t mask;\n\tchar *lxcpath = argv[1];\n\tbool mainloop_opened = false;\n\tbool monitord_created = false;\n\n\tif (argc != 3) {\n\t\tfprintf(stderr,\n\t\t\t\"Usage: lxc-monitord lxcpath sync-pipe-fd\\n\\n\"\n\t\t\t\"NOTE: lxc-monitord is intended for use by lxc internally\\n\"\n\t\t\t\"      and does not need to be run by hand\\n\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = snprintf(logpath, sizeof(logpath), \"%s/lxc-monitord.log\",\n\t\t       (strcmp(LXCPATH, lxcpath) ? lxcpath : LOGPATH ));\n\tif (ret < 0 || ret >= sizeof(logpath))\n\t\texit(EXIT_FAILURE);\n\n\tret = lxc_log_init(NULL, logpath, \"DEBUG\", \"lxc-monitord\", 0, lxcpath);\n\tif (ret)\n\t\tINFO(\"Failed to open log file %s, log will be lost.\", lxcpath);\n\tlxc_log_options_no_override();\n\n\tif (lxc_safe_int(argv[2], &pipefd) < 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (sigfillset(&mask) ||\n\t    sigdelset(&mask, SIGILL)  ||\n\t    sigdelset(&mask, SIGSEGV) ||\n\t    sigdelset(&mask, SIGBUS)  ||\n\t    sigdelset(&mask, SIGTERM) ||\n\t    sigprocmask(SIG_BLOCK, &mask, NULL)) {\n\t\tSYSERROR(\"Failed to set signal mask.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsignal(SIGILL,  lxc_monitord_sig_handler);\n\tsignal(SIGSEGV, lxc_monitord_sig_handler);\n\tsignal(SIGBUS,  lxc_monitord_sig_handler);\n\tsignal(SIGTERM, lxc_monitord_sig_handler);\n\n\tif (sigsetjmp(mark, 1) != 0)\n\t\tgoto on_signal;\n\n\tret = EXIT_FAILURE;\n\tmemset(&mon, 0, sizeof(mon));\n\tmon.lxcpath = lxcpath;\n\tif (lxc_mainloop_open(&mon.descr)) {\n\t\tERROR(\"Failed to create mainloop.\");\n\t\tgoto on_error;\n\t}\n\tmainloop_opened = true;\n\n\tif (lxc_monitord_create(&mon))\n\t\tgoto on_error;\n\tmonitord_created = true;\n\n\t/* sync with parent, we're ignoring the return from write\n\t * because regardless if it works or not, the following\n\t * close will sync us with the parent process. the\n\t * if-empty-statement construct is to quiet the\n\t * warn-unused-result warning.\n\t */\n\tif (write(pipefd, \"S\", 1))\n\t\t;\n\tclose(pipefd);\n\n\tif (lxc_monitord_mainloop_add(&mon)) {\n\t\tERROR(\"Failed to add mainloop handlers.\");\n\t\tgoto on_error;\n\t}\n\n\tNOTICE(\"lxc-monitord with pid %d is now monitoring lxcpath %s.\",\n\t       getpid(), mon.lxcpath);\n\tfor (;;) {\n\t\tret = lxc_mainloop(&mon.descr, 1000 * 30);\n\t\tif (mon.clientfds_cnt <= 0) {\n\t\t\tNOTICE(\"No remaining clients. lxc-monitord is exiting.\");\n\t\t\tbreak;\n\t\t}\n\t}\n\non_signal:\n\tret = EXIT_SUCCESS;\non_error:\n\tif (monitord_created)\n\t\tlxc_monitord_cleanup();\n\tif (mainloop_opened)\n\t\tlxc_mainloop_close(&mon.descr);\n\n\texit(ret);\n}"
  },
  {
    "function_name": "lxc_monitord_sig_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "340-343",
    "snippet": "static void lxc_monitord_sig_handler(int sig)\n{\n\tsiglongjmp(mark, 1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "sigjmp_buf mark;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "siglongjmp",
          "args": [
            "mark",
            "1"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nsigjmp_buf mark;\n\nstatic void lxc_monitord_sig_handler(int sig)\n{\n\tsiglongjmp(mark, 1);\n}"
  },
  {
    "function_name": "lxc_monitord_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "335-338",
    "snippet": "static void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_monitord_cleanup(void);",
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitord_delete",
          "args": [
            "&mon"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "272-289",
          "snippet": "static void lxc_monitord_delete(struct lxc_monitor *mon)\n{\n\tint i;\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->listenfd);\n\tclose(mon->listenfd);\n\tlxc_monitord_sock_delete(mon);\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->fifofd);\n\tlxc_monitord_fifo_delete(mon);\n\tclose(mon->fifofd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tlxc_mainloop_del_handler(&mon->descr, mon->clientfds[i]);\n\t\tclose(mon->clientfds[i]);\n\t}\n\tmon->clientfds_cnt = 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_delete(struct lxc_monitor *mon)\n{\n\tint i;\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->listenfd);\n\tclose(mon->listenfd);\n\tlxc_monitord_sock_delete(mon);\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->fifofd);\n\tlxc_monitord_fifo_delete(mon);\n\tclose(mon->fifofd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tlxc_mainloop_del_handler(&mon->descr, mon->clientfds[i]);\n\t\tclose(mon->clientfds[i]);\n\t}\n\tmon->clientfds_cnt = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}"
  },
  {
    "function_name": "lxc_monitord_mainloop_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "314-333",
    "snippet": "static int lxc_monitord_mainloop_add(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->fifofd,\n\t\t\t\t       lxc_monitord_fifo_handler, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for fifo.\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->listenfd,\n\t\t\t\t       lxc_monitord_sock_accept, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for listen socket.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add to mainloop monitor handler for listen socket.\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "&mon->descr",
            "mon->listenfd",
            "lxc_monitord_sock_accept",
            "mon"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add to mainloop monitor handler for fifo.\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_mainloop_add(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->fifofd,\n\t\t\t\t       lxc_monitord_fifo_handler, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for fifo.\");\n\t\treturn -1;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, mon->listenfd,\n\t\t\t\t       lxc_monitord_sock_accept, mon);\n\tif (ret < 0) {\n\t\tERROR(\"Failed to add to mainloop monitor handler for listen socket.\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitord_fifo_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "291-312",
    "snippet": "static int lxc_monitord_fifo_handler(int fd, uint32_t events, void *data,\n\t\t\t\t     struct lxc_epoll_descr *descr)\n{\n\tint ret,i;\n\tstruct lxc_msg msglxc;\n\tstruct lxc_monitor *mon = data;\n\n\tret = read(fd, &msglxc, sizeof(msglxc));\n\tif (ret != sizeof(msglxc)) {\n\t\tSYSERROR(\"Reading from fifo failed: %s.\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tret = write(mon->clientfds[i], &msglxc, sizeof(msglxc));\n\t\tif (ret < 0)\n\t\t\tERROR(\"Failed to send message to client file descriptor %d: %s.\",\n\t\t\t      mon->clientfds[i], strerror(errno));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to send message to client file descriptor %d: %s.\"",
            "mon->clientfds[i]",
            "strerror(errno)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "mon->clientfds[i]",
            "&msglxc",
            "sizeof(msglxc)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Reading from fifo failed: %s.\"",
            "strerror(errno)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&msglxc",
            "sizeof(msglxc)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_fifo_handler(int fd, uint32_t events, void *data,\n\t\t\t\t     struct lxc_epoll_descr *descr)\n{\n\tint ret,i;\n\tstruct lxc_msg msglxc;\n\tstruct lxc_monitor *mon = data;\n\n\tret = read(fd, &msglxc, sizeof(msglxc));\n\tif (ret != sizeof(msglxc)) {\n\t\tSYSERROR(\"Reading from fifo failed: %s.\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tret = write(mon->clientfds[i], &msglxc, sizeof(msglxc));\n\t\tif (ret < 0)\n\t\t\tERROR(\"Failed to send message to client file descriptor %d: %s.\",\n\t\t\t      mon->clientfds[i], strerror(errno));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitord_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "272-289",
    "snippet": "static void lxc_monitord_delete(struct lxc_monitor *mon)\n{\n\tint i;\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->listenfd);\n\tclose(mon->listenfd);\n\tlxc_monitord_sock_delete(mon);\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->fifofd);\n\tlxc_monitord_fifo_delete(mon);\n\tclose(mon->fifofd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tlxc_mainloop_del_handler(&mon->descr, mon->clientfds[i]);\n\t\tclose(mon->clientfds[i]);\n\t}\n\tmon->clientfds_cnt = 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "mon->clientfds[i]"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "&mon->descr",
            "mon->clientfds[i]"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_fifo_delete",
          "args": [
            "mon"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_fifo_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "115-126",
          "snippet": "static int lxc_monitord_fifo_delete(struct lxc_monitor *mon)\n{\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tunlink(fifo_path);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_fifo_delete(struct lxc_monitor *mon)\n{\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tunlink(fifo_path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_sock_delete",
          "args": [
            "mon"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_sock_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "249-258",
          "snippet": "static int lxc_monitord_sock_delete(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\tif (addr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_sock_delete(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\tif (addr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_delete(struct lxc_monitor *mon)\n{\n\tint i;\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->listenfd);\n\tclose(mon->listenfd);\n\tlxc_monitord_sock_delete(mon);\n\n\tlxc_mainloop_del_handler(&mon->descr, mon->fifofd);\n\tlxc_monitord_fifo_delete(mon);\n\tclose(mon->fifofd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tlxc_mainloop_del_handler(&mon->descr, mon->clientfds[i]);\n\t\tclose(mon->clientfds[i]);\n\t}\n\tmon->clientfds_cnt = 0;\n}"
  },
  {
    "function_name": "lxc_monitord_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "260-270",
    "snippet": "static int lxc_monitord_create(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_monitord_fifo_create(mon);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lxc_monitord_sock_create(mon);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitord_sock_create",
          "args": [
            "mon"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_sock_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "231-247",
          "snippet": "static int lxc_monitord_sock_create(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(addr.sun_path, SOCK_STREAM, O_TRUNC);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open unix socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->listenfd = fd;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_sock_create(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(addr.sun_path, SOCK_STREAM, O_TRUNC);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open unix socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->listenfd = fd;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_fifo_create",
          "args": [
            "mon"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_fifo_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "79-113",
          "snippet": "static int lxc_monitord_fifo_create(struct lxc_monitor *mon)\n{\n\tstruct flock lk;\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mknod(fifo_path, S_IFIFO|S_IRUSR|S_IWUSR, 0);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tINFO(\"Failed to mknod monitor fifo %s: %s.\", fifo_path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->fifofd = open(fifo_path, O_RDWR);\n\tif (mon->fifofd < 0) {\n\t\tunlink(fifo_path);\n\t\tERROR(\"Failed to open monitor fifo.\");\n\t\treturn -1;\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(mon->fifofd, F_SETLK, &lk) != 0) {\n\t\t/* another lxc-monitord is already running, don't start up */\n\t\tDEBUG(\"lxc-monitord already running on lxcpath %s.\", mon->lxcpath);\n\t\tclose(mon->fifofd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_fifo_create(struct lxc_monitor *mon)\n{\n\tstruct flock lk;\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mknod(fifo_path, S_IFIFO|S_IRUSR|S_IWUSR, 0);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tINFO(\"Failed to mknod monitor fifo %s: %s.\", fifo_path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->fifofd = open(fifo_path, O_RDWR);\n\tif (mon->fifofd < 0) {\n\t\tunlink(fifo_path);\n\t\tERROR(\"Failed to open monitor fifo.\");\n\t\treturn -1;\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(mon->fifofd, F_SETLK, &lk) != 0) {\n\t\t/* another lxc-monitord is already running, don't start up */\n\t\tDEBUG(\"lxc-monitord already running on lxcpath %s.\", mon->lxcpath);\n\t\tclose(mon->fifofd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_create(struct lxc_monitor *mon)\n{\n\tint ret;\n\n\tret = lxc_monitord_fifo_create(mon);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = lxc_monitord_sock_create(mon);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_monitord_sock_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "249-258",
    "snippet": "static int lxc_monitord_sock_delete(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\tif (addr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "addr.sun_path"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_sock_name",
          "args": [
            "mon->lxcpath",
            "&addr"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_sock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "156-188",
          "snippet": "int lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_sock_delete(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\tif (addr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitord_sock_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "231-247",
    "snippet": "static int lxc_monitord_sock_create(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(addr.sun_path, SOCK_STREAM, O_TRUNC);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open unix socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->listenfd = fd;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to open unix socket: %s.\"",
            "strerror(errno)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abstract_unix_open",
          "args": [
            "addr.sun_path",
            "SOCK_STREAM",
            "O_TRUNC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitor_sock_name",
          "args": [
            "mon->lxcpath",
            "&addr"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_sock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "156-188",
          "snippet": "int lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_sock_create(struct lxc_monitor *mon)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\n\tif (lxc_monitor_sock_name(mon->lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = lxc_abstract_unix_open(addr.sun_path, SOCK_STREAM, O_TRUNC);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to open unix socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->listenfd = fd;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitord_sock_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "169-229",
    "snippet": "static int lxc_monitord_sock_accept(int fd, uint32_t events, void *data,\n\t\t\t\t    struct lxc_epoll_descr *descr)\n{\n\tint ret,clientfd;\n\tstruct lxc_monitor *mon = data;\n\tstruct ucred cred;\n\tsocklen_t credsz = sizeof(cred);\n\n\tret = -1;\n\tclientfd = accept(fd, NULL, 0);\n\tif (clientfd < 0) {\n\t\tSYSERROR(\"Failed to accept connection for client file descriptor %d.\", fd);\n\t\tgoto out;\n\t}\n\n\tif (fcntl(clientfd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on client socket connection %d.\", clientfd);\n\t\tgoto err1;\n\t}\n\n\tif (getsockopt(clientfd, SOL_SOCKET, SO_PEERCRED, &cred, &credsz))\n\t{\n\t\tERROR(\"Failed to get credentials on client socket connection %d.\", clientfd);\n\t\tgoto err1;\n\t}\n\tif (cred.uid && cred.uid != geteuid()) {\n\t\tWARN(\"Monitor denied for uid %d on client socket connection %d.\", cred.uid, clientfd);\n\t\tret = -EACCES;\n\t\tgoto err1;\n\t}\n\n\tif (mon->clientfds_cnt + 1 > mon->clientfds_size) {\n\t\tint *clientfds;\n\t\tclientfds = realloc(mon->clientfds,\n\t\t\t\t    (mon->clientfds_size + CLIENTFDS_CHUNK) * sizeof(mon->clientfds[0]));\n\t\tif (clientfds == NULL) {\n\t\t\tERROR(\"Failed to realloc memory for %d client file \"\n\t\t\t      \"descriptors.\",\n\t\t\t      mon->clientfds_size + CLIENTFDS_CHUNK);\n\t\t\tgoto err1;\n\t\t}\n\t\tmon->clientfds = clientfds;\n\t\tmon->clientfds_size += CLIENTFDS_CHUNK;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, clientfd,\n\t\t\t\t       lxc_monitord_sock_handler, mon);\n\tif (ret) {\n\t\tERROR(\"Failed to add socket handler.\");\n\t\tgoto err1;\n\t}\n\n\tmon->clientfds[mon->clientfds_cnt++] = clientfd;\n\tINFO(\"Accepted client file descriptor %d. Number of accepted file descriptors is now %d.\", clientfd, mon->clientfds_cnt);\n\tgoto out;\n\nerr1:\n\tclose(clientfd);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define CLIENTFDS_CHUNK 64"
    ],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "clientfd"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Accepted client file descriptor %d. Number of accepted file descriptors is now %d.\"",
            "clientfd",
            "mon->clientfds_cnt"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to add socket handler.\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_add_handler",
          "args": [
            "&mon->descr",
            "clientfd",
            "lxc_monitord_sock_handler",
            "mon"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_add_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "75-107",
          "snippet": "int lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_add_handler(struct lxc_epoll_descr *descr, int fd,\n\t\t\t     lxc_mainloop_callback_t callback, void *data)\n{\n\tstruct epoll_event ev;\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *item;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn -1;\n\n\thandler->callback = callback;\n\thandler->fd = fd;\n\thandler->data = data;\n\n\tev.events = EPOLLIN;\n\tev.data.ptr = handler;\n\n\tif (epoll_ctl(descr->epfd, EPOLL_CTL_ADD, fd, &ev) < 0)\n\t\tgoto out_free_handler;\n\n\titem = malloc(sizeof(*item));\n\tif (!item)\n\t\tgoto out_free_handler;\n\n\titem->elem = handler;\n\tlxc_list_add(&descr->handlers, item);\n\treturn 0;\n\nout_free_handler:\n\tfree(handler);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to realloc memory for %d client file \"\n\t\t\t      \"descriptors.\"",
            "mon->clientfds_size + CLIENTFDS_CHUNK"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "mon->clientfds",
            "(mon->clientfds_size + CLIENTFDS_CHUNK) * sizeof(mon->clientfds[0])"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Monitor denied for uid %d on client socket connection %d.\"",
            "cred.uid",
            "clientfd"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to get credentials on client socket connection %d.\"",
            "clientfd"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "clientfd",
            "SOL_SOCKET",
            "SO_PEERCRED",
            "&cred",
            "&credsz"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to set FD_CLOEXEC on client socket connection %d.\"",
            "clientfd"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "clientfd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to accept connection for client file descriptor %d.\"",
            "fd"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "fd",
            "NULL",
            "0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CLIENTFDS_CHUNK 64\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_sock_accept(int fd, uint32_t events, void *data,\n\t\t\t\t    struct lxc_epoll_descr *descr)\n{\n\tint ret,clientfd;\n\tstruct lxc_monitor *mon = data;\n\tstruct ucred cred;\n\tsocklen_t credsz = sizeof(cred);\n\n\tret = -1;\n\tclientfd = accept(fd, NULL, 0);\n\tif (clientfd < 0) {\n\t\tSYSERROR(\"Failed to accept connection for client file descriptor %d.\", fd);\n\t\tgoto out;\n\t}\n\n\tif (fcntl(clientfd, F_SETFD, FD_CLOEXEC)) {\n\t\tSYSERROR(\"Failed to set FD_CLOEXEC on client socket connection %d.\", clientfd);\n\t\tgoto err1;\n\t}\n\n\tif (getsockopt(clientfd, SOL_SOCKET, SO_PEERCRED, &cred, &credsz))\n\t{\n\t\tERROR(\"Failed to get credentials on client socket connection %d.\", clientfd);\n\t\tgoto err1;\n\t}\n\tif (cred.uid && cred.uid != geteuid()) {\n\t\tWARN(\"Monitor denied for uid %d on client socket connection %d.\", cred.uid, clientfd);\n\t\tret = -EACCES;\n\t\tgoto err1;\n\t}\n\n\tif (mon->clientfds_cnt + 1 > mon->clientfds_size) {\n\t\tint *clientfds;\n\t\tclientfds = realloc(mon->clientfds,\n\t\t\t\t    (mon->clientfds_size + CLIENTFDS_CHUNK) * sizeof(mon->clientfds[0]));\n\t\tif (clientfds == NULL) {\n\t\t\tERROR(\"Failed to realloc memory for %d client file \"\n\t\t\t      \"descriptors.\",\n\t\t\t      mon->clientfds_size + CLIENTFDS_CHUNK);\n\t\t\tgoto err1;\n\t\t}\n\t\tmon->clientfds = clientfds;\n\t\tmon->clientfds_size += CLIENTFDS_CHUNK;\n\t}\n\n\tret = lxc_mainloop_add_handler(&mon->descr, clientfd,\n\t\t\t\t       lxc_monitord_sock_handler, mon);\n\tif (ret) {\n\t\tERROR(\"Failed to add socket handler.\");\n\t\tgoto err1;\n\t}\n\n\tmon->clientfds[mon->clientfds_cnt++] = clientfd;\n\tINFO(\"Accepted client file descriptor %d. Number of accepted file descriptors is now %d.\", clientfd, mon->clientfds_cnt);\n\tgoto out;\n\nerr1:\n\tclose(clientfd);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_monitord_sock_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "150-167",
    "snippet": "static int lxc_monitord_sock_handler(int fd, uint32_t events, void *data,\n\t\t\t\t     struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_monitor *mon = data;\n\n\tif (events & EPOLLIN) {\n\t\tint rc;\n\t\tchar buf[4];\n\n\t\trc = read(fd, buf, sizeof(buf));\n\t\tif (rc > 0 && !strncmp(buf, \"quit\", 4))\n\t\t\tquit = 1;\n\t}\n\n\tif (events & EPOLLHUP)\n\t\tlxc_monitord_sockfd_remove(mon, fd);\n\treturn quit;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;",
      "static int quit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitord_sockfd_remove",
          "args": [
            "mon",
            "fd"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_sockfd_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "128-148",
          "snippet": "static void lxc_monitord_sockfd_remove(struct lxc_monitor *mon, int fd) {\n\tint i;\n\n\tif (lxc_mainloop_del_handler(&mon->descr, fd))\n\t\tCRIT(\"File descriptor %d not found in mainloop.\", fd);\n\tclose(fd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tif (mon->clientfds[i] == fd)\n\t\t\tbreak;\n\t}\n\tif (i >= mon->clientfds_cnt) {\n\t\tCRIT(\"File descriptor %d not found in clients array.\", fd);\n\t\tlxc_monitord_cleanup();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemmove(&mon->clientfds[i], &mon->clientfds[i+1],\n\t\t(mon->clientfds_cnt - i - 1) * sizeof(mon->clientfds[0]));\n\tmon->clientfds_cnt--;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_monitord_cleanup(void);",
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_sockfd_remove(struct lxc_monitor *mon, int fd) {\n\tint i;\n\n\tif (lxc_mainloop_del_handler(&mon->descr, fd))\n\t\tCRIT(\"File descriptor %d not found in mainloop.\", fd);\n\tclose(fd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tif (mon->clientfds[i] == fd)\n\t\t\tbreak;\n\t}\n\tif (i >= mon->clientfds_cnt) {\n\t\tCRIT(\"File descriptor %d not found in clients array.\", fd);\n\t\tlxc_monitord_cleanup();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemmove(&mon->clientfds[i], &mon->clientfds[i+1],\n\t\t(mon->clientfds_cnt - i - 1) * sizeof(mon->clientfds[0]));\n\tmon->clientfds_cnt--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"quit\"",
            "4"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\nstatic int quit;\n\nstatic int lxc_monitord_sock_handler(int fd, uint32_t events, void *data,\n\t\t\t\t     struct lxc_epoll_descr *descr)\n{\n\tstruct lxc_monitor *mon = data;\n\n\tif (events & EPOLLIN) {\n\t\tint rc;\n\t\tchar buf[4];\n\n\t\trc = read(fd, buf, sizeof(buf));\n\t\tif (rc > 0 && !strncmp(buf, \"quit\", 4))\n\t\t\tquit = 1;\n\t}\n\n\tif (events & EPOLLHUP)\n\t\tlxc_monitord_sockfd_remove(mon, fd);\n\treturn quit;\n}"
  },
  {
    "function_name": "lxc_monitord_sockfd_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "128-148",
    "snippet": "static void lxc_monitord_sockfd_remove(struct lxc_monitor *mon, int fd) {\n\tint i;\n\n\tif (lxc_mainloop_del_handler(&mon->descr, fd))\n\t\tCRIT(\"File descriptor %d not found in mainloop.\", fd);\n\tclose(fd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tif (mon->clientfds[i] == fd)\n\t\t\tbreak;\n\t}\n\tif (i >= mon->clientfds_cnt) {\n\t\tCRIT(\"File descriptor %d not found in clients array.\", fd);\n\t\tlxc_monitord_cleanup();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemmove(&mon->clientfds[i], &mon->clientfds[i+1],\n\t\t(mon->clientfds_cnt - i - 1) * sizeof(mon->clientfds[0]));\n\tmon->clientfds_cnt--;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lxc_monitord_cleanup(void);",
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&mon->clientfds[i]",
            "&mon->clientfds[i+1]",
            "(mon->clientfds_cnt - i - 1) * sizeof(mon->clientfds[0])"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitord_cleanup",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
          "lines": "335-338",
          "snippet": "static void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"log.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/epoll.h>",
            "#include <setjmp.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_monitord_cleanup(void);",
            "static struct lxc_monitor mon;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_cleanup(void)\n{\n\tlxc_monitord_delete(&mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRIT",
          "args": [
            "\"File descriptor %d not found in clients array.\"",
            "fd"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRIT",
          "args": [
            "\"File descriptor %d not found in mainloop.\"",
            "fd"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_mainloop_del_handler",
          "args": [
            "&mon->descr",
            "fd"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mainloop_del_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/mainloop.c",
          "lines": "109-130",
          "snippet": "int lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"mainloop.h\"",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mainloop.h\"\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint lxc_mainloop_del_handler(struct lxc_epoll_descr *descr, int fd)\n{\n\tstruct mainloop_handler *handler;\n\tstruct lxc_list *iterator;\n\n\tlxc_list_for_each(iterator, &descr->handlers) {\n\t\thandler = iterator->elem;\n\n\t\tif (handler->fd == fd) {\n\t\t\t/* found */\n\t\t\tif (epoll_ctl(descr->epfd, EPOLL_CTL_DEL, fd, NULL))\n\t\t\t\treturn -1;\n\n\t\t\tlxc_list_del(iterator);\n\t\t\tfree(iterator->elem);\n\t\t\tfree(iterator);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitord_cleanup(void);\nstatic struct lxc_monitor mon;\n\nstatic void lxc_monitord_sockfd_remove(struct lxc_monitor *mon, int fd) {\n\tint i;\n\n\tif (lxc_mainloop_del_handler(&mon->descr, fd))\n\t\tCRIT(\"File descriptor %d not found in mainloop.\", fd);\n\tclose(fd);\n\n\tfor (i = 0; i < mon->clientfds_cnt; i++) {\n\t\tif (mon->clientfds[i] == fd)\n\t\t\tbreak;\n\t}\n\tif (i >= mon->clientfds_cnt) {\n\t\tCRIT(\"File descriptor %d not found in clients array.\", fd);\n\t\tlxc_monitord_cleanup();\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemmove(&mon->clientfds[i], &mon->clientfds[i+1],\n\t\t(mon->clientfds_cnt - i - 1) * sizeof(mon->clientfds[0]));\n\tmon->clientfds_cnt--;\n}"
  },
  {
    "function_name": "lxc_monitord_fifo_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "115-126",
    "snippet": "static int lxc_monitord_fifo_delete(struct lxc_monitor *mon)\n{\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tunlink(fifo_path);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "fifo_path"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_fifo_name",
          "args": [
            "mon->lxcpath",
            "fifo_path",
            "sizeof(fifo_path)",
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_fifo_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "55-87",
          "snippet": "int lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_fifo_delete(struct lxc_monitor *mon)\n{\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tunlink(fifo_path);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitord_fifo_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxc_monitord.c",
    "lines": "79-113",
    "snippet": "static int lxc_monitord_fifo_create(struct lxc_monitor *mon)\n{\n\tstruct flock lk;\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mknod(fifo_path, S_IFIFO|S_IRUSR|S_IWUSR, 0);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tINFO(\"Failed to mknod monitor fifo %s: %s.\", fifo_path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->fifofd = open(fifo_path, O_RDWR);\n\tif (mon->fifofd < 0) {\n\t\tunlink(fifo_path);\n\t\tERROR(\"Failed to open monitor fifo.\");\n\t\treturn -1;\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(mon->fifofd, F_SETLK, &lk) != 0) {\n\t\t/* another lxc-monitord is already running, don't start up */\n\t\tDEBUG(\"lxc-monitord already running on lxcpath %s.\", mon->lxcpath);\n\t\tclose(mon->fifofd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"monitor.h\"",
      "#include \"mainloop.h\"",
      "#include \"log.h\"",
      "#include \"af_unix.h\"",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/epoll.h>",
      "#include <setjmp.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_monitor mon;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "mon->fifofd"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"lxc-monitord already running on lxcpath %s.\"",
            "mon->lxcpath"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "mon->fifofd",
            "F_SETLK",
            "&lk"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to open monitor fifo.\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "fifo_path"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fifo_path",
            "O_RDWR"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Failed to mknod monitor fifo %s: %s.\"",
            "fifo_path",
            "strerror(errno)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mknod",
          "args": [
            "fifo_path",
            "S_IFIFO|S_IRUSR|S_IWUSR",
            "0"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_fifo_name",
          "args": [
            "mon->lxcpath",
            "fifo_path",
            "sizeof(fifo_path)",
            "1"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_fifo_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "55-87",
          "snippet": "int lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"log.h\"\n#include \"af_unix.h\"\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/epoll.h>\n#include <setjmp.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic struct lxc_monitor mon;\n\nstatic int lxc_monitord_fifo_create(struct lxc_monitor *mon)\n{\n\tstruct flock lk;\n\tchar fifo_path[PATH_MAX];\n\tint ret;\n\n\tret = lxc_monitor_fifo_name(mon->lxcpath, fifo_path, sizeof(fifo_path), 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mknod(fifo_path, S_IFIFO|S_IRUSR|S_IWUSR, 0);\n\tif (ret < 0 && errno != EEXIST) {\n\t\tINFO(\"Failed to mknod monitor fifo %s: %s.\", fifo_path, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmon->fifofd = open(fifo_path, O_RDWR);\n\tif (mon->fifofd < 0) {\n\t\tunlink(fifo_path);\n\t\tERROR(\"Failed to open monitor fifo.\");\n\t\treturn -1;\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(mon->fifofd, F_SETLK, &lk) != 0) {\n\t\t/* another lxc-monitord is already running, don't start up */\n\t\tDEBUG(\"lxc-monitord already running on lxcpath %s.\", mon->lxcpath);\n\t\tclose(mon->fifofd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  }
]