[
  {
    "function_name": "lxc_setgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "2063-2072",
    "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Dropped additional groups.\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgroups().\""
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "size",
            "list"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_switch_uid_gid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "2045-2060",
    "snippet": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Switched to uid %d.\"",
            "uid"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to switch to uid %d.\"",
            "uid"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "uid"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"Switched to gid %d.\"",
            "gid"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to switch to gid %d.\"",
            "gid"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "gid"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_safe_long",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "2025-2043",
    "snippet": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > LONG_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = sli;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "numstr",
            "&err",
            "0"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > LONG_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = sli;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_safe_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "2005-2023",
    "snippet": "int lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "numstr",
            "&err",
            "0"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_safe_uint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1985-2003",
    "snippet": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "numstr",
            "&err",
            "0"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_preserve_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1965-1983",
    "snippet": "int lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define __NS_PATH_LEN 50"
    ],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "__NS_PATH_LEN",
            "\"/proc/%d/ns%s%s\"",
            "pid",
            "!ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\"",
            "!ns || strcmp(ns, \"\") == 0 ? \"\" : ns"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ns",
            "\"\""
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ns",
            "\"\""
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __NS_PATH_LEN 50\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint lxc_preserve_ns(const int pid, const char *ns)\n{\n\tint ret;\n/* 5 /proc + 21 /int_as_str + 3 /ns + 20 /NS_NAME + 1 \\0 */\n#define __NS_PATH_LEN 50\n\tchar path[__NS_PATH_LEN];\n\n\t/* This way we can use this function to also check whether namespaces\n\t * are supported by the kernel by passing in the NULL or the empty\n\t * string.\n\t */\n\tret = snprintf(path, __NS_PATH_LEN, \"/proc/%d/ns%s%s\", pid,\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : \"/\",\n\t\t       !ns || strcmp(ns, \"\") == 0 ? \"\" : ns);\n\tif (ret < 0 || (size_t)ret >= __NS_PATH_LEN)\n\t\treturn -1;\n\n\treturn open(path, O_RDONLY | O_CLOEXEC);\n}"
  },
  {
    "function_name": "lxc_append_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1947-1963",
    "snippet": "int lxc_append_string(char ***list, char *entry)\n{\n\tchar *copy;\n\tint newentry;\n\n\tnewentry = lxc_append_null_to_list((void ***)list);\n\tif (newentry < 0)\n\t\treturn -1;\n\n\tcopy = strdup(entry);\n\tif (!copy)\n\t\treturn -1;\n\n\t(*list)[newentry] = copy;\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "entry"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_append_null_to_list",
          "args": [
            "(void ***)list"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_null_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1927-1945",
          "snippet": "static int lxc_append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\tvoid **tmp;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++) {\n\t\t\t;\n\t\t}\n\n\ttmp = realloc(*list, (newentry + 2) * sizeof(void **));\n\tif (!tmp)\n\t\treturn -1;\n\n\t*list = tmp;\n\t(*list)[newentry + 1] = NULL;\n\n\treturn newentry;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\tvoid **tmp;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++) {\n\t\t\t;\n\t\t}\n\n\ttmp = realloc(*list, (newentry + 2) * sizeof(void **));\n\tif (!tmp)\n\t\treturn -1;\n\n\t*list = tmp;\n\t(*list)[newentry + 1] = NULL;\n\n\treturn newentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_append_string(char ***list, char *entry)\n{\n\tchar *copy;\n\tint newentry;\n\n\tnewentry = lxc_append_null_to_list((void ***)list);\n\tif (newentry < 0)\n\t\treturn -1;\n\n\tcopy = strdup(entry);\n\tif (!copy)\n\t\treturn -1;\n\n\t(*list)[newentry] = copy;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_append_null_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1927-1945",
    "snippet": "static int lxc_append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\tvoid **tmp;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++) {\n\t\t\t;\n\t\t}\n\n\ttmp = realloc(*list, (newentry + 2) * sizeof(void **));\n\tif (!tmp)\n\t\treturn -1;\n\n\t*list = tmp;\n\t(*list)[newentry + 1] = NULL;\n\n\treturn newentry;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*list",
            "(newentry + 2) * sizeof(void **)"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int lxc_append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\tvoid **tmp;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++) {\n\t\t\t;\n\t\t}\n\n\ttmp = realloc(*list, (newentry + 2) * sizeof(void **));\n\tif (!tmp)\n\t\treturn -1;\n\n\t*list = tmp;\n\t(*list)[newentry + 1] = NULL;\n\n\treturn newentry;\n}"
  },
  {
    "function_name": "task_blocking_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1893-1925",
    "snippet": "bool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line + 8",
            "\"%lx\"",
            "&sigblk"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"SigBlk:\\t\"",
            "8"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&n",
            "f"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "status",
            "\"r\""
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "status",
            "__PROC_STATUS_LEN",
            "\"/proc/%d/status\"",
            "pid"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nbool task_blocking_signal(pid_t pid, int signal)\n{\n\tbool bret = false;\n\tchar *line = NULL;\n\tlong unsigned int sigblk = 0;\n\tsize_t n = 0;\n\tint ret;\n\tFILE *f;\n\n\tchar status[__PROC_STATUS_LEN];\n\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tif (!strncmp(line, \"SigBlk:\\t\", 8))\n\t\t\tif (sscanf(line + 8, \"%lx\", &sigblk) != 1)\n\t\t\t\tgoto out;\n\t}\n\n\tif (sigblk & signal)\n\t\tbret = true;\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}"
  },
  {
    "function_name": "lxc_strmunmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1885-1888",
    "snippet": "int lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "addr",
            "length + 1"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1885-1888",
          "snippet": "int lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}"
  },
  {
    "function_name": "lxc_strmmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1863-1883",
    "snippet": "void *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "tmp",
            "length + 1"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1885-1888",
          "snippet": "int lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_strmunmap(void *addr, size_t length)\n{\n\treturn munmap(addr, length + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "tmp",
            "length",
            "prot",
            "MAP_FIXED | flags",
            "fd",
            "offset"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_strmmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1863-1883",
          "snippet": "void *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid *lxc_strmmap(void *addr, size_t length, int prot, int flags, int fd,\n\t\t  off_t offset)\n{\n\tvoid *tmp = NULL, *overlap = NULL;\n\n\t/* We establish an anonymous mapping that is one byte larger than the\n\t * underlying file. The pages handed to us are zero filled. */\n\ttmp = mmap(addr, length + 1, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (tmp == MAP_FAILED)\n\t\treturn tmp;\n\n\t/* Now we establish a fixed-address mapping starting at the address we\n\t * received from our anonymous mapping and replace all bytes excluding\n\t * the additional \\0-byte with the file. This allows us to use normal\n\t * string-handling functions. */\n\toverlap = mmap(tmp, length, prot, MAP_FIXED | flags, fd, offset);\n\tif (overlap == MAP_FAILED)\n\t\tmunmap(tmp, length + 1);\n\n\treturn overlap;\n}"
  },
  {
    "function_name": "lxc_count_file_lines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1844-1861",
    "snippet": "int lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "f"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "fn",
            "\"r\""
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}"
  },
  {
    "function_name": "null_stdfds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1828-1839",
    "snippet": "int null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_stdfds",
          "args": [
            "fd"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "set_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1813-1826",
          "snippet": "int set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (dup2(fd, 0) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 1) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 2) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (dup2(fd, 0) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 1) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 2) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_devnull",
          "args": [],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "open_devnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1803-1811",
          "snippet": "int open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "set_stdfds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1813-1826",
    "snippet": "int set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (dup2(fd, 0) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 1) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 2) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "2"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "1"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "0"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint set_stdfds(int fd)\n{\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (dup2(fd, 0) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 1) < 0)\n\t\treturn -1;\n\tif (dup2(fd, 2) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "open_devnull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1803-1811",
    "snippet": "int open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Can't open /dev/null\""
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint open_devnull(void)\n{\n\tint fd = open(\"/dev/null\", O_RDWR);\n\n\tif (fd < 0)\n\t\tSYSERROR(\"Can't open /dev/null\");\n\n\treturn fd;\n}"
  },
  {
    "function_name": "mount_proc_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1757-1801",
    "snippet": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint link_to_pid, linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (lxc_safe_int(link, &link_to_pid) < 0)\n\t\treturn -1;\n\tif (link_to_pid != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (!strcmp(rootfs,\"\")) /* rootfs is NULL */\n\t\tret = mount(\"proc\", path, \"proc\", 0, NULL);\n\telse\n\t\tret = safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mounted /proc in container for security transition\""
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "\"proc\"",
            "path",
            "\"proc\"",
            "0",
            "NULL",
            "rootfs"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "path",
            "\"proc\"",
            "0",
            "NULL"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rootfs",
            "\"\""
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "path",
            "MNT_DETACH"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_int",
          "args": [
            "link",
            "&link_to_pid"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2005-2023",
          "snippet": "int lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"proc path name too long\""
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/proc\"",
            "rootfs"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"I am %d, /proc/self points to '%s'\"",
            "mypid",
            "link"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "path",
            "link",
            "20"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "link",
            "0",
            "20"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"proc path name too long\""
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPATHLEN",
            "\"%s/proc/self\"",
            "rootfs"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint link_to_pid, linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (lxc_safe_int(link, &link_to_pid) < 0)\n\t\treturn -1;\n\tif (link_to_pid != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (!strcmp(rootfs,\"\")) /* rootfs is NULL */\n\t\tret = mount(\"proc\", path, \"proc\", 0, NULL);\n\telse\n\t\tret = safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs);\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}"
  },
  {
    "function_name": "safe_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1687-1743",
    "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to mount %s onto %s\"",
            "src",
            "dest"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "destfd"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "mntsrc",
            "destbuf",
            "fstype",
            "flags",
            "data"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "destbuf",
            "50",
            "\"/proc/self/fd/%d\"",
            "destfd"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_without_symlink",
          "args": [
            "dest",
            "rootfs"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "srcbuf",
            "50",
            "\"/proc/self/fd/%d\"",
            "srcfd"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"this is a relative bind mount\""
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "open_without_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1616-1677",
    "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dup"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s in %s was a symbolic link!\"",
            "nextpath",
            "target"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dirfd"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_if_safe",
          "args": [
            "dirfd",
            "nextpath"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "open_if_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1574-1601",
          "snippet": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) // was not a symlink, all good\n\t\treturn newfd;\n\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\n\tif (errno == EPERM || errno == EACCES) {\n\t\t/* we're not root (cause we got EPERM) so\n\t\t   try opening with O_PATH */\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\t/* O_PATH will return an fd for symlinks.  We know\n\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n\t\t\t * is now a link, then something * fishy is going on\n\t\t\t */\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define O_NOFOLLOW  00400000",
            "#define O_PATH      010000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define O_NOFOLLOW  00400000\n#define O_PATH      010000000\n\nstatic int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) // was not a symlink, all good\n\t\treturn newfd;\n\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\n\tif (errno == EPERM || errno == EACCES) {\n\t\t/* we're not root (cause we got EPERM) so\n\t\t   try opening with O_PATH */\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\t/* O_PATH will return an fd for symlinks.  We know\n\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n\t\t\t * is now a link, then something * fishy is going on\n\t\t\t */\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nextpath",
          "args": [
            "dup",
            "&curlen",
            "fulllen"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "get_nextpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1518-1532",
          "snippet": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nstatic char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "prefix_skip",
            "O_RDONLY"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Out of memory checking for symbolic link\""
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "target"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"WHOA there - target '%s' didn't start with prefix '%s'\"",
            "target",
            "prefix_skip"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_subdir",
          "args": [
            "target",
            "prefix_skip",
            "curlen"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "is_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1538-1551",
          "snippet": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix_skip"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix_skip"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
  },
  {
    "function_name": "open_if_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1574-1601",
    "snippet": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) // was not a symlink, all good\n\t\treturn newfd;\n\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\n\tif (errno == EPERM || errno == EACCES) {\n\t\t/* we're not root (cause we got EPERM) so\n\t\t   try opening with O_PATH */\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\t/* O_PATH will return an fd for symlinks.  We know\n\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n\t\t\t * is now a link, then something * fishy is going on\n\t\t\t */\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newfd;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define O_NOFOLLOW  00400000",
      "#define O_PATH      010000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "newfd"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_symlink",
          "args": [
            "newfd"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "check_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1557-1566",
          "snippet": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd",
            "nextpath",
            "O_PATH | O_NOFOLLOW"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "lsm_openat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/attach.c",
          "lines": "90-123",
          "snippet": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}",
          "includes": [
            "#include <sys/personality.h>",
            "#include \"confile.h\"",
            "#include \"lsm/lsm.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include \"lxcseccomp.h\"",
            "#include \"conf.h\"",
            "#include \"lxclock.h\"",
            "#include \"cgroup.h\"",
            "#include \"commands.h\"",
            "#include \"utils.h\"",
            "#include \"config.h\"",
            "#include \"caps.h\"",
            "#include \"attach.h\"",
            "#include \"af_unix.h\"",
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <pwd.h>",
            "#include <linux/unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/mount.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/personality.h>\n#include \"confile.h\"\n#include \"lsm/lsm.h\"\n#include <lxc/lxccontainer.h>\n#include \"lxcseccomp.h\"\n#include \"conf.h\"\n#include \"lxclock.h\"\n#include \"cgroup.h\"\n#include \"commands.h\"\n#include \"utils.h\"\n#include \"config.h\"\n#include \"caps.h\"\n#include \"attach.h\"\n#include \"af_unix.h\"\n#include \"log.h\"\n#include \"namespace.h\"\n#include <pwd.h>\n#include <linux/unistd.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#define __LSMATTRLEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)\n\nstatic int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char *name;\n\tchar path[__LSMATTRLEN];\n\n\tname = lsm_name();\n\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\n\t/* We don't support on-exec with AppArmor */\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\n\tif (on_exec)\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\telse\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\treturn -1;\n\n\tlabelfd = openat(procfd, path, O_RDWR);\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open file descriptor to set LSM label.\");\n\t\treturn -1;\n\t}\n\n\treturn labelfd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define O_NOFOLLOW  00400000\n#define O_PATH      010000000\n\nstatic int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) // was not a symlink, all good\n\t\treturn newfd;\n\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\n\tif (errno == EPERM || errno == EACCES) {\n\t\t/* we're not root (cause we got EPERM) so\n\t\t   try opening with O_PATH */\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\t/* O_PATH will return an fd for symlinks.  We know\n\t\t\t * nextpath wasn't a symlink at last openat, so if fd\n\t\t\t * is now a link, then something * fishy is going on\n\t\t\t */\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newfd;\n}"
  },
  {
    "function_name": "check_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1557-1566",
    "snippet": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sb.st_mode"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sb"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_subdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1538-1551",
    "snippet": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "subdir",
            "dir",
            "len"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "subdir"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "get_nextpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1518-1532",
    "snippet": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nstatic char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}"
  },
  {
    "function_name": "setproctitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1411-1509",
    "snippet": "int setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define PR_SET_MM_MAP 14",
      "#define PR_SET_MM 35"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"setting cmdline failed - %s\"",
            "strerror(errno)"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char*)arg_start",
            "title"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_MM",
            "PR_SET_MM_MAP",
            "(long) &prctl_map",
            "sizeof(prctl_map)",
            "0"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_brk",
            "0"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "proctitle",
            "len"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp",
            "\"%lu %lu %lu %*u %*u %lu %lu\"",
            "&start_data",
            "&end_data",
            "&start_brk",
            "&env_start",
            "&env_end"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp+1",
            "' '"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp",
            "\"%lu %lu %lu\"",
            "&start_code",
            "&end_code",
            "&start_stack"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "f"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "\"/proc/self/stat\"",
            "\"r\""
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_SET_MM_MAP 14\n#define PR_SET_MM 35\n\nint setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_template_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1379-1405",
    "snippet": "char *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tpath"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"bad template: %s\"",
            "t"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "tpath",
            "X_OK"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tpath",
            "len",
            "\"%s/lxc-%s\"",
            "LXCTEMPLATEDIR",
            "t"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/lxc-\""
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "LXCTEMPLATEDIR"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "t"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "t",
            "X_OK"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_template_path(const char *t)\n{\n\tint ret, len;\n\tchar *tpath;\n\n\tif (t[0] == '/' && access(t, X_OK) == 0) {\n\t\ttpath = strdup(t);\n\t\treturn tpath;\n\t}\n\n\tlen = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen(\"/lxc-\") + 1;\n\ttpath = malloc(len);\n\tif (!tpath)\n\t\treturn NULL;\n\tret = snprintf(tpath, len, \"%s/lxc-%s\", LXCTEMPLATEDIR, t);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\tif (access(tpath, X_OK) < 0) {\n\t\tSYSERROR(\"bad template: %s\", t);\n\t\tfree(tpath);\n\t\treturn NULL;\n\t}\n\n\treturn tpath;\n}"
  },
  {
    "function_name": "is_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1364-1371",
    "snippet": "int is_dir(const char *path)\n{\n\tstruct stat statbuf;\n\tint ret = stat(path, &statbuf);\n\tif (ret == 0 && S_ISDIR(statbuf.st_mode))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "statbuf.st_mode"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&statbuf"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nint is_dir(const char *path)\n{\n\tstruct stat statbuf;\n\tint ret = stat(path, &statbuf);\n\tif (ret == 0 && S_ISDIR(statbuf.st_mode))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "print_to_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1350-1362",
    "snippet": "int print_to_file(const char *file, const char *content)\n{\n\tFILE *f;\n\tint ret = 0;\n\n\tf = fopen(file, \"w\");\n\tif (!f)\n\t\treturn -1;\n\tif (fprintf(f, \"%s\", content) != strlen(content))\n\t\tret = -1;\n\tfclose(f);\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "content"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "content"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"w\""
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint print_to_file(const char *file, const char *content)\n{\n\tFILE *f;\n\tint ret = 0;\n\n\tf = fopen(file, \"w\");\n\tif (!f)\n\t\treturn -1;\n\tif (fprintf(f, \"%s\", content) != strlen(content))\n\t\tret = -1;\n\tfclose(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "choose_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1255-1348",
    "snippet": "char *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "retv"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "retv",
            "&mystat"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Nonsense - name /lxc.init.static too long\""
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "retv",
            "PATH_MAX",
            "\"/init.lxc.static\""
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "retv",
            "PATH_MAX",
            "\"%s/sbin/lxc-init\"",
            "tmp"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "retv",
            "PATH_MAX",
            "\"%s/usr/lib/lxc/lxc-init\"",
            "tmp"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "retv",
            "PATH_MAX",
            "\"%s/%s/%s\"",
            "tmp",
            "LXCINITDIR",
            "\"/lxc/lxc-init\""
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "retv",
            "PATH_MAX",
            "\"%s/%s/%s\"",
            "tmp",
            "SBINDIR",
            "\"/init.lxc\""
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "PATH_MAX"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to unsetenv\""
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "\"PATH\""
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"init.lxc\"",
            "rootfs"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setenv\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PATH\"",
            "\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"",
            "0"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgns_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1247-1250",
    "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "\"/proc/self/ns/cgroup\""
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
  },
  {
    "function_name": "file_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1240-1245",
    "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "f",
            "&statbuf"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
  },
  {
    "function_name": "on_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1202-1238",
    "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\":\"",
            "&saveptr"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmdpath"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "cmdpath",
            "X_OK"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmdpath",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "entry",
            "cmd"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmdpath",
            "MAXPATHLEN",
            "\"%s/%s/%s\"",
            "rootfs",
            "entry",
            "cmd"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "path",
            "\":\"",
            "&saveptr"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
  },
  {
    "function_name": "detect_ramfs_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1166-1200",
    "snippet": "bool detect_ramfs_rootfs(void)\n{\n\tFILE *f;\n\tchar *p, *p2;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint i;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tfor (p = line, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it the ramfs?\n\t\t\tp = strchr(p2 + 1, '-');\n\t\t\tif (p && strncmp(p, \"- rootfs rootfs \", 16) == 0) {\n\t\t\t\tfree(line);\n\t\t\t\tfclose(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn false;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"- rootfs rootfs \"",
            "16"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p2 + 1",
            "'-'"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p + 1",
            "\"/\""
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool detect_ramfs_rootfs(void)\n{\n\tFILE *f;\n\tchar *p, *p2;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint i;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tfor (p = line, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it the ramfs?\n\t\t\tp = strchr(p2 + 1, '-');\n\t\t\tif (p && strncmp(p, \"- rootfs rootfs \", 16) == 0) {\n\t\t\t\tfree(line);\n\t\t\t\tfclose(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn false;\n}"
  },
  {
    "function_name": "switch_to_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1134-1157",
    "snippet": "bool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\n\t/* Switch to new ns */\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to set process %d to %s of %d.\"",
            "pid",
            "ns",
            "fd"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setns",
          "args": [
            "fd",
            "0"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "setns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "58-68",
          "snippet": "static inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int setns(int fd, int nstype)\n{\n#ifdef __NR_setns\n\treturn syscall(__NR_setns, fd, nstype);\n#elif defined(__NR_set_ns)\n\treturn syscall(__NR_set_ns, fd, nstype);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open %s\"",
            "nspath"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "nspath",
            "O_RDONLY"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nspath",
            "MAXPATHLEN",
            "\"/proc/%d/ns/%s\"",
            "pid",
            "ns"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\n\t/* Switch to new ns */\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}"
  },
  {
    "function_name": "detect_shared_rootfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1102-1132",
    "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"shared:\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p2 + 1",
            "' '"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p + 1",
            "\"/\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "LXC_LINELEN",
            "f"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
  },
  {
    "function_name": "fnv_64a_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1076-1093",
    "snippet": "uint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}"
  },
  {
    "function_name": "dir_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1059-1069",
    "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
  },
  {
    "function_name": "get_ns_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1034-1057",
    "snippet": "uid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%u %u %u\"",
            "&nsid",
            "&hostid",
            "&range"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "f"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/uid_map\"",
            "\"r\""
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}"
  },
  {
    "function_name": "randseed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "1012-1032",
    "snippet": "int randseed(bool srand_it)\n{\n\t/*\n\t   srand pre-seed function based on /dev/urandom\n\t   */\n\tunsigned int seed = time(NULL) + getpid();\n\n\tFILE *f;\n\tf = fopen(\"/dev/urandom\", \"r\");\n\tif (f) {\n\t\tint ret = fread(&seed, sizeof(seed), 1, f);\n\t\tif (ret != 1)\n\t\t\tDEBUG(\"unable to fread /dev/urandom, %s, fallback to time+pid rand seed\", strerror(errno));\n\t\tfclose(f);\n\t}\n\n\tif (srand_it)\n\t\tsrand(seed);\n\n\treturn seed;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "seed"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"unable to fread /dev/urandom, %s, fallback to time+pid rand seed\"",
            "strerror(errno)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&seed",
            "sizeof(seed)",
            "1",
            "f"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/dev/urandom\"",
            "\"r\""
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint randseed(bool srand_it)\n{\n\t/*\n\t   srand pre-seed function based on /dev/urandom\n\t   */\n\tunsigned int seed = time(NULL) + getpid();\n\n\tFILE *f;\n\tf = fopen(\"/dev/urandom\", \"r\");\n\tif (f) {\n\t\tint ret = fread(&seed, sizeof(seed), 1, f);\n\t\tif (ret != 1)\n\t\t\tDEBUG(\"unable to fread /dev/urandom, %s, fallback to time+pid rand seed\", strerror(errno));\n\t\tfclose(f);\n\t}\n\n\tif (srand_it)\n\t\tsrand(seed);\n\n\treturn seed;\n}"
  },
  {
    "function_name": "lxc_append_null_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "992-1010",
    "snippet": "void **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "array"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "array",
            "(count + 1) * sizeof(*array)"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t/* Append NULL to the array */\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tsize_t i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}"
  },
  {
    "function_name": "lxc_read_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "962-990",
    "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"read %s: %s\"",
            "filename",
            "strerror(errno)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf",
            "count"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "count"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "open_without_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1616-1677",
          "snippet": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\n\tfulllen = strlen(target);\n\n\t/* make sure prefix-skip makes sense */\n\tif (prefix_skip && strlen(prefix_skip) > 0) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * get_nextpath() expects the curlen argument to be\n\t\t * on a  (turned into \\0) / or before it, so decrement\n\t\t * curlen to make sure that happens\n\t\t */\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\n\t/* Make a copy of target which we can hack up, and tokenize it */\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(dup);\n\treturn dirfd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_write_to_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "934-960",
    "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "fd",
            "\"\\n\"",
            "1"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC",
            "0666"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "37-82",
          "snippet": "int lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_open(const char *path, int type, int flags)\n{\n\tint fd;\n\tsize_t len;\n\tstruct sockaddr_un addr;\n\n\tif (flags & O_TRUNC)\n\t\tunlink(path);\n\n\tfd = socket(PF_UNIX, type, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/* Clear address structure */\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (!path)\n\t\treturn fd;\n\n\taddr.sun_family = AF_UNIX;\n\n\tlen = strlen(&path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tclose(fd);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\t/* addr.sun_path[0] has already been set to 0 by memset() */\n\tstrncpy(&addr.sun_path[1], &path[1], strlen(&path[1]));\n\n\tif (bind(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\tif (type == SOCK_STREAM && listen(fd, 100)) {\n\t\tint tmp = errno;\n\t\tclose(fd);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_array_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "923-932",
    "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_grow_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "894-921",
    "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_array[*capacity]",
            "0",
            "(new_capacity - (*capacity)) * sizeof(void *)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*array",
            "new_capacity * sizeof(void *)"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_free_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "886-892",
    "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(void*)array"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "element_free_fn",
          "args": [
            "*p"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
  },
  {
    "function_name": "lxc_string_split_and_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "845-884",
    "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)result",
            "free"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "result",
            "(result_count + 1) * sizeof(char *)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&result",
            "&result_capacity",
            "result_count + 1",
            "16"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "sep",
            "&saveptr"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "string"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(string)+1"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(char *)"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_string_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "805-843",
    "snippet": "char **lxc_string_split(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = {_sep, '\\0'};\n\tchar **tmp = NULL, **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string) + 1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\ttmp = realloc(result, (result_count + 1) * sizeof(char *));\n\tif (!tmp)\n\t\tgoto error_out;\n\tresult = tmp;\n\t/* Make sure we don't return uninitialized memory. */\n\tif (result_count == 0)\n\t\t*result = NULL;\n\treturn result;\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)result",
            "free"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "result",
            "(result_count + 1) * sizeof(char *)"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "token"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_grow_array",
          "args": [
            "(void ***)&result",
            "&result_capacity",
            "result_count + 1",
            "16"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_grow_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "894-921",
          "snippet": "int lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_grow_array(void ***array, size_t* capacity, size_t new_size, size_t capacity_increment)\n{\n\tsize_t new_capacity;\n\tvoid **new_array;\n\n\t/* first time around, catch some trivial mistakes of the user\n\t * only initializing one of these */\n\tif (!*array || !*capacity) {\n\t\t*array = NULL;\n\t\t*capacity = 0;\n\t}\n\n\tnew_capacity = *capacity;\n\twhile (new_size + 1 > new_capacity)\n\t\tnew_capacity += capacity_increment;\n\tif (new_capacity != *capacity) {\n\t\t/* we have to reallocate */\n\t\tnew_array = realloc(*array, new_capacity * sizeof(void *));\n\t\tif (!new_array)\n\t\t\treturn -1;\n\t\tmemset(&new_array[*capacity], 0, (new_capacity - (*capacity)) * sizeof(void *));\n\t\t*array = new_array;\n\t\t*capacity = new_capacity;\n\t}\n\n\t/* array has sufficient elements */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "sep",
            "&saveptr"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "string"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(string) + 1"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(char *)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = {_sep, '\\0'};\n\tchar **tmp = NULL, **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string) + 1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\ttmp = realloc(result, (result_count + 1) * sizeof(char *));\n\tif (!tmp)\n\t\tgoto error_out;\n\tresult = tmp;\n\t/* Make sure we don't return uninitialized memory. */\n\tif (result_count == 0)\n\t\t*result = NULL;\n\treturn result;\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_string_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "787-803",
    "snippet": "bool lxc_string_in_list(const char *needle, const char *haystack, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\n\tif (!haystack || !needle)\n\t\treturn 0;\n\n\tstr = alloca(strlen(haystack)+1);\n\tstrcpy(str, haystack);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tif (strcmp(needle, token) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "needle",
            "token"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "sep",
            "&saveptr"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "haystack"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(haystack)+1"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "haystack"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_list(const char *needle, const char *haystack, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\n\tif (!haystack || !needle)\n\t\treturn 0;\n\n\tstr = alloca(strlen(haystack)+1);\n\tstrcpy(str, haystack);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\tif (strcmp(needle, token) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_append_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "768-785",
    "snippet": "char *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "pattern",
            "first",
            "second"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "len"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "second"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "first"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_deslashify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "725-766",
    "snippet": "bool lxc_deslashify(char **path)\n{\n\tbool ret = false;\n\tchar *p;\n\tchar **parts = NULL;\n\tsize_t n, len;\n\n\tparts = lxc_normalize_path(*path);\n\tif (!parts)\n\t\treturn false;\n\n\t/* We'll end up here if path == \"///\" or path == \"\". */\n\tif (!*parts) {\n\t\tlen = strlen(*path);\n\t\tif (!len) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\tn = strcspn(*path, \"/\");\n\t\tif (n == len) {\n\t\t\tp = strdup(\"/\");\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\tfree(*path);\n\t\t\t*path = p;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tp = lxc_string_join(\"/\", (const char **)parts, **path == '/');\n\tif (!p)\n\t\tgoto out;\n\n\tfree(*path);\n\t*path = p;\n\tret = true;\n\nout:\n\tlxc_free_array((void **)parts, free);\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)parts",
            "free"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*path"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\"/\"",
            "(const char **)parts",
            "**path == '/'"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/\""
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "*path",
            "\"/\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*path"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_normalize_path",
          "args": [
            "*path"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_normalize_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "690-723",
          "snippet": "char **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool lxc_deslashify(char **path)\n{\n\tbool ret = false;\n\tchar *p;\n\tchar **parts = NULL;\n\tsize_t n, len;\n\n\tparts = lxc_normalize_path(*path);\n\tif (!parts)\n\t\treturn false;\n\n\t/* We'll end up here if path == \"///\" or path == \"\". */\n\tif (!*parts) {\n\t\tlen = strlen(*path);\n\t\tif (!len) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\tn = strcspn(*path, \"/\");\n\t\tif (n == len) {\n\t\t\tp = strdup(\"/\");\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\tfree(*path);\n\t\t\t*path = p;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tp = lxc_string_join(\"/\", (const char **)parts, **path == '/');\n\tif (!p)\n\t\tgoto out;\n\n\tfree(*path);\n\t*path = p;\n\tret = true;\n\nout:\n\tlxc_free_array((void **)parts, free);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_normalize_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "690-723",
    "snippet": "char **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&components[pos-1]",
            "&components[pos+1]",
            "sizeof(char *) * (components_len - pos)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "components[pos]"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "components[pos]",
            "\"..\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&components[pos]",
            "&components[pos+1]",
            "sizeof(char *) * (components_len - pos)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "components[pos]",
            "\"..\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "components[pos]",
            "\".\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_split",
          "args": [
            "path",
            "'/'"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar **lxc_normalize_path(const char *path)\n{\n\tchar **components;\n\tchar **p;\n\tsize_t components_len = 0;\n\tsize_t pos = 0;\n\n\tcomponents = lxc_string_split(path, '/');\n\tif (!components)\n\t\treturn NULL;\n\tfor (p = components; *p; p++)\n\t\tcomponents_len++;\n\n\t/* resolve '.' and '..' */\n\tfor (pos = 0; pos < components_len; ) {\n\t\tif (!strcmp(components[pos], \".\") || (!strcmp(components[pos], \"..\") && pos == 0)) {\n\t\t\t/* eat this element */\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len--;\n\t\t} else if (!strcmp(components[pos], \"..\")) {\n\t\t\t/* eat this and the previous element */\n\t\t\tfree(components[pos - 1]);\n\t\t\tfree(components[pos]);\n\t\t\tmemmove(&components[pos-1], &components[pos+1], sizeof(char *) * (components_len - pos));\n\t\t\tcomponents_len -= 2;\n\t\t\tpos--;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n\n\treturn components;\n}"
  },
  {
    "function_name": "lxc_string_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "664-688",
    "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "result",
            "*p"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "result",
            "sep"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "result",
            "sep"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "result_len + 1",
            "1"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*p"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sep"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_string_in_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "656-662",
    "snippet": "bool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "needle",
            "*haystack"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool lxc_string_in_array(const char *needle, const char **haystack)\n{\n\tfor (; haystack && *haystack; haystack++)\n\t\tif (!strcmp(needle, *haystack))\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "lxc_string_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "601-654",
    "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&result[len]",
            "last_p",
            "part_len"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "last_p"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&result[len]",
            "replacement",
            "replacement_len"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&result[len]",
            "last_p",
            "part_len"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "last_p",
            "needle"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "last_p",
            "needle"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "len + 1"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "needle"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "replacement"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "lxc_pclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "569-599",
    "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"waitpid failure\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child_pid",
            "&wstatus",
            "0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"fclose failure\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
  },
  {
    "function_name": "lxc_popen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "469-567",
    "snippet": "extern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parent_end"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp->f"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"fdopen failure\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "parent_end",
            "\"r\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to allocate memory\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*fp)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"fork failure\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "127"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "\"/bin/sh\"",
            "\"sh\"",
            "\"-c\"",
            "command",
            "(char *) NULL"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_UNBLOCK",
            "&mask",
            "NULL"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&mask"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "127"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remove FD_CLOEXEC from fd.\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "child_end",
            "F_SETFD",
            "0"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "child_end",
            "child_std_end"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pipe2 failure\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "pipe_fds",
            "O_CLOEXEC"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "lxc_va_arg_list_to_argv_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "464-467",
    "snippet": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_va_arg_list_to_argv",
          "args": [
            "ap",
            "skip",
            "0"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "424-462",
          "snippet": "char** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nconst char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}"
  },
  {
    "function_name": "lxc_va_arg_list_to_argv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "424-462",
    "snippet": "char** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "result"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "arg"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ap",
            "char*"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "464-467",
          "snippet": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nconst char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "count",
            "sizeof(char*)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap2"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_copy",
          "args": [
            "ap2",
            "ap"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar** lxc_va_arg_list_to_argv(va_list ap, size_t skip, int do_strdup)\n{\n\tva_list ap2;\n\tsize_t count = 1 + skip;\n\tchar **result;\n\n\t/* first determine size of argument list, we don't want to reallocate\n\t * constantly...\n\t */\n\tva_copy(ap2, ap);\n\twhile (1) {\n\t\tchar* arg = va_arg(ap2, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tva_end(ap2);\n\n\tresult = calloc(count, sizeof(char*));\n\tif (!result)\n\t\treturn NULL;\n\tcount = skip;\n\twhile (1) {\n\t\tchar* arg = va_arg(ap, char*);\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ = do_strdup ? strdup(arg) : arg;\n\t\tif (!arg)\n\t\t\tgoto oom;\n\t\tresult[count++] = arg;\n\t}\n\n\t/* calloc has already set last element to NULL*/\n\treturn result;\n\noom:\n\tfree(result);\n\treturn NULL;\n}"
  },
  {
    "function_name": "sha1sum_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "372-421",
    "snippet": "int sha1sum_file(char *fnam, unsigned char *digest)\n{\n\tchar *buf;\n\tint ret;\n\tFILE *f;\n\tlong flen;\n\n\tif (!fnam)\n\t\treturn -1;\n\tf = fopen_cloexec(fnam, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Error opening template\");\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_END) < 0) {\n\t\tSYSERROR(\"Error seeking to end of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((flen = ftell(f)) < 0) {\n\t\tSYSERROR(\"Error telling size of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to start of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((buf = malloc(flen+1)) == NULL) {\n\t\tSYSERROR(\"Out of memory\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fread(buf, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Failure reading template\");\n\t\tfree(buf);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fclose(f) < 0) {\n\t\tSYSERROR(\"Failre closing template\");\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\tbuf[flen] = '\\0';\n\tret = gnutls_hash_fast(GNUTLS_DIG_SHA1, buf, flen, (void *)digest);\n\tfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_hash_fast",
          "args": [
            "GNUTLS_DIG_SHA1",
            "buf",
            "flen",
            "(void *)digest"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failre closing template\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failure reading template\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "flen",
            "f"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Out of memory\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "flen+1"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error seeking to start of template\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_SET"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error telling size of template\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "f"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error seeking to end of template\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_END"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error opening template\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen_cloexec",
          "args": [
            "fnam",
            "\"r\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint sha1sum_file(char *fnam, unsigned char *digest)\n{\n\tchar *buf;\n\tint ret;\n\tFILE *f;\n\tlong flen;\n\n\tif (!fnam)\n\t\treturn -1;\n\tf = fopen_cloexec(fnam, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"Error opening template\");\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_END) < 0) {\n\t\tSYSERROR(\"Error seeking to end of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((flen = ftell(f)) < 0) {\n\t\tSYSERROR(\"Error telling size of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fseek(f, 0, SEEK_SET) < 0) {\n\t\tSYSERROR(\"Error seeking to start of template\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif ((buf = malloc(flen+1)) == NULL) {\n\t\tSYSERROR(\"Out of memory\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fread(buf, 1, flen, f) != flen) {\n\t\tSYSERROR(\"Failure reading template\");\n\t\tfree(buf);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tif (fclose(f) < 0) {\n\t\tSYSERROR(\"Failre closing template\");\n\t\tfree(buf);\n\t\treturn -1;\n\t}\n\tbuf[flen] = '\\0';\n\tret = gnutls_hash_fast(GNUTLS_DIG_SHA1, buf, flen, (void *)digest);\n\tfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "gnutls_lxc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "366-370",
    "snippet": "__attribute__((constructor))\nstatic void gnutls_lxc_init(void)\n{\n\tgnutls_global_init();\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_global_init",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n__attribute__((constructor))\nstatic void gnutls_lxc_init(void)\n{\n\tgnutls_global_init();\n}"
  },
  {
    "function_name": "lxc_read_nointr_expect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "347-360",
    "snippet": "ssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "expected_buf",
            "count"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "fd",
            "buf",
            "count"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr_expect(int fd, void* buf, size_t count, const void* expected_buf)\n{\n\tssize_t ret;\n\tret = lxc_read_nointr(fd, buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\tif ((size_t)ret != count)\n\t\treturn -1;\n\tif (expected_buf && memcmp(buf, expected_buf, count) != 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_read_nointr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "337-345",
    "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf",
            "count"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_write_nointr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "327-335",
    "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "buf",
            "count"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_wait_for_pid_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "311-325",
    "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
  },
  {
    "function_name": "wait_for_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "293-309",
    "snippet": "int wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_rundir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "264-291",
    "snippet": "char *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "rundir",
            "\"%s/.cache/lxc/run/\"",
            "homedir"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (17 + strlen(homedir))"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "homedir"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"HOME isn't set in the environment.\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"HOME\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"XDG_RUNTIME_DIR isn't set in the environment.\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rundir"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XDG_RUNTIME_DIR\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "RUNTIME_PATH"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}"
  },
  {
    "function_name": "mkdir_p",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "241-262",
    "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "makeme"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to create directory '%s'\"",
            "makeme"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "makeme",
            "mode"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strndup",
          "args": [
            "orig",
            "dir - orig"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "dir",
            "\"/\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "tmp",
            "\"/\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_u16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "223-239",
    "snippet": "extern int get_u16(unsigned short *val, const char *arg, int base)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (!arg || !*arg)\n\t\treturn -1;\n\n\terrno = 0;\n\tres = strtoul(arg, &ptr, base);\n\tif (!ptr || ptr == arg || *ptr || res > 0xFFFF || errno != 0)\n\t\treturn -1;\n\n\t*val = res;\n\n\treturn 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg",
            "&ptr",
            "base"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int get_u16(unsigned short *val, const char *arg, int base)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (!arg || !*arg)\n\t\treturn -1;\n\n\terrno = 0;\n\tres = strtoul(arg, &ptr, base);\n\tif (!ptr || ptr == arg || *ptr || res > 0xFFFF || errno != 0)\n\t\treturn -1;\n\n\t*val = res;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_rmdir_onedev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "203-220",
    "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_recursive_rmdir",
          "args": [
            "path",
            "mystat.st_dev",
            "exclude",
            "0",
            "onedev"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "_recursive_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "90-181",
          "snippet": "static int _recursive_rmdir(char *dirname, dev_t pdev,\n\t\t\t    const char *exclude, int level, bool onedev)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\tbool hadexclude = false;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!level && exclude && !strcmp(direntp->d_name, exclude)) {\n\t\t\tret = rmdir(pathname);\n\t\t\tif (ret < 0) {\n\t\t\t\tswitch(errno) {\n\t\t\t\tcase ENOTEMPTY:\n\t\t\t\t\tINFO(\"Not deleting snapshot %s\", pathname);\n\t\t\t\t\thadexclude = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENOTDIR:\n\t\t\t\t\tret = unlink(pathname);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tINFO(\"%s: failed to remove %s\", __func__, pathname);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tSYSERROR(\"%s: failed to rmdir %s\", __func__, pathname);\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (onedev && mystat.st_dev != pdev) {\n\t\t\t/* TODO should we be checking /proc/self/mountinfo for\n\t\t\t * pathname and not doing this if found? */\n\t\t\tif (btrfs_try_remove_subvol(pathname))\n\t\t\t\tINFO(\"Removed btrfs subvolume at %s\\n\", pathname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (_recursive_rmdir(pathname, pdev, exclude, level+1, onedev) < 0)\n\t\t\t\tfailed=1;\n\t\t} else {\n\t\t\tif (unlink(pathname) < 0) {\n\t\t\t\tSYSERROR(\"%s: failed to delete %s\", __func__, pathname);\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0 && !btrfs_try_remove_subvol(dirname) && !hadexclude) {\n\t\tERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\treturn failed ? -1 : 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int _recursive_rmdir(char *dirname, dev_t pdev,\n\t\t\t    const char *exclude, int level, bool onedev)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\tbool hadexclude = false;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!level && exclude && !strcmp(direntp->d_name, exclude)) {\n\t\t\tret = rmdir(pathname);\n\t\t\tif (ret < 0) {\n\t\t\t\tswitch(errno) {\n\t\t\t\tcase ENOTEMPTY:\n\t\t\t\t\tINFO(\"Not deleting snapshot %s\", pathname);\n\t\t\t\t\thadexclude = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENOTDIR:\n\t\t\t\t\tret = unlink(pathname);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tINFO(\"%s: failed to remove %s\", __func__, pathname);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tSYSERROR(\"%s: failed to rmdir %s\", __func__, pathname);\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (onedev && mystat.st_dev != pdev) {\n\t\t\t/* TODO should we be checking /proc/self/mountinfo for\n\t\t\t * pathname and not doing this if found? */\n\t\t\tif (btrfs_try_remove_subvol(pathname))\n\t\t\t\tINFO(\"Removed btrfs subvolume at %s\\n\", pathname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (_recursive_rmdir(pathname, pdev, exclude, level+1, onedev) < 0)\n\t\t\t\tfailed=1;\n\t\t} else {\n\t\t\tif (unlink(pathname) < 0) {\n\t\t\t\tSYSERROR(\"%s: failed to delete %s\", __func__, pathname);\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0 && !btrfs_try_remove_subvol(dirname) && !hadexclude) {\n\t\tERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\treturn failed ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to stat %s\"",
            "__func__",
            "path"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&mystat"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_native_overlayfs",
          "args": [
            "path"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "is_native_overlayfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "190-200",
          "snippet": "static bool is_native_overlayfs(const char *path)\n{\n\tstruct statfs sb;\n\n\tif (statfs(path, &sb) < 0)\n\t\treturn false;\n\tif (sb.f_type == OVERLAYFS_SUPER_MAGIC ||\n\t\t\tsb.f_type == OVERLAY_SUPER_MAGIC)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define OVERLAY_SUPER_MAGIC 0x794c7630",
            "#define OVERLAYFS_SUPER_MAGIC 0x794c764f"
          ],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define OVERLAY_SUPER_MAGIC 0x794c7630\n#define OVERLAYFS_SUPER_MAGIC 0x794c764f\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nstatic bool is_native_overlayfs(const char *path)\n{\n\tstruct statfs sb;\n\n\tif (statfs(path, &sb) < 0)\n\t\treturn false;\n\tif (sb.f_type == OVERLAYFS_SUPER_MAGIC ||\n\t\t\tsb.f_type == OVERLAY_SUPER_MAGIC)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
  },
  {
    "function_name": "is_native_overlayfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "190-200",
    "snippet": "static bool is_native_overlayfs(const char *path)\n{\n\tstruct statfs sb;\n\n\tif (statfs(path, &sb) < 0)\n\t\treturn false;\n\tif (sb.f_type == OVERLAYFS_SUPER_MAGIC ||\n\t\t\tsb.f_type == OVERLAY_SUPER_MAGIC)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define OVERLAY_SUPER_MAGIC 0x794c7630",
      "#define OVERLAYFS_SUPER_MAGIC 0x794c764f"
    ],
    "globals_used": [
      "extern bool btrfs_try_remove_subvol(const char *path);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "statfs",
          "args": [
            "path",
            "&sb"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define OVERLAY_SUPER_MAGIC 0x794c7630\n#define OVERLAYFS_SUPER_MAGIC 0x794c764f\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nstatic bool is_native_overlayfs(const char *path)\n{\n\tstruct statfs sb;\n\n\tif (statfs(path, &sb) < 0)\n\t\treturn false;\n\tif (sb.f_type == OVERLAYFS_SUPER_MAGIC ||\n\t\t\tsb.f_type == OVERLAY_SUPER_MAGIC)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "_recursive_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
    "lines": "90-181",
    "snippet": "static int _recursive_rmdir(char *dirname, dev_t pdev,\n\t\t\t    const char *exclude, int level, bool onedev)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\tbool hadexclude = false;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!level && exclude && !strcmp(direntp->d_name, exclude)) {\n\t\t\tret = rmdir(pathname);\n\t\t\tif (ret < 0) {\n\t\t\t\tswitch(errno) {\n\t\t\t\tcase ENOTEMPTY:\n\t\t\t\t\tINFO(\"Not deleting snapshot %s\", pathname);\n\t\t\t\t\thadexclude = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENOTDIR:\n\t\t\t\t\tret = unlink(pathname);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tINFO(\"%s: failed to remove %s\", __func__, pathname);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tSYSERROR(\"%s: failed to rmdir %s\", __func__, pathname);\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (onedev && mystat.st_dev != pdev) {\n\t\t\t/* TODO should we be checking /proc/self/mountinfo for\n\t\t\t * pathname and not doing this if found? */\n\t\t\tif (btrfs_try_remove_subvol(pathname))\n\t\t\t\tINFO(\"Removed btrfs subvolume at %s\\n\", pathname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (_recursive_rmdir(pathname, pdev, exclude, level+1, onedev) < 0)\n\t\t\t\tfailed=1;\n\t\t} else {\n\t\t\tif (unlink(pathname) < 0) {\n\t\t\t\tSYSERROR(\"%s: failed to delete %s\", __func__, pathname);\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0 && !btrfs_try_remove_subvol(dirname) && !hadexclude) {\n\t\tERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\treturn failed ? -1 : 0;\n}",
    "includes": [
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include <sys/wait.h>",
      "#include <sys/vfs.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/prctl.h>",
      "#include <sys/param.h>",
      "#include <sys/mount.h>",
      "#include <sys/mman.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <libgen.h>",
      "#include <grp.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to close directory %s\"",
            "__func__",
            "dirname"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to delete %s\"",
            "__func__",
            "dirname"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_try_remove_subvol",
          "args": [
            "dirname"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_remove_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "729-734",
          "snippet": "bool btrfs_try_remove_subvol(const char *path)\n{\n\tif (!btrfs_detect(path))\n\t\treturn false;\n\treturn btrfs_recursive_destroy(path) == 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nbool btrfs_try_remove_subvol(const char *path)\n{\n\tif (!btrfs_detect(path))\n\t\treturn false;\n\treturn btrfs_recursive_destroy(path) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dirname"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2332-2336",
          "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: failed to delete %s\"",
            "__func__",
            "pathname"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pathname"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recursive_rmdir",
          "args": [
            "pathname",
            "pdev",
            "exclude",
            "level+1",
            "onedev"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "_recursive_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "90-181",
          "snippet": "static int _recursive_rmdir(char *dirname, dev_t pdev,\n\t\t\t    const char *exclude, int level, bool onedev)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\tbool hadexclude = false;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!level && exclude && !strcmp(direntp->d_name, exclude)) {\n\t\t\tret = rmdir(pathname);\n\t\t\tif (ret < 0) {\n\t\t\t\tswitch(errno) {\n\t\t\t\tcase ENOTEMPTY:\n\t\t\t\t\tINFO(\"Not deleting snapshot %s\", pathname);\n\t\t\t\t\thadexclude = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENOTDIR:\n\t\t\t\t\tret = unlink(pathname);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tINFO(\"%s: failed to remove %s\", __func__, pathname);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tSYSERROR(\"%s: failed to rmdir %s\", __func__, pathname);\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (onedev && mystat.st_dev != pdev) {\n\t\t\t/* TODO should we be checking /proc/self/mountinfo for\n\t\t\t * pathname and not doing this if found? */\n\t\t\tif (btrfs_try_remove_subvol(pathname))\n\t\t\t\tINFO(\"Removed btrfs subvolume at %s\\n\", pathname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (_recursive_rmdir(pathname, pdev, exclude, level+1, onedev) < 0)\n\t\t\t\tfailed=1;\n\t\t} else {\n\t\t\tif (unlink(pathname) < 0) {\n\t\t\t\tSYSERROR(\"%s: failed to delete %s\", __func__, pathname);\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0 && !btrfs_try_remove_subvol(dirname) && !hadexclude) {\n\t\tERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\treturn failed ? -1 : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mystat.st_mode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Removed btrfs subvolume at %s\\n\"",
            "pathname"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to stat %s\"",
            "__func__",
            "pathname"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "pathname",
            "&mystat"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"%s: failed to rmdir %s\"",
            "__func__",
            "pathname"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"%s: failed to remove %s\"",
            "__func__",
            "pathname"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pathname"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Not deleting snapshot %s\"",
            "pathname"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "exclude"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"pathname too long\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "MAXPATHLEN",
            "\"%s/%s\"",
            "dirname",
            "direntp->d_name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s: failed to open %s\"",
            "__func__",
            "dirname"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic int _recursive_rmdir(char *dirname, dev_t pdev,\n\t\t\t    const char *exclude, int level, bool onedev)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint ret, failed=0;\n\tchar pathname[MAXPATHLEN];\n\tbool hadexclude = false;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tERROR(\"%s: failed to open %s\", __func__, dirname);\n\t\treturn -1;\n\t}\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tint rc;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\trc = snprintf(pathname, MAXPATHLEN, \"%s/%s\", dirname, direntp->d_name);\n\t\tif (rc < 0 || rc >= MAXPATHLEN) {\n\t\t\tERROR(\"pathname too long\");\n\t\t\tfailed=1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!level && exclude && !strcmp(direntp->d_name, exclude)) {\n\t\t\tret = rmdir(pathname);\n\t\t\tif (ret < 0) {\n\t\t\t\tswitch(errno) {\n\t\t\t\tcase ENOTEMPTY:\n\t\t\t\t\tINFO(\"Not deleting snapshot %s\", pathname);\n\t\t\t\t\thadexclude = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ENOTDIR:\n\t\t\t\t\tret = unlink(pathname);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tINFO(\"%s: failed to remove %s\", __func__, pathname);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tSYSERROR(\"%s: failed to rmdir %s\", __func__, pathname);\n\t\t\t\t\tfailed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret) {\n\t\t\tERROR(\"%s: failed to stat %s\", __func__, pathname);\n\t\t\tfailed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (onedev && mystat.st_dev != pdev) {\n\t\t\t/* TODO should we be checking /proc/self/mountinfo for\n\t\t\t * pathname and not doing this if found? */\n\t\t\tif (btrfs_try_remove_subvol(pathname))\n\t\t\t\tINFO(\"Removed btrfs subvolume at %s\\n\", pathname);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(mystat.st_mode)) {\n\t\t\tif (_recursive_rmdir(pathname, pdev, exclude, level+1, onedev) < 0)\n\t\t\t\tfailed=1;\n\t\t} else {\n\t\t\tif (unlink(pathname) < 0) {\n\t\t\t\tSYSERROR(\"%s: failed to delete %s\", __func__, pathname);\n\t\t\t\tfailed=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rmdir(dirname) < 0 && !btrfs_try_remove_subvol(dirname) && !hadexclude) {\n\t\tERROR(\"%s: failed to delete %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\tret = closedir(dir);\n\tif (ret) {\n\t\tERROR(\"%s: failed to close directory %s\", __func__, dirname);\n\t\tfailed=1;\n\t}\n\n\treturn failed ? -1 : 0;\n}"
  }
]