[
  {
    "function_name": "lsm_apparmor_drv_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "249-255",
    "snippet": "struct lsm_drv *lsm_apparmor_drv_init(void)\n{\n\tif (!apparmor_enabled())\n\t\treturn NULL;\n\taa_enabled = 1;\n\treturn &apparmor_drv;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aa_enabled = 0;",
      "static struct lsm_drv apparmor_drv = {\n\t.name = \"AppArmor\",\n\t.enabled           = apparmor_enabled,\n\t.process_label_get = apparmor_process_label_get,\n\t.process_label_set = apparmor_process_label_set,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apparmor_enabled",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "65-82",
          "snippet": "static int apparmor_enabled(void)\n{\n\tFILE *fin;\n\tchar e;\n\tint ret;\n\n\tfin = fopen(AA_ENABLED_FILE, \"r\");\n\tif (!fin)\n\t\treturn 0;\n\tret = fscanf(fin, \"%c\", &e);\n\tfclose(fin);\n\tif (ret == 1 && e == 'Y') {\n\t\tload_mount_features_enabled();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define AA_ENABLED_FILE \"/sys/module/apparmor/parameters/enabled\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define AA_ENABLED_FILE \"/sys/module/apparmor/parameters/enabled\"\n\nstatic int apparmor_enabled(void)\n{\n\tFILE *fin;\n\tchar e;\n\tint ret;\n\n\tfin = fopen(AA_ENABLED_FILE, \"r\");\n\tif (!fin)\n\t\treturn 0;\n\tret = fscanf(fin, \"%c\", &e);\n\tfclose(fin);\n\tif (ret == 1 && e == 'Y') {\n\t\tload_mount_features_enabled();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int aa_enabled = 0;\nstatic struct lsm_drv apparmor_drv = {\n\t.name = \"AppArmor\",\n\t.enabled           = apparmor_enabled,\n\t.process_label_get = apparmor_process_label_get,\n\t.process_label_set = apparmor_process_label_set,\n};\n\nstruct lsm_drv *lsm_apparmor_drv_init(void)\n{\n\tif (!apparmor_enabled())\n\t\treturn NULL;\n\taa_enabled = 1;\n\treturn &apparmor_drv;\n}"
  },
  {
    "function_name": "apparmor_process_label_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "174-240",
    "snippet": "static int apparmor_process_label_set(const char *inlabel, struct lxc_conf *conf,\n\t\t\t\t      int use_default, int on_exec)\n{\n\tconst char *label = inlabel ? inlabel : conf->lsm_aa_profile;\n\tchar *curlabel;\n\n\tif (!aa_enabled)\n\t\treturn 0;\n\n\t/* user may request that we just ignore apparmor */\n\tif (label && strcmp(label, AA_UNCHANGED) == 0) {\n\t\tINFO(\"apparmor profile unchanged per user request\");\n\t\treturn 0;\n\t}\n\n\tcurlabel = apparmor_process_label_get(getpid());\n\n\tif (!aa_stacking_supported() && aa_needs_transition(curlabel)) {\n\t\t// we're already confined, and stacking isn't supported\n\n\t\tif (!label || strcmp(curlabel, label) == 0) {\n\t\t\t// no change requested\n\t\t\tfree(curlabel);\n\t\t\treturn 0;\n\t\t}\n\n\t\tERROR(\"already apparmor confined, but new label requested.\");\n\t\tfree(curlabel);\n\t\treturn -1;\n\t}\n\tfree(curlabel);\n\n\tif (!label) {\n\t\tif (use_default) {\n\t\t\tif (cgns_supported())\n\t\t\t\tlabel = AA_DEF_PROFILE_CGNS;\n\t\t\telse\n\t\t\t\tlabel = AA_DEF_PROFILE;\n\t\t}\n\t\telse\n\t\t\tlabel = \"unconfined\";\n\t}\n\n\tif (!check_mount_feature_enabled() && strcmp(label, \"unconfined\") != 0) {\n\t\tWARN(\"Incomplete AppArmor support in your kernel\");\n\t\tif (!conf->lsm_aa_allow_incomplete) {\n\t\t\tERROR(\"If you really want to start this container, set\");\n\t\t\tERROR(\"lxc.aa_allow_incomplete = 1\");\n\t\t\tERROR(\"in your container configuration file\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\tif (strcmp(label, \"unconfined\") == 0 && apparmor_am_unconfined()) {\n\t\tINFO(\"apparmor profile unchanged\");\n\t\treturn 0;\n\t}\n\n\tif (aa_change_profile(label) < 0) {\n\t\tSYSERROR(\"failed to change apparmor profile to %s\", label);\n\t\treturn -1;\n\t}\n\n\tINFO(\"changed apparmor profile to %s\", label);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define AA_UNCHANGED \"unchanged\"",
      "#define AA_DEF_PROFILE_CGNS \"lxc-container-default-cgns\"",
      "#define AA_DEF_PROFILE \"lxc-container-default\""
    ],
    "globals_used": [
      "static int aa_enabled = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"changed apparmor profile to %s\"",
            "label"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to change apparmor profile to %s\"",
            "label"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_change_profile",
          "args": [
            "label"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"apparmor profile unchanged\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apparmor_am_unconfined",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor_am_unconfined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "136-144",
          "snippet": "static bool apparmor_am_unconfined(void)\n{\n\tchar *p = apparmor_process_label_get(getpid());\n\tbool ret = false;\n\tif (!p || strcmp(p, \"unconfined\") == 0)\n\t\tret = true;\n\tfree(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool apparmor_am_unconfined(void)\n{\n\tchar *p = apparmor_process_label_get(getpid());\n\tbool ret = false;\n\tif (!p || strcmp(p, \"unconfined\") == 0)\n\t\tret = true;\n\tfree(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "label",
            "\"unconfined\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"in your container configuration file\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc.aa_allow_incomplete = 1\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"If you really want to start this container, set\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Incomplete AppArmor support in your kernel\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "label",
            "\"unconfined\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mount_feature_enabled",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "check_mount_feature_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "49-52",
          "snippet": "static bool check_mount_feature_enabled(void)\n{\n\treturn mount_features_enabled == 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int mount_features_enabled = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int mount_features_enabled = 0;\n\nstatic bool check_mount_feature_enabled(void)\n{\n\treturn mount_features_enabled == 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "curlabel"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"already apparmor confined, but new label requested.\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curlabel",
            "label"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_needs_transition",
          "args": [
            "curlabel"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "aa_needs_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "151-160",
          "snippet": "static bool aa_needs_transition(char *curlabel)\n{\n\tif (!curlabel)\n\t\treturn false;\n\tif (strcmp(curlabel, \"unconfined\") == 0)\n\t\treturn false;\n\tif (strcmp(curlabel, \"/usr/bin/lxc-start\") == 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool aa_needs_transition(char *curlabel)\n{\n\tif (!curlabel)\n\t\treturn false;\n\tif (strcmp(curlabel, \"unconfined\") == 0)\n\t\treturn false;\n\tif (strcmp(curlabel, \"/usr/bin/lxc-start\") == 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_stacking_supported",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "aa_stacking_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "147-149",
          "snippet": "static bool aa_stacking_supported(void) {\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool aa_stacking_supported(void) {\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apparmor_process_label_get",
          "args": [
            "getpid()"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor_process_label_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "84-130",
          "snippet": "static char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"apparmor profile unchanged per user request\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "label",
            "AA_UNCHANGED"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define AA_UNCHANGED \"unchanged\"\n#define AA_DEF_PROFILE_CGNS \"lxc-container-default-cgns\"\n#define AA_DEF_PROFILE \"lxc-container-default\"\n\nstatic int aa_enabled = 0;\n\nstatic int apparmor_process_label_set(const char *inlabel, struct lxc_conf *conf,\n\t\t\t\t      int use_default, int on_exec)\n{\n\tconst char *label = inlabel ? inlabel : conf->lsm_aa_profile;\n\tchar *curlabel;\n\n\tif (!aa_enabled)\n\t\treturn 0;\n\n\t/* user may request that we just ignore apparmor */\n\tif (label && strcmp(label, AA_UNCHANGED) == 0) {\n\t\tINFO(\"apparmor profile unchanged per user request\");\n\t\treturn 0;\n\t}\n\n\tcurlabel = apparmor_process_label_get(getpid());\n\n\tif (!aa_stacking_supported() && aa_needs_transition(curlabel)) {\n\t\t// we're already confined, and stacking isn't supported\n\n\t\tif (!label || strcmp(curlabel, label) == 0) {\n\t\t\t// no change requested\n\t\t\tfree(curlabel);\n\t\t\treturn 0;\n\t\t}\n\n\t\tERROR(\"already apparmor confined, but new label requested.\");\n\t\tfree(curlabel);\n\t\treturn -1;\n\t}\n\tfree(curlabel);\n\n\tif (!label) {\n\t\tif (use_default) {\n\t\t\tif (cgns_supported())\n\t\t\t\tlabel = AA_DEF_PROFILE_CGNS;\n\t\t\telse\n\t\t\t\tlabel = AA_DEF_PROFILE;\n\t\t}\n\t\telse\n\t\t\tlabel = \"unconfined\";\n\t}\n\n\tif (!check_mount_feature_enabled() && strcmp(label, \"unconfined\") != 0) {\n\t\tWARN(\"Incomplete AppArmor support in your kernel\");\n\t\tif (!conf->lsm_aa_allow_incomplete) {\n\t\t\tERROR(\"If you really want to start this container, set\");\n\t\t\tERROR(\"lxc.aa_allow_incomplete = 1\");\n\t\t\tERROR(\"in your container configuration file\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\tif (strcmp(label, \"unconfined\") == 0 && apparmor_am_unconfined()) {\n\t\tINFO(\"apparmor profile unchanged\");\n\t\treturn 0;\n\t}\n\n\tif (aa_change_profile(label) < 0) {\n\t\tSYSERROR(\"failed to change apparmor profile to %s\", label);\n\t\treturn -1;\n\t}\n\n\tINFO(\"changed apparmor profile to %s\", label);\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_needs_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "151-160",
    "snippet": "static bool aa_needs_transition(char *curlabel)\n{\n\tif (!curlabel)\n\t\treturn false;\n\tif (strcmp(curlabel, \"unconfined\") == 0)\n\t\treturn false;\n\tif (strcmp(curlabel, \"/usr/bin/lxc-start\") == 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curlabel",
            "\"/usr/bin/lxc-start\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curlabel",
            "\"unconfined\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool aa_needs_transition(char *curlabel)\n{\n\tif (!curlabel)\n\t\treturn false;\n\tif (strcmp(curlabel, \"unconfined\") == 0)\n\t\treturn false;\n\tif (strcmp(curlabel, \"/usr/bin/lxc-start\") == 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "aa_stacking_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "147-149",
    "snippet": "static bool aa_stacking_supported(void) {\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool aa_stacking_supported(void) {\n\treturn false;\n}"
  },
  {
    "function_name": "apparmor_am_unconfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "136-144",
    "snippet": "static bool apparmor_am_unconfined(void)\n{\n\tchar *p = apparmor_process_label_get(getpid());\n\tbool ret = false;\n\tif (!p || strcmp(p, \"unconfined\") == 0)\n\t\tret = true;\n\tfree(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unconfined\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apparmor_process_label_get",
          "args": [
            "getpid()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor_process_label_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "84-130",
          "snippet": "static char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool apparmor_am_unconfined(void)\n{\n\tchar *p = apparmor_process_label_get(getpid());\n\tbool ret = false;\n\tif (!p || strcmp(p, \"unconfined\") == 0)\n\t\tret = true;\n\tfree(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "apparmor_process_label_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "84-130",
    "snippet": "static char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "' '"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "freeifaddrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/ifaddrs.c",
          "lines": "590-599",
          "snippet": "void freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}",
          "includes": [
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/if_arp.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"ifaddrs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/if_arp.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ifaddrs.h\"\n\nvoid freeifaddrs(struct ifaddrs *ifa)\n{\n    struct ifaddrs *l_cur;\n    while(ifa)\n    {\n        l_cur = ifa;\n        ifa = ifa->ifa_next;\n        free(l_cur);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"reading %s\"",
            "path"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "sz - 1",
            "f"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sz"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"out of memory\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "buf",
            "sz"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"opening %s\"",
            "path"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"path name too long\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "100",
            "\"/proc/%d/attr/current\"",
            "pid"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *apparmor_process_label_get(pid_t pid)\n{\n\tchar path[100], *space;\n\tint ret;\n\tchar *buf = NULL, *newbuf;\n\tint sz = 0;\n\tFILE *f;\n\n\tret = snprintf(path, 100, \"/proc/%d/attr/current\", pid);\n\tif (ret < 0 || ret >= 100) {\n\t\tERROR(\"path name too long\");\n\t\treturn NULL;\n\t}\nagain:\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\tSYSERROR(\"opening %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tsz += 1024;\n\tnewbuf = realloc(buf, sz);\n\tif (!newbuf) {\n\t\tfree(buf);\n\t\tERROR(\"out of memory\");\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tbuf = newbuf;\n\tmemset(buf, 0, sz);\n\tret = fread(buf, 1, sz - 1, f);\n\tfclose(f);\n\tif (ret < 0) {\n\t\tERROR(\"reading %s\", path);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (ret >= sz)\n\t\tgoto again;\n\tspace = strchr(buf, '\\n');\n\tif (space)\n\t\t*space = '\\0';\n\tspace = strchr(buf, ' ');\n\tif (space)\n\t\t*space = '\\0';\n\treturn buf;\n}"
  },
  {
    "function_name": "apparmor_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "65-82",
    "snippet": "static int apparmor_enabled(void)\n{\n\tFILE *fin;\n\tchar e;\n\tint ret;\n\n\tfin = fopen(AA_ENABLED_FILE, \"r\");\n\tif (!fin)\n\t\treturn 0;\n\tret = fscanf(fin, \"%c\", &e);\n\tfclose(fin);\n\tif (ret == 1 && e == 'Y') {\n\t\tload_mount_features_enabled();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define AA_ENABLED_FILE \"/sys/module/apparmor/parameters/enabled\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_mount_features_enabled",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "load_mount_features_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
          "lines": "54-62",
          "snippet": "static void load_mount_features_enabled(void)\n{\n\tstruct stat statbuf;\n\tint ret;\n\n\tret = stat(AA_MOUNT_RESTR, &statbuf);\n\tif (ret == 0)\n\t\tmount_features_enabled = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"lsm/lsm.h\"",
            "#include \"log.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/apparmor.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define AA_MOUNT_RESTR \"/sys/kernel/security/apparmor/features/mount/mask\""
          ],
          "globals_used": [
            "static int mount_features_enabled = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define AA_MOUNT_RESTR \"/sys/kernel/security/apparmor/features/mount/mask\"\n\nstatic int mount_features_enabled = 0;\n\nstatic void load_mount_features_enabled(void)\n{\n\tstruct stat statbuf;\n\tint ret;\n\n\tret = stat(AA_MOUNT_RESTR, &statbuf);\n\tif (ret == 0)\n\t\tmount_features_enabled = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fin",
            "\"%c\"",
            "&e"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "AA_ENABLED_FILE",
            "\"r\""
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define AA_ENABLED_FILE \"/sys/module/apparmor/parameters/enabled\"\n\nstatic int apparmor_enabled(void)\n{\n\tFILE *fin;\n\tchar e;\n\tint ret;\n\n\tfin = fopen(AA_ENABLED_FILE, \"r\");\n\tif (!fin)\n\t\treturn 0;\n\tret = fscanf(fin, \"%c\", &e);\n\tfclose(fin);\n\tif (ret == 1 && e == 'Y') {\n\t\tload_mount_features_enabled();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load_mount_features_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "54-62",
    "snippet": "static void load_mount_features_enabled(void)\n{\n\tstruct stat statbuf;\n\tint ret;\n\n\tret = stat(AA_MOUNT_RESTR, &statbuf);\n\tif (ret == 0)\n\t\tmount_features_enabled = 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define AA_MOUNT_RESTR \"/sys/kernel/security/apparmor/features/mount/mask\""
    ],
    "globals_used": [
      "static int mount_features_enabled = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "AA_MOUNT_RESTR",
            "&statbuf"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define AA_MOUNT_RESTR \"/sys/kernel/security/apparmor/features/mount/mask\"\n\nstatic int mount_features_enabled = 0;\n\nstatic void load_mount_features_enabled(void)\n{\n\tstruct stat statbuf;\n\tint ret;\n\n\tret = stat(AA_MOUNT_RESTR, &statbuf);\n\tif (ret == 0)\n\t\tmount_features_enabled = 1;\n}"
  },
  {
    "function_name": "check_mount_feature_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lsm/apparmor.c",
    "lines": "49-52",
    "snippet": "static bool check_mount_feature_enabled(void)\n{\n\treturn mount_features_enabled == 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"conf.h\"",
      "#include \"lsm/lsm.h\"",
      "#include \"log.h\"",
      "#include <sys/vfs.h>",
      "#include <sys/apparmor.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int mount_features_enabled = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"conf.h\"\n#include \"lsm/lsm.h\"\n#include \"log.h\"\n#include <sys/vfs.h>\n#include <sys/apparmor.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int mount_features_enabled = 0;\n\nstatic bool check_mount_feature_enabled(void)\n{\n\treturn mount_features_enabled == 1;\n}"
  }
]