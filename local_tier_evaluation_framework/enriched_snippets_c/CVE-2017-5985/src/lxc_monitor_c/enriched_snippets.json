[
  {
    "function_name": "lxc_monitord_spawn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "287-372",
    "snippet": "int lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [
      "#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to exec lxc-monitord.\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "args[0]",
            "args"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Using pipe file descriptor %d for monitord.\"",
            "pipefd[1]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create pid argument to pass to monitord.\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pipefd_str",
            "LXC_NUMSTRLEN64",
            "\"%d\"",
            "pipefd[1]"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[0]"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "151-154",
          "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to dup2() standard file descriptors to /dev/null.\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "null_stdfds",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "null_stdfds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1828-1839",
          "snippet": "int null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint null_stdfds(void)\n{\n\tint ret = -1;\n\tint fd = open_devnull();\n\n\tif (fd >= 0) {\n\t\tret = set_stdfds(fd);\n\t\tclose(fd);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_check_inherited",
          "args": [
            "NULL",
            "true",
            "pipefd[1]"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_check_inherited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "198-257",
          "snippet": "int lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nint lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setsid().\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Successfully synced with child process.\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "&c",
            "1"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_read_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "266-275",
          "snippet": "int lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Trying to sync with child process.\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to fork().\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create pipe.\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Finished waiting on pid %d.\"",
            "pid1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid1",
            "NULL",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Going to wait for pid %d.\"",
            "pid1"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to fork().\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\"\n\nint lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "lxc_monitor_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "277-280",
    "snippet": "int lxc_monitor_read(int fd, struct lxc_msg *msg)\n{\n\treturn lxc_monitor_read_timeout(fd, msg, -1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_read_timeout",
          "args": [
            "fd",
            "msg",
            "-1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_read_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "266-275",
          "snippet": "int lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read(int fd, struct lxc_msg *msg)\n{\n\treturn lxc_monitor_read_timeout(fd, msg, -1);\n}"
  },
  {
    "function_name": "lxc_monitor_read_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "266-275",
    "snippet": "int lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_read_fdset",
          "args": [
            "&fds",
            "1",
            "msg",
            "timeout"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_read_fdset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "234-264",
          "snippet": "int lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}"
  },
  {
    "function_name": "lxc_monitor_read_fdset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "234-264",
    "snippet": "int lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"No ready fd found.\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to receive message. Did monitord die?: %s.\"",
            "strerror(errno)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "fds[i].fd",
            "msg",
            "sizeof(*msg)",
            "0"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_recv_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "164-201",
          "snippet": "int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tchar buf[1];\n\tint ret, *val;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tiov.iov_base = data ? data : buf;\n\tiov.iov_len = data ? size : sizeof(buf);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\t/* if the message is wrong the variable will not be\n\t * filled and the peer will notified about a problem */\n\t*recvfd = -1;\n\n\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&\n\t\t\tcmsg->cmsg_level == SOL_SOCKET &&\n\t\t\tcmsg->cmsg_type == SCM_RIGHTS) {\n\t\tval = (int *) CMSG_DATA(cmsg);\n\t\t*recvfd = *val;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "nfds",
            "timeout * 1000"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_fdset(struct pollfd *fds, nfds_t nfds, struct lxc_msg *msg,\n\t\t\t   int timeout)\n{\n\tlong i;\n\tint ret;\n\n\tret = poll(fds, nfds, timeout * 1000);\n\tif (ret == -1)\n\t\treturn -1;\n\telse if (ret == 0)\n\t\treturn -2;  // timed out\n\n\t/* Only read from the first ready fd, the others will remain ready for\n\t * when this routine is called again.\n\t */\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].revents != 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tret = recv(fds[i].fd, msg, sizeof(*msg), 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tSYSERROR(\"Failed to receive message. Did monitord die?: %s.\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSYSERROR(\"No ready fd found.\");\n\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_monitor_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "190-232",
    "snippet": "int lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "151-154",
          "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to connect to monitor socket: %s.\"",
            "strerror(errno)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "backoff_ms[retry] * 1000"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to connect to monitor socket. Retrying in %d ms.\"",
            "backoff_ms[retry]"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "fd",
            "(struct sockaddr *)&addr",
            "offsetof(struct sockaddr_un, sun_path) + len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "&addr.sun_path[1]"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create socket: %s.\"",
            "strerror(errno)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_sock_name",
          "args": [
            "lxcpath",
            "&addr"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_sock_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "156-188",
          "snippet": "int lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_monitor_sock_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "156-188",
    "snippet": "int lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Using monitor socket name \\\"%s\\\".\"",
            "sockname"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sockname",
            "len",
            "\"lxc/%016\" PRIx64 \"/%s\"",
            "hash",
            "lxcpath"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnv_64a_buf",
          "args": [
            "path",
            "ret",
            "FNV1A_64_INIT"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "fnv_64a_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1076-1093",
          "snippet": "uint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuint64_t fnv_64a_buf(void *buf, size_t len, uint64_t hval)\n{\n\tunsigned char *bp;\n\n\tfor(bp = buf; bp < (unsigned char *)buf + len; bp++)\n\t{\n\t\t/* xor the bottom with the current octet */\n\t\thval ^= (uint64_t)*bp;\n\n\t\t/* gcc optimised:\n\t\t * multiply by the 64 bit FNV magic prime mod 2^64\n\t\t */\n\t\thval += (hval << 1) + (hval << 4) + (hval << 5) +\n\t\t\t(hval << 7) + (hval << 8) + (hval << 40);\n\t}\n\n\treturn hval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to create path for monitor.\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "len",
            "\"lxc/%s/monitor-sock\"",
            "lxcpath"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "0",
            "sizeof(*addr)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_sock_name(const char *lxcpath, struct sockaddr_un *addr) {\n\tsize_t len;\n\tint ret;\n\tchar *sockname;\n\tchar *path;\n\tuint64_t hash;\n\n\t/* addr.sun_path is only 108 bytes, so we hash the full name and\n\t * then append as much of the name as we can fit.\n\t */\n\tsockname = &addr->sun_path[1];\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sun_family = AF_UNIX;\n\n\tlen = strlen(lxcpath) + 18;\n\tpath = alloca(len);\n\tret = snprintf(path, len, \"lxc/%s/monitor-sock\", lxcpath);\n\tif (ret < 0 || (size_t)ret >= len) {\n\t\tERROR(\"Failed to create path for monitor.\");\n\t\treturn -1;\n\t}\n\n\tlen = sizeof(addr->sun_path) - 1;\n\thash = fnv_64a_buf(path, ret, FNV1A_64_INIT);\n\tret = snprintf(sockname, len, \"lxc/%016\" PRIx64 \"/%s\", hash, lxcpath);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tsockname[sizeof(addr->sun_path)-3] = '\\0';\n\tINFO(\"Using monitor socket name \\\"%s\\\".\", sockname);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_monitor_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "151-154",
    "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "151-154",
          "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}"
  },
  {
    "function_name": "lxc_monitor_send_exit_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "140-148",
    "snippet": "void lxc_monitor_send_exit_code(const char *name, int exit_code,\n\t\t\t\tconst char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_exit_code, .value = exit_code};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_fifo_send",
          "args": [
            "&msg",
            "lxcpath"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_fifo_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "89-128",
          "snippet": "static void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "msg.name",
            "name",
            "sizeof(msg.name)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_monitor_send_exit_code(const char *name, int exit_code,\n\t\t\t\tconst char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_exit_code, .value = exit_code};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}"
  },
  {
    "function_name": "lxc_monitor_send_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "130-138",
    "snippet": "void lxc_monitor_send_state(const char *name, lxc_state_t state,\n\t\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_state, .value = state};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_fifo_send",
          "args": [
            "&msg",
            "lxcpath"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_fifo_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "89-128",
          "snippet": "static void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "msg.name",
            "name",
            "sizeof(msg.name)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nvoid lxc_monitor_send_state(const char *name, lxc_state_t state,\n\t\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg = {.type = lxc_msg_state, .value = state};\n\tstrncpy(msg.name, name, sizeof(msg.name));\n\tmsg.name[sizeof(msg.name) - 1] = 0;\n\n\tlxc_monitor_fifo_send(&msg, lxcpath);\n}"
  },
  {
    "function_name": "lxc_monitor_fifo_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "89-128",
    "snippet": "static void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "151-154",
          "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to write to monitor fifo \\\"%s\\\".\"",
            "fifo_path"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "msg",
            "sizeof(*msg)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "O_WRONLY"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to open fifo to send message: %s.\"",
            "strerror(errno)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "fifo_path",
            "O_WRONLY | O_NONBLOCK"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitor_fifo_name",
          "args": [
            "lxcpath",
            "fifo_path",
            "sizeof(fifo_path)",
            "0"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_fifo_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "55-87",
          "snippet": "int lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(*msg) > PIPE_BUF"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void lxc_monitor_fifo_send(struct lxc_msg *msg, const char *lxcpath)\n{\n\tint fd,ret;\n\tchar fifo_path[PATH_MAX];\n\n\tBUILD_BUG_ON(sizeof(*msg) > PIPE_BUF); /* write not guaranteed atomic */\n\n\tret = lxc_monitor_fifo_name(lxcpath, fifo_path, sizeof(fifo_path), 0);\n\tif (ret < 0)\n\t\treturn;\n\n\t/* Open the fifo nonblock in case the monitor is dead, we don't want the\n\t * open to wait for a reader since it may never come.\n\t */\n\tfd = open(fifo_path, O_WRONLY | O_NONBLOCK);\n\tif (fd < 0) {\n\t\t/* It is normal for this open() to fail with ENXIO when there is\n\t\t * no monitor running, so we don't log it.\n\t\t */\n\t\tif (errno == ENXIO)\n\t\t\treturn;\n\n\t\tWARN(\"Failed to open fifo to send message: %s.\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fcntl(fd, F_SETFL, O_WRONLY) < 0) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\n\tret = write(fd, msg, sizeof(*msg));\n\tif (ret != sizeof(*msg)) {\n\t\tclose(fd);\n\t\tSYSERROR(\"Failed to write to monitor fifo \\\"%s\\\".\", fifo_path);\n\t\treturn;\n\t}\n\n\tclose(fd);\n}"
  },
  {
    "function_name": "lxc_monitor_fifo_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
    "lines": "55-87",
    "snippet": "int lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"state.h\"",
      "#include \"monitor.h\"",
      "#include \"lxclock.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"af_unix.h\"",
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stddef.h>",
      "#include <poll.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"rundir/lxcpath (%s/%s) too long for monitor fifo.\"",
            "rundir",
            "lxcpath"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fifo_path",
            "fifo_path_sz",
            "\"%s/lxc/%s/monitor-fifo\"",
            "rundir",
            "lxcpath"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to create monitor fifo directory %s.\"",
            "fifo_path"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "fifo_path",
            "0755"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"rundir/lxcpath (%s/%s) too long for monitor fifo.\"",
            "rundir",
            "lxcpath"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fifo_path",
            "fifo_path_sz",
            "\"%s/lxc/%s\"",
            "rundir",
            "lxcpath"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rundir",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "get_rundir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "264-291",
          "snippet": "char *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_fifo_name(const char *lxcpath, char *fifo_path, size_t fifo_path_sz,\n\t\t\t  int do_mkdirp)\n{\n\tint ret;\n\tchar *rundir;\n\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn -1;\n\n\tif (do_mkdirp) {\n\t\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s\", rundir, lxcpath);\n\t\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\t\tfree(rundir);\n\t\t\treturn -1;\n\t\t}\n\t\tret = mkdir_p(fifo_path, 0755);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"Unable to create monitor fifo directory %s.\", fifo_path);\n\t\t\tfree(rundir);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = snprintf(fifo_path, fifo_path_sz, \"%s/lxc/%s/monitor-fifo\", rundir, lxcpath);\n\tif (ret < 0 || (size_t)ret >= fifo_path_sz) {\n\t\tERROR(\"rundir/lxcpath (%s/%s) too long for monitor fifo.\", rundir, lxcpath);\n\t\tfree(rundir);\n\t\treturn -1;\n\t}\n\tfree(rundir);\n\treturn 0;\n}"
  }
]