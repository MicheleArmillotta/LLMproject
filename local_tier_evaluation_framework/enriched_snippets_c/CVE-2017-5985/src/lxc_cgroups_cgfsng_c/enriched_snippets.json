[
  {
    "function_name": "cgfsng_setup_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1922-1966",
    "snippet": "static bool cgfsng_setup_limits(void *hdata, struct lxc_list *cgroup_settings,\n\t\t\t\t  bool do_devices)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tbool ret = false;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn true;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn false;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = true;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sorted_cgroup_settings"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_del",
          "args": [
            "iterator"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "148-156",
          "snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_del(struct lxc_list *list)\n{\n\tstruct lxc_list *next, *prev;\n\n\tnext = list->next;\n\tprev = list->prev;\n\tnext->prev = prev;\n\tprev->next = next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each_safe",
          "args": [
            "iterator",
            "sorted_cgroup_settings",
            "next"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"cgroup has been setup\""
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"cgroup '%s' set to '%s'\"",
            "cg->subsystem",
            "cg->value"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error setting %s to %s for %s\"",
            "cg->subsystem",
            "cg->value",
            "d->name"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error setting %s to %s for %s\"",
            "cg->subsystem",
            "cg->value",
            "d->name"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cgroup_set_data",
          "args": [
            "cg->subsystem",
            "cg->value",
            "d"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cgroup_set_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1902-1920",
          "snippet": "static int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfsng_handler_data *d)\n{\n\tchar *subsystem = NULL, *p;\n\tint ret = -1;\n\tstruct hierarchy *h;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = must_make_path(h->fullcgpath, filename, NULL);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfsng_handler_data *d)\n{\n\tchar *subsystem = NULL, *p;\n\tint ret = -1;\n\tstruct hierarchy *h;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = must_make_path(h->fullcgpath, filename, NULL);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"devices\"",
            "cg->subsystem",
            "7"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "iterator",
            "sorted_cgroup_settings"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort_cgroup_settings",
          "args": [
            "cgroup_settings"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "sort_cgroup_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4634-4672",
          "snippet": "struct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstruct lxc_list *sort_cgroup_settings(struct lxc_list* cgroup_settings)\n{\n\tstruct lxc_list *result;\n\tstruct lxc_list *memsw_limit = NULL;\n\tstruct lxc_list *it = NULL;\n\tstruct lxc_cgroup *cg = NULL;\n\tstruct lxc_list *item = NULL;\n\n\tresult = malloc(sizeof(*result));\n\tif (!result) {\n\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\treturn NULL;\n\t}\n\tlxc_list_init(result);\n\n\t/*Iterate over the cgroup settings and copy them to the output list*/\n\tlxc_list_for_each(it, cgroup_settings) {\n\t\titem = malloc(sizeof(*item));\n\t\tif (!item) {\n\t\t\tERROR(\"failed to allocate memory to sort cgroup settings\");\n\t\t\tfree_cgroup_settings(result);\n\t\t\treturn NULL;\n\t\t}\n\t\titem->elem = it->elem;\n\t\tcg = it->elem;\n\t\tif (strcmp(cg->subsystem, \"memory.memsw.limit_in_bytes\") == 0) {\n\t\t\t/* Store the memsw_limit location */\n\t\t\tmemsw_limit = item;\n\t\t} else if (strcmp(cg->subsystem, \"memory.limit_in_bytes\") == 0 && memsw_limit != NULL) {\n\t\t\t/* lxc.cgroup.memory.memsw.limit_in_bytes is found before\n\t\t\t * lxc.cgroup.memory.limit_in_bytes, swap these two items */\n\t\t\titem->elem = memsw_limit->elem;\n\t\t\tmemsw_limit->elem = it->elem;\n\t\t}\n\t\tlxc_list_add_tail(result, item);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "cgroup_settings"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cgfsng_setup_limits(void *hdata, struct lxc_list *cgroup_settings,\n\t\t\t\t  bool do_devices)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tbool ret = false;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn true;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn false;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tif (do_devices && (errno == EACCES || errno == EPERM)) {\n\t\t\t\t\tWARN(\"Error setting %s to %s for %s\",\n\t\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSYSERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = true;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}"
  },
  {
    "function_name": "lxc_cgroup_set_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1902-1920",
    "snippet": "static int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfsng_handler_data *d)\n{\n\tchar *subsystem = NULL, *p;\n\tint ret = -1;\n\tstruct hierarchy *h;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = must_make_path(h->fullcgpath, filename, NULL);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "value",
            "strlen(value)",
            "false"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "h->fullcgpath",
            "filename",
            "NULL"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hierarchy",
          "args": [
            "subsystem"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "get_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "243-254",
          "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int lxc_cgroup_set_data(const char *filename, const char *value, struct cgfsng_handler_data *d)\n{\n\tchar *subsystem = NULL, *p;\n\tint ret = -1;\n\tstruct hierarchy *h;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = must_make_path(h->fullcgpath, filename, NULL);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cgfsng_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1871-1896",
    "snippet": "static int cgfsng_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tchar *subsystem, *p, *path;\n\tstruct hierarchy *h;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, subsystem);\n\tif (!path) // not running\n\t\treturn -1;\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = build_full_cgpath_from_monitorpath(h, path, filename);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\n\tfree(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "value",
            "strlen(value)",
            "false"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_full_cgpath_from_monitorpath",
          "args": [
            "h",
            "path",
            "filename"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "build_full_cgpath_from_monitorpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1790-1802",
          "snippet": "static char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hierarchy",
          "args": [
            "subsystem"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "get_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "243-254",
          "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "name",
            "lxcpath",
            "subsystem"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int cgfsng_set(const char *filename, const char *value, const char *name, const char *lxcpath)\n{\n\tchar *subsystem, *p, *path;\n\tstruct hierarchy *h;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, subsystem);\n\tif (!path) // not running\n\t\treturn -1;\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = build_full_cgpath_from_monitorpath(h, path, filename);\n\t\tret = lxc_write_to_file(fullpath, value, strlen(value), false);\n\t\tfree(fullpath);\n\t}\n\n\tfree(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgfsng_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1839-1864",
    "snippet": "static int cgfsng_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tchar *subsystem, *p, *path;\n\tstruct hierarchy *h;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, subsystem);\n\tif (!path) // not running\n\t\treturn -1;\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = build_full_cgpath_from_monitorpath(h, path, filename);\n\t\tret = lxc_read_from_file(fullpath, value, len);\n\t\tfree(fullpath);\n\t}\n\n\tfree(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "fullpath",
            "value",
            "len"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_full_cgpath_from_monitorpath",
          "args": [
            "h",
            "path",
            "filename"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "build_full_cgpath_from_monitorpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1790-1802",
          "snippet": "static char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hierarchy",
          "args": [
            "subsystem"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "get_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "243-254",
          "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "name",
            "lxcpath",
            "subsystem"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "subsystem",
            "'.'"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "subsystem",
            "filename"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(filename) + 1"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int cgfsng_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tchar *subsystem, *p, *path;\n\tstruct hierarchy *h;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, subsystem);\n\tif (!path) // not running\n\t\treturn -1;\n\n\th = get_hierarchy(subsystem);\n\tif (h) {\n\t\tchar *fullpath = build_full_cgpath_from_monitorpath(h, path, filename);\n\t\tret = lxc_read_from_file(fullpath, value, len);\n\t\tfree(fullpath);\n\t}\n\n\tfree(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgfsng_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1804-1832",
    "snippet": "static bool cgfsng_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tchar pidstr[25];\n\tint i, len;\n\n\tlen = snprintf(pidstr, 25, \"%d\", pid);\n\tif (len < 0 || len > 25)\n\t\treturn false;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *path, *fullpath;\n\t\tstruct hierarchy *h = hierarchies[i];\n\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->controllers[0]);\n\t\tif (!path) // not running\n\t\t\tcontinue;\n\n\t\tfullpath = build_full_cgpath_from_monitorpath(h, path, \"cgroup.procs\");\n\t\tfree(path);\n\t\tif (lxc_write_to_file(fullpath, pidstr, len, false) != 0) {\n\t\t\tSYSERROR(\"Failed to attach %d to %s\", (int)pid, fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to attach %d to %s\"",
            "(int)pid",
            "fullpath"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "pidstr",
            "len",
            "false"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_full_cgpath_from_monitorpath",
          "args": [
            "h",
            "path",
            "\"cgroup.procs\""
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "build_full_cgpath_from_monitorpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1790-1802",
          "snippet": "static char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "name",
            "lxcpath",
            "h->controllers[0]"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pidstr",
            "25",
            "\"%d\"",
            "pid"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool cgfsng_attach(const char *name, const char *lxcpath, pid_t pid)\n{\n\tchar pidstr[25];\n\tint i, len;\n\n\tlen = snprintf(pidstr, 25, \"%d\", pid);\n\tif (len < 0 || len > 25)\n\t\treturn false;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *path, *fullpath;\n\t\tstruct hierarchy *h = hierarchies[i];\n\n\t\tpath = lxc_cmd_get_cgroup_path(name, lxcpath, h->controllers[0]);\n\t\tif (!path) // not running\n\t\t\tcontinue;\n\n\t\tfullpath = build_full_cgpath_from_monitorpath(h, path, \"cgroup.procs\");\n\t\tfree(path);\n\t\tif (lxc_write_to_file(fullpath, pidstr, len, false) != 0) {\n\t\t\tSYSERROR(\"Failed to attach %d to %s\", (int)pid, fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "build_full_cgpath_from_monitorpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1790-1802",
    "snippet": "static char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "h->mountpoint",
            "inpath",
            "filename",
            "NULL"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "inpath",
            "\"/sys/fs/cgroup/\"",
            "15"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *build_full_cgpath_from_monitorpath(struct hierarchy *h,\n\t\t\t\t\t\tconst char *inpath,\n\t\t\t\t\t\tconst char *filename)\n{\n\t/*\n\t * XXX Remove this case after 2.0 release.  It's for dealing with\n\t * containers spawned under the old buggy cgfsng which wasn't around\n\t * for long.\n\t */\n\tif (strncmp(inpath, \"/sys/fs/cgroup/\", 15) == 0)\n\t\treturn must_make_path(inpath, filename, NULL);\n\treturn must_make_path(h->mountpoint, inpath, filename, NULL);\n}"
  },
  {
    "function_name": "cgfsng_get_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1777-1784",
    "snippet": "static const char *cgfsng_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct hierarchy *h = get_hierarchy(subsystem);\n\tif (!h)\n\t\treturn NULL;\n\n\treturn h->fullcgpath ? h->fullcgpath + strlen(h->mountpoint) : NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "h->mountpoint"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hierarchy",
          "args": [
            "subsystem"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "get_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "243-254",
          "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic const char *cgfsng_get_cgroup(void *hdata, const char *subsystem)\n{\n\tstruct hierarchy *h = get_hierarchy(subsystem);\n\tif (!h)\n\t\treturn NULL;\n\n\treturn h->fullcgpath ? h->fullcgpath + strlen(h->mountpoint) : NULL;\n}"
  },
  {
    "function_name": "cgfsng_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1761-1775",
    "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define THAWED_LEN (strlen(THAWED))",
      "#define THAWED \"THAWED\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "THAWED",
            "THAWED_LEN",
            "false"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "h->fullcgpath",
            "\"freezer.state\"",
            "NULL"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hierarchy",
          "args": [
            "\"freezer\""
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "get_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "243-254",
          "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
  },
  {
    "function_name": "cgfsng_get_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1743-1756",
    "snippet": "static bool cgfsng_get_hierarchies(int n, char ***out)\n{\n\tint i;\n\n\t/* sanity check n */\n\tfor (i = 0; i < n; i++) {\n\t\tif (!hierarchies[i])\n\t\t\treturn false;\n\t}\n\n\t*out = hierarchies[i]->controllers;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool cgfsng_get_hierarchies(int n, char ***out)\n{\n\tint i;\n\n\t/* sanity check n */\n\tfor (i = 0; i < n; i++) {\n\t\tif (!hierarchies[i])\n\t\t\treturn false;\n\t}\n\n\t*out = hierarchies[i]->controllers;\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgfsng_num_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1733-1741",
    "snippet": "static int cgfsng_num_hierarchies(void)\n{\n\tint i;\n\n\tfor (i = 0; hierarchies[i]; i++)\n\t\t;\n\n\treturn i;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic int cgfsng_num_hierarchies(void)\n{\n\tint i;\n\n\tfor (i = 0; hierarchies[i]; i++)\n\t\t;\n\n\treturn i;\n}"
  },
  {
    "function_name": "cgfsng_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1711-1731",
    "snippet": "static bool cgfsng_escape()\n{\n\tint i;\n\n\tif (geteuid())\n\t\treturn true;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath = must_make_path(hierarchies[i]->mountpoint,\n\t\t\t\t\t\thierarchies[i]->base_cgroup,\n\t\t\t\t\t\t\"cgroup.procs\", NULL);\n\t\tif (lxc_write_to_file(fullpath, \"0\", 2, false) != 0) {\n\t\t\tSYSERROR(\"Failed to escape to %s\", fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to escape to %s\"",
            "fullpath"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "\"0\"",
            "2",
            "false"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "hierarchies[i]->mountpoint",
            "hierarchies[i]->base_cgroup",
            "\"cgroup.procs\"",
            "NULL"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool cgfsng_escape()\n{\n\tint i;\n\n\tif (geteuid())\n\t\treturn true;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath = must_make_path(hierarchies[i]->mountpoint,\n\t\t\t\t\t\thierarchies[i]->base_cgroup,\n\t\t\t\t\t\t\"cgroup.procs\", NULL);\n\t\tif (lxc_write_to_file(fullpath, \"0\", 2, false) != 0) {\n\t\t\tSYSERROR(\"Failed to escape to %s\", fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgfsng_nrtasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1697-1708",
    "snippet": "static int cgfsng_nrtasks(void *hdata) {\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *path;\n\tint count;\n\n\tif (!d || !d->container_cgroup || !hierarchies)\n\t\treturn -1;\n\tpath = must_make_path(hierarchies[0]->fullcgpath, NULL);\n\tcount = recursive_count_nrtasks(path);\n\tfree(path);\n\treturn count;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursive_count_nrtasks",
          "args": [
            "path"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "recursive_count_nrtasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1652-1695",
          "snippet": "static int recursive_count_nrtasks(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count = 0, ret;\n\tchar *path;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpath = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(path, &mystat))\n\t\t\tgoto next;\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\n\t\tcount += recursive_count_nrtasks(path);\nnext:\n\t\tfree(path);\n\t}\n\n\tpath = must_make_path(dirname, \"cgroup.procs\", NULL);\n\tret = lxc_count_file_lines(path);\n\tif (ret != -1)\n\t\tcount += ret;\n\tfree(path);\n\n\t(void) closedir(dir);\n\n\treturn count;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int recursive_count_nrtasks(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count = 0, ret;\n\tchar *path;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpath = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(path, &mystat))\n\t\t\tgoto next;\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\n\t\tcount += recursive_count_nrtasks(path);\nnext:\n\t\tfree(path);\n\t}\n\n\tpath = must_make_path(dirname, \"cgroup.procs\", NULL);\n\tret = lxc_count_file_lines(path);\n\tif (ret != -1)\n\t\tcount += ret;\n\tfree(path);\n\n\t(void) closedir(dir);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "hierarchies[0]->fullcgpath",
            "NULL"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic int cgfsng_nrtasks(void *hdata) {\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *path;\n\tint count;\n\n\tif (!d || !d->container_cgroup || !hierarchies)\n\t\treturn -1;\n\tpath = must_make_path(hierarchies[0]->fullcgpath, NULL);\n\tcount = recursive_count_nrtasks(path);\n\tfree(path);\n\treturn count;\n}"
  },
  {
    "function_name": "recursive_count_nrtasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1652-1695",
    "snippet": "static int recursive_count_nrtasks(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count = 0, ret;\n\tchar *path;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpath = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(path, &mystat))\n\t\t\tgoto next;\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\n\t\tcount += recursive_count_nrtasks(path);\nnext:\n\t\tfree(path);\n\t}\n\n\tpath = must_make_path(dirname, \"cgroup.procs\", NULL);\n\tret = lxc_count_file_lines(path);\n\tif (ret != -1)\n\t\tcount += ret;\n\tfree(path);\n\n\t(void) closedir(dir);\n\n\treturn count;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_count_file_lines",
          "args": [
            "path"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_count_file_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1844-1861",
          "snippet": "int lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_count_file_lines(const char *fn)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tint n = 0;\n\n\tf = fopen_cloexec(fn, \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tn++;\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "dirname",
            "\"cgroup.procs\"",
            "NULL"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursive_count_nrtasks",
          "args": [
            "path"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "recursive_count_nrtasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1652-1695",
          "snippet": "static int recursive_count_nrtasks(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count = 0, ret;\n\tchar *path;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpath = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(path, &mystat))\n\t\t\tgoto next;\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\n\t\tcount += recursive_count_nrtasks(path);\nnext:\n\t\tfree(path);\n\t}\n\n\tpath = must_make_path(dirname, \"cgroup.procs\", NULL);\n\tret = lxc_count_file_lines(path);\n\tif (ret != -1)\n\t\tcount += ret;\n\tfree(path);\n\n\t(void) closedir(dir);\n\n\treturn count;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mystat.st_mode"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&mystat"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int recursive_count_nrtasks(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint count = 0, ret;\n\tchar *path;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpath = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(path, &mystat))\n\t\t\tgoto next;\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\n\t\tcount += recursive_count_nrtasks(path);\nnext:\n\t\tfree(path);\n\t}\n\n\tpath = must_make_path(dirname, \"cgroup.procs\", NULL);\n\tret = lxc_count_file_lines(path);\n\tif (ret != -1)\n\t\tcount += ret;\n\tfree(path);\n\n\t(void) closedir(dir);\n\n\treturn count;\n}"
  },
  {
    "function_name": "cgfsng_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1578-1650",
    "snippet": "static bool cgfsng_mount(void *hdata, const char *root, int type)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *tmpfspath = NULL;\n\tbool retval = false;\n\tint i;\n\n\tif ((type & LXC_AUTO_CGROUP_MASK) == 0)\n\t\treturn true;\n\n\tif (cgns_supported())\n\t\treturn true;\n\n\ttmpfspath = must_make_path(root, \"/sys/fs/cgroup\", NULL);\n\n\tif (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\n\t/* Mount tmpfs */\n\tif (safe_mount(\"cgroup_root\", tmpfspath, \"tmpfs\",\n\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n\t\t\t\"size=10240k,mode=755\",\n\t\t\troot) < 0)\n\t\tgoto  bad;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *controllerpath, *path2;\n\t\tstruct hierarchy *h = hierarchies[i];\n\t\tchar *controller = strrchr(h->mountpoint, '/');\n\t\tint r;\n\n\t\tif (!controller)\n\t\t\tcontinue;\n\t\tcontroller++;\n\t\tcontrollerpath = must_make_path(tmpfspath, controller, NULL);\n\t\tif (dir_exists(controllerpath)) {\n\t\t\tfree(controllerpath);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mkdir(controllerpath, 0755) < 0) {\n\t\t\tSYSERROR(\"Error creating cgroup path: %s\", controllerpath);\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (mount_cgroup_full(type, h, controllerpath, d->container_cgroup) < 0) {\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!cg_mount_needs_subdirs(type)) {\n\t\t\tfree(controllerpath);\n\t\t\tcontinue;\n\t\t}\n\t\tpath2 = must_make_path(controllerpath, h->base_cgroup, d->container_cgroup, NULL);\n\t\tif (mkdir_p(path2, 0755) < 0) {\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tr = do_secondstage_mounts_if_needed(type, h, controllerpath, path2,\n\t\t\t\t\t\t    d->container_cgroup);\n\t\tfree(controllerpath);\n\t\tfree(path2);\n\t\tif (r < 0)\n\t\t\tgoto bad;\n\t}\n\tretval = true;\n\nbad:\n\tfree(tmpfspath);\n\treturn retval;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmpfspath"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_secondstage_mounts_if_needed",
          "args": [
            "type",
            "h",
            "controllerpath",
            "path2",
            "d->container_cgroup"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "do_secondstage_mounts_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1545-1576",
          "snippet": "static int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "path2",
            "0755"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "controllerpath",
            "h->base_cgroup",
            "d->container_cgroup",
            "NULL"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cg_mount_needs_subdirs",
          "args": [
            "type"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "cg_mount_needs_subdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1533-1538",
          "snippet": "static bool cg_mount_needs_subdirs(int type)\n{\n\tif (type >= LXC_AUTO_CGROUP_FULL_RO)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cg_mount_needs_subdirs(int type)\n{\n\tif (type >= LXC_AUTO_CGROUP_FULL_RO)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount_cgroup_full",
          "args": [
            "type",
            "h",
            "controllerpath",
            "d->container_cgroup"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "mount_cgroup_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1498-1530",
          "snippet": "static int mount_cgroup_full(int type, struct hierarchy *h, char *dest,\n\t\t\t\t   char *container_cgroup)\n{\n\tif (type < LXC_AUTO_CGROUP_FULL_RO || type > LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\tif (mount(h->mountpoint, dest, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\tSYSERROR(\"Error bind-mounting %s cgroup onto %s\", h->mountpoint,\n\t\t\t dest);\n\t\treturn -1;\n\t}\n\tif (type != LXC_AUTO_CGROUP_FULL_RW) {\n\t\tunsigned long flags = MS_BIND | MS_NOSUID | MS_NOEXEC | MS_NODEV |\n\t\t\t\t      MS_REMOUNT | MS_RDONLY;\n\t\tif (mount(NULL, dest, \"cgroup\", flags, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s readonly\", dest);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Bind mounted %s onto %s\", h->mountpoint, dest);\n\tif (type != LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\n\t/* mount just the container path rw */\n\tchar *source = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tchar *rwpath = must_make_path(dest, h->base_cgroup, container_cgroup, NULL);\n\tif (mount(source, rwpath, \"cgroup\", MS_BIND, NULL) < 0)\n\t\tWARN(\"Failed to mount %s read-write: %m\", rwpath);\n\tINFO(\"Made %s read-write\", rwpath);\n\tfree(rwpath);\n\tfree(source);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int mount_cgroup_full(int type, struct hierarchy *h, char *dest,\n\t\t\t\t   char *container_cgroup)\n{\n\tif (type < LXC_AUTO_CGROUP_FULL_RO || type > LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\tif (mount(h->mountpoint, dest, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\tSYSERROR(\"Error bind-mounting %s cgroup onto %s\", h->mountpoint,\n\t\t\t dest);\n\t\treturn -1;\n\t}\n\tif (type != LXC_AUTO_CGROUP_FULL_RW) {\n\t\tunsigned long flags = MS_BIND | MS_NOSUID | MS_NOEXEC | MS_NODEV |\n\t\t\t\t      MS_REMOUNT | MS_RDONLY;\n\t\tif (mount(NULL, dest, \"cgroup\", flags, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s readonly\", dest);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Bind mounted %s onto %s\", h->mountpoint, dest);\n\tif (type != LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\n\t/* mount just the container path rw */\n\tchar *source = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tchar *rwpath = must_make_path(dest, h->base_cgroup, container_cgroup, NULL);\n\tif (mount(source, rwpath, \"cgroup\", MS_BIND, NULL) < 0)\n\t\tWARN(\"Failed to mount %s read-write: %m\", rwpath);\n\tINFO(\"Made %s read-write\", rwpath);\n\tfree(rwpath);\n\tfree(source);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error creating cgroup path: %s\"",
            "controllerpath"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "controllerpath"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "h->mountpoint",
            "'/'"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_mount",
          "args": [
            "\"cgroup_root\"",
            "tmpfspath",
            "\"tmpfs\"",
            "MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME",
            "\"size=10240k,mode=755\"",
            "root"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "safe_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1687-1743",
          "snippet": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>\n\tconst char *mntsrc = src;\n\n\tif (!rootfs)\n\t\trootfs = \"\";\n\n\t/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1) {\n\t\t\tsaved_errno = errno;\n\t\t\tclose(srcfd);\n\t\t\terrno = saved_errno;\n\t\t}\n\t\treturn destfd;\n\t}\n\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgns_supported",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "cgns_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1247-1250",
          "snippet": "bool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool cgns_supported(void)\n{\n\treturn file_exists(\"/proc/self/ns/cgroup\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool cgfsng_mount(void *hdata, const char *root, int type)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *tmpfspath = NULL;\n\tbool retval = false;\n\tint i;\n\n\tif ((type & LXC_AUTO_CGROUP_MASK) == 0)\n\t\treturn true;\n\n\tif (cgns_supported())\n\t\treturn true;\n\n\ttmpfspath = must_make_path(root, \"/sys/fs/cgroup\", NULL);\n\n\tif (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\n\t/* Mount tmpfs */\n\tif (safe_mount(\"cgroup_root\", tmpfspath, \"tmpfs\",\n\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n\t\t\t\"size=10240k,mode=755\",\n\t\t\troot) < 0)\n\t\tgoto  bad;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *controllerpath, *path2;\n\t\tstruct hierarchy *h = hierarchies[i];\n\t\tchar *controller = strrchr(h->mountpoint, '/');\n\t\tint r;\n\n\t\tif (!controller)\n\t\t\tcontinue;\n\t\tcontroller++;\n\t\tcontrollerpath = must_make_path(tmpfspath, controller, NULL);\n\t\tif (dir_exists(controllerpath)) {\n\t\t\tfree(controllerpath);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mkdir(controllerpath, 0755) < 0) {\n\t\t\tSYSERROR(\"Error creating cgroup path: %s\", controllerpath);\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (mount_cgroup_full(type, h, controllerpath, d->container_cgroup) < 0) {\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!cg_mount_needs_subdirs(type)) {\n\t\t\tfree(controllerpath);\n\t\t\tcontinue;\n\t\t}\n\t\tpath2 = must_make_path(controllerpath, h->base_cgroup, d->container_cgroup, NULL);\n\t\tif (mkdir_p(path2, 0755) < 0) {\n\t\t\tfree(controllerpath);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tr = do_secondstage_mounts_if_needed(type, h, controllerpath, path2,\n\t\t\t\t\t\t    d->container_cgroup);\n\t\tfree(controllerpath);\n\t\tfree(path2);\n\t\tif (r < 0)\n\t\t\tgoto bad;\n\t}\n\tretval = true;\n\nbad:\n\tfree(tmpfspath);\n\treturn retval;\n}"
  },
  {
    "function_name": "do_secondstage_mounts_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1545-1576",
    "snippet": "static int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Completed second stage cgroup automounts for %s\"",
            "cgpath"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sourcepath"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error mounting cgroup %s onto %s\"",
            "h->controllers[0]",
            "cgpath"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "sourcepath",
            "cgpath",
            "\"cgroup\"",
            "flags",
            "NULL"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "do_secondstage_mounts_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1545-1576",
          "snippet": "static int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Mounting %s onto %s\"",
            "sourcepath",
            "cgpath"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "h->mountpoint",
            "h->base_cgroup",
            "container_cgroup",
            "NULL"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Remounted %s read-only\"",
            "controllerpath"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error remounting %s read-only\"",
            "controllerpath"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error bind-mounting %s\"",
            "controllerpath"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}"
  },
  {
    "function_name": "cg_mount_needs_subdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1533-1538",
    "snippet": "static bool cg_mount_needs_subdirs(int type)\n{\n\tif (type >= LXC_AUTO_CGROUP_FULL_RO)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cg_mount_needs_subdirs(int type)\n{\n\tif (type >= LXC_AUTO_CGROUP_FULL_RO)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "mount_cgroup_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1498-1530",
    "snippet": "static int mount_cgroup_full(int type, struct hierarchy *h, char *dest,\n\t\t\t\t   char *container_cgroup)\n{\n\tif (type < LXC_AUTO_CGROUP_FULL_RO || type > LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\tif (mount(h->mountpoint, dest, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\tSYSERROR(\"Error bind-mounting %s cgroup onto %s\", h->mountpoint,\n\t\t\t dest);\n\t\treturn -1;\n\t}\n\tif (type != LXC_AUTO_CGROUP_FULL_RW) {\n\t\tunsigned long flags = MS_BIND | MS_NOSUID | MS_NOEXEC | MS_NODEV |\n\t\t\t\t      MS_REMOUNT | MS_RDONLY;\n\t\tif (mount(NULL, dest, \"cgroup\", flags, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s readonly\", dest);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Bind mounted %s onto %s\", h->mountpoint, dest);\n\tif (type != LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\n\t/* mount just the container path rw */\n\tchar *source = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tchar *rwpath = must_make_path(dest, h->base_cgroup, container_cgroup, NULL);\n\tif (mount(source, rwpath, \"cgroup\", MS_BIND, NULL) < 0)\n\t\tWARN(\"Failed to mount %s read-write: %m\", rwpath);\n\tINFO(\"Made %s read-write\", rwpath);\n\tfree(rwpath);\n\tfree(source);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "source"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Made %s read-write\"",
            "rwpath"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed to mount %s read-write: %m\"",
            "rwpath"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "source",
            "rwpath",
            "\"cgroup\"",
            "MS_BIND",
            "NULL"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "do_secondstage_mounts_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1545-1576",
          "snippet": "static int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int\ndo_secondstage_mounts_if_needed(int type, struct hierarchy *h,\n\t\t\t\tchar *controllerpath, char *cgpath,\n\t\t\t\tconst char *container_cgroup)\n{\n\tif (type == LXC_AUTO_CGROUP_RO || type == LXC_AUTO_CGROUP_MIXED) {\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\t\tSYSERROR(\"Error bind-mounting %s\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tif (mount(controllerpath, controllerpath, \"cgroup\",\n\t\t\t   MS_REMOUNT | MS_BIND | MS_RDONLY, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s read-only\", controllerpath);\n\t\t\treturn -1;\n\t\t}\n\t\tINFO(\"Remounted %s read-only\", controllerpath);\n\t}\n\tchar *sourcepath = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tint flags = MS_BIND;\n\tif (type == LXC_AUTO_CGROUP_RO)\n\t\tflags |= MS_RDONLY;\n\tINFO(\"Mounting %s onto %s\", sourcepath, cgpath);\n\tif (mount(sourcepath, cgpath, \"cgroup\", flags, NULL) < 0) {\n\t\tfree(sourcepath);\n\t\tSYSERROR(\"Error mounting cgroup %s onto %s\", h->controllers[0],\n\t\t\t\tcgpath);\n\t\treturn -1;\n\t}\n\tfree(sourcepath);\n\tINFO(\"Completed second stage cgroup automounts for %s\", cgpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "dest",
            "h->base_cgroup",
            "container_cgroup",
            "NULL"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"Bind mounted %s onto %s\"",
            "h->mountpoint",
            "dest"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error remounting %s readonly\"",
            "dest"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error bind-mounting %s cgroup onto %s\"",
            "h->mountpoint",
            "dest"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int mount_cgroup_full(int type, struct hierarchy *h, char *dest,\n\t\t\t\t   char *container_cgroup)\n{\n\tif (type < LXC_AUTO_CGROUP_FULL_RO || type > LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\tif (mount(h->mountpoint, dest, \"cgroup\", MS_BIND, NULL) < 0) {\n\t\tSYSERROR(\"Error bind-mounting %s cgroup onto %s\", h->mountpoint,\n\t\t\t dest);\n\t\treturn -1;\n\t}\n\tif (type != LXC_AUTO_CGROUP_FULL_RW) {\n\t\tunsigned long flags = MS_BIND | MS_NOSUID | MS_NOEXEC | MS_NODEV |\n\t\t\t\t      MS_REMOUNT | MS_RDONLY;\n\t\tif (mount(NULL, dest, \"cgroup\", flags, NULL) < 0) {\n\t\t\tSYSERROR(\"Error remounting %s readonly\", dest);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Bind mounted %s onto %s\", h->mountpoint, dest);\n\tif (type != LXC_AUTO_CGROUP_FULL_MIXED)\n\t\treturn 0;\n\n\t/* mount just the container path rw */\n\tchar *source = must_make_path(h->mountpoint, h->base_cgroup, container_cgroup, NULL);\n\tchar *rwpath = must_make_path(dest, h->base_cgroup, container_cgroup, NULL);\n\tif (mount(source, rwpath, \"cgroup\", MS_BIND, NULL) < 0)\n\t\tWARN(\"Failed to mount %s read-write: %m\", rwpath);\n\tINFO(\"Made %s read-write\", rwpath);\n\tfree(rwpath);\n\tfree(source);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgfsns_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1470-1490",
    "snippet": "static bool cgfsns_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tstruct chown_data wrap;\n\n\tif (!d)\n\t\treturn false;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\treturn true;\n\n\twrap.d = d;\n\twrap.origuid = geteuid();\n\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &wrap) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error requesting cgroup chown in new namespace\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "chown_cgroup_wrapper",
            "&wrap"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool cgfsns_chown(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tstruct chown_data wrap;\n\n\tif (!d)\n\t\treturn false;\n\n\tif (lxc_list_empty(&conf->id_map))\n\t\treturn true;\n\n\twrap.d = d;\n\twrap.origuid = geteuid();\n\n\tif (userns_exec_1(conf, chown_cgroup_wrapper, &wrap) < 0) {\n\t\tERROR(\"Error requesting cgroup chown in new namespace\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "chown_cgroup_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1417-1468",
    "snippet": "static int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tuid_t destuid;\n\tint i;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath, *path = hierarchies[i]->fullcgpath;\n\n\t\tif (chown(path, destuid, 0) < 0) {\n\t\t\tSYSERROR(\"Error chowning %s to %d\", path, (int) destuid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (chmod(path, 0775) < 0) {\n\t\t\tSYSERROR(\"Error chmoding %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Failures to chown these are inconvenient but not detrimental\n\t\t * We leave these owned by the container launcher, so that container\n\t\t * root can write to the files to attach.  We chmod them 664 so that\n\t\t * container systemd can write to the files (which systemd in wily\n\t\t * insists on doing)\n\t\t */\n\t\tfullpath = must_make_path(path, \"tasks\", NULL);\n\t\tif (chown(fullpath, destuid, 0) < 0 && errno != ENOENT)\n\t\t\tWARN(\"Failed chowning %s to %d: %m\", fullpath, (int) destuid);\n\t\tif (chmod(fullpath, 0664) < 0)\n\t\t\tWARN(\"Error chmoding %s: %m\", path);\n\t\tfree(fullpath);\n\n\t\tfullpath = must_make_path(path, \"cgroup.procs\", NULL);\n\t\tif (chown(fullpath, destuid, 0) < 0 && errno != ENOENT)\n\t\t\tWARN(\"Failed chowning %s to %d: %m\", fullpath, (int) destuid);\n\t\tif (chmod(fullpath, 0664) < 0)\n\t\t\tWARN(\"Error chmoding %s: %m\", path);\n\t\tfree(fullpath);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error chmoding %s: %m\"",
            "path"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fullpath",
            "0664"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed chowning %s to %d: %m\"",
            "fullpath",
            "(int) destuid"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "fullpath",
            "destuid",
            "0"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "do_chown_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgmanager.c",
          "lines": "357-430",
          "snippet": "static int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}",
          "includes": [
            "#include <nih/string.h>",
            "#include <nih/error.h>",
            "#include <nih/alloc.h>",
            "#include <cgmanager/cgmanager-client.h>",
            "#include <nih-dbus/dbus_connection.h>",
            "#include \"state.h\"",
            "#include \"start.h\"",
            "#include \"cgroup.h\"",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"list.h\"",
            "#include \"commands.h\"",
            "#include \"error.h\"",
            "#include \"bdev.h\"",
            "#include <poll.h>",
            "#include <net/if.h>",
            "#include <netinet/in.h>",
            "#include <sys/mount.h>",
            "#include <sys/inotify.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <grp.h>",
            "#include <pthread.h>",
            "#include <ctype.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <nih/string.h>\n#include <nih/error.h>\n#include <nih/alloc.h>\n#include <cgmanager/cgmanager-client.h>\n#include <nih-dbus/dbus_connection.h>\n#include \"state.h\"\n#include \"start.h\"\n#include \"cgroup.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"list.h\"\n#include \"commands.h\"\n#include \"error.h\"\n#include \"bdev.h\"\n#include <poll.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/mount.h>\n#include <sys/inotify.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <grp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_chown_cgroup(const char *controller, const char *cgroup_path,\n\t\tuid_t newuid)\n{\n\tint sv[2] = {-1, -1}, optval = 1, ret = -1;\n\tchar buf[1];\n\tstruct pollfd fds;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sv) < 0) {\n\t\tSYSERROR(\"Error creating socketpair\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[1], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif (setsockopt(sv[0], SOL_SOCKET, SO_PASSCRED, &optval, sizeof(optval)) == -1) {\n\t\tSYSERROR(\"setsockopt failed\");\n\t\tgoto out;\n\t}\n\tif ( cgmanager_chown_scm_sync(NULL, cgroup_manager, controller,\n\t\t\t\t       cgroup_path, sv[1]) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chown_scm_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\tgoto out;\n\t}\n\t/* now send credentials */\n\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), getuid(), getgid())) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (read(sv[0], &buf, 1) != 1) {\n\t\tERROR(\"Error getting reply from server over socketpair\");\n\t\tgoto out;\n\t}\n\tif (send_creds(sv[0], getpid(), newuid, 0)) {\n\t\tSYSERROR(\"%s: Error sending pid over SCM_CREDENTIAL\", __func__);\n\t\tgoto out;\n\t}\n\tfds.fd = sv[0];\n\tfds.events = POLLIN;\n\tfds.revents = 0;\n\tif (poll(&fds, 1, -1) <= 0) {\n\t\tERROR(\"Error getting go-ahead from server: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tret = read(sv[0], buf, 1);\nout:\n\tclose(sv[0]);\n\tclose(sv[1]);\n\tif (ret == 1 && *buf == '1')\n\t\treturn 0;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "path",
            "\"cgroup.procs\"",
            "NULL"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Error chmoding %s: %m\"",
            "path"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "fullpath",
            "0664"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Failed chowning %s to %d: %m\"",
            "fullpath",
            "(int) destuid"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chmoding %s\"",
            "path"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "path",
            "0775"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error chowning %s to %d\"",
            "path",
            "(int) destuid"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ns_uid",
          "args": [
            "arg->origuid"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "get_ns_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1034-1057",
          "snippet": "uid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nuid_t get_ns_uid(uid_t orig)\n{\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tuid_t nsid, hostid, range;\n\tFILE *f = fopen(\"/proc/self/uid_map\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\n\twhile (getline(&line, &sz, f) != -1) {\n\t\tif (sscanf(line, \"%u %u %u\", &nsid, &hostid, &range) != 3)\n\t\t\tcontinue;\n\t\tif (hostid <= orig && hostid + range > orig) {\n\t\t\tnsid += orig - hostid;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tnsid = 0;\nfound:\n\tfclose(f);\n\tfree(line);\n\treturn nsid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic int chown_cgroup_wrapper(void *data)\n{\n\tstruct chown_data *arg = data;\n\tuid_t destuid;\n\tint i;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\tdestuid = get_ns_uid(arg->origuid);\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath, *path = hierarchies[i]->fullcgpath;\n\n\t\tif (chown(path, destuid, 0) < 0) {\n\t\t\tSYSERROR(\"Error chowning %s to %d\", path, (int) destuid);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (chmod(path, 0775) < 0) {\n\t\t\tSYSERROR(\"Error chmoding %s\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Failures to chown these are inconvenient but not detrimental\n\t\t * We leave these owned by the container launcher, so that container\n\t\t * root can write to the files to attach.  We chmod them 664 so that\n\t\t * container systemd can write to the files (which systemd in wily\n\t\t * insists on doing)\n\t\t */\n\t\tfullpath = must_make_path(path, \"tasks\", NULL);\n\t\tif (chown(fullpath, destuid, 0) < 0 && errno != ENOENT)\n\t\t\tWARN(\"Failed chowning %s to %d: %m\", fullpath, (int) destuid);\n\t\tif (chmod(fullpath, 0664) < 0)\n\t\t\tWARN(\"Error chmoding %s: %m\", path);\n\t\tfree(fullpath);\n\n\t\tfullpath = must_make_path(path, \"cgroup.procs\", NULL);\n\t\tif (chown(fullpath, destuid, 0) < 0 && errno != ENOENT)\n\t\t\tWARN(\"Failed chowning %s to %d: %m\", fullpath, (int) destuid);\n\t\tif (chmod(fullpath, 0664) < 0)\n\t\t\tWARN(\"Error chmoding %s: %m\", path);\n\t\tfree(fullpath);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgfsng_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1381-1402",
    "snippet": "static bool cgfsng_enter(void *hdata, pid_t pid)\n{\n\tchar pidstr[25];\n\tint i, len;\n\n\tlen = snprintf(pidstr, 25, \"%d\", pid);\n\tif (len < 0 || len > 25)\n\t\treturn false;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath = must_make_path(hierarchies[i]->fullcgpath,\n\t\t\t\t\t\t\"cgroup.procs\", NULL);\n\t\tif (lxc_write_to_file(fullpath, pidstr, len, false) != 0) {\n\t\t\tSYSERROR(\"Failed to enter %s\", fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to enter %s\"",
            "fullpath"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fullpath",
            "pidstr",
            "len",
            "false"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "hierarchies[i]->fullcgpath",
            "\"cgroup.procs\"",
            "NULL"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pidstr",
            "25",
            "\"%d\"",
            "pid"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool cgfsng_enter(void *hdata, pid_t pid)\n{\n\tchar pidstr[25];\n\tint i, len;\n\n\tlen = snprintf(pidstr, 25, \"%d\", pid);\n\tif (len < 0 || len > 25)\n\t\treturn false;\n\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tchar *fullpath = must_make_path(hierarchies[i]->fullcgpath,\n\t\t\t\t\t\t\"cgroup.procs\", NULL);\n\t\tif (lxc_write_to_file(fullpath, pidstr, len, false) != 0) {\n\t\t\tSYSERROR(\"Failed to enter %s\", fullpath);\n\t\t\tfree(fullpath);\n\t\t\treturn false;\n\t\t}\n\t\tfree(fullpath);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgfsng_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1328-1379",
    "snippet": "static inline bool cgfsng_create(void *hdata)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *tmp, *cgname, *offset;\n\tint i, idx = 0;\n\tsize_t len;\n\n\tif (!d)\n\t\treturn false;\n\tif (d->container_cgroup) {\n\t\tWARN(\"cgfsng_create called a second time\");\n\t\treturn false;\n\t}\n\n\ttmp = lxc_string_replace(\"%n\", d->name, d->cgroup_pattern);\n\tif (!tmp) {\n\t\tERROR(\"Failed expanding cgroup name pattern\");\n\t\treturn false;\n\t}\n\tlen = strlen(tmp) + 5; // leave room for -NNN\\0\n\tcgname = must_alloc(len);\n\tstrcpy(cgname, tmp);\n\tfree(tmp);\n\toffset = cgname + len - 5;\n\nagain:\n\tif (idx == 1000) {\n\t\tERROR(\"Too many conflicting cgroup names\");\n\t\tgoto out_free;\n\t}\n\tif (idx)\n\t\tsnprintf(offset, 5, \"-%d\", idx);\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (!create_path_for_hierarchy(hierarchies[i], cgname)) {\n\t\t\tint j;\n\t\t\tSYSERROR(\"Failed to create %s: %s\", hierarchies[i]->fullcgpath, strerror(errno));\n\t\t\tfree(hierarchies[i]->fullcgpath);\n\t\t\thierarchies[i]->fullcgpath = NULL;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tremove_path_for_hierarchy(hierarchies[j], cgname);\n\t\t\tidx++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\t/* Done */\n\td->container_cgroup = cgname;\n\treturn true;\n\nout_free:\n\tfree(cgname);\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cgname"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_path_for_hierarchy",
          "args": [
            "hierarchies[j]",
            "cgname"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "remove_path_for_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1316-1322",
          "snippet": "static void remove_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tif (rmdir(h->fullcgpath) < 0)\n\t\tSYSERROR(\"Failed to clean up cgroup %s from failed creation attempt\", h->fullcgpath);\n\tfree(h->fullcgpath);\n\th->fullcgpath = NULL;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void remove_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tif (rmdir(h->fullcgpath) < 0)\n\t\tSYSERROR(\"Failed to clean up cgroup %s from failed creation attempt\", h->fullcgpath);\n\tfree(h->fullcgpath);\n\th->fullcgpath = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create %s: %s\"",
            "hierarchies[i]->fullcgpath",
            "strerror(errno)"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_path_for_hierarchy",
          "args": [
            "hierarchies[i]",
            "cgname"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "create_path_for_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1302-1314",
          "snippet": "static bool create_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\th->fullcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (dir_exists(h->fullcgpath)) { // it must not already exist\n\t\tERROR(\"Path \\\"%s\\\" already existed.\", h->fullcgpath);\n\t\treturn false;\n\t}\n\tif (!handle_cpuset_hierarchy(h, cgname)) {\n\t\tERROR(\"Failed to handle cgroupfs v1 cpuset controller.\");\n\t\treturn false;\n\t}\n\treturn mkdir_p(h->fullcgpath, 0755) == 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool create_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\th->fullcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (dir_exists(h->fullcgpath)) { // it must not already exist\n\t\tERROR(\"Path \\\"%s\\\" already existed.\", h->fullcgpath);\n\t\treturn false;\n\t}\n\tif (!handle_cpuset_hierarchy(h, cgname)) {\n\t\tERROR(\"Failed to handle cgroupfs v1 cpuset controller.\");\n\t\treturn false;\n\t}\n\treturn mkdir_p(h->fullcgpath, 0755) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "offset",
            "5",
            "\"-%d\"",
            "idx"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Too many conflicting cgroup names\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "cgname",
            "tmp"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "len"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed expanding cgroup name pattern\""
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"%n\"",
            "d->name",
            "d->cgroup_pattern"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"cgfsng_create called a second time\""
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic inline bool cgfsng_create(void *hdata)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\tchar *tmp, *cgname, *offset;\n\tint i, idx = 0;\n\tsize_t len;\n\n\tif (!d)\n\t\treturn false;\n\tif (d->container_cgroup) {\n\t\tWARN(\"cgfsng_create called a second time\");\n\t\treturn false;\n\t}\n\n\ttmp = lxc_string_replace(\"%n\", d->name, d->cgroup_pattern);\n\tif (!tmp) {\n\t\tERROR(\"Failed expanding cgroup name pattern\");\n\t\treturn false;\n\t}\n\tlen = strlen(tmp) + 5; // leave room for -NNN\\0\n\tcgname = must_alloc(len);\n\tstrcpy(cgname, tmp);\n\tfree(tmp);\n\toffset = cgname + len - 5;\n\nagain:\n\tif (idx == 1000) {\n\t\tERROR(\"Too many conflicting cgroup names\");\n\t\tgoto out_free;\n\t}\n\tif (idx)\n\t\tsnprintf(offset, 5, \"-%d\", idx);\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (!create_path_for_hierarchy(hierarchies[i], cgname)) {\n\t\t\tint j;\n\t\t\tSYSERROR(\"Failed to create %s: %s\", hierarchies[i]->fullcgpath, strerror(errno));\n\t\t\tfree(hierarchies[i]->fullcgpath);\n\t\t\thierarchies[i]->fullcgpath = NULL;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tremove_path_for_hierarchy(hierarchies[j], cgname);\n\t\t\tidx++;\n\t\t\tgoto again;\n\t\t}\n\t}\n\t/* Done */\n\td->container_cgroup = cgname;\n\treturn true;\n\nout_free:\n\tfree(cgname);\n\treturn false;\n}"
  },
  {
    "function_name": "remove_path_for_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1316-1322",
    "snippet": "static void remove_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tif (rmdir(h->fullcgpath) < 0)\n\t\tSYSERROR(\"Failed to clean up cgroup %s from failed creation attempt\", h->fullcgpath);\n\tfree(h->fullcgpath);\n\th->fullcgpath = NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "h->fullcgpath"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clean up cgroup %s from failed creation attempt\"",
            "h->fullcgpath"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "h->fullcgpath"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1247-1259",
          "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void remove_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tif (rmdir(h->fullcgpath) < 0)\n\t\tSYSERROR(\"Failed to clean up cgroup %s from failed creation attempt\", h->fullcgpath);\n\tfree(h->fullcgpath);\n\th->fullcgpath = NULL;\n}"
  },
  {
    "function_name": "create_path_for_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1302-1314",
    "snippet": "static bool create_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\th->fullcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (dir_exists(h->fullcgpath)) { // it must not already exist\n\t\tERROR(\"Path \\\"%s\\\" already existed.\", h->fullcgpath);\n\t\treturn false;\n\t}\n\tif (!handle_cpuset_hierarchy(h, cgname)) {\n\t\tERROR(\"Failed to handle cgroupfs v1 cpuset controller.\");\n\t\treturn false;\n\t}\n\treturn mkdir_p(h->fullcgpath, 0755) == 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "h->fullcgpath",
            "0755"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to handle cgroupfs v1 cpuset controller.\""
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_cpuset_hierarchy",
          "args": [
            "h",
            "cgname"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cpuset_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "600-667",
          "snippet": "static bool handle_cpuset_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tchar *cgpath, *clonechildrenpath, v, *slash;\n\n\tif (!string_in_list(h->controllers, \"cpuset\"))\n\t\treturn true;\n\n\tif (*cgname == '/')\n\t\tcgname++;\n\tslash = strchr(cgname, '/');\n\tif (slash)\n\t\t*slash = '\\0';\n\n\tcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (slash)\n\t\t*slash = '/';\n\tif (mkdir(cgpath, 0755) < 0 && errno != EEXIST) {\n\t\tSYSERROR(\"Failed to create '%s'\", cgpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tclonechildrenpath = must_make_path(cgpath, \"cgroup.clone_children\", NULL);\n\tif (!file_exists(clonechildrenpath)) { /* unified hierarchy doesn't have clone_children */\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\tif (lxc_read_from_file(clonechildrenpath, &v, 1) < 0) {\n\t\tSYSERROR(\"Failed to read '%s'\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\t/* Make sure any isolated cpus are removed from cpuset.cpus. */\n\tif (!filter_and_set_cpus(cgpath, v == '1')) {\n\t\tSYSERROR(\"Failed to remove isolated cpus.\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tif (v == '1') {  /* already set for us by someone else */\n\t\tDEBUG(\"\\\"cgroup.clone_children\\\" was already set to \\\"1\\\".\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\n\t/* copy parent's settings */\n\tif (!copy_parent_file(cgpath, \"cpuset.mems\")) {\n\t\tSYSERROR(\"Failed to copy \\\"cpuset.mems\\\" settings.\");\n\t\tfree(cgpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(cgpath);\n\n\tif (lxc_write_to_file(clonechildrenpath, \"1\", 1, false) < 0) {\n\t\t/* Set clone_children so children inherit our settings */\n\t\tSYSERROR(\"Failed to write 1 to %s\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(clonechildrenpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool handle_cpuset_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tchar *cgpath, *clonechildrenpath, v, *slash;\n\n\tif (!string_in_list(h->controllers, \"cpuset\"))\n\t\treturn true;\n\n\tif (*cgname == '/')\n\t\tcgname++;\n\tslash = strchr(cgname, '/');\n\tif (slash)\n\t\t*slash = '\\0';\n\n\tcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (slash)\n\t\t*slash = '/';\n\tif (mkdir(cgpath, 0755) < 0 && errno != EEXIST) {\n\t\tSYSERROR(\"Failed to create '%s'\", cgpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tclonechildrenpath = must_make_path(cgpath, \"cgroup.clone_children\", NULL);\n\tif (!file_exists(clonechildrenpath)) { /* unified hierarchy doesn't have clone_children */\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\tif (lxc_read_from_file(clonechildrenpath, &v, 1) < 0) {\n\t\tSYSERROR(\"Failed to read '%s'\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\t/* Make sure any isolated cpus are removed from cpuset.cpus. */\n\tif (!filter_and_set_cpus(cgpath, v == '1')) {\n\t\tSYSERROR(\"Failed to remove isolated cpus.\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tif (v == '1') {  /* already set for us by someone else */\n\t\tDEBUG(\"\\\"cgroup.clone_children\\\" was already set to \\\"1\\\".\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\n\t/* copy parent's settings */\n\tif (!copy_parent_file(cgpath, \"cpuset.mems\")) {\n\t\tSYSERROR(\"Failed to copy \\\"cpuset.mems\\\" settings.\");\n\t\tfree(cgpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(cgpath);\n\n\tif (lxc_write_to_file(clonechildrenpath, \"1\", 1, false) < 0) {\n\t\t/* Set clone_children so children inherit our settings */\n\t\tSYSERROR(\"Failed to write 1 to %s\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(clonechildrenpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Path \\\"%s\\\" already existed.\"",
            "h->fullcgpath"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "h->fullcgpath"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "h->mountpoint",
            "h->base_cgroup",
            "cgname",
            "NULL"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool create_path_for_hierarchy(struct hierarchy *h, char *cgname)\n{\n\th->fullcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (dir_exists(h->fullcgpath)) { // it must not already exist\n\t\tERROR(\"Path \\\"%s\\\" already existed.\", h->fullcgpath);\n\t\treturn false;\n\t}\n\tif (!handle_cpuset_hierarchy(h, cgname)) {\n\t\tERROR(\"Failed to handle cgroupfs v1 cpuset controller.\");\n\t\treturn false;\n\t}\n\treturn mkdir_p(h->fullcgpath, 0755) == 0;\n}"
  },
  {
    "function_name": "cgfsng_ops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1295-1300",
    "snippet": "struct cgroup_ops *cgfsng_ops_init(void)\n{\n\tif (!collect_hierarchy_info())\n\t\treturn NULL;\n\treturn &cgfsng_ops;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_ops cgfsng_ops;",
      "static struct cgroup_ops cgfsng_ops = {\n\t.init = cgfsng_init,\n\t.destroy = cgfsng_destroy,\n\t.create = cgfsng_create,\n\t.enter = cgfsng_enter,\n\t.escape = cgfsng_escape,\n\t.num_hierarchies = cgfsng_num_hierarchies,\n\t.get_hierarchies = cgfsng_get_hierarchies,\n\t.get_cgroup = cgfsng_get_cgroup,\n\t.get = cgfsng_get,\n\t.set = cgfsng_set,\n\t.unfreeze = cgfsng_unfreeze,\n\t.setup_limits = cgfsng_setup_limits,\n\t.name = \"cgroupfs-ng\",\n\t.attach = cgfsng_attach,\n\t.chown = cgfsns_chown,\n\t.mount_cgroup = cgfsng_mount,\n\t.nrtasks = cgfsng_nrtasks,\n\t.driver = CGFSNG,\n\n\t/* unsupported */\n\t.create_legacy = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_hierarchy_info",
          "args": [],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "collect_hierarchy_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1128-1140",
          "snippet": "static bool collect_hierarchy_info(void)\n{\n\tconst char *tmp;\n\terrno = 0;\n\ttmp = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0) { // lxc.cgroup.use can be NULL\n\t\tSYSERROR(\"cgfsng: error reading list of cgroups to use\");\n\t\treturn false;\n\t}\n\tcgroup_use = must_copy_string(tmp);\n\n\treturn parse_hierarchies();\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *cgroup_use;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nchar *cgroup_use;\n\nstatic bool collect_hierarchy_info(void)\n{\n\tconst char *tmp;\n\terrno = 0;\n\ttmp = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0) { // lxc.cgroup.use can be NULL\n\t\tSYSERROR(\"cgfsng: error reading list of cgroups to use\");\n\t\treturn false;\n\t}\n\tcgroup_use = must_copy_string(tmp);\n\n\treturn parse_hierarchies();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic struct cgroup_ops cgfsng_ops;\nstatic struct cgroup_ops cgfsng_ops = {\n\t.init = cgfsng_init,\n\t.destroy = cgfsng_destroy,\n\t.create = cgfsng_create,\n\t.enter = cgfsng_enter,\n\t.escape = cgfsng_escape,\n\t.num_hierarchies = cgfsng_num_hierarchies,\n\t.get_hierarchies = cgfsng_get_hierarchies,\n\t.get_cgroup = cgfsng_get_cgroup,\n\t.get = cgfsng_get,\n\t.set = cgfsng_set,\n\t.unfreeze = cgfsng_unfreeze,\n\t.setup_limits = cgfsng_setup_limits,\n\t.name = \"cgroupfs-ng\",\n\t.attach = cgfsng_attach,\n\t.chown = cgfsns_chown,\n\t.mount_cgroup = cgfsng_mount,\n\t.nrtasks = cgfsng_nrtasks,\n\t.driver = CGFSNG,\n\n\t/* unsupported */\n\t.create_legacy = NULL,\n};\n\nstruct cgroup_ops *cgfsng_ops_init(void)\n{\n\tif (!collect_hierarchy_info())\n\t\treturn NULL;\n\treturn &cgfsng_ops;\n}"
  },
  {
    "function_name": "cgfsng_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1273-1293",
    "snippet": "static void cgfsng_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\n\tif (!d)\n\t\treturn;\n\n\tif (d->container_cgroup && hierarchies) {\n\t\tint i;\n\t\tfor (i = 0; hierarchies[i]; i++) {\n\t\t\tstruct hierarchy *h = hierarchies[i];\n\t\t\tif (h->fullcgpath) {\n\t\t\t\trecursive_destroy(h->fullcgpath, conf);\n\t\t\t\tfree(h->fullcgpath);\n\t\t\t\th->fullcgpath = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_handler_data(d);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_handler_data",
          "args": [
            "d"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "free_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "231-237",
          "snippet": "static void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "h->fullcgpath"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recursive_destroy",
          "args": [
            "h->fullcgpath",
            "conf"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "recursive_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1261-1271",
          "snippet": "void recursive_destroy(char *path, struct lxc_conf *conf)\n{\n\tint r;\n\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\tr = userns_exec_1(conf, rmdir_wrapper, path);\n\telse\n\t\tr = cgroup_rmdir(path);\n\n\tif (r < 0)\n\t\tERROR(\"Error destroying %s\", path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nvoid recursive_destroy(char *path, struct lxc_conf *conf)\n{\n\tint r;\n\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\tr = userns_exec_1(conf, rmdir_wrapper, path);\n\telse\n\t\tr = cgroup_rmdir(path);\n\n\tif (r < 0)\n\t\tERROR(\"Error destroying %s\", path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic void cgfsng_destroy(void *hdata, struct lxc_conf *conf)\n{\n\tstruct cgfsng_handler_data *d = hdata;\n\n\tif (!d)\n\t\treturn;\n\n\tif (d->container_cgroup && hierarchies) {\n\t\tint i;\n\t\tfor (i = 0; hierarchies[i]; i++) {\n\t\t\tstruct hierarchy *h = hierarchies[i];\n\t\t\tif (h->fullcgpath) {\n\t\t\t\trecursive_destroy(h->fullcgpath, conf);\n\t\t\t\tfree(h->fullcgpath);\n\t\t\t\th->fullcgpath = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_handler_data(d);\n}"
  },
  {
    "function_name": "recursive_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1261-1271",
    "snippet": "void recursive_destroy(char *path, struct lxc_conf *conf)\n{\n\tint r;\n\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\tr = userns_exec_1(conf, rmdir_wrapper, path);\n\telse\n\t\tr = cgroup_rmdir(path);\n\n\tif (r < 0)\n\t\tERROR(\"Error destroying %s\", path);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error destroying %s\"",
            "path"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "path"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1195-1245",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_exec_1",
          "args": [
            "conf",
            "rmdir_wrapper",
            "path"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "userns_exec_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "4435-4487",
          "snippet": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\t// kick the child\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&conf->id_map"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nvoid recursive_destroy(char *path, struct lxc_conf *conf)\n{\n\tint r;\n\tif (conf && !lxc_list_empty(&conf->id_map))\n\t\tr = userns_exec_1(conf, rmdir_wrapper, path);\n\telse\n\t\tr = cgroup_rmdir(path);\n\n\tif (r < 0)\n\t\tERROR(\"Error destroying %s\", path);\n}"
  },
  {
    "function_name": "rmdir_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1247-1259",
    "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "path"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1195-1245",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to clear groups\""
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setuid to 0\""
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to setgid to 0\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "0",
            "0",
            "0"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
  },
  {
    "function_name": "cgroup_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1195-1245",
    "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"%s: failed to delete %s: %m\"",
            "__func__",
            "dirname"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"%s: failed to delete %s: %m\"",
            "__func__",
            "dirname"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "dirname"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "rmdir_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1247-1259",
          "snippet": "static int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int rmdir_wrapper(void *data)\n{\n\tchar *path = data;\n\n\tif (setresgid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setgid to 0\");\n\tif (setresuid(0,0,0) < 0)\n\t\tSYSERROR(\"Failed to setuid to 0\");\n\tif (setgroups(0, NULL) < 0)\n\t\tSYSERROR(\"Failed to clear groups\");\n\n\treturn cgroup_rmdir(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pathname"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rmdir",
          "args": [
            "pathname"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1195-1245",
          "snippet": "static int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mystat.st_mode"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"failed to stat %s\"",
            "pathname"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "pathname",
            "&mystat"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "dirname",
            "direntp->d_name",
            "NULL"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\"..\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntp->d_name",
            "\".\""
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dirname"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int cgroup_rmdir(char *dirname)\n{\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\n\twhile ((direntp = readdir(dir))) {\n\t\tstruct stat mystat;\n\t\tchar *pathname;\n\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\n\t\tif (lstat(pathname, &mystat)) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"failed to stat %s\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tif (cgroup_rmdir(pathname) < 0)\n\t\t\tr = -1;\nnext:\n\t\tfree(pathname);\n\t}\n\n\tif (rmdir(dirname) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\n\tif (closedir(dir) < 0) {\n\t\tif (!r)\n\t\t\tWARN(\"%s: failed to delete %s: %m\", __func__, dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "must_make_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1172-1193",
    "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dest",
            "cur"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dest",
            "\"/\""
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_realloc",
          "args": [
            "dest",
            "full_len + 1"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cur"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "char*"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_va_arg_list_to_argv_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "464-467",
          "snippet": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nconst char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "first"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_copy_string",
          "args": [
            "first"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "must_copy_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "133-143",
          "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "first"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
  },
  {
    "function_name": "cgfsng_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1142-1166",
    "snippet": "static void *cgfsng_init(const char *name)\n{\n\tstruct cgfsng_handler_data *d;\n\tconst char *cgroup_pattern;\n\n\td = must_alloc(sizeof(*d));\n\tmemset(d, 0, sizeof(*d));\n\n\td->name = must_copy_string(name);\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\tif (!cgroup_pattern) { // lxc.cgroup.pattern is only NULL on error\n\t\tERROR(\"Error getting cgroup pattern\");\n\t\tgoto out_free;\n\t}\n\td->cgroup_pattern = must_copy_string(cgroup_pattern);\n\n\tprint_init_debuginfo(d);\n\n\treturn d;\n\nout_free:\n\tfree_handler_data(d);\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_handler_data",
          "args": [
            "d"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "free_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "231-237",
          "snippet": "static void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_init_debuginfo",
          "args": [
            "d"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "print_init_debuginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "993-1020",
          "snippet": "static void print_init_debuginfo(struct cgfsng_handler_data *d)\n{\n\tstruct hierarchy **it;\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name ? d->name : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.use: %s\", cgroup_use ? cgroup_use : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.pattern: %s\", d->cgroup_pattern ? d->cgroup_pattern : \"(null)\");\n\tDEBUG(\"  cgroup: %s\", d->container_cgroup ? d->container_cgroup : \"(null)\");\n\tif (!hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Hierarchies:\");\n\tfor (i = 0, it = hierarchies; it && *it; it++, i++) {\n\t\tchar **cit;\n\t\tint j;\n\t\tDEBUG(\"  %d: base_cgroup %s\", i, (*it)->base_cgroup ? (*it)->base_cgroup : \"(null)\");\n\t\tDEBUG(\"      mountpoint %s\", (*it)->mountpoint ? (*it)->mountpoint : \"(null)\");\n\t\tDEBUG(\"      controllers:\");\n\t\tfor (j = 0, cit = (*it)->controllers; cit && *cit; cit++, j++)\n\t\t\tDEBUG(\"      %d: %s\", j, *cit);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;",
            "char *cgroup_use;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\nchar *cgroup_use;\n\nstatic void print_init_debuginfo(struct cgfsng_handler_data *d)\n{\n\tstruct hierarchy **it;\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name ? d->name : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.use: %s\", cgroup_use ? cgroup_use : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.pattern: %s\", d->cgroup_pattern ? d->cgroup_pattern : \"(null)\");\n\tDEBUG(\"  cgroup: %s\", d->container_cgroup ? d->container_cgroup : \"(null)\");\n\tif (!hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Hierarchies:\");\n\tfor (i = 0, it = hierarchies; it && *it; it++, i++) {\n\t\tchar **cit;\n\t\tint j;\n\t\tDEBUG(\"  %d: base_cgroup %s\", i, (*it)->base_cgroup ? (*it)->base_cgroup : \"(null)\");\n\t\tDEBUG(\"      mountpoint %s\", (*it)->mountpoint ? (*it)->mountpoint : \"(null)\");\n\t\tDEBUG(\"      controllers:\");\n\t\tfor (j = 0, cit = (*it)->controllers; cit && *cit; cit++, j++)\n\t\t\tDEBUG(\"      %d: %s\", j, *cit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_copy_string",
          "args": [
            "cgroup_pattern"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "must_copy_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "133-143",
          "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting cgroup pattern\""
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.pattern\""
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(*d)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "sizeof(*d)"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *cgfsng_init(const char *name)\n{\n\tstruct cgfsng_handler_data *d;\n\tconst char *cgroup_pattern;\n\n\td = must_alloc(sizeof(*d));\n\tmemset(d, 0, sizeof(*d));\n\n\td->name = must_copy_string(name);\n\n\tcgroup_pattern = lxc_global_config_value(\"lxc.cgroup.pattern\");\n\tif (!cgroup_pattern) { // lxc.cgroup.pattern is only NULL on error\n\t\tERROR(\"Error getting cgroup pattern\");\n\t\tgoto out_free;\n\t}\n\td->cgroup_pattern = must_copy_string(cgroup_pattern);\n\n\tprint_init_debuginfo(d);\n\n\treturn d;\n\nout_free:\n\tfree_handler_data(d);\n\treturn NULL;\n}"
  },
  {
    "function_name": "collect_hierarchy_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1128-1140",
    "snippet": "static bool collect_hierarchy_info(void)\n{\n\tconst char *tmp;\n\terrno = 0;\n\ttmp = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0) { // lxc.cgroup.use can be NULL\n\t\tSYSERROR(\"cgfsng: error reading list of cgroups to use\");\n\t\treturn false;\n\t}\n\tcgroup_use = must_copy_string(tmp);\n\n\treturn parse_hierarchies();\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *cgroup_use;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_hierarchies",
          "args": [],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "parse_hierarchies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1042-1126",
          "snippet": "static bool parse_hierarchies(void)\n{\n\tFILE *f;\n\tchar * line = NULL, *basecginfo;\n\tchar **klist = NULL, **nlist = NULL;\n\tsize_t len = 0;\n\n\t/*\n\t * Root spawned containers escape the current cgroup, so use init's\n\t * cgroups as our base in that case.\n\t */\n\tif (geteuid())\n\t\tbasecginfo = read_file(\"/proc/self/cgroup\");\n\telse\n\t\tbasecginfo = read_file(\"/proc/1/cgroup\");\n\tif (!basecginfo)\n\t\treturn false;\n\n\tif ((f = fopen(\"/proc/self/mountinfo\", \"r\")) == NULL) {\n\t\tSYSERROR(\"Failed opening /proc/self/mountinfo\");\n\t\treturn false;\n\t}\n\n\tget_existing_subsystems(&klist, &nlist);\n\n\tprint_basecg_debuginfo(basecginfo, klist, nlist);\n\n\t/* we support simple cgroup mounts and lxcfs mounts */\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar **controller_list = NULL;\n\t\tchar *mountpoint, *base_cgroup;\n\n\t\tif (!is_lxcfs(line) && !is_cgroupfs(line))\n\t\t\tcontinue;\n\n\t\tcontroller_list = get_controllers(klist, nlist, line);\n\t\tif (!controller_list)\n\t\t\tcontinue;\n\n\t\tif (controller_list_is_dup(hierarchies, controller_list)) {\n\t\t\tfree(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmountpoint = get_mountpoint(line);\n\t\tif (!mountpoint) {\n\t\t\tERROR(\"Error reading mountinfo: bad line '%s'\", line);\n\t\t\tfree_string_list(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase_cgroup = get_current_cgroup(basecginfo, controller_list[0]);\n\t\tif (!base_cgroup) {\n\t\t\tERROR(\"Failed to find current cgroup for controller '%s'\", controller_list[0]);\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tcontinue;\n\t\t}\n\t\ttrim(base_cgroup);\n\t\tprune_init_scope(base_cgroup);\n\t\tif (!test_writeable(mountpoint, base_cgroup)) {\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tfree(base_cgroup);\n\t\t\tcontinue;\n\t\t}\n\t\tadd_controller(controller_list, mountpoint, base_cgroup);\n\t}\n\n\tfree_string_list(klist);\n\tfree_string_list(nlist);\n\n\tfree(basecginfo);\n\n\tfclose(f);\n\tfree(line);\n\n\t/* verify that all controllers in cgroup.use and all crucial\n\t * controllers are accounted for\n\t */\n\tif (!all_controllers_found())\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool parse_hierarchies(void)\n{\n\tFILE *f;\n\tchar * line = NULL, *basecginfo;\n\tchar **klist = NULL, **nlist = NULL;\n\tsize_t len = 0;\n\n\t/*\n\t * Root spawned containers escape the current cgroup, so use init's\n\t * cgroups as our base in that case.\n\t */\n\tif (geteuid())\n\t\tbasecginfo = read_file(\"/proc/self/cgroup\");\n\telse\n\t\tbasecginfo = read_file(\"/proc/1/cgroup\");\n\tif (!basecginfo)\n\t\treturn false;\n\n\tif ((f = fopen(\"/proc/self/mountinfo\", \"r\")) == NULL) {\n\t\tSYSERROR(\"Failed opening /proc/self/mountinfo\");\n\t\treturn false;\n\t}\n\n\tget_existing_subsystems(&klist, &nlist);\n\n\tprint_basecg_debuginfo(basecginfo, klist, nlist);\n\n\t/* we support simple cgroup mounts and lxcfs mounts */\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar **controller_list = NULL;\n\t\tchar *mountpoint, *base_cgroup;\n\n\t\tif (!is_lxcfs(line) && !is_cgroupfs(line))\n\t\t\tcontinue;\n\n\t\tcontroller_list = get_controllers(klist, nlist, line);\n\t\tif (!controller_list)\n\t\t\tcontinue;\n\n\t\tif (controller_list_is_dup(hierarchies, controller_list)) {\n\t\t\tfree(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmountpoint = get_mountpoint(line);\n\t\tif (!mountpoint) {\n\t\t\tERROR(\"Error reading mountinfo: bad line '%s'\", line);\n\t\t\tfree_string_list(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase_cgroup = get_current_cgroup(basecginfo, controller_list[0]);\n\t\tif (!base_cgroup) {\n\t\t\tERROR(\"Failed to find current cgroup for controller '%s'\", controller_list[0]);\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tcontinue;\n\t\t}\n\t\ttrim(base_cgroup);\n\t\tprune_init_scope(base_cgroup);\n\t\tif (!test_writeable(mountpoint, base_cgroup)) {\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tfree(base_cgroup);\n\t\t\tcontinue;\n\t\t}\n\t\tadd_controller(controller_list, mountpoint, base_cgroup);\n\t}\n\n\tfree_string_list(klist);\n\tfree_string_list(nlist);\n\n\tfree(basecginfo);\n\n\tfclose(f);\n\tfree(line);\n\n\t/* verify that all controllers in cgroup.use and all crucial\n\t * controllers are accounted for\n\t */\n\tif (!all_controllers_found())\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_copy_string",
          "args": [
            "tmp"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "must_copy_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "133-143",
          "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"cgfsng: error reading list of cgroups to use\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.cgroup.use\""
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nchar *cgroup_use;\n\nstatic bool collect_hierarchy_info(void)\n{\n\tconst char *tmp;\n\terrno = 0;\n\ttmp = lxc_global_config_value(\"lxc.cgroup.use\");\n\tif (!cgroup_use && errno != 0) { // lxc.cgroup.use can be NULL\n\t\tSYSERROR(\"cgfsng: error reading list of cgroups to use\");\n\t\treturn false;\n\t}\n\tcgroup_use = must_copy_string(tmp);\n\n\treturn parse_hierarchies();\n}"
  },
  {
    "function_name": "parse_hierarchies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1042-1126",
    "snippet": "static bool parse_hierarchies(void)\n{\n\tFILE *f;\n\tchar * line = NULL, *basecginfo;\n\tchar **klist = NULL, **nlist = NULL;\n\tsize_t len = 0;\n\n\t/*\n\t * Root spawned containers escape the current cgroup, so use init's\n\t * cgroups as our base in that case.\n\t */\n\tif (geteuid())\n\t\tbasecginfo = read_file(\"/proc/self/cgroup\");\n\telse\n\t\tbasecginfo = read_file(\"/proc/1/cgroup\");\n\tif (!basecginfo)\n\t\treturn false;\n\n\tif ((f = fopen(\"/proc/self/mountinfo\", \"r\")) == NULL) {\n\t\tSYSERROR(\"Failed opening /proc/self/mountinfo\");\n\t\treturn false;\n\t}\n\n\tget_existing_subsystems(&klist, &nlist);\n\n\tprint_basecg_debuginfo(basecginfo, klist, nlist);\n\n\t/* we support simple cgroup mounts and lxcfs mounts */\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar **controller_list = NULL;\n\t\tchar *mountpoint, *base_cgroup;\n\n\t\tif (!is_lxcfs(line) && !is_cgroupfs(line))\n\t\t\tcontinue;\n\n\t\tcontroller_list = get_controllers(klist, nlist, line);\n\t\tif (!controller_list)\n\t\t\tcontinue;\n\n\t\tif (controller_list_is_dup(hierarchies, controller_list)) {\n\t\t\tfree(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmountpoint = get_mountpoint(line);\n\t\tif (!mountpoint) {\n\t\t\tERROR(\"Error reading mountinfo: bad line '%s'\", line);\n\t\t\tfree_string_list(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase_cgroup = get_current_cgroup(basecginfo, controller_list[0]);\n\t\tif (!base_cgroup) {\n\t\t\tERROR(\"Failed to find current cgroup for controller '%s'\", controller_list[0]);\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tcontinue;\n\t\t}\n\t\ttrim(base_cgroup);\n\t\tprune_init_scope(base_cgroup);\n\t\tif (!test_writeable(mountpoint, base_cgroup)) {\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tfree(base_cgroup);\n\t\t\tcontinue;\n\t\t}\n\t\tadd_controller(controller_list, mountpoint, base_cgroup);\n\t}\n\n\tfree_string_list(klist);\n\tfree_string_list(nlist);\n\n\tfree(basecginfo);\n\n\tfclose(f);\n\tfree(line);\n\n\t/* verify that all controllers in cgroup.use and all crucial\n\t * controllers are accounted for\n\t */\n\tif (!all_controllers_found())\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "all_controllers_found",
          "args": [],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "all_controllers_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "725-745",
          "snippet": "static bool all_controllers_found(void)\n{\n\tchar *p, *saveptr = NULL;\n\tstruct hierarchy ** hlist = hierarchies;\n\n\tif (!controller_found(hlist, \"freezer\")) {\n\t\tERROR(\"no freezer controller mountpoint found\");\n\t\treturn false;\n\t}\n\n\tif (!cgroup_use)\n\t\treturn true;\n\tfor (p = strtok_r(cgroup_use, \",\", &saveptr); p;\n\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (!controller_found(hlist, p)) {\n\t\t\tERROR(\"no %s controller mountpoint found\", p);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;",
            "char *cgroup_use;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\nchar *cgroup_use;\n\nstatic bool all_controllers_found(void)\n{\n\tchar *p, *saveptr = NULL;\n\tstruct hierarchy ** hlist = hierarchies;\n\n\tif (!controller_found(hlist, \"freezer\")) {\n\t\tERROR(\"no freezer controller mountpoint found\");\n\t\treturn false;\n\t}\n\n\tif (!cgroup_use)\n\t\treturn true;\n\tfor (p = strtok_r(cgroup_use, \",\", &saveptr); p;\n\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (!controller_found(hlist, p)) {\n\t\t\tERROR(\"no %s controller mountpoint found\", p);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_string_list",
          "args": [
            "nlist"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "free_string_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "104-113",
          "snippet": "static void free_string_list(char **clist)\n{\n\tif (clist) {\n\t\tint i;\n\n\t\tfor (i = 0; clist[i]; i++)\n\t\t\tfree(clist[i]);\n\t\tfree(clist);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void free_string_list(char **clist)\n{\n\tif (clist) {\n\t\tint i;\n\n\t\tfor (i = 0; clist[i]; i++)\n\t\t\tfree(clist[i]);\n\t\tfree(clist);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_controller",
          "args": [
            "controller_list",
            "mountpoint",
            "base_cgroup"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "add_controller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "807-820",
          "snippet": "static void add_controller(char **clist, char *mountpoint, char *base_cgroup)\n{\n\tstruct hierarchy *new;\n\tint newentry;\n\n\tnew = must_alloc(sizeof(*new));\n\tnew->controllers = clist;\n\tnew->mountpoint = mountpoint;\n\tnew->base_cgroup = base_cgroup;\n\tnew->fullcgpath = NULL;\n\n\tnewentry = append_null_to_list((void ***)&hierarchies);\n\thierarchies[newentry] = new;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic void add_controller(char **clist, char *mountpoint, char *base_cgroup)\n{\n\tstruct hierarchy *new;\n\tint newentry;\n\n\tnew = must_alloc(sizeof(*new));\n\tnew->controllers = clist;\n\tnew->mountpoint = mountpoint;\n\tnew->base_cgroup = base_cgroup;\n\tnew->fullcgpath = NULL;\n\n\tnewentry = append_null_to_list((void ***)&hierarchies);\n\thierarchies[newentry] = new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_writeable",
          "args": [
            "mountpoint",
            "base_cgroup"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "test_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "924-932",
          "snippet": "static bool test_writeable(char *mountpoint, char *path)\n{\n\tchar *fullpath = must_make_path(mountpoint, path, NULL);\n\tint ret;\n\n\tret = access(fullpath, W_OK);\n\tfree(fullpath);\n\treturn ret == 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool test_writeable(char *mountpoint, char *path)\n{\n\tchar *fullpath = must_make_path(mountpoint, path, NULL);\n\tint ret;\n\n\tret = access(fullpath, W_OK);\n\tfree(fullpath);\n\treturn ret == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_init_scope",
          "args": [
            "base_cgroup"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "prune_init_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "212-228",
          "snippet": "void prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define INIT_SCOPE \"/init.scope\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\n#define INIT_SCOPE \"/init.scope\"\n\nvoid prune_init_scope(char *cg)\n{\n\tchar *point;\n\n\tif (!cg)\n\t\treturn;\n\n\tpoint = cg + strlen(cg) - strlen(INIT_SCOPE);\n\tif (point < cg)\n\t\treturn;\n\tif (strcmp(point, INIT_SCOPE) == 0) {\n\t\tif (point == cg)\n\t\t\t*(point+1) = '\\0';\n\t\telse\n\t\t\t*point = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim",
          "args": [
            "base_cgroup"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "986-991",
          "snippet": "static void trim(char *s)\n{\n\tsize_t len = strlen(s);\n\twhile ((len > 1) && (s[len - 1] == '\\n'))\n\t\ts[--len] = '\\0';\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void trim(char *s)\n{\n\tsize_t len = strlen(s);\n\twhile ((len > 1) && (s[len - 1] == '\\n'))\n\t\ts[--len] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to find current cgroup for controller '%s'\"",
            "controller_list[0]"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_cgroup",
          "args": [
            "basecginfo",
            "controller_list[0]"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "896-918",
          "snippet": "static char *get_current_cgroup(char *basecginfo, char *controller)\n{\n\tchar *p = basecginfo;\n\n\twhile (1) {\n\t\tp = strchr(p, ':');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t\tif (controller_in_clist(p, controller)) {\n\t\t\tp = strchr(p, ':');\n\t\t\tif (!p)\n\t\t\t\treturn NULL;\n\t\t\tp++;\n\t\t\treturn copy_to_eol(p);\n\t\t}\n\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *get_current_cgroup(char *basecginfo, char *controller)\n{\n\tchar *p = basecginfo;\n\n\twhile (1) {\n\t\tp = strchr(p, ':');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t\tif (controller_in_clist(p, controller)) {\n\t\t\tp = strchr(p, ':');\n\t\t\tif (!p)\n\t\t\t\treturn NULL;\n\t\t\tp++;\n\t\t\treturn copy_to_eol(p);\n\t\t}\n\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error reading mountinfo: bad line '%s'\"",
            "line"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mountpoint",
          "args": [
            "line"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "get_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "826-844",
          "snippet": "static char *get_mountpoint(char *line)\n{\n\tint i;\n\tchar *p = line, *sret;\n\tsize_t len;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\t/* we've already stuck a \\0 after the mountpoint */\n\tlen = strlen(p);\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *get_mountpoint(char *line)\n{\n\tint i;\n\tchar *p = line, *sret;\n\tsize_t len;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\t/* we've already stuck a \\0 after the mountpoint */\n\tlen = strlen(p);\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "controller_list_is_dup",
          "args": [
            "hierarchies",
            "controller_list"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "controller_list_is_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "692-703",
          "snippet": "static bool controller_list_is_dup(struct hierarchy **hlist, char **clist)\n{\n\tint i;\n\n\tif (!hlist)\n\t\treturn false;\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (controller_lists_intersect(hlist[i]->controllers, clist))\n\t\t\treturn true;\n\treturn false;\n\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_list_is_dup(struct hierarchy **hlist, char **clist)\n{\n\tint i;\n\n\tif (!hlist)\n\t\treturn false;\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (controller_lists_intersect(hlist[i]->controllers, clist))\n\t\t\treturn true;\n\treturn false;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_controllers",
          "args": [
            "klist",
            "nlist",
            "line"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "get_controllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "763-795",
          "snippet": "static char **get_controllers(char **klist, char **nlist, char *line)\n{\n\t// the fourth field is /sys/fs/cgroup/comma-delimited-controller-list\n\tint i;\n\tchar *p = line, *p2, *tok, *saveptr = NULL;\n\tchar **aret = NULL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\t/* note - if we change how mountinfo works, then our caller\n\t * will need to verify /sys/fs/cgroup/ in this field */\n\tif (strncmp(p, \"/sys/fs/cgroup/\", 15) != 0)\n\t\treturn NULL;\n\tp += 15;\n\tp2 = strchr(p, ' ');\n\tif (!p2) {\n\t\tERROR(\"corrupt mountinfo\");\n\t\treturn NULL;\n\t}\n\t*p2 = '\\0';\n\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tmust_append_controller(klist, nlist, &aret, tok);\n\t}\n\n\treturn aret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char **get_controllers(char **klist, char **nlist, char *line)\n{\n\t// the fourth field is /sys/fs/cgroup/comma-delimited-controller-list\n\tint i;\n\tchar *p = line, *p2, *tok, *saveptr = NULL;\n\tchar **aret = NULL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\t/* note - if we change how mountinfo works, then our caller\n\t * will need to verify /sys/fs/cgroup/ in this field */\n\tif (strncmp(p, \"/sys/fs/cgroup/\", 15) != 0)\n\t\treturn NULL;\n\tp += 15;\n\tp2 = strchr(p, ' ');\n\tif (!p2) {\n\t\tERROR(\"corrupt mountinfo\");\n\t\treturn NULL;\n\t}\n\t*p2 = '\\0';\n\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tmust_append_controller(klist, nlist, &aret, tok);\n\t}\n\n\treturn aret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cgroupfs",
          "args": [
            "line"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "is_cgroupfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "798-804",
          "snippet": "static bool is_cgroupfs(char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - cgroup \", 10) == 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool is_cgroupfs(char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - cgroup \", 10) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_lxcfs",
          "args": [
            "line"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "is_lxcfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "748-754",
          "snippet": "static bool is_lxcfs(const char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - fuse.lxcfs \", 14) == 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool is_lxcfs(const char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - fuse.lxcfs \", 14) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_basecg_debuginfo",
          "args": [
            "basecginfo",
            "klist",
            "nlist"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "print_basecg_debuginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1022-1036",
          "snippet": "static void print_basecg_debuginfo(char *basecginfo, char **klist, char **nlist)\n{\n\tint k;\n\tchar **it;\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tprintf(\"basecginfo is:\\n\");\n\tprintf(\"%s\\n\", basecginfo);\n\n\tfor (k = 0, it = klist; it && *it; it++, k++)\n\t\tprintf(\"kernel subsystem %d: %s\\n\", k, *it);\n\tfor (k = 0, it = nlist; it && *it; it++, k++)\n\t\tprintf(\"named subsystem %d: %s\\n\", k, *it);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void print_basecg_debuginfo(char *basecginfo, char **klist, char **nlist)\n{\n\tint k;\n\tchar **it;\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tprintf(\"basecginfo is:\\n\");\n\tprintf(\"%s\\n\", basecginfo);\n\n\tfor (k = 0, it = klist; it && *it; it++, k++)\n\t\tprintf(\"kernel subsystem %d: %s\\n\", k, *it);\n\tfor (k = 0, it = nlist; it && *it; it++, k++)\n\t\tprintf(\"named subsystem %d: %s\\n\", k, *it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_existing_subsystems",
          "args": [
            "&klist",
            "&nlist"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "get_existing_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "943-984",
          "snippet": "static void get_existing_subsystems(char ***klist, char ***nlist)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL)\n\t\treturn;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *p, *p2, *tok, *saveptr = NULL;\n\t\tp = strchr(line, ':');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\t/* If we have a mixture between cgroup v1 and cgroup v2\n\t\t * hierarchies, then /proc/self/cgroup contains entries of the\n\t\t * form:\n\t\t *\n\t\t *\t0::/some/path\n\t\t *\n\t\t * We need to skip those.\n\t\t */\n\t\tif ((p2 - p) == 0)\n\t\t\tcontinue;\n\n\t\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif (strncmp(tok, \"name=\", 5) == 0)\n\t\t\t\tmust_append_string(nlist, tok);\n\t\t\telse\n\t\t\t\tmust_append_string(klist, tok);\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct hierarchy **hierarchies;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic void get_existing_subsystems(char ***klist, char ***nlist)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL)\n\t\treturn;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *p, *p2, *tok, *saveptr = NULL;\n\t\tp = strchr(line, ':');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\t/* If we have a mixture between cgroup v1 and cgroup v2\n\t\t * hierarchies, then /proc/self/cgroup contains entries of the\n\t\t * form:\n\t\t *\n\t\t *\t0::/some/path\n\t\t *\n\t\t * We need to skip those.\n\t\t */\n\t\tif ((p2 - p) == 0)\n\t\t\tcontinue;\n\n\t\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif (strncmp(tok, \"name=\", 5) == 0)\n\t\t\t\tmust_append_string(nlist, tok);\n\t\t\telse\n\t\t\t\tmust_append_string(klist, tok);\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed opening /proc/self/mountinfo\""
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/mountinfo\"",
            "\"r\""
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_file",
          "args": [
            "\"/proc/1/cgroup\""
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "read_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "279-296",
          "snippet": "static char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic bool parse_hierarchies(void)\n{\n\tFILE *f;\n\tchar * line = NULL, *basecginfo;\n\tchar **klist = NULL, **nlist = NULL;\n\tsize_t len = 0;\n\n\t/*\n\t * Root spawned containers escape the current cgroup, so use init's\n\t * cgroups as our base in that case.\n\t */\n\tif (geteuid())\n\t\tbasecginfo = read_file(\"/proc/self/cgroup\");\n\telse\n\t\tbasecginfo = read_file(\"/proc/1/cgroup\");\n\tif (!basecginfo)\n\t\treturn false;\n\n\tif ((f = fopen(\"/proc/self/mountinfo\", \"r\")) == NULL) {\n\t\tSYSERROR(\"Failed opening /proc/self/mountinfo\");\n\t\treturn false;\n\t}\n\n\tget_existing_subsystems(&klist, &nlist);\n\n\tprint_basecg_debuginfo(basecginfo, klist, nlist);\n\n\t/* we support simple cgroup mounts and lxcfs mounts */\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar **controller_list = NULL;\n\t\tchar *mountpoint, *base_cgroup;\n\n\t\tif (!is_lxcfs(line) && !is_cgroupfs(line))\n\t\t\tcontinue;\n\n\t\tcontroller_list = get_controllers(klist, nlist, line);\n\t\tif (!controller_list)\n\t\t\tcontinue;\n\n\t\tif (controller_list_is_dup(hierarchies, controller_list)) {\n\t\t\tfree(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmountpoint = get_mountpoint(line);\n\t\tif (!mountpoint) {\n\t\t\tERROR(\"Error reading mountinfo: bad line '%s'\", line);\n\t\t\tfree_string_list(controller_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbase_cgroup = get_current_cgroup(basecginfo, controller_list[0]);\n\t\tif (!base_cgroup) {\n\t\t\tERROR(\"Failed to find current cgroup for controller '%s'\", controller_list[0]);\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tcontinue;\n\t\t}\n\t\ttrim(base_cgroup);\n\t\tprune_init_scope(base_cgroup);\n\t\tif (!test_writeable(mountpoint, base_cgroup)) {\n\t\t\tfree_string_list(controller_list);\n\t\t\tfree(mountpoint);\n\t\t\tfree(base_cgroup);\n\t\t\tcontinue;\n\t\t}\n\t\tadd_controller(controller_list, mountpoint, base_cgroup);\n\t}\n\n\tfree_string_list(klist);\n\tfree_string_list(nlist);\n\n\tfree(basecginfo);\n\n\tfclose(f);\n\tfree(line);\n\n\t/* verify that all controllers in cgroup.use and all crucial\n\t * controllers are accounted for\n\t */\n\tif (!all_controllers_found())\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "print_basecg_debuginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "1022-1036",
    "snippet": "static void print_basecg_debuginfo(char *basecginfo, char **klist, char **nlist)\n{\n\tint k;\n\tchar **it;\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tprintf(\"basecginfo is:\\n\");\n\tprintf(\"%s\\n\", basecginfo);\n\n\tfor (k = 0, it = klist; it && *it; it++, k++)\n\t\tprintf(\"kernel subsystem %d: %s\\n\", k, *it);\n\tfor (k = 0, it = nlist; it && *it; it++, k++)\n\t\tprintf(\"named subsystem %d: %s\\n\", k, *it);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"named subsystem %d: %s\\n\"",
            "k",
            "*it"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"kernel subsystem %d: %s\\n\"",
            "k",
            "*it"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "basecginfo"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"basecginfo is:\\n\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LXC_DEBUG_CGFSNG\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void print_basecg_debuginfo(char *basecginfo, char **klist, char **nlist)\n{\n\tint k;\n\tchar **it;\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tprintf(\"basecginfo is:\\n\");\n\tprintf(\"%s\\n\", basecginfo);\n\n\tfor (k = 0, it = klist; it && *it; it++, k++)\n\t\tprintf(\"kernel subsystem %d: %s\\n\", k, *it);\n\tfor (k = 0, it = nlist; it && *it; it++, k++)\n\t\tprintf(\"named subsystem %d: %s\\n\", k, *it);\n}"
  },
  {
    "function_name": "print_init_debuginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "993-1020",
    "snippet": "static void print_init_debuginfo(struct cgfsng_handler_data *d)\n{\n\tstruct hierarchy **it;\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name ? d->name : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.use: %s\", cgroup_use ? cgroup_use : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.pattern: %s\", d->cgroup_pattern ? d->cgroup_pattern : \"(null)\");\n\tDEBUG(\"  cgroup: %s\", d->container_cgroup ? d->container_cgroup : \"(null)\");\n\tif (!hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Hierarchies:\");\n\tfor (i = 0, it = hierarchies; it && *it; it++, i++) {\n\t\tchar **cit;\n\t\tint j;\n\t\tDEBUG(\"  %d: base_cgroup %s\", i, (*it)->base_cgroup ? (*it)->base_cgroup : \"(null)\");\n\t\tDEBUG(\"      mountpoint %s\", (*it)->mountpoint ? (*it)->mountpoint : \"(null)\");\n\t\tDEBUG(\"      controllers:\");\n\t\tfor (j = 0, cit = (*it)->controllers; cit && *cit; cit++, j++)\n\t\t\tDEBUG(\"      %d: %s\", j, *cit);\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;",
      "char *cgroup_use;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"      %d: %s\"",
            "j",
            "*cit"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"      controllers:\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"      mountpoint %s\"",
            "(*it)->mountpoint ? (*it)->mountpoint : \"(null)\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  %d: base_cgroup %s\"",
            "i",
            "(*it)->base_cgroup ? (*it)->base_cgroup : \"(null)\""
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  Hierarchies:\""
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  No hierarchies found.\""
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  cgroup: %s\"",
            "d->container_cgroup ? d->container_cgroup : \"(null)\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  lxc.cgroup.pattern: %s\"",
            "d->cgroup_pattern ? d->cgroup_pattern : \"(null)\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  lxc.cgroup.use: %s\"",
            "cgroup_use ? cgroup_use : \"(null)\""
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"  container name: %s\"",
            "d->name ? d->name : \"(null)\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Cgroup information:\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LXC_DEBUG_CGFSNG\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\nchar *cgroup_use;\n\nstatic void print_init_debuginfo(struct cgfsng_handler_data *d)\n{\n\tstruct hierarchy **it;\n\tint i;\n\n\tif (!getenv(\"LXC_DEBUG_CGFSNG\"))\n\t\treturn;\n\n\tDEBUG(\"Cgroup information:\");\n\tDEBUG(\"  container name: %s\", d->name ? d->name : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.use: %s\", cgroup_use ? cgroup_use : \"(null)\");\n\tDEBUG(\"  lxc.cgroup.pattern: %s\", d->cgroup_pattern ? d->cgroup_pattern : \"(null)\");\n\tDEBUG(\"  cgroup: %s\", d->container_cgroup ? d->container_cgroup : \"(null)\");\n\tif (!hierarchies) {\n\t\tDEBUG(\"  No hierarchies found.\");\n\t\treturn;\n\t}\n\tDEBUG(\"  Hierarchies:\");\n\tfor (i = 0, it = hierarchies; it && *it; it++, i++) {\n\t\tchar **cit;\n\t\tint j;\n\t\tDEBUG(\"  %d: base_cgroup %s\", i, (*it)->base_cgroup ? (*it)->base_cgroup : \"(null)\");\n\t\tDEBUG(\"      mountpoint %s\", (*it)->mountpoint ? (*it)->mountpoint : \"(null)\");\n\t\tDEBUG(\"      controllers:\");\n\t\tfor (j = 0, cit = (*it)->controllers; cit && *cit; cit++, j++)\n\t\t\tDEBUG(\"      %d: %s\", j, *cit);\n\t}\n}"
  },
  {
    "function_name": "trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "986-991",
    "snippet": "static void trim(char *s)\n{\n\tsize_t len = strlen(s);\n\twhile ((len > 1) && (s[len - 1] == '\\n'))\n\t\ts[--len] = '\\0';\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void trim(char *s)\n{\n\tsize_t len = strlen(s);\n\twhile ((len > 1) && (s[len - 1] == '\\n'))\n\t\ts[--len] = '\\0';\n}"
  },
  {
    "function_name": "get_existing_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "943-984",
    "snippet": "static void get_existing_subsystems(char ***klist, char ***nlist)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL)\n\t\treturn;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *p, *p2, *tok, *saveptr = NULL;\n\t\tp = strchr(line, ':');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\t/* If we have a mixture between cgroup v1 and cgroup v2\n\t\t * hierarchies, then /proc/self/cgroup contains entries of the\n\t\t * form:\n\t\t *\n\t\t *\t0::/some/path\n\t\t *\n\t\t * We need to skip those.\n\t\t */\n\t\tif ((p2 - p) == 0)\n\t\t\tcontinue;\n\n\t\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif (strncmp(tok, \"name=\", 5) == 0)\n\t\t\t\tmust_append_string(nlist, tok);\n\t\t\telse\n\t\t\t\tmust_append_string(klist, tok);\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_append_string",
          "args": [
            "klist",
            "tok"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "must_append_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "934-941",
          "snippet": "static void must_append_string(char ***list, char *entry)\n{\n\tint newentry = append_null_to_list((void ***)list);\n\tchar *copy;\n\n\tcopy = must_copy_string(entry);\n\t(*list)[newentry] = copy;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void must_append_string(char ***list, char *entry)\n{\n\tint newentry = append_null_to_list((void ***)list);\n\tchar *copy;\n\n\tcopy = must_copy_string(entry);\n\t(*list)[newentry] = copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "tok",
            "\"name=\"",
            "5"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "p",
            "\",\"",
            "&saveptr"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/cgroup\"",
            "\"r\""
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic void get_existing_subsystems(char ***klist, char ***nlist)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif ((f = fopen(\"/proc/self/cgroup\", \"r\")) == NULL)\n\t\treturn;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *p, *p2, *tok, *saveptr = NULL;\n\t\tp = strchr(line, ':');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tp2 = strchr(p, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\t/* If we have a mixture between cgroup v1 and cgroup v2\n\t\t * hierarchies, then /proc/self/cgroup contains entries of the\n\t\t * form:\n\t\t *\n\t\t *\t0::/some/path\n\t\t *\n\t\t * We need to skip those.\n\t\t */\n\t\tif ((p2 - p) == 0)\n\t\t\tcontinue;\n\n\t\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\t\tif (strncmp(tok, \"name=\", 5) == 0)\n\t\t\t\tmust_append_string(nlist, tok);\n\t\t\telse\n\t\t\t\tmust_append_string(klist, tok);\n\t\t}\n\t}\n\n\tfree(line);\n\tfclose(f);\n}"
  },
  {
    "function_name": "must_append_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "934-941",
    "snippet": "static void must_append_string(char ***list, char *entry)\n{\n\tint newentry = append_null_to_list((void ***)list);\n\tchar *copy;\n\n\tcopy = must_copy_string(entry);\n\t(*list)[newentry] = copy;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_copy_string",
          "args": [
            "entry"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "must_copy_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "133-143",
          "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_null_to_list",
          "args": [
            "(void ***)list"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "append_null_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "166-176",
          "snippet": "static int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void must_append_string(char ***list, char *entry)\n{\n\tint newentry = append_null_to_list((void ***)list);\n\tchar *copy;\n\n\tcopy = must_copy_string(entry);\n\t(*list)[newentry] = copy;\n}"
  },
  {
    "function_name": "test_writeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "924-932",
    "snippet": "static bool test_writeable(char *mountpoint, char *path)\n{\n\tchar *fullpath = must_make_path(mountpoint, path, NULL);\n\tint ret;\n\n\tret = access(fullpath, W_OK);\n\tfree(fullpath);\n\treturn ret == 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fullpath"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "fullpath",
            "W_OK"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "mountpoint",
            "path",
            "NULL"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool test_writeable(char *mountpoint, char *path)\n{\n\tchar *fullpath = must_make_path(mountpoint, path, NULL);\n\tint ret;\n\n\tret = access(fullpath, W_OK);\n\tfree(fullpath);\n\treturn ret == 0;\n}"
  },
  {
    "function_name": "get_current_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "896-918",
    "snippet": "static char *get_current_cgroup(char *basecginfo, char *controller)\n{\n\tchar *p = basecginfo;\n\n\twhile (1) {\n\t\tp = strchr(p, ':');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t\tif (controller_in_clist(p, controller)) {\n\t\t\tp = strchr(p, ':');\n\t\t\tif (!p)\n\t\t\t\treturn NULL;\n\t\t\tp++;\n\t\t\treturn copy_to_eol(p);\n\t\t}\n\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'\\n'"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_eol",
          "args": [
            "p"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "850-863",
          "snippet": "static char *copy_to_eol(char *p)\n{\n\tchar *p2 = strchr(p, '\\n'), *sret;\n\tsize_t len;\n\n\tif (!p2)\n\t\treturn NULL;\n\n\tlen = p2 - p;\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *copy_to_eol(char *p)\n{\n\tchar *p2 = strchr(p, '\\n'), *sret;\n\tsize_t len;\n\n\tif (!p2)\n\t\treturn NULL;\n\n\tlen = p2 - p;\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "controller_in_clist",
          "args": [
            "p",
            "controller"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "controller_in_clist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "870-890",
          "snippet": "static bool controller_in_clist(char *cgline, char *c)\n{\n\tchar *tok, *saveptr = NULL, *eol, *tmp;\n\tsize_t len;\n\n\teol = strchr(cgline, ':');\n\tif (!eol)\n\t\treturn false;\n\n\tlen = eol - cgline;\n\ttmp = alloca(len + 1);\n\tmemcpy(tmp, cgline, len);\n\ttmp[len] = '\\0';\n\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (strcmp(tok, c) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_in_clist(char *cgline, char *c)\n{\n\tchar *tok, *saveptr = NULL, *eol, *tmp;\n\tsize_t len;\n\n\teol = strchr(cgline, ':');\n\tif (!eol)\n\t\treturn false;\n\n\tlen = eol - cgline;\n\ttmp = alloca(len + 1);\n\tmemcpy(tmp, cgline, len);\n\ttmp[len] = '\\0';\n\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (strcmp(tok, c) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *get_current_cgroup(char *basecginfo, char *controller)\n{\n\tchar *p = basecginfo;\n\n\twhile (1) {\n\t\tp = strchr(p, ':');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t\tif (controller_in_clist(p, controller)) {\n\t\t\tp = strchr(p, ':');\n\t\t\tif (!p)\n\t\t\t\treturn NULL;\n\t\t\tp++;\n\t\t\treturn copy_to_eol(p);\n\t\t}\n\n\t\tp = strchr(p, '\\n');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n}"
  },
  {
    "function_name": "controller_in_clist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "870-890",
    "snippet": "static bool controller_in_clist(char *cgline, char *c)\n{\n\tchar *tok, *saveptr = NULL, *eol, *tmp;\n\tsize_t len;\n\n\teol = strchr(cgline, ':');\n\tif (!eol)\n\t\treturn false;\n\n\tlen = eol - cgline;\n\ttmp = alloca(len + 1);\n\tmemcpy(tmp, cgline, len);\n\ttmp[len] = '\\0';\n\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (strcmp(tok, c) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tok",
            "c"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\",\"",
            "&saveptr"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "cgline",
            "len"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len + 1"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cgline",
            "':'"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_in_clist(char *cgline, char *c)\n{\n\tchar *tok, *saveptr = NULL, *eol, *tmp;\n\tsize_t len;\n\n\teol = strchr(cgline, ':');\n\tif (!eol)\n\t\treturn false;\n\n\tlen = eol - cgline;\n\ttmp = alloca(len + 1);\n\tmemcpy(tmp, cgline, len);\n\ttmp[len] = '\\0';\n\n\tfor (tok = strtok_r(tmp, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (strcmp(tok, c) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "copy_to_eol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "850-863",
    "snippet": "static char *copy_to_eol(char *p)\n{\n\tchar *p2 = strchr(p, '\\n'), *sret;\n\tsize_t len;\n\n\tif (!p2)\n\t\treturn NULL;\n\n\tlen = p2 - p;\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sret",
            "p",
            "len"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "len + 1"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'\\n'"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *copy_to_eol(char *p)\n{\n\tchar *p2 = strchr(p, '\\n'), *sret;\n\tsize_t len;\n\n\tif (!p2)\n\t\treturn NULL;\n\n\tlen = p2 - p;\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}"
  },
  {
    "function_name": "get_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "826-844",
    "snippet": "static char *get_mountpoint(char *line)\n{\n\tint i;\n\tchar *p = line, *sret;\n\tsize_t len;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\t/* we've already stuck a \\0 after the mountpoint */\n\tlen = strlen(p);\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sret",
            "p",
            "len"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "len + 1"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "' '"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *get_mountpoint(char *line)\n{\n\tint i;\n\tchar *p = line, *sret;\n\tsize_t len;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\t/* we've already stuck a \\0 after the mountpoint */\n\tlen = strlen(p);\n\tsret = must_alloc(len + 1);\n\tmemcpy(sret, p, len);\n\tsret[len] = '\\0';\n\treturn sret;\n}"
  },
  {
    "function_name": "add_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "807-820",
    "snippet": "static void add_controller(char **clist, char *mountpoint, char *base_cgroup)\n{\n\tstruct hierarchy *new;\n\tint newentry;\n\n\tnew = must_alloc(sizeof(*new));\n\tnew->controllers = clist;\n\tnew->mountpoint = mountpoint;\n\tnew->base_cgroup = base_cgroup;\n\tnew->fullcgpath = NULL;\n\n\tnewentry = append_null_to_list((void ***)&hierarchies);\n\thierarchies[newentry] = new;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_null_to_list",
          "args": [
            "(void ***)&hierarchies"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "append_null_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "166-176",
          "snippet": "static int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "sizeof(*new)"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstatic void add_controller(char **clist, char *mountpoint, char *base_cgroup)\n{\n\tstruct hierarchy *new;\n\tint newentry;\n\n\tnew = must_alloc(sizeof(*new));\n\tnew->controllers = clist;\n\tnew->mountpoint = mountpoint;\n\tnew->base_cgroup = base_cgroup;\n\tnew->fullcgpath = NULL;\n\n\tnewentry = append_null_to_list((void ***)&hierarchies);\n\thierarchies[newentry] = new;\n}"
  },
  {
    "function_name": "is_cgroupfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "798-804",
    "snippet": "static bool is_cgroupfs(char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - cgroup \", 10) == 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\" - cgroup \"",
            "10"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\" - \""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool is_cgroupfs(char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - cgroup \", 10) == 0;\n}"
  },
  {
    "function_name": "get_controllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "763-795",
    "snippet": "static char **get_controllers(char **klist, char **nlist, char *line)\n{\n\t// the fourth field is /sys/fs/cgroup/comma-delimited-controller-list\n\tint i;\n\tchar *p = line, *p2, *tok, *saveptr = NULL;\n\tchar **aret = NULL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\t/* note - if we change how mountinfo works, then our caller\n\t * will need to verify /sys/fs/cgroup/ in this field */\n\tif (strncmp(p, \"/sys/fs/cgroup/\", 15) != 0)\n\t\treturn NULL;\n\tp += 15;\n\tp2 = strchr(p, ' ');\n\tif (!p2) {\n\t\tERROR(\"corrupt mountinfo\");\n\t\treturn NULL;\n\t}\n\t*p2 = '\\0';\n\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tmust_append_controller(klist, nlist, &aret, tok);\n\t}\n\n\treturn aret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_append_controller",
          "args": [
            "klist",
            "nlist",
            "&aret",
            "tok"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "must_append_controller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "208-229",
          "snippet": "static void must_append_controller(char **klist, char **nlist, char ***clist, char *entry)\n{\n\tint newentry;\n\tchar *copy;\n\n\tif (string_in_list(klist, entry) && string_in_list(nlist, entry)) {\n\t\tERROR(\"Refusing to use ambiguous controller '%s'\", entry);\n\t\tERROR(\"It is both a named and kernel subsystem\");\n\t\treturn;\n\t}\n\n\tnewentry = append_null_to_list((void ***)clist);\n\n\tif (strncmp(entry, \"name=\", 5) == 0)\n\t\tcopy = must_copy_string(entry);\n\telse if (string_in_list(klist, entry))\n\t\tcopy = must_copy_string(entry);\n\telse\n\t\tcopy = must_prefix_named(entry);\n\n\t(*clist)[newentry] = copy;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void must_append_controller(char **klist, char **nlist, char ***clist, char *entry)\n{\n\tint newentry;\n\tchar *copy;\n\n\tif (string_in_list(klist, entry) && string_in_list(nlist, entry)) {\n\t\tERROR(\"Refusing to use ambiguous controller '%s'\", entry);\n\t\tERROR(\"It is both a named and kernel subsystem\");\n\t\treturn;\n\t}\n\n\tnewentry = append_null_to_list((void ***)clist);\n\n\tif (strncmp(entry, \"name=\", 5) == 0)\n\t\tcopy = must_copy_string(entry);\n\telse if (string_in_list(klist, entry))\n\t\tcopy = must_copy_string(entry);\n\telse\n\t\tcopy = must_prefix_named(entry);\n\n\t(*clist)[newentry] = copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "p",
            "\",\"",
            "&saveptr"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"corrupt mountinfo\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "' '"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"/sys/fs/cgroup/\"",
            "15"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char **get_controllers(char **klist, char **nlist, char *line)\n{\n\t// the fourth field is /sys/fs/cgroup/comma-delimited-controller-list\n\tint i;\n\tchar *p = line, *p2, *tok, *saveptr = NULL;\n\tchar **aret = NULL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\tp++;\n\t}\n\tif (!p)\n\t\treturn NULL;\n\t/* note - if we change how mountinfo works, then our caller\n\t * will need to verify /sys/fs/cgroup/ in this field */\n\tif (strncmp(p, \"/sys/fs/cgroup/\", 15) != 0)\n\t\treturn NULL;\n\tp += 15;\n\tp2 = strchr(p, ' ');\n\tif (!p2) {\n\t\tERROR(\"corrupt mountinfo\");\n\t\treturn NULL;\n\t}\n\t*p2 = '\\0';\n\tfor (tok = strtok_r(p, \",\", &saveptr); tok;\n\t\t\ttok = strtok_r(NULL, \",\", &saveptr)) {\n\t\tmust_append_controller(klist, nlist, &aret, tok);\n\t}\n\n\treturn aret;\n}"
  },
  {
    "function_name": "is_lxcfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "748-754",
    "snippet": "static bool is_lxcfs(const char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - fuse.lxcfs \", 14) == 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\" - fuse.lxcfs \"",
            "14"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\" - \""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool is_lxcfs(const char *line)\n{\n\tchar *p = strstr(line, \" - \");\n\tif (!p)\n\t\treturn false;\n\treturn strncmp(p, \" - fuse.lxcfs \", 14) == 0;\n}"
  },
  {
    "function_name": "all_controllers_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "725-745",
    "snippet": "static bool all_controllers_found(void)\n{\n\tchar *p, *saveptr = NULL;\n\tstruct hierarchy ** hlist = hierarchies;\n\n\tif (!controller_found(hlist, \"freezer\")) {\n\t\tERROR(\"no freezer controller mountpoint found\");\n\t\treturn false;\n\t}\n\n\tif (!cgroup_use)\n\t\treturn true;\n\tfor (p = strtok_r(cgroup_use, \",\", &saveptr); p;\n\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (!controller_found(hlist, p)) {\n\t\t\tERROR(\"no %s controller mountpoint found\", p);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;",
      "char *cgroup_use;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no %s controller mountpoint found\"",
            "p"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "controller_found",
          "args": [
            "hlist",
            "p"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "controller_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "709-719",
          "snippet": "static bool controller_found(struct hierarchy **hlist, char *entry)\n{\n\tint i;\n\tif (!hlist)\n\t\treturn false;\n\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (string_in_list(hlist[i]->controllers, entry))\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_found(struct hierarchy **hlist, char *entry)\n{\n\tint i;\n\tif (!hlist)\n\t\treturn false;\n\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (string_in_list(hlist[i]->controllers, entry))\n\t\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&saveptr"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "cgroup_use",
            "\",\"",
            "&saveptr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no freezer controller mountpoint found\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\nchar *cgroup_use;\n\nstatic bool all_controllers_found(void)\n{\n\tchar *p, *saveptr = NULL;\n\tstruct hierarchy ** hlist = hierarchies;\n\n\tif (!controller_found(hlist, \"freezer\")) {\n\t\tERROR(\"no freezer controller mountpoint found\");\n\t\treturn false;\n\t}\n\n\tif (!cgroup_use)\n\t\treturn true;\n\tfor (p = strtok_r(cgroup_use, \",\", &saveptr); p;\n\t\t\tp = strtok_r(NULL, \",\", &saveptr)) {\n\t\tif (!controller_found(hlist, p)) {\n\t\t\tERROR(\"no %s controller mountpoint found\", p);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "controller_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "709-719",
    "snippet": "static bool controller_found(struct hierarchy **hlist, char *entry)\n{\n\tint i;\n\tif (!hlist)\n\t\treturn false;\n\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (string_in_list(hlist[i]->controllers, entry))\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string_in_list",
          "args": [
            "hlist[i]->controllers",
            "entry"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "182-193",
          "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_found(struct hierarchy **hlist, char *entry)\n{\n\tint i;\n\tif (!hlist)\n\t\treturn false;\n\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (string_in_list(hlist[i]->controllers, entry))\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "controller_list_is_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "692-703",
    "snippet": "static bool controller_list_is_dup(struct hierarchy **hlist, char **clist)\n{\n\tint i;\n\n\tif (!hlist)\n\t\treturn false;\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (controller_lists_intersect(hlist[i]->controllers, clist))\n\t\t\treturn true;\n\treturn false;\n\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "controller_lists_intersect",
          "args": [
            "hlist[i]->controllers",
            "clist"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "controller_lists_intersect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "673-685",
          "snippet": "static bool controller_lists_intersect(char **l1, char **l2)\n{\n\tint i;\n\n\tif (!l1 || !l2)\n\t\treturn false;\n\n\tfor (i = 0; l1[i]; i++) {\n\t\tif (string_in_list(l2, l1[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_lists_intersect(char **l1, char **l2)\n{\n\tint i;\n\n\tif (!l1 || !l2)\n\t\treturn false;\n\n\tfor (i = 0; l1[i]; i++) {\n\t\tif (string_in_list(l2, l1[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_list_is_dup(struct hierarchy **hlist, char **clist)\n{\n\tint i;\n\n\tif (!hlist)\n\t\treturn false;\n\tfor (i = 0; hlist[i]; i++)\n\t\tif (controller_lists_intersect(hlist[i]->controllers, clist))\n\t\t\treturn true;\n\treturn false;\n\n}"
  },
  {
    "function_name": "controller_lists_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "673-685",
    "snippet": "static bool controller_lists_intersect(char **l1, char **l2)\n{\n\tint i;\n\n\tif (!l1 || !l2)\n\t\treturn false;\n\n\tfor (i = 0; l1[i]; i++) {\n\t\tif (string_in_list(l2, l1[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "string_in_list",
          "args": [
            "l2",
            "l1[i]"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "182-193",
          "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool controller_lists_intersect(char **l1, char **l2)\n{\n\tint i;\n\n\tif (!l1 || !l2)\n\t\treturn false;\n\n\tfor (i = 0; l1[i]; i++) {\n\t\tif (string_in_list(l2, l1[i]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "handle_cpuset_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "600-667",
    "snippet": "static bool handle_cpuset_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tchar *cgpath, *clonechildrenpath, v, *slash;\n\n\tif (!string_in_list(h->controllers, \"cpuset\"))\n\t\treturn true;\n\n\tif (*cgname == '/')\n\t\tcgname++;\n\tslash = strchr(cgname, '/');\n\tif (slash)\n\t\t*slash = '\\0';\n\n\tcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (slash)\n\t\t*slash = '/';\n\tif (mkdir(cgpath, 0755) < 0 && errno != EEXIST) {\n\t\tSYSERROR(\"Failed to create '%s'\", cgpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tclonechildrenpath = must_make_path(cgpath, \"cgroup.clone_children\", NULL);\n\tif (!file_exists(clonechildrenpath)) { /* unified hierarchy doesn't have clone_children */\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\tif (lxc_read_from_file(clonechildrenpath, &v, 1) < 0) {\n\t\tSYSERROR(\"Failed to read '%s'\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\t/* Make sure any isolated cpus are removed from cpuset.cpus. */\n\tif (!filter_and_set_cpus(cgpath, v == '1')) {\n\t\tSYSERROR(\"Failed to remove isolated cpus.\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tif (v == '1') {  /* already set for us by someone else */\n\t\tDEBUG(\"\\\"cgroup.clone_children\\\" was already set to \\\"1\\\".\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\n\t/* copy parent's settings */\n\tif (!copy_parent_file(cgpath, \"cpuset.mems\")) {\n\t\tSYSERROR(\"Failed to copy \\\"cpuset.mems\\\" settings.\");\n\t\tfree(cgpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(cgpath);\n\n\tif (lxc_write_to_file(clonechildrenpath, \"1\", 1, false) < 0) {\n\t\t/* Set clone_children so children inherit our settings */\n\t\tSYSERROR(\"Failed to write 1 to %s\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(clonechildrenpath);\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "clonechildrenpath"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to write 1 to %s\"",
            "clonechildrenpath"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "clonechildrenpath",
            "\"1\"",
            "1",
            "false"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to copy \\\"cpuset.mems\\\" settings.\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_parent_file",
          "args": [
            "cgpath",
            "\"cpuset.mems\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "copy_parent_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "557-592",
          "snippet": "static bool copy_parent_file(char *path, char *file)\n{\n\tchar *lastslash, *value = NULL, *fpath, oldv;\n\tint len = 0;\n\tint ret;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"cgfsng:copy_parent_file: bad path %s\", path);\n\t\treturn false;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, file, NULL);\n\tlen = lxc_read_from_file(fpath, NULL, 0);\n\tif (len <= 0)\n\t\tgoto bad;\n\tvalue = must_alloc(len + 1);\n\tif (lxc_read_from_file(fpath, value, len) != len)\n\t\tgoto bad;\n\tfree(fpath);\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, file, NULL);\n\tret = lxc_write_to_file(fpath, value, len, false);\n\tif (ret < 0)\n\t\tSYSERROR(\"Unable to write %s to %s\", value, fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn ret >= 0;\n\nbad:\n\tSYSERROR(\"Error reading '%s'\", fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool copy_parent_file(char *path, char *file)\n{\n\tchar *lastslash, *value = NULL, *fpath, oldv;\n\tint len = 0;\n\tint ret;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"cgfsng:copy_parent_file: bad path %s\", path);\n\t\treturn false;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, file, NULL);\n\tlen = lxc_read_from_file(fpath, NULL, 0);\n\tif (len <= 0)\n\t\tgoto bad;\n\tvalue = must_alloc(len + 1);\n\tif (lxc_read_from_file(fpath, value, len) != len)\n\t\tgoto bad;\n\tfree(fpath);\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, file, NULL);\n\tret = lxc_write_to_file(fpath, value, len, false);\n\tif (ret < 0)\n\t\tSYSERROR(\"Unable to write %s to %s\", value, fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn ret >= 0;\n\nbad:\n\tSYSERROR(\"Error reading '%s'\", fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"\\\"cgroup.clone_children\\\" was already set to \\\"1\\\".\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to remove isolated cpus.\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_and_set_cpus",
          "args": [
            "cgpath",
            "v == '1'"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "filter_and_set_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "420-554",
          "snippet": "static bool filter_and_set_cpus(char *path, bool am_initialized)\n{\n\tchar *lastslash, *fpath, oldv;\n\tint ret;\n\tssize_t i;\n\n\tssize_t maxposs = 0, maxisol = 0;\n\tchar *cpulist = NULL, *posscpus = NULL, *isolcpus = NULL;\n\tuint32_t *possmask = NULL, *isolmask = NULL;\n\tbool bret = false, flipped_bit = false;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"Invalid path: %s.\", path);\n\t\treturn bret;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tposscpus = read_file(fpath);\n\tif (!posscpus) {\n\t\tSYSERROR(\"Could not read file: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\n\t/* Get maximum number of cpus found in possible cpuset. */\n\tmaxposs = get_max_cpus(posscpus);\n\tif (maxposs < 0)\n\t\tgoto on_error;\n\n\tif (!file_exists(__ISOL_CPUS)) {\n\t\t/* This system doesn't expose isolated cpus. */\n\t\tDEBUG(\"Path: \"__ISOL_CPUS\" to read isolated cpus from does not exist.\\n\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\tisolcpus = read_file(__ISOL_CPUS);\n\tif (!isolcpus) {\n\t\tSYSERROR(\"Could not read file \"__ISOL_CPUS);\n\t\tgoto on_error;\n\t}\n\tif (!isdigit(isolcpus[0])) {\n\t\tDEBUG(\"No isolated cpus detected.\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\t/* Get maximum number of cpus found in isolated cpuset. */\n\tmaxisol = get_max_cpus(isolcpus);\n\tif (maxisol < 0)\n\t\tgoto on_error;\n\n\tif (maxposs < maxisol)\n\t\tmaxposs = maxisol;\n\tmaxposs++;\n\n\tpossmask = lxc_cpumask(posscpus, maxposs);\n\tif (!possmask) {\n\t\tERROR(\"Could not create cpumask for all possible cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tisolmask = lxc_cpumask(isolcpus, maxposs);\n\tif (!isolmask) {\n\t\tERROR(\"Could not create cpumask for all isolated cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tfor (i = 0; i <= maxposs; i++) {\n\t\tif (is_set(i, isolmask) && is_set(i, possmask)) {\n\t\t\tflipped_bit = true;\n\t\t\tclear_bit(i, possmask);\n\t\t}\n\t}\n\n\tif (!flipped_bit) {\n\t\tDEBUG(\"No isolated cpus present in cpuset.\");\n\t\tgoto on_success;\n\t}\n\tDEBUG(\"Removed isolated cpus from cpuset.\");\n\n\tcpulist = lxc_cpumask_to_cpulist(possmask, maxposs);\n\tif (!cpulist) {\n\t\tERROR(\"Could not create cpu list.\\n\");\n\t\tgoto on_error;\n\t}\n\ncopy_parent:\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tret = lxc_write_to_file(fpath, cpulist, strlen(cpulist), false);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not write cpu list to: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\non_success:\n\tbret = true;\n\non_error:\n\tfree(fpath);\n\n\tfree(isolcpus);\n\tfree(isolmask);\n\n\tif (posscpus != cpulist)\n\t\tfree(posscpus);\n\tfree(possmask);\n\n\tfree(cpulist);\n\treturn bret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define __ISOL_CPUS \"/sys/devices/system/cpu/isolated\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define __ISOL_CPUS \"/sys/devices/system/cpu/isolated\"\n\nstatic bool filter_and_set_cpus(char *path, bool am_initialized)\n{\n\tchar *lastslash, *fpath, oldv;\n\tint ret;\n\tssize_t i;\n\n\tssize_t maxposs = 0, maxisol = 0;\n\tchar *cpulist = NULL, *posscpus = NULL, *isolcpus = NULL;\n\tuint32_t *possmask = NULL, *isolmask = NULL;\n\tbool bret = false, flipped_bit = false;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"Invalid path: %s.\", path);\n\t\treturn bret;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tposscpus = read_file(fpath);\n\tif (!posscpus) {\n\t\tSYSERROR(\"Could not read file: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\n\t/* Get maximum number of cpus found in possible cpuset. */\n\tmaxposs = get_max_cpus(posscpus);\n\tif (maxposs < 0)\n\t\tgoto on_error;\n\n\tif (!file_exists(__ISOL_CPUS)) {\n\t\t/* This system doesn't expose isolated cpus. */\n\t\tDEBUG(\"Path: \"__ISOL_CPUS\" to read isolated cpus from does not exist.\\n\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\tisolcpus = read_file(__ISOL_CPUS);\n\tif (!isolcpus) {\n\t\tSYSERROR(\"Could not read file \"__ISOL_CPUS);\n\t\tgoto on_error;\n\t}\n\tif (!isdigit(isolcpus[0])) {\n\t\tDEBUG(\"No isolated cpus detected.\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\t/* Get maximum number of cpus found in isolated cpuset. */\n\tmaxisol = get_max_cpus(isolcpus);\n\tif (maxisol < 0)\n\t\tgoto on_error;\n\n\tif (maxposs < maxisol)\n\t\tmaxposs = maxisol;\n\tmaxposs++;\n\n\tpossmask = lxc_cpumask(posscpus, maxposs);\n\tif (!possmask) {\n\t\tERROR(\"Could not create cpumask for all possible cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tisolmask = lxc_cpumask(isolcpus, maxposs);\n\tif (!isolmask) {\n\t\tERROR(\"Could not create cpumask for all isolated cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tfor (i = 0; i <= maxposs; i++) {\n\t\tif (is_set(i, isolmask) && is_set(i, possmask)) {\n\t\t\tflipped_bit = true;\n\t\t\tclear_bit(i, possmask);\n\t\t}\n\t}\n\n\tif (!flipped_bit) {\n\t\tDEBUG(\"No isolated cpus present in cpuset.\");\n\t\tgoto on_success;\n\t}\n\tDEBUG(\"Removed isolated cpus from cpuset.\");\n\n\tcpulist = lxc_cpumask_to_cpulist(possmask, maxposs);\n\tif (!cpulist) {\n\t\tERROR(\"Could not create cpu list.\\n\");\n\t\tgoto on_error;\n\t}\n\ncopy_parent:\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tret = lxc_write_to_file(fpath, cpulist, strlen(cpulist), false);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not write cpu list to: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\non_success:\n\tbret = true;\n\non_error:\n\tfree(fpath);\n\n\tfree(isolcpus);\n\tfree(isolmask);\n\n\tif (posscpus != cpulist)\n\t\tfree(posscpus);\n\tfree(possmask);\n\n\tfree(cpulist);\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to read '%s'\"",
            "clonechildrenpath"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "clonechildrenpath",
            "&v",
            "1"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "clonechildrenpath"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "cgpath",
            "\"cgroup.clone_children\"",
            "NULL"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Failed to create '%s'\"",
            "cgpath"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cgpath",
            "0755"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cgname",
            "'/'"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_in_list",
          "args": [
            "h->controllers",
            "\"cpuset\""
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "182-193",
          "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool handle_cpuset_hierarchy(struct hierarchy *h, char *cgname)\n{\n\tchar *cgpath, *clonechildrenpath, v, *slash;\n\n\tif (!string_in_list(h->controllers, \"cpuset\"))\n\t\treturn true;\n\n\tif (*cgname == '/')\n\t\tcgname++;\n\tslash = strchr(cgname, '/');\n\tif (slash)\n\t\t*slash = '\\0';\n\n\tcgpath = must_make_path(h->mountpoint, h->base_cgroup, cgname, NULL);\n\tif (slash)\n\t\t*slash = '/';\n\tif (mkdir(cgpath, 0755) < 0 && errno != EEXIST) {\n\t\tSYSERROR(\"Failed to create '%s'\", cgpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tclonechildrenpath = must_make_path(cgpath, \"cgroup.clone_children\", NULL);\n\tif (!file_exists(clonechildrenpath)) { /* unified hierarchy doesn't have clone_children */\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\tif (lxc_read_from_file(clonechildrenpath, &v, 1) < 0) {\n\t\tSYSERROR(\"Failed to read '%s'\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\t/* Make sure any isolated cpus are removed from cpuset.cpus. */\n\tif (!filter_and_set_cpus(cgpath, v == '1')) {\n\t\tSYSERROR(\"Failed to remove isolated cpus.\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn false;\n\t}\n\n\tif (v == '1') {  /* already set for us by someone else */\n\t\tDEBUG(\"\\\"cgroup.clone_children\\\" was already set to \\\"1\\\".\");\n\t\tfree(clonechildrenpath);\n\t\tfree(cgpath);\n\t\treturn true;\n\t}\n\n\t/* copy parent's settings */\n\tif (!copy_parent_file(cgpath, \"cpuset.mems\")) {\n\t\tSYSERROR(\"Failed to copy \\\"cpuset.mems\\\" settings.\");\n\t\tfree(cgpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(cgpath);\n\n\tif (lxc_write_to_file(clonechildrenpath, \"1\", 1, false) < 0) {\n\t\t/* Set clone_children so children inherit our settings */\n\t\tSYSERROR(\"Failed to write 1 to %s\", clonechildrenpath);\n\t\tfree(clonechildrenpath);\n\t\treturn false;\n\t}\n\tfree(clonechildrenpath);\n\treturn true;\n}"
  },
  {
    "function_name": "copy_parent_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "557-592",
    "snippet": "static bool copy_parent_file(char *path, char *file)\n{\n\tchar *lastslash, *value = NULL, *fpath, oldv;\n\tint len = 0;\n\tint ret;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"cgfsng:copy_parent_file: bad path %s\", path);\n\t\treturn false;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, file, NULL);\n\tlen = lxc_read_from_file(fpath, NULL, 0);\n\tif (len <= 0)\n\t\tgoto bad;\n\tvalue = must_alloc(len + 1);\n\tif (lxc_read_from_file(fpath, value, len) != len)\n\t\tgoto bad;\n\tfree(fpath);\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, file, NULL);\n\tret = lxc_write_to_file(fpath, value, len, false);\n\tif (ret < 0)\n\t\tSYSERROR(\"Unable to write %s to %s\", value, fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn ret >= 0;\n\nbad:\n\tSYSERROR(\"Error reading '%s'\", fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Error reading '%s'\"",
            "fpath"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Unable to write %s to %s\"",
            "value",
            "fpath"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fpath",
            "value",
            "len",
            "false"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "path",
            "file",
            "NULL"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_from_file",
          "args": [
            "fpath",
            "value",
            "len"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "len + 1"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"cgfsng:copy_parent_file: bad path %s\"",
            "path"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool copy_parent_file(char *path, char *file)\n{\n\tchar *lastslash, *value = NULL, *fpath, oldv;\n\tint len = 0;\n\tint ret;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"cgfsng:copy_parent_file: bad path %s\", path);\n\t\treturn false;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, file, NULL);\n\tlen = lxc_read_from_file(fpath, NULL, 0);\n\tif (len <= 0)\n\t\tgoto bad;\n\tvalue = must_alloc(len + 1);\n\tif (lxc_read_from_file(fpath, value, len) != len)\n\t\tgoto bad;\n\tfree(fpath);\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, file, NULL);\n\tret = lxc_write_to_file(fpath, value, len, false);\n\tif (ret < 0)\n\t\tSYSERROR(\"Unable to write %s to %s\", value, fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn ret >= 0;\n\nbad:\n\tSYSERROR(\"Error reading '%s'\", fpath);\n\tfree(fpath);\n\tfree(value);\n\treturn false;\n}"
  },
  {
    "function_name": "filter_and_set_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "420-554",
    "snippet": "static bool filter_and_set_cpus(char *path, bool am_initialized)\n{\n\tchar *lastslash, *fpath, oldv;\n\tint ret;\n\tssize_t i;\n\n\tssize_t maxposs = 0, maxisol = 0;\n\tchar *cpulist = NULL, *posscpus = NULL, *isolcpus = NULL;\n\tuint32_t *possmask = NULL, *isolmask = NULL;\n\tbool bret = false, flipped_bit = false;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"Invalid path: %s.\", path);\n\t\treturn bret;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tposscpus = read_file(fpath);\n\tif (!posscpus) {\n\t\tSYSERROR(\"Could not read file: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\n\t/* Get maximum number of cpus found in possible cpuset. */\n\tmaxposs = get_max_cpus(posscpus);\n\tif (maxposs < 0)\n\t\tgoto on_error;\n\n\tif (!file_exists(__ISOL_CPUS)) {\n\t\t/* This system doesn't expose isolated cpus. */\n\t\tDEBUG(\"Path: \"__ISOL_CPUS\" to read isolated cpus from does not exist.\\n\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\tisolcpus = read_file(__ISOL_CPUS);\n\tif (!isolcpus) {\n\t\tSYSERROR(\"Could not read file \"__ISOL_CPUS);\n\t\tgoto on_error;\n\t}\n\tif (!isdigit(isolcpus[0])) {\n\t\tDEBUG(\"No isolated cpus detected.\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\t/* Get maximum number of cpus found in isolated cpuset. */\n\tmaxisol = get_max_cpus(isolcpus);\n\tif (maxisol < 0)\n\t\tgoto on_error;\n\n\tif (maxposs < maxisol)\n\t\tmaxposs = maxisol;\n\tmaxposs++;\n\n\tpossmask = lxc_cpumask(posscpus, maxposs);\n\tif (!possmask) {\n\t\tERROR(\"Could not create cpumask for all possible cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tisolmask = lxc_cpumask(isolcpus, maxposs);\n\tif (!isolmask) {\n\t\tERROR(\"Could not create cpumask for all isolated cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tfor (i = 0; i <= maxposs; i++) {\n\t\tif (is_set(i, isolmask) && is_set(i, possmask)) {\n\t\t\tflipped_bit = true;\n\t\t\tclear_bit(i, possmask);\n\t\t}\n\t}\n\n\tif (!flipped_bit) {\n\t\tDEBUG(\"No isolated cpus present in cpuset.\");\n\t\tgoto on_success;\n\t}\n\tDEBUG(\"Removed isolated cpus from cpuset.\");\n\n\tcpulist = lxc_cpumask_to_cpulist(possmask, maxposs);\n\tif (!cpulist) {\n\t\tERROR(\"Could not create cpu list.\\n\");\n\t\tgoto on_error;\n\t}\n\ncopy_parent:\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tret = lxc_write_to_file(fpath, cpulist, strlen(cpulist), false);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not write cpu list to: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\non_success:\n\tbret = true;\n\non_error:\n\tfree(fpath);\n\n\tfree(isolcpus);\n\tfree(isolmask);\n\n\tif (posscpus != cpulist)\n\t\tfree(posscpus);\n\tfree(possmask);\n\n\tfree(cpulist);\n\treturn bret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define __ISOL_CPUS \"/sys/devices/system/cpu/isolated\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cpulist"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not write cpu list to: %s.\\n\"",
            "fpath"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_write_to_file",
          "args": [
            "fpath",
            "cpulist",
            "strlen(cpulist)",
            "false"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "934-960",
          "snippet": "int lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_write_to_file(const char *filename, const void* buf, size_t count, bool add_newline)\n{\n\tint fd, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_CLOEXEC, 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tret = lxc_write_nointr(fd, buf, count);\n\tif (ret < 0)\n\t\tgoto out_error;\n\tif ((size_t)ret != count)\n\t\tgoto out_error;\n\tif (add_newline) {\n\t\tret = lxc_write_nointr(fd, \"\\n\", 1);\n\t\tif (ret != 1)\n\t\t\tgoto out_error;\n\t}\n\tclose(fd);\n\treturn 0;\n\nout_error:\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cpulist"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_make_path",
          "args": [
            "path",
            "\"cpuset.cpus\"",
            "NULL"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "must_make_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1172-1193",
          "snippet": "static char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_make_path(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t full_len = strlen(first);\n\n\tdest = must_copy_string(first);\n\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tfull_len += strlen(cur);\n\t\tif (cur[0] != '/')\n\t\t\tfull_len++;\n\t\tdest = must_realloc(dest, full_len + 1);\n\t\tif (cur[0] != '/')\n\t\t\tstrcat(dest, \"/\");\n\t\tstrcat(dest, cur);\n\t}\n\tva_end(args);\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not create cpu list.\\n\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cpumask_to_cpulist",
          "args": [
            "possmask",
            "maxposs"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cpumask_to_cpulist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "361-382",
          "snippet": "static char *lxc_cpumask_to_cpulist(uint32_t *bitarr, size_t nbits)\n{\n\tsize_t i;\n\tint ret;\n\tchar numstr[LXC_NUMSTRLEN64] = {0};\n\tchar **cpulist = NULL;\n\n\tfor (i = 0; i <= nbits; i++) {\n\t\tif (is_set(i, bitarr)) {\n\t\t\tret = snprintf(numstr, LXC_NUMSTRLEN64, \"%zu\", i);\n\t\t\tif (ret < 0 || (size_t)ret >= LXC_NUMSTRLEN64) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (lxc_append_string(&cpulist, numstr) < 0) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn lxc_string_join(\",\", (const char **)cpulist, false);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *lxc_cpumask_to_cpulist(uint32_t *bitarr, size_t nbits)\n{\n\tsize_t i;\n\tint ret;\n\tchar numstr[LXC_NUMSTRLEN64] = {0};\n\tchar **cpulist = NULL;\n\n\tfor (i = 0; i <= nbits; i++) {\n\t\tif (is_set(i, bitarr)) {\n\t\t\tret = snprintf(numstr, LXC_NUMSTRLEN64, \"%zu\", i);\n\t\t\tif (ret < 0 || (size_t)ret >= LXC_NUMSTRLEN64) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (lxc_append_string(&cpulist, numstr) < 0) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn lxc_string_join(\",\", (const char **)cpulist, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Removed isolated cpus from cpuset.\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"No isolated cpus present in cpuset.\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "i",
            "possmask"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "308-311",
          "snippet": "static void clear_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] &= ~(1 << (bit % NBITS));\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NBITS 32 /* bits in uint32_t */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic void clear_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] &= ~(1 << (bit % NBITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_set",
          "args": [
            "i",
            "possmask"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "is_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "313-316",
          "snippet": "static bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NBITS 32 /* bits in uint32_t */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not create cpumask for all isolated cpus.\\n\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Could not create cpumask for all possible cpus.\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_max_cpus",
          "args": [
            "isolcpus"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "384-417",
          "snippet": "static ssize_t get_max_cpus(char *cpulist)\n{\n\tchar *c1, *c2;\n\tchar *maxcpus = cpulist;\n\tsize_t cpus = 0;\n\n\tc1 = strrchr(maxcpus, ',');\n\tif (c1)\n\t\tc1++;\n\n\tc2 = strrchr(maxcpus, '-');\n\tif (c2)\n\t\tc2++;\n\n\tif (!c1 && !c2)\n\t\tc1 = maxcpus;\n\telse if (c1 > c2)\n\t\tc2 = c1;\n\telse if (c1 < c2)\n\t\tc1 = c2;\n\telse if (!c1 && c2) // The reverse case is obvs. not needed.\n\t\tc1 = c2;\n\n\t/* If the above logic is correct, c1 should always hold a valid string\n\t * here.\n\t */\n\n\terrno = 0;\n\tcpus = strtoul(c1, NULL, 0);\n\tif (errno != 0)\n\t\treturn -1;\n\n\treturn cpus;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic ssize_t get_max_cpus(char *cpulist)\n{\n\tchar *c1, *c2;\n\tchar *maxcpus = cpulist;\n\tsize_t cpus = 0;\n\n\tc1 = strrchr(maxcpus, ',');\n\tif (c1)\n\t\tc1++;\n\n\tc2 = strrchr(maxcpus, '-');\n\tif (c2)\n\t\tc2++;\n\n\tif (!c1 && !c2)\n\t\tc1 = maxcpus;\n\telse if (c1 > c2)\n\t\tc2 = c1;\n\telse if (c1 < c2)\n\t\tc1 = c2;\n\telse if (!c1 && c2) // The reverse case is obvs. not needed.\n\t\tc1 = c2;\n\n\t/* If the above logic is correct, c1 should always hold a valid string\n\t * here.\n\t */\n\n\terrno = 0;\n\tcpus = strtoul(c1, NULL, 0);\n\tif (errno != 0)\n\t\treturn -1;\n\n\treturn cpus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Copying cpuset of parent cgroup.\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"No isolated cpus detected.\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "isolcpus[0]"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not read file \"__ISOL_CPUS"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_file",
          "args": [
            "__ISOL_CPUS"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "read_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "279-296",
          "snippet": "static char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Copying cpuset of parent cgroup.\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Path: \"__ISOL_CPUS\" to read isolated cpus from does not exist.\\n\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "__ISOL_CPUS"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1240-1245",
          "snippet": "bool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nbool file_exists(const char *f)\n{\n\tstruct stat statbuf;\n\n\treturn stat(f, &statbuf) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"Could not read file: %s.\\n\"",
            "fpath"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid path: %s.\"",
            "path"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define __ISOL_CPUS \"/sys/devices/system/cpu/isolated\"\n\nstatic bool filter_and_set_cpus(char *path, bool am_initialized)\n{\n\tchar *lastslash, *fpath, oldv;\n\tint ret;\n\tssize_t i;\n\n\tssize_t maxposs = 0, maxisol = 0;\n\tchar *cpulist = NULL, *posscpus = NULL, *isolcpus = NULL;\n\tuint32_t *possmask = NULL, *isolmask = NULL;\n\tbool bret = false, flipped_bit = false;\n\n\tlastslash = strrchr(path, '/');\n\tif (!lastslash) { // bug...  this shouldn't be possible\n\t\tERROR(\"Invalid path: %s.\", path);\n\t\treturn bret;\n\t}\n\toldv = *lastslash;\n\t*lastslash = '\\0';\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tposscpus = read_file(fpath);\n\tif (!posscpus) {\n\t\tSYSERROR(\"Could not read file: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\n\t/* Get maximum number of cpus found in possible cpuset. */\n\tmaxposs = get_max_cpus(posscpus);\n\tif (maxposs < 0)\n\t\tgoto on_error;\n\n\tif (!file_exists(__ISOL_CPUS)) {\n\t\t/* This system doesn't expose isolated cpus. */\n\t\tDEBUG(\"Path: \"__ISOL_CPUS\" to read isolated cpus from does not exist.\\n\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\tisolcpus = read_file(__ISOL_CPUS);\n\tif (!isolcpus) {\n\t\tSYSERROR(\"Could not read file \"__ISOL_CPUS);\n\t\tgoto on_error;\n\t}\n\tif (!isdigit(isolcpus[0])) {\n\t\tDEBUG(\"No isolated cpus detected.\");\n\t\tcpulist = posscpus;\n\t\t/* No isolated cpus but we weren't already initialized by\n\t\t * someone. We should simply copy the parents cpuset.cpus\n\t\t * values.\n\t\t */\n\t\tif (!am_initialized) {\n\t\t\tDEBUG(\"Copying cpuset of parent cgroup.\");\n\t\t\tgoto copy_parent;\n\t\t}\n\t\t/* No isolated cpus but we were already initialized by someone.\n\t\t * Nothing more to do for us.\n\t\t */\n\t\tgoto on_success;\n\t}\n\n\t/* Get maximum number of cpus found in isolated cpuset. */\n\tmaxisol = get_max_cpus(isolcpus);\n\tif (maxisol < 0)\n\t\tgoto on_error;\n\n\tif (maxposs < maxisol)\n\t\tmaxposs = maxisol;\n\tmaxposs++;\n\n\tpossmask = lxc_cpumask(posscpus, maxposs);\n\tif (!possmask) {\n\t\tERROR(\"Could not create cpumask for all possible cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tisolmask = lxc_cpumask(isolcpus, maxposs);\n\tif (!isolmask) {\n\t\tERROR(\"Could not create cpumask for all isolated cpus.\\n\");\n\t\tgoto on_error;\n\t}\n\n\tfor (i = 0; i <= maxposs; i++) {\n\t\tif (is_set(i, isolmask) && is_set(i, possmask)) {\n\t\t\tflipped_bit = true;\n\t\t\tclear_bit(i, possmask);\n\t\t}\n\t}\n\n\tif (!flipped_bit) {\n\t\tDEBUG(\"No isolated cpus present in cpuset.\");\n\t\tgoto on_success;\n\t}\n\tDEBUG(\"Removed isolated cpus from cpuset.\");\n\n\tcpulist = lxc_cpumask_to_cpulist(possmask, maxposs);\n\tif (!cpulist) {\n\t\tERROR(\"Could not create cpu list.\\n\");\n\t\tgoto on_error;\n\t}\n\ncopy_parent:\n\t*lastslash = oldv;\n\tfpath = must_make_path(path, \"cpuset.cpus\", NULL);\n\tret = lxc_write_to_file(fpath, cpulist, strlen(cpulist), false);\n\tif (ret < 0) {\n\t\tSYSERROR(\"Could not write cpu list to: %s.\\n\", fpath);\n\t\tgoto on_error;\n\t}\n\non_success:\n\tbret = true;\n\non_error:\n\tfree(fpath);\n\n\tfree(isolcpus);\n\tfree(isolmask);\n\n\tif (posscpus != cpulist)\n\t\tfree(posscpus);\n\tfree(possmask);\n\n\tfree(cpulist);\n\treturn bret;\n}"
  },
  {
    "function_name": "get_max_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "384-417",
    "snippet": "static ssize_t get_max_cpus(char *cpulist)\n{\n\tchar *c1, *c2;\n\tchar *maxcpus = cpulist;\n\tsize_t cpus = 0;\n\n\tc1 = strrchr(maxcpus, ',');\n\tif (c1)\n\t\tc1++;\n\n\tc2 = strrchr(maxcpus, '-');\n\tif (c2)\n\t\tc2++;\n\n\tif (!c1 && !c2)\n\t\tc1 = maxcpus;\n\telse if (c1 > c2)\n\t\tc2 = c1;\n\telse if (c1 < c2)\n\t\tc1 = c2;\n\telse if (!c1 && c2) // The reverse case is obvs. not needed.\n\t\tc1 = c2;\n\n\t/* If the above logic is correct, c1 should always hold a valid string\n\t * here.\n\t */\n\n\terrno = 0;\n\tcpus = strtoul(c1, NULL, 0);\n\tif (errno != 0)\n\t\treturn -1;\n\n\treturn cpus;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "c1",
            "NULL",
            "0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "maxcpus",
            "'-'"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "maxcpus",
            "','"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic ssize_t get_max_cpus(char *cpulist)\n{\n\tchar *c1, *c2;\n\tchar *maxcpus = cpulist;\n\tsize_t cpus = 0;\n\n\tc1 = strrchr(maxcpus, ',');\n\tif (c1)\n\t\tc1++;\n\n\tc2 = strrchr(maxcpus, '-');\n\tif (c2)\n\t\tc2++;\n\n\tif (!c1 && !c2)\n\t\tc1 = maxcpus;\n\telse if (c1 > c2)\n\t\tc2 = c1;\n\telse if (c1 < c2)\n\t\tc1 = c2;\n\telse if (!c1 && c2) // The reverse case is obvs. not needed.\n\t\tc1 = c2;\n\n\t/* If the above logic is correct, c1 should always hold a valid string\n\t * here.\n\t */\n\n\terrno = 0;\n\tcpus = strtoul(c1, NULL, 0);\n\tif (errno != 0)\n\t\treturn -1;\n\n\treturn cpus;\n}"
  },
  {
    "function_name": "lxc_cpumask_to_cpulist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "361-382",
    "snippet": "static char *lxc_cpumask_to_cpulist(uint32_t *bitarr, size_t nbits)\n{\n\tsize_t i;\n\tint ret;\n\tchar numstr[LXC_NUMSTRLEN64] = {0};\n\tchar **cpulist = NULL;\n\n\tfor (i = 0; i <= nbits; i++) {\n\t\tif (is_set(i, bitarr)) {\n\t\t\tret = snprintf(numstr, LXC_NUMSTRLEN64, \"%zu\", i);\n\t\t\tif (ret < 0 || (size_t)ret >= LXC_NUMSTRLEN64) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (lxc_append_string(&cpulist, numstr) < 0) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn lxc_string_join(\",\", (const char **)cpulist, false);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\",\"",
            "(const char **)cpulist",
            "false"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)cpulist",
            "free"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_append_string",
          "args": [
            "&cpulist",
            "numstr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1947-1963",
          "snippet": "int lxc_append_string(char ***list, char *entry)\n{\n\tchar *copy;\n\tint newentry;\n\n\tnewentry = lxc_append_null_to_list((void ***)list);\n\tif (newentry < 0)\n\t\treturn -1;\n\n\tcopy = strdup(entry);\n\tif (!copy)\n\t\treturn -1;\n\n\t(*list)[newentry] = copy;\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_append_string(char ***list, char *entry)\n{\n\tchar *copy;\n\tint newentry;\n\n\tnewentry = lxc_append_null_to_list((void ***)list);\n\tif (newentry < 0)\n\t\treturn -1;\n\n\tcopy = strdup(entry);\n\tif (!copy)\n\t\treturn -1;\n\n\t(*list)[newentry] = copy;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "numstr",
            "LXC_NUMSTRLEN64",
            "\"%zu\"",
            "i"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_set",
          "args": [
            "i",
            "bitarr"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "is_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "313-316",
          "snippet": "static bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NBITS 32 /* bits in uint32_t */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *lxc_cpumask_to_cpulist(uint32_t *bitarr, size_t nbits)\n{\n\tsize_t i;\n\tint ret;\n\tchar numstr[LXC_NUMSTRLEN64] = {0};\n\tchar **cpulist = NULL;\n\n\tfor (i = 0; i <= nbits; i++) {\n\t\tif (is_set(i, bitarr)) {\n\t\t\tret = snprintf(numstr, LXC_NUMSTRLEN64, \"%zu\", i);\n\t\t\tif (ret < 0 || (size_t)ret >= LXC_NUMSTRLEN64) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (lxc_append_string(&cpulist, numstr) < 0) {\n\t\t\t\tlxc_free_array((void **)cpulist, free);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn lxc_string_join(\",\", (const char **)cpulist, false);\n}"
  },
  {
    "function_name": "lxc_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "326-358",
    "snippet": "static uint32_t *lxc_cpumask(char *buf, size_t nbits)\n{\n\tchar *token;\n\tchar *saveptr = NULL;\n\tsize_t arrlen = BITS_TO_LONGS(nbits);\n\tuint32_t *bitarr = calloc(arrlen, sizeof(uint32_t));\n\tif (!bitarr)\n\t\treturn NULL;\n\n\tfor (; (token = strtok_r(buf, \",\", &saveptr)); buf = NULL) {\n\t\terrno = 0;\n\t\tunsigned start = strtoul(token, NULL, 0);\n\t\tunsigned end = start;\n\n\t\tchar *range = strchr(token, '-');\n\t\tif (range)\n\t\t\tend = strtoul(range + 1, NULL, 0);\n\t\tif (!(start <= end)) {\n\t\t\tfree(bitarr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (end >= nbits) {\n\t\t\tfree(bitarr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\twhile (start <= end)\n\t\t\tset_bit(start++, bitarr);\n\t}\n\n\treturn bitarr;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "start++",
            "bitarr"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "303-306",
          "snippet": "static void set_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] |= (1 << (bit % NBITS));\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NBITS 32 /* bits in uint32_t */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic void set_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] |= (1 << (bit % NBITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bitarr"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "range + 1",
            "NULL",
            "0"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "token",
            "'-'"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "token",
            "NULL",
            "0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "buf",
            "\",\"",
            "&saveptr"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "arrlen",
            "sizeof(uint32_t)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "nbits"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic uint32_t *lxc_cpumask(char *buf, size_t nbits)\n{\n\tchar *token;\n\tchar *saveptr = NULL;\n\tsize_t arrlen = BITS_TO_LONGS(nbits);\n\tuint32_t *bitarr = calloc(arrlen, sizeof(uint32_t));\n\tif (!bitarr)\n\t\treturn NULL;\n\n\tfor (; (token = strtok_r(buf, \",\", &saveptr)); buf = NULL) {\n\t\terrno = 0;\n\t\tunsigned start = strtoul(token, NULL, 0);\n\t\tunsigned end = start;\n\n\t\tchar *range = strchr(token, '-');\n\t\tif (range)\n\t\t\tend = strtoul(range + 1, NULL, 0);\n\t\tif (!(start <= end)) {\n\t\t\tfree(bitarr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (end >= nbits) {\n\t\t\tfree(bitarr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\twhile (start <= end)\n\t\t\tset_bit(start++, bitarr);\n\t}\n\n\treturn bitarr;\n}"
  },
  {
    "function_name": "is_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "313-316",
    "snippet": "static bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NBITS 32 /* bits in uint32_t */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic bool is_set(unsigned bit, uint32_t *bitarr)\n{\n\treturn (bitarr[bit / NBITS] & (1 << (bit % NBITS))) != 0;\n}"
  },
  {
    "function_name": "clear_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "308-311",
    "snippet": "static void clear_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] &= ~(1 << (bit % NBITS));\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NBITS 32 /* bits in uint32_t */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic void clear_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] &= ~(1 << (bit % NBITS));\n}"
  },
  {
    "function_name": "set_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "303-306",
    "snippet": "static void set_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] |= (1 << (bit % NBITS));\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NBITS 32 /* bits in uint32_t */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define NBITS 32 /* bits in uint32_t */\n\nstatic void set_bit(unsigned bit, uint32_t *bitarr)\n{\n\tbitarr[bit / NBITS] |= (1 << (bit % NBITS));\n}"
  },
  {
    "function_name": "read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "279-296",
    "snippet": "static char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_line",
          "args": [
            "&buf",
            "fulllen",
            "line",
            "linelen"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "append_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "269-276",
          "snippet": "static void append_line(char **dest, size_t oldlen, char *new, size_t newlen)\n{\n\tsize_t full = oldlen + newlen;\n\n\tbatch_realloc(dest, oldlen, full + 1);\n\n\tmemcpy(*dest + oldlen, new, newlen + 1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void append_line(char **dest, size_t oldlen, char *new, size_t newlen)\n{\n\tsize_t full = oldlen + newlen;\n\n\tbatch_realloc(dest, oldlen, full + 1);\n\n\tmemcpy(*dest + oldlen, new, newlen + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&len",
            "f"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fnam",
            "\"r\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *read_file(char *fnam)\n{\n\tFILE *f;\n\tchar *line = NULL, *buf = NULL;\n\tsize_t len = 0, fulllen = 0;\n\tint linelen;\n\n\tf = fopen(fnam, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\twhile ((linelen = getline(&line, &len, f)) != -1) {\n\t\tappend_line(&buf, fulllen, line, linelen);\n\t\tfulllen += linelen;\n\t}\n\tfclose(f);\n\tfree(line);\n\treturn buf;\n}"
  },
  {
    "function_name": "append_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "269-276",
    "snippet": "static void append_line(char **dest, size_t oldlen, char *new, size_t newlen)\n{\n\tsize_t full = oldlen + newlen;\n\n\tbatch_realloc(dest, oldlen, full + 1);\n\n\tmemcpy(*dest + oldlen, new, newlen + 1);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*dest + oldlen",
            "new",
            "newlen + 1"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "batch_realloc",
          "args": [
            "dest",
            "oldlen",
            "full + 1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "batch_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "259-267",
          "snippet": "static void batch_realloc(char **mem, size_t oldlen, size_t newlen)\n{\n\tint newbatches = (newlen / BATCH_SIZE) + 1;\n\tint oldbatches = (oldlen / BATCH_SIZE) + 1;\n\n\tif (!*mem || newbatches > oldbatches) {\n\t\t*mem = must_realloc(*mem, newbatches * BATCH_SIZE);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define BATCH_SIZE 50"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define BATCH_SIZE 50\n\nstatic void batch_realloc(char **mem, size_t oldlen, size_t newlen)\n{\n\tint newbatches = (newlen / BATCH_SIZE) + 1;\n\tint oldbatches = (oldlen / BATCH_SIZE) + 1;\n\n\tif (!*mem || newbatches > oldbatches) {\n\t\t*mem = must_realloc(*mem, newbatches * BATCH_SIZE);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void append_line(char **dest, size_t oldlen, char *new, size_t newlen)\n{\n\tsize_t full = oldlen + newlen;\n\n\tbatch_realloc(dest, oldlen, full + 1);\n\n\tmemcpy(*dest + oldlen, new, newlen + 1);\n}"
  },
  {
    "function_name": "batch_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "259-267",
    "snippet": "static void batch_realloc(char **mem, size_t oldlen, size_t newlen)\n{\n\tint newbatches = (newlen / BATCH_SIZE) + 1;\n\tint oldbatches = (oldlen / BATCH_SIZE) + 1;\n\n\tif (!*mem || newbatches > oldbatches) {\n\t\t*mem = must_realloc(*mem, newbatches * BATCH_SIZE);\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define BATCH_SIZE 50"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_realloc",
          "args": [
            "*mem",
            "newbatches * BATCH_SIZE"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define BATCH_SIZE 50\n\nstatic void batch_realloc(char **mem, size_t oldlen, size_t newlen)\n{\n\tint newbatches = (newlen / BATCH_SIZE) + 1;\n\tint oldbatches = (oldlen / BATCH_SIZE) + 1;\n\n\tif (!*mem || newbatches > oldbatches) {\n\t\t*mem = must_realloc(*mem, newbatches * BATCH_SIZE);\n\t}\n}"
  },
  {
    "function_name": "get_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "243-254",
    "snippet": "struct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct hierarchy **hierarchies;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "string_in_list",
          "args": [
            "hierarchies[i]->controllers",
            "c"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "182-193",
          "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstruct hierarchy **hierarchies;\n\nstruct hierarchy *get_hierarchy(const char *c)\n{\n\tint i;\n\n\tif (!hierarchies)\n\t\treturn NULL;\n\tfor (i = 0; hierarchies[i]; i++) {\n\t\tif (string_in_list(hierarchies[i]->controllers, c))\n\t\t\treturn hierarchies[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_handler_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "231-237",
    "snippet": "static void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void free_handler_data(struct cgfsng_handler_data *d)\n{\n\tfree(d->cgroup_pattern);\n\tfree(d->container_cgroup);\n\tfree(d->name);\n\tfree(d);\n}"
  },
  {
    "function_name": "must_append_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "208-229",
    "snippet": "static void must_append_controller(char **klist, char **nlist, char ***clist, char *entry)\n{\n\tint newentry;\n\tchar *copy;\n\n\tif (string_in_list(klist, entry) && string_in_list(nlist, entry)) {\n\t\tERROR(\"Refusing to use ambiguous controller '%s'\", entry);\n\t\tERROR(\"It is both a named and kernel subsystem\");\n\t\treturn;\n\t}\n\n\tnewentry = append_null_to_list((void ***)clist);\n\n\tif (strncmp(entry, \"name=\", 5) == 0)\n\t\tcopy = must_copy_string(entry);\n\telse if (string_in_list(klist, entry))\n\t\tcopy = must_copy_string(entry);\n\telse\n\t\tcopy = must_prefix_named(entry);\n\n\t(*clist)[newentry] = copy;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_prefix_named",
          "args": [
            "entry"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "must_prefix_named",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "150-158",
          "snippet": "static char *must_prefix_named(char *entry)\n{\n\tchar *ret;\n\tsize_t len = strlen(entry);\n\n\tret = must_alloc(len + 6);\n\tsnprintf(ret, len + 6, \"name=%s\", entry);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_prefix_named(char *entry)\n{\n\tchar *ret;\n\tsize_t len = strlen(entry);\n\n\tret = must_alloc(len + 6);\n\tsnprintf(ret, len + 6, \"name=%s\", entry);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "must_copy_string",
          "args": [
            "entry"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "must_copy_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "133-143",
          "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_in_list",
          "args": [
            "klist",
            "entry"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "string_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "182-193",
          "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry",
            "\"name=\"",
            "5"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_null_to_list",
          "args": [
            "(void ***)clist"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "append_null_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "166-176",
          "snippet": "static int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"It is both a named and kernel subsystem\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Refusing to use ambiguous controller '%s'\"",
            "entry"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void must_append_controller(char **klist, char **nlist, char ***clist, char *entry)\n{\n\tint newentry;\n\tchar *copy;\n\n\tif (string_in_list(klist, entry) && string_in_list(nlist, entry)) {\n\t\tERROR(\"Refusing to use ambiguous controller '%s'\", entry);\n\t\tERROR(\"It is both a named and kernel subsystem\");\n\t\treturn;\n\t}\n\n\tnewentry = append_null_to_list((void ***)clist);\n\n\tif (strncmp(entry, \"name=\", 5) == 0)\n\t\tcopy = must_copy_string(entry);\n\telse if (string_in_list(klist, entry))\n\t\tcopy = must_copy_string(entry);\n\telse\n\t\tcopy = must_prefix_named(entry);\n\n\t(*clist)[newentry] = copy;\n}"
  },
  {
    "function_name": "string_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "182-193",
    "snippet": "static bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "list[i]",
            "entry"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic bool string_in_list(char **list, const char *entry)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\tfor (i = 0; list[i]; i++)\n\t\tif (strcmp(list[i], entry) == 0)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "append_null_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "166-176",
    "snippet": "static int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_realloc",
          "args": [
            "*list",
            "(newentry + 2) * sizeof(void **)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic int append_null_to_list(void ***list)\n{\n\tint newentry = 0;\n\n\tif (*list)\n\t\tfor (; (*list)[newentry]; newentry++);\n\n\t*list = must_realloc(*list, (newentry + 2) * sizeof(void **));\n\t(*list)[newentry + 1] = NULL;\n\treturn newentry;\n}"
  },
  {
    "function_name": "must_prefix_named",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "150-158",
    "snippet": "static char *must_prefix_named(char *entry)\n{\n\tchar *ret;\n\tsize_t len = strlen(entry);\n\n\tret = must_alloc(len + 6);\n\tsnprintf(ret, len + 6, \"name=%s\", entry);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ret",
            "len + 6",
            "\"name=%s\"",
            "entry"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "must_alloc",
          "args": [
            "len + 6"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "must_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "127-130",
          "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_prefix_named(char *entry)\n{\n\tchar *ret;\n\tsize_t len = strlen(entry);\n\n\tret = must_alloc(len + 6);\n\tsnprintf(ret, len + 6, \"name=%s\", entry);\n\treturn ret;\n}"
  },
  {
    "function_name": "must_copy_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "133-143",
    "snippet": "static char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "entry"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "must_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "127-130",
    "snippet": "static void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "must_realloc",
          "args": [
            "NULL",
            "sz"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_alloc(size_t sz)\n{\n\treturn must_realloc(NULL, sz);\n}"
  },
  {
    "function_name": "must_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "116-124",
    "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "orig",
            "sz"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_string_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
    "lines": "104-113",
    "snippet": "static void free_string_list(char **clist)\n{\n\tif (clist) {\n\t\tint i;\n\n\t\tfor (i = 0; clist[i]; i++)\n\t\t\tfree(clist[i]);\n\t\tfree(clist);\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"log.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <grp.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "clist"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "cgfsng_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "1761-1775",
          "snippet": "static bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define THAWED_LEN (strlen(THAWED))",
            "#define THAWED \"THAWED\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\n#define THAWED_LEN (strlen(THAWED))\n#define THAWED \"THAWED\"\n\nstatic bool cgfsng_unfreeze(void *hdata)\n{\n\tchar *fullpath;\n\tstruct hierarchy *h = get_hierarchy(\"freezer\");\n\n\tif (!h)\n\t\treturn false;\n\tfullpath = must_make_path(h->fullcgpath, \"freezer.state\", NULL);\n\tif (lxc_write_to_file(fullpath, THAWED, THAWED_LEN, false) != 0) {\n\t\tfree(fullpath);\n\t\treturn false;\n\t}\n\tfree(fullpath);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void free_string_list(char **clist)\n{\n\tif (clist) {\n\t\tint i;\n\n\t\tfor (i = 0; clist[i]; i++)\n\t\t\tfree(clist[i]);\n\t\tfree(clist);\n\t}\n}"
  }
]