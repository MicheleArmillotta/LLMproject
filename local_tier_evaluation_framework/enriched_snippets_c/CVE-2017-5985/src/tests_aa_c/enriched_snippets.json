[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
    "lines": "150-198",
    "snippet": "int main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\ttry_to_remove();\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (!c) {\n\t\tfprintf(stderr, \"%s: %d: failed to load first container\\n\", __FILE__, __LINE__);\n\t\texit(1);\n\t}\n\n\tif (c->is_defined(c)) {\n\t\tfprintf(stderr, \"%d: %s thought it was defined\\n\", __LINE__, MYNAME);\n\t\tgoto err;\n\t}\n\tif (!c->set_config_item(c, \"lxc.network.type\", \"empty\")) {\n\t\tfprintf(stderr, \"%s: %d: failed to set network type\\n\", __FILE__, __LINE__);\n\t\tgoto err;\n\t}\n\tc->save_config(c, NULL);\n\tif (!c->createl(c, \"busybox\", NULL, NULL, 0, NULL)) {\n\t\tfprintf(stderr, \"%s: %d: failed to create container\\n\", __FILE__, __LINE__);\n\t\tgoto err;\n\t}\n\n\tc->clear_config_item(c, \"lxc.mount.auto\");\n\tc->set_config_item(c, \"lxc.mount.entry\", \"proc proc proc\");\n\tc->set_config_item(c, \"lxc.mount.entry\", \"sysfs sys sysfs\");\n\tc->save_config(c, NULL);\n\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tfprintf(stderr, \"Error starting container\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!test_aa_policy(c)) {\n\t\tc->stop(c);\n\t\tgoto err;\n\t}\n\n\tc->stop(c);\n\n\ttry_to_remove();\n\texit(0);\n\nerr:\n\ttry_to_remove();\n\texit(1);\n}",
    "includes": [
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"test-aa\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_remove",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
          "lines": "30-39",
          "snippet": "static void try_to_remove(void)\n{\n\tstruct lxc_container *c;\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (c) {\n\t\tif (c->is_defined(c))\n\t\t\tc->destroy(c);\n\t\tlxc_container_put(c);\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [
            "#define MYNAME \"test-aa\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"test-aa\"\n\nstatic void try_to_remove(void)\n{\n\tstruct lxc_container *c;\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (c) {\n\t\tif (c->is_defined(c))\n\t\t\tc->destroy(c);\n\t\tlxc_container_put(c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->stop",
          "args": [
            "c"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_aa_policy",
          "args": [
            "c"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "test_aa_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
          "lines": "115-148",
          "snippet": "static bool test_aa_policy(struct lxc_container *c)\n{\n\tint i, ret;\n\n\tfor (i = 0; files_to_deny[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_deny[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tfprintf(stderr, \"failed - opened %s\\n\",\n\t\t\t\t\tfiles_to_deny[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_deny[i]);\n\t}\n\n\tfor (i = 0; files_to_allow[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_allow[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfprintf(stderr, \"failed - could not open %s\\n\",\n\t\t\t\t\tfiles_to_allow[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_allow[i]);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *files_to_allow[] = { \"/sys/class/net/lo/ifalias\",\n\t\t\"/proc/sys/kernel/shmmax\",\n\t\tNULL };",
            "char *files_to_deny[] = { \"/proc/mem\", \"/proc/kmem\",\n\t\t\"/sys/kernel/uevent_helper\",\n\t\t\"/proc/sys/fs/file-nr\",\n\t\t\"/sys/kernel/mm/ksm/pages_to_scan\",\n\t\t\"/proc/sys/kernel/sysrq\",\n\t\tNULL };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nchar *files_to_allow[] = { \"/sys/class/net/lo/ifalias\",\n\t\t\"/proc/sys/kernel/shmmax\",\n\t\tNULL };\nchar *files_to_deny[] = { \"/proc/mem\", \"/proc/kmem\",\n\t\t\"/sys/kernel/uevent_helper\",\n\t\t\"/proc/sys/fs/file-nr\",\n\t\t\"/sys/kernel/mm/ksm/pages_to_scan\",\n\t\t\"/proc/sys/kernel/sysrq\",\n\t\tNULL };\n\nstatic bool test_aa_policy(struct lxc_container *c)\n{\n\tint i, ret;\n\n\tfor (i = 0; files_to_deny[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_deny[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tfprintf(stderr, \"failed - opened %s\\n\",\n\t\t\t\t\tfiles_to_deny[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_deny[i]);\n\t}\n\n\tfor (i = 0; files_to_allow[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_allow[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfprintf(stderr, \"failed - could not open %s\\n\",\n\t\t\t\t\tfiles_to_allow[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_allow[i]);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error starting container\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->startl",
          "args": [
            "c",
            "0",
            "NULL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->want_daemonize",
          "args": [
            "c",
            "true"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.mount.entry\"",
            "\"sysfs sys sysfs\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.mount.entry\"",
            "\"proc proc proc\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->clear_config_item",
          "args": [
            "c",
            "\"lxc.mount.auto\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %d: failed to create container\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->createl",
          "args": [
            "c",
            "\"busybox\"",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->save_config",
          "args": [
            "c",
            "NULL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %d: failed to set network type\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->set_config_item",
          "args": [
            "c",
            "\"lxc.network.type\"",
            "\"empty\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: %s thought it was defined\\n\"",
            "__LINE__",
            "MYNAME"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %d: failed to load first container\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "MYNAME",
            "NULL"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"test-aa\"\n\nint main(int argc, char *argv[])\n{\n\tstruct lxc_container *c;\n\ttry_to_remove();\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (!c) {\n\t\tfprintf(stderr, \"%s: %d: failed to load first container\\n\", __FILE__, __LINE__);\n\t\texit(1);\n\t}\n\n\tif (c->is_defined(c)) {\n\t\tfprintf(stderr, \"%d: %s thought it was defined\\n\", __LINE__, MYNAME);\n\t\tgoto err;\n\t}\n\tif (!c->set_config_item(c, \"lxc.network.type\", \"empty\")) {\n\t\tfprintf(stderr, \"%s: %d: failed to set network type\\n\", __FILE__, __LINE__);\n\t\tgoto err;\n\t}\n\tc->save_config(c, NULL);\n\tif (!c->createl(c, \"busybox\", NULL, NULL, 0, NULL)) {\n\t\tfprintf(stderr, \"%s: %d: failed to create container\\n\", __FILE__, __LINE__);\n\t\tgoto err;\n\t}\n\n\tc->clear_config_item(c, \"lxc.mount.auto\");\n\tc->set_config_item(c, \"lxc.mount.entry\", \"proc proc proc\");\n\tc->set_config_item(c, \"lxc.mount.entry\", \"sysfs sys sysfs\");\n\tc->save_config(c, NULL);\n\n\tc->want_daemonize(c, true);\n\tif (!c->startl(c, 0, NULL)) {\n\t\tfprintf(stderr, \"Error starting container\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!test_aa_policy(c)) {\n\t\tc->stop(c);\n\t\tgoto err;\n\t}\n\n\tc->stop(c);\n\n\ttry_to_remove();\n\texit(0);\n\nerr:\n\ttry_to_remove();\n\texit(1);\n}"
  },
  {
    "function_name": "test_aa_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
    "lines": "115-148",
    "snippet": "static bool test_aa_policy(struct lxc_container *c)\n{\n\tint i, ret;\n\n\tfor (i = 0; files_to_deny[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_deny[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tfprintf(stderr, \"failed - opened %s\\n\",\n\t\t\t\t\tfiles_to_deny[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_deny[i]);\n\t}\n\n\tfor (i = 0; files_to_allow[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_allow[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfprintf(stderr, \"failed - could not open %s\\n\",\n\t\t\t\t\tfiles_to_allow[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_allow[i]);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *files_to_allow[] = { \"/sys/class/net/lo/ifalias\",\n\t\t\"/proc/sys/kernel/shmmax\",\n\t\tNULL };",
      "char *files_to_deny[] = { \"/proc/mem\", \"/proc/kmem\",\n\t\t\"/sys/kernel/uevent_helper\",\n\t\t\"/proc/sys/fs/file-nr\",\n\t\t\"/sys/kernel/mm/ksm/pages_to_scan\",\n\t\t\"/proc/sys/kernel/sysrq\",\n\t\tNULL };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"passed with %s\\n\"",
            "files_to_allow[i]"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed - could not open %s\\n\"",
            "files_to_allow[i]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"attach failed; skipping test\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_test_file_open",
          "args": [
            "c",
            "files_to_allow[i]"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "do_test_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
          "lines": "63-102",
          "snippet": "static int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}",
          "includes": [
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include \"lxc/utils.h\"",
            "#include <lxc/lxccontainer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"passed with %s\\n\"",
            "files_to_deny[i]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failed - opened %s\\n\"",
            "files_to_deny[i]"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"attach failed; skipping test\\n\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nchar *files_to_allow[] = { \"/sys/class/net/lo/ifalias\",\n\t\t\"/proc/sys/kernel/shmmax\",\n\t\tNULL };\nchar *files_to_deny[] = { \"/proc/mem\", \"/proc/kmem\",\n\t\t\"/sys/kernel/uevent_helper\",\n\t\t\"/proc/sys/fs/file-nr\",\n\t\t\"/sys/kernel/mm/ksm/pages_to_scan\",\n\t\t\"/proc/sys/kernel/sysrq\",\n\t\tNULL };\n\nstatic bool test_aa_policy(struct lxc_container *c)\n{\n\tint i, ret;\n\n\tfor (i = 0; files_to_deny[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_deny[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tfprintf(stderr, \"failed - opened %s\\n\",\n\t\t\t\t\tfiles_to_deny[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_deny[i]);\n\t}\n\n\tfor (i = 0; files_to_allow[i]; i++) {\n\t\tret = do_test_file_open(c, files_to_allow[i]);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"attach failed; skipping test\\n\");\n\t\t\treturn true;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfprintf(stderr, \"failed - could not open %s\\n\",\n\t\t\t\t\tfiles_to_allow[i]);\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(stderr, \"passed with %s\\n\", files_to_allow[i]);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_test_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
    "lines": "63-102",
    "snippet": "static int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}",
    "includes": [
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[1]"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "result",
            "\"no\"",
            "2"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read failed %d\\n\"",
            "ret"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "result",
            "sizeof(result)-1"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"attach failed\\n\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->attach",
          "args": [
            "c",
            "test_attach_write_file",
            "fnam",
            "&attach_options",
            "&pid"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pipe failed %d\\n\"",
            "ret"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int do_test_file_open(struct lxc_container *c, char *fnam)\n{\n\tint fret = -1;\n\tint ret;\n\tpid_t pid;\n\tint pipefd[2];\n\tchar result[1024];\n\tlxc_attach_options_t attach_options = LXC_ATTACH_OPTIONS_DEFAULT;\n\n\tret = pipe(pipefd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"pipe failed %d\\n\", ret);\n\t\treturn fret;\n\t}\n\tattach_options.stdout_fd = pipefd[1];\n\tattach_options.attach_flags &= ~(LXC_ATTACH_LSM_EXEC|LXC_ATTACH_DROP_CAPABILITIES);\n\tattach_options.attach_flags |= LXC_ATTACH_LSM_NOW;\n\tret = c->attach(c, test_attach_write_file, fnam, &attach_options, &pid);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"attach failed\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = read(pipefd[0], result, sizeof(result)-1);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"read failed %d\\n\", ret);\n\t\tgoto err2;\n\t}\n\n\tfret = 1;\n\tif (strncmp(result, \"no\", 2) == 0)\n\t\tfret = 0;\n\nerr2:\n\twait_for_pid(pid);\nerr1:\n\tclose(pipefd[0]);\n\tclose(pipefd[1]);\n\treturn fret;\n}"
  },
  {
    "function_name": "test_attach_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
    "lines": "41-56",
    "snippet": "static int test_attach_write_file(void* payload)\n{\n\tchar *fnam = payload;\n\tFILE *f;\n\n\tf = fopen(fnam, \"w\");\n\tif (f) {\n\t\tprintf(\"yes\\n\");\n\t\tfclose(f);\n\t\tfflush(NULL);\n\t\treturn 1;\n\t}\n\tprintf(\"no\\n\");\n\tfflush(NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "NULL"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "NULL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"yes\\n\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fnam",
            "\"w\""
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\nstatic int test_attach_write_file(void* payload)\n{\n\tchar *fnam = payload;\n\tFILE *f;\n\n\tf = fopen(fnam, \"w\");\n\tif (f) {\n\t\tprintf(\"yes\\n\");\n\t\tfclose(f);\n\t\tfflush(NULL);\n\t\treturn 1;\n\t}\n\tprintf(\"no\\n\");\n\tfflush(NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "try_to_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/aa.c",
    "lines": "30-39",
    "snippet": "static void try_to_remove(void)\n{\n\tstruct lxc_container *c;\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (c) {\n\t\tif (c->is_defined(c))\n\t\t\tc->destroy(c);\n\t\tlxc_container_put(c);\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include \"lxc/utils.h\"",
      "#include <lxc/lxccontainer.h>"
    ],
    "macros_used": [
      "#define MYNAME \"test-aa\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->destroy",
          "args": [
            "c"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "MYNAME",
            "NULL"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include \"lxc/utils.h\"\n#include <lxc/lxccontainer.h>\n\n#define MYNAME \"test-aa\"\n\nstatic void try_to_remove(void)\n{\n\tstruct lxc_container *c;\n\tc = lxc_container_new(MYNAME, NULL);\n\tif (c) {\n\t\tif (c->is_defined(c))\n\t\t\tc->destroy(c);\n\t\tlxc_container_put(c);\n\t}\n}"
  }
]