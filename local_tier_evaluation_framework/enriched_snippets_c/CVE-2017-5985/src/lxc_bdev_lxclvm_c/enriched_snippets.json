[
  {
    "function_name": "lvm_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "377-435",
    "snippet": "int lvm_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *vg, *thinpool, *fstype, *lv = n;\n\tuint64_t sz;\n\tint ret, len;\n\n\tif (!specs)\n\t\treturn -1;\n\n\tvg = specs->lvm.vg;\n\tif (!vg)\n\t\tvg = lxc_global_config_value(\"lxc.bdev.lvm.vg\");\n\n\tthinpool = specs->lvm.thinpool;\n\tif (!thinpool)\n\t\tthinpool = lxc_global_config_value(\"lxc.bdev.lvm.thin_pool\");\n\n\t/* /dev/$vg/$lv */\n\tif (specs->lvm.lv)\n\t\tlv = specs->lvm.lv;\n\n\tlen = strlen(vg) + strlen(lv) + 7;\n\tbdev->src = malloc(len);\n\tif (!bdev->src)\n\t\treturn -1;\n\n\tret = snprintf(bdev->src, len, \"/dev/%s/%s\", vg, lv);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\t// fssize is in bytes.\n\tsz = specs->fssize;\n\tif (!sz)\n\t\tsz = DEFAULT_FS_SIZE;\n\n\tif (do_lvm_create(bdev->src, sz, thinpool) < 0) {\n\t\tERROR(\"Error creating new lvm blockdev %s size %\"PRIu64\" bytes\", bdev->src, sz);\n\t\treturn -1;\n\t}\n\n\tfstype = specs->fstype;\n\tif (!fstype)\n\t\tfstype = DEFAULT_FSTYPE;\n\tif (do_mkfs(bdev->src, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tbdev->src);\n\t\treturn -1;\n\t}\n\tif (!(bdev->dest = strdup(dest)))\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating %s\"",
            "bdev->dest"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "bdev->dest",
            "0755"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dest"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating filesystem type %s on %s\"",
            "fstype",
            "bdev->src"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mkfs",
          "args": [
            "bdev->src",
            "fstype"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "709-726",
          "snippet": "int do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating new lvm blockdev %s size %\"PRIu64\" bytes\"",
            "bdev->src",
            "sz"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lvm_create",
          "args": [
            "bdev->src",
            "sz",
            "thinpool"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "do_lvm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "66-125",
          "snippet": "static int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nstatic int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "bdev->src",
            "len",
            "\"/dev/%s/%s\"",
            "vg",
            "lv"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lv"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vg"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.bdev.lvm.thin_pool\""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_create(struct bdev *bdev, const char *dest, const char *n,\n\t\tstruct bdev_specs *specs)\n{\n\tconst char *vg, *thinpool, *fstype, *lv = n;\n\tuint64_t sz;\n\tint ret, len;\n\n\tif (!specs)\n\t\treturn -1;\n\n\tvg = specs->lvm.vg;\n\tif (!vg)\n\t\tvg = lxc_global_config_value(\"lxc.bdev.lvm.vg\");\n\n\tthinpool = specs->lvm.thinpool;\n\tif (!thinpool)\n\t\tthinpool = lxc_global_config_value(\"lxc.bdev.lvm.thin_pool\");\n\n\t/* /dev/$vg/$lv */\n\tif (specs->lvm.lv)\n\t\tlv = specs->lvm.lv;\n\n\tlen = strlen(vg) + strlen(lv) + 7;\n\tbdev->src = malloc(len);\n\tif (!bdev->src)\n\t\treturn -1;\n\n\tret = snprintf(bdev->src, len, \"/dev/%s/%s\", vg, lv);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\t// fssize is in bytes.\n\tsz = specs->fssize;\n\tif (!sz)\n\t\tsz = DEFAULT_FS_SIZE;\n\n\tif (do_lvm_create(bdev->src, sz, thinpool) < 0) {\n\t\tERROR(\"Error creating new lvm blockdev %s size %\"PRIu64\" bytes\", bdev->src, sz);\n\t\treturn -1;\n\t}\n\n\tfstype = specs->fstype;\n\tif (!fstype)\n\t\tfstype = DEFAULT_FSTYPE;\n\tif (do_mkfs(bdev->src, fstype) < 0) {\n\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\tbdev->src);\n\t\treturn -1;\n\t}\n\tif (!(bdev->dest = strdup(dest)))\n\t\treturn -1;\n\n\tif (mkdir_p(bdev->dest, 0755) < 0) {\n\t\tERROR(\"Error creating %s\", bdev->dest);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lvm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "363-375",
    "snippet": "int lvm_destroy(struct bdev *orig)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (!pid) {\n\t\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\t\texeclp(\"lvremove\", \"lvremove\", \"-f\", orig->src, (char *)NULL);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn wait_for_pid(pid);\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lvremove\"",
            "\"lvremove\"",
            "\"-f\"",
            "orig->src",
            "(char *)NULL"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LVM_SUPPRESS_FD_WARNINGS\"",
            "\"1\"",
            "1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_destroy(struct bdev *orig)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (!pid) {\n\t\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\t\texeclp(\"lvremove\", \"lvremove\", \"-f\", orig->src, (char *)NULL);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn wait_for_pid(pid);\n}"
  },
  {
    "function_name": "lvm_clonepaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "280-361",
    "snippet": "int lvm_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath, int snap,\n\t\tuint64_t newsize, struct lxc_conf *conf)\n{\n\tchar fstype[100];\n\tuint64_t size = newsize;\n\tint len, ret;\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tif (strcmp(orig->type, \"lvm\")) {\n\t\tconst char *vg;\n\n\t\tif (snap) {\n\t\t\tERROR(\"LVM snapshot from %s backing store is not supported\",\n\t\t\t\torig->type);\n\t\t\treturn -1;\n\t\t}\n\t\tvg = lxc_global_config_value(\"lxc.bdev.lvm.vg\");\n\t\tlen = strlen(\"/dev/\") + strlen(vg) + strlen(cname) + 2;\n\t\tif ((new->src = malloc(len)) == NULL)\n\t\t\treturn -1;\n\t\tret = snprintf(new->src, len, \"/dev/%s/%s\", vg, cname);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -1;\n\t} else {\n\t\tnew->src = dir_new_path(orig->src, oldname, cname, oldpath, lxcpath);\n\t\tif (!new->src)\n\t\t\treturn -1;\n\t}\n\n\tif (orig->mntopts) {\n\t\tnew->mntopts = strdup(orig->mntopts);\n\t\tif (!new->mntopts)\n\t\t\treturn -1;\n\t}\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\tnew->dest = malloc(len);\n\tif (!new->dest)\n\t\treturn -1;\n\tret = snprintf(new->dest, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (is_blktype(orig)) {\n\t\tif (!newsize && blk_getsize(orig, &size) < 0) {\n\t\t\tERROR(\"Error getting size of %s\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_fs(orig, fstype, 100) < 0) {\n\t\t\tINFO(\"could not find fstype for %s, using ext3\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tsprintf(fstype, \"ext3\");\n\t\tif (!newsize)\n\t\t\tsize = DEFAULT_FS_SIZE;\n\t}\n\n\tif (snap) {\n\t\tif (lvm_snapshot(orig->src, new->src, size) < 0) {\n\t\t\tERROR(\"could not create %s snapshot of %s\", new->src, orig->src);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (do_lvm_create(new->src, size, lxc_global_config_value(\"lxc.bdev.lvm.thin_pool\")) < 0) {\n\t\t\tERROR(\"Error creating new lvm blockdev\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (do_mkfs(new->src, fstype) < 0) {\n\t\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\t\tnew->src);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating filesystem type %s on %s\"",
            "fstype",
            "new->src"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mkfs",
          "args": [
            "new->src",
            "fstype"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "709-726",
          "snippet": "int do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nint do_mkfs(const char *path, const char *fstype)\n{\n\tpid_t pid;\n\n\tif ((pid = fork()) < 0) {\n\t\tERROR(\"error forking\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// If the file is not a block device, we don't want mkfs to ask\n\t// us about whether to proceed.\n\tif (null_stdfds() < 0)\n\t\texit(1);\n\texeclp(\"mkfs\", \"mkfs\", \"-t\", fstype, path, (char *)NULL);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error creating new lvm blockdev\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lvm_create",
          "args": [
            "new->src",
            "size",
            "lxc_global_config_value(\"lxc.bdev.lvm.thin_pool\")"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "do_lvm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "66-125",
          "snippet": "static int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nstatic int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_global_config_value",
          "args": [
            "\"lxc.bdev.lvm.thin_pool\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_global_config_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "88-247",
          "snippet": "const char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nconst char *lxc_global_config_value(const char *option_name)\n{\n\tstatic const char * const options[][2] = {\n\t\t{ \"lxc.bdev.lvm.vg\",        DEFAULT_VG      },\n\t\t{ \"lxc.bdev.lvm.thin_pool\", DEFAULT_THIN_POOL },\n\t\t{ \"lxc.bdev.zfs.root\",      DEFAULT_ZFSROOT },\n\t\t{ \"lxc.bdev.rbd.rbdpool\",   DEFAULT_RBDPOOL },\n\t\t{ \"lxc.lxcpath\",            NULL            },\n\t\t{ \"lxc.default_config\",     NULL            },\n\t\t{ \"lxc.cgroup.pattern\",     NULL            },\n\t\t{ \"lxc.cgroup.use\",         NULL            },\n\t\t{ NULL, NULL },\n\t};\n\n\t/* placed in the thread local storage pool for non-bionic targets */\n#ifdef HAVE_TLS\n\tstatic __thread const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#else\n\tstatic const char *values[sizeof(options) / sizeof(options[0])] = { 0 };\n#endif\n\n\t/* user_config_path is freed as soon as it is used */\n\tchar *user_config_path = NULL;\n\n\t/*\n\t * The following variables are freed at bottom unconditionally.\n\t * So NULL the value if it is to be returned to the caller\n\t */\n\tchar *user_default_config_path = NULL;\n\tchar *user_lxc_path = NULL;\n\tchar *user_cgroup_pattern = NULL;\n\n\tif (geteuid() > 0) {\n\t\tconst char *user_home = getenv(\"HOME\");\n\t\tif (!user_home)\n\t\t\tuser_home = \"/\";\n\n\t\tuser_config_path = malloc(sizeof(char) * (22 + strlen(user_home)));\n\t\tuser_default_config_path = malloc(sizeof(char) * (26 + strlen(user_home)));\n\t\tuser_lxc_path = malloc(sizeof(char) * (19 + strlen(user_home)));\n\n\t\tsprintf(user_config_path, \"%s/.config/lxc/lxc.conf\", user_home);\n\t\tsprintf(user_default_config_path, \"%s/.config/lxc/default.conf\", user_home);\n\t\tsprintf(user_lxc_path, \"%s/.local/share/lxc/\", user_home);\n\t\tuser_cgroup_pattern = strdup(\"lxc/%n\");\n\t}\n\telse {\n\t\tuser_config_path = strdup(LXC_GLOBAL_CONF);\n\t\tuser_default_config_path = strdup(LXC_DEFAULT_CONFIG);\n\t\tuser_lxc_path = strdup(LXCPATH);\n\t\tuser_cgroup_pattern = strdup(DEFAULT_CGROUP_PATTERN);\n\t}\n\n\tconst char * const (*ptr)[2];\n\tsize_t i;\n\tchar buf[1024], *p, *p2;\n\tFILE *fin = NULL;\n\n\tfor (i = 0, ptr = options; (*ptr)[0]; ptr++, i++) {\n\t\tif (!strcmp(option_name, (*ptr)[0]))\n\t\t\tbreak;\n\t}\n\tif (!(*ptr)[0]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (values[i]) {\n\t\tfree(user_config_path);\n\t\tfree(user_default_config_path);\n\t\tfree(user_lxc_path);\n\t\tfree(user_cgroup_pattern);\n\t\treturn values[i];\n\t}\n\n\tfin = fopen_cloexec(user_config_path, \"r\");\n\tfree(user_config_path);\n\tif (fin) {\n\t\twhile (fgets(buf, 1024, fin)) {\n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tp = strstr(buf, option_name);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space in front\n\t\t\t * of the option name\n\t\t\t */\n\t\t\tfor (p2 = buf; p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp = strchr(p, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t/* see if there was just white space after\n\t\t\t * the option name\n\t\t\t */\n\t\t\tfor (p2 += strlen(option_name); p2 < p; p2++) {\n\t\t\t\tif (*p2 != ' ' && *p2 != '\\t')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p2 < p)\n\t\t\t\tcontinue;\n\t\t\tp++;\n\t\t\twhile (*p && (*p == ' ' || *p == '\\t')) p++;\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\t\t\tfree(user_lxc_path);\n\t\t\t\tuser_lxc_path = copy_global_config_value(p);\n\t\t\t\tremove_trailing_slashes(user_lxc_path);\n\t\t\t\tvalues[i] = user_lxc_path;\n\t\t\t\tuser_lxc_path = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvalues[i] = copy_global_config_value(p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* could not find value, use default */\n\tif (strcmp(option_name, \"lxc.lxcpath\") == 0) {\n\t\tremove_trailing_slashes(user_lxc_path);\n\t\tvalues[i] = user_lxc_path;\n\t\tuser_lxc_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.default_config\") == 0) {\n\t\tvalues[i] = user_default_config_path;\n\t\tuser_default_config_path = NULL;\n\t}\n\telse if (strcmp(option_name, \"lxc.cgroup.pattern\") == 0) {\n\t\tvalues[i] = user_cgroup_pattern;\n\t\tuser_cgroup_pattern = NULL;\n\t}\n\telse\n\t\tvalues[i] = (*ptr)[1];\n\n\t/* special case: if default value is NULL,\n\t * and there is no config, don't view that\n\t * as an error... */\n\tif (!values[i])\n\t\terrno = 0;\n\nout:\n\tif (fin)\n\t\tfclose(fin);\n\n\tfree(user_cgroup_pattern);\n\tfree(user_default_config_path);\n\tfree(user_lxc_path);\n\n\treturn values[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"could not create %s snapshot of %s\"",
            "new->src",
            "orig->src"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvm_snapshot",
          "args": [
            "orig->src",
            "new->src",
            "size"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "233-278",
          "snippet": "int lvm_snapshot(const char *orig, const char *path, uint64_t size)\n{\n\tint ret, pid;\n\tchar sz[24], *pathdup, *lv;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\tlv = strrchr(pathdup, '/');\n\tif (!lv) {\n\t\tfree(pathdup);\n\t\texit(EXIT_FAILURE);\n\t}\n\t*lv = '\\0';\n\tlv++;\n\n\t// check if the original lv is backed by a thin pool, in which case we\n\t// cannot specify a size that's different from the original size.\n\tret = lvm_is_thin_volume(orig);\n\tif (ret == -1) {\n\t\tfree(pathdup);\n\t\treturn -1;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!ret) {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-L\", sz, \"-n\", lv, orig, (char *)NULL);\n\t} else {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-n\", lv, orig, (char *)NULL);\n\t}\n\n\tfree(pathdup);\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_snapshot(const char *orig, const char *path, uint64_t size)\n{\n\tint ret, pid;\n\tchar sz[24], *pathdup, *lv;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\tlv = strrchr(pathdup, '/');\n\tif (!lv) {\n\t\tfree(pathdup);\n\t\texit(EXIT_FAILURE);\n\t}\n\t*lv = '\\0';\n\tlv++;\n\n\t// check if the original lv is backed by a thin pool, in which case we\n\t// cannot specify a size that's different from the original size.\n\tret = lvm_is_thin_volume(orig);\n\tif (ret == -1) {\n\t\tfree(pathdup);\n\t\treturn -1;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!ret) {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-L\", sz, \"-n\", lv, orig, (char *)NULL);\n\t} else {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-n\", lv, orig, (char *)NULL);\n\t}\n\n\tfree(pathdup);\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fstype",
            "\"ext3\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"could not find fstype for %s, using ext3\"",
            "orig->src"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detect_fs",
          "args": [
            "orig",
            "fstype",
            "100"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "detect_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "621-707",
          "snippet": "int detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);",
            "static char *linkderef(char *path, char *dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\nstatic char *linkderef(char *path, char *dest);\n\nint detect_fs(struct bdev *bdev, char *type, int len)\n{\n\tint  p[2], ret;\n\tsize_t linelen;\n\tpid_t pid;\n\tFILE *f;\n\tchar *sp1, *sp2, *sp3, *line = NULL;\n\tchar *srcdev;\n\n\tif (!bdev || !bdev->src || !bdev->dest)\n\t\treturn -1;\n\n\tsrcdev = bdev->src;\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tsrcdev = bdev->src + 5;\n\n\tret = pipe(p);\n\tif (ret < 0)\n\t\treturn -1;\n\tif ((pid = fork()) < 0)\n\t\treturn -1;\n\tif (pid > 0) {\n\t\tint status;\n\t\tclose(p[1]);\n\t\tmemset(type, 0, len);\n\t\tret = read(p[0], type, len - 1);\n\t\tclose(p[0]);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"error reading from pipe\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t} else if (ret == 0) {\n\t\t\tERROR(\"child exited early - fstype not found\");\n\t\t\twait(&status);\n\t\t\treturn -1;\n\t\t}\n\t\twait(&status);\n\t\ttype[len - 1] = '\\0';\n\t\tINFO(\"detected fstype %s for %s\", type, srcdev);\n\t\treturn ret;\n\t}\n\n\tif (unshare(CLONE_NEWNS) < 0)\n\t\texit(1);\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"Failed to make / rslave\");\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\n\tret = mount_unknown_fs(srcdev, bdev->dest, bdev->mntopts);\n\tif (ret < 0) {\n\t\tERROR(\"failed mounting %s onto %s to detect fstype\", srcdev, bdev->dest);\n\t\texit(1);\n\t}\n\t// if symlink, get the real dev name\n\tchar devpath[MAXPATHLEN];\n\tchar *l = linkderef(srcdev, devpath);\n\tif (!l)\n\t\texit(1);\n\tf = fopen(\"/proc/self/mounts\", \"r\");\n\tif (!f)\n\t\texit(1);\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsp1 = strchr(line, ' ');\n\t\tif (!sp1)\n\t\t\texit(1);\n\t\t*sp1 = '\\0';\n\t\tif (strcmp(line, l))\n\t\t\tcontinue;\n\t\tsp2 = strchr(sp1 + 1, ' ');\n\t\tif (!sp2)\n\t\t\texit(1);\n\t\t*sp2 = '\\0';\n\t\tsp3 = strchr(sp2 + 1, ' ');\n\t\tif (!sp3)\n\t\t\texit(1);\n\t\t*sp3 = '\\0';\n\t\tsp2++;\n\t\tif (write(p[1], sp2, strlen(sp2)) != strlen(sp2))\n\t\t\texit(1);\n\t\texit(0);\n\t}\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Error getting size of %s\"",
            "orig->src"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_getsize",
          "args": [
            "orig",
            "&size"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "blk_getsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "590-605",
          "snippet": "int blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [
            "#define BLKGETSIZE64 _IOR(0x12, 114, size_t)"
          ],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);",
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\n#define BLKGETSIZE64 _IOR(0x12, 114, size_t)\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\nstatic struct bdev *bdev_get(const char *type);\n\nint blk_getsize(struct bdev *bdev, uint64_t *size)\n{\n\tint fd, ret;\n\tchar *path = bdev->src;\n\n\tif (strcmp(bdev->type, \"loop\") == 0)\n\t\tpath = bdev->src + 5;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = ioctl(fd, BLKGETSIZE64, size); // size of device in bytes\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_blktype",
          "args": [
            "orig"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "is_blktype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "732-737",
          "snippet": "int is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint is_blktype(struct bdev *b)\n{\n\tif (strcmp(b->type, \"lvm\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "new->dest",
            "0755"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->dest",
            "len",
            "\"%s/%s/rootfs\"",
            "lxcpath",
            "cname"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rootfs\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lxcpath"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "orig->mntopts"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_new_path",
          "args": [
            "orig->src",
            "oldname",
            "cname",
            "oldpath",
            "lxcpath"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "dir_new_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "214-253",
          "snippet": "char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic const struct bdev_type *bdev_query(struct lxc_conf *conf, const char *src);\n\nchar *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath)\n{\n\tchar *ret, *p, *p2;\n\tint l1, l2, nlen;\n\n\tnlen = strlen(src) + 1;\n\tl1 = strlen(oldpath);\n\tp = src;\n\t/* if src starts with oldpath, look for oldname only after\n\t * that path */\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += l1;\n\t\tnlen += (strlen(lxcpath) - l1);\n\t}\n\tl2 = strlen(oldname);\n\twhile ((p = strstr(p, oldname)) != NULL) {\n\t\tp += l2;\n\t\tnlen += strlen(name) - l2;\n\t}\n\n\tret = malloc(nlen);\n\tif (!ret)\n\t\treturn NULL;\n\n\tp = ret;\n\tif (strncmp(src, oldpath, l1) == 0) {\n\t\tp += sprintf(p, \"%s\", lxcpath);\n\t\tsrc += l1;\n\t}\n\n\twhile ((p2 = strstr(src, oldname)) != NULL) {\n\t\tstrncpy(p, src, p2 - src); // copy text up to oldname\n\t\tp += p2 - src; // move target pointer (p)\n\t\tp += sprintf(p, \"%s\", name); // print new name in place of oldname\n\t\tsrc = p2 + l2;  // move src to end of oldname\n\t}\n\tsprintf(p, \"%s\", src);  // copy the rest of src\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "new->src",
            "len",
            "\"/dev/%s/%s\"",
            "vg",
            "cname"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cname"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vg"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/dev/\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"LVM snapshot from %s backing store is not supported\"",
            "orig->type"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "orig->type",
            "\"lvm\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nextern char *dir_new_path(char *src, const char *oldname, const char *name,\n\t\tconst char *oldpath, const char *lxcpath);\n\nint lvm_clonepaths(struct bdev *orig, struct bdev *new, const char *oldname,\n\t\tconst char *cname, const char *oldpath, const char *lxcpath, int snap,\n\t\tuint64_t newsize, struct lxc_conf *conf)\n{\n\tchar fstype[100];\n\tuint64_t size = newsize;\n\tint len, ret;\n\n\tif (!orig->src || !orig->dest)\n\t\treturn -1;\n\n\tif (strcmp(orig->type, \"lvm\")) {\n\t\tconst char *vg;\n\n\t\tif (snap) {\n\t\t\tERROR(\"LVM snapshot from %s backing store is not supported\",\n\t\t\t\torig->type);\n\t\t\treturn -1;\n\t\t}\n\t\tvg = lxc_global_config_value(\"lxc.bdev.lvm.vg\");\n\t\tlen = strlen(\"/dev/\") + strlen(vg) + strlen(cname) + 2;\n\t\tif ((new->src = malloc(len)) == NULL)\n\t\t\treturn -1;\n\t\tret = snprintf(new->src, len, \"/dev/%s/%s\", vg, cname);\n\t\tif (ret < 0 || ret >= len)\n\t\t\treturn -1;\n\t} else {\n\t\tnew->src = dir_new_path(orig->src, oldname, cname, oldpath, lxcpath);\n\t\tif (!new->src)\n\t\t\treturn -1;\n\t}\n\n\tif (orig->mntopts) {\n\t\tnew->mntopts = strdup(orig->mntopts);\n\t\tif (!new->mntopts)\n\t\t\treturn -1;\n\t}\n\n\tlen = strlen(lxcpath) + strlen(cname) + strlen(\"rootfs\") + 3;\n\tnew->dest = malloc(len);\n\tif (!new->dest)\n\t\treturn -1;\n\tret = snprintf(new->dest, len, \"%s/%s/rootfs\", lxcpath, cname);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\tif (mkdir_p(new->dest, 0755) < 0)\n\t\treturn -1;\n\n\tif (is_blktype(orig)) {\n\t\tif (!newsize && blk_getsize(orig, &size) < 0) {\n\t\t\tERROR(\"Error getting size of %s\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t\tif (detect_fs(orig, fstype, 100) < 0) {\n\t\t\tINFO(\"could not find fstype for %s, using ext3\", orig->src);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tsprintf(fstype, \"ext3\");\n\t\tif (!newsize)\n\t\t\tsize = DEFAULT_FS_SIZE;\n\t}\n\n\tif (snap) {\n\t\tif (lvm_snapshot(orig->src, new->src, size) < 0) {\n\t\t\tERROR(\"could not create %s snapshot of %s\", new->src, orig->src);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (do_lvm_create(new->src, size, lxc_global_config_value(\"lxc.bdev.lvm.thin_pool\")) < 0) {\n\t\t\tERROR(\"Error creating new lvm blockdev\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (do_mkfs(new->src, fstype) < 0) {\n\t\t\tERROR(\"Error creating filesystem type %s on %s\", fstype,\n\t\t\t\tnew->src);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lvm_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "233-278",
    "snippet": "int lvm_snapshot(const char *orig, const char *path, uint64_t size)\n{\n\tint ret, pid;\n\tchar sz[24], *pathdup, *lv;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\tlv = strrchr(pathdup, '/');\n\tif (!lv) {\n\t\tfree(pathdup);\n\t\texit(EXIT_FAILURE);\n\t}\n\t*lv = '\\0';\n\tlv++;\n\n\t// check if the original lv is backed by a thin pool, in which case we\n\t// cannot specify a size that's different from the original size.\n\tret = lvm_is_thin_volume(orig);\n\tif (ret == -1) {\n\t\tfree(pathdup);\n\t\treturn -1;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!ret) {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-L\", sz, \"-n\", lv, orig, (char *)NULL);\n\t} else {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-n\", lv, orig, (char *)NULL);\n\t}\n\n\tfree(pathdup);\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pathdup"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "free_btrfs_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcbtrfs.c",
          "lines": "536-547",
          "snippet": "static void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxcrsync.h\"\n#include \"lxcbtrfs.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic void free_btrfs_tree(struct my_btrfs_tree *tree)\n{\n\tint i;\n\tif (!tree)\n\t\treturn;\n\tfor (i = 0; i < tree->num;  i++) {\n\t\tfree(tree->nodes[i].name);\n\t\tfree(tree->nodes[i].dirname);\n\t}\n\tfree(tree->nodes);\n\tfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lvcreate\"",
            "\"lvcreate\"",
            "\"-s\"",
            "\"-n\"",
            "lv",
            "orig",
            "(char *)NULL"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lvcreate\"",
            "\"lvcreate\"",
            "\"-s\"",
            "\"-L\"",
            "sz",
            "\"-n\"",
            "lv",
            "orig",
            "(char *)NULL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LVM_SUPPRESS_FD_WARNINGS\"",
            "\"1\"",
            "1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvm_is_thin_volume",
          "args": [
            "orig"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_is_thin_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "223-226",
          "snippet": "int lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "pathdup",
            "'/'"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sz",
            "24",
            "\"%\"PRIu64\"b\"",
            "size"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed fork\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_snapshot(const char *orig, const char *path, uint64_t size)\n{\n\tint ret, pid;\n\tchar sz[24], *pathdup, *lv;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\tlv = strrchr(pathdup, '/');\n\tif (!lv) {\n\t\tfree(pathdup);\n\t\texit(EXIT_FAILURE);\n\t}\n\t*lv = '\\0';\n\tlv++;\n\n\t// check if the original lv is backed by a thin pool, in which case we\n\t// cannot specify a size that's different from the original size.\n\tret = lvm_is_thin_volume(orig);\n\tif (ret == -1) {\n\t\tfree(pathdup);\n\t\treturn -1;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!ret) {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-L\", sz, \"-n\", lv, orig, (char *)NULL);\n\t} else {\n\t\tret = execlp(\"lvcreate\", \"lvcreate\", \"-s\", \"-n\", lv, orig, (char *)NULL);\n\t}\n\n\tfree(pathdup);\n\texit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "lvm_is_thin_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "228-231",
    "snippet": "int lvm_is_thin_pool(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 0, 't');\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lvm_compare_lv_attr",
          "args": [
            "path",
            "0",
            "'t'"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_compare_lv_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "184-221",
          "snippet": "int lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_is_thin_pool(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 0, 't');\n}"
  },
  {
    "function_name": "lvm_is_thin_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "223-226",
    "snippet": "int lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lvm_compare_lv_attr",
          "args": [
            "path",
            "6",
            "'t'"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_compare_lv_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "184-221",
          "snippet": "int lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_is_thin_volume(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 6, 't');\n}"
  },
  {
    "function_name": "lvm_compare_lv_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "184-221",
    "snippet": "int lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "output"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_pclose",
          "args": [
            "f"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_pclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "569-599",
          "snippet": "extern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tFILE *f = NULL;\n\tpid_t child_pid = 0;\n\tint wstatus = 0;\n\tpid_t wait_pid;\n\n\tif (fp) {\n\t\tf = fp->f;\n\t\tchild_pid = fp->child_pid;\n\t\t/* free memory (we still need to close file stream) */\n\t\tfree(fp);\n\t\tfp = NULL;\n\t}\n\n\tif (!f || fclose(f)) {\n\t\tERROR(\"fclose failure\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\twait_pid = waitpid(child_pid, &wstatus, 0);\n\t} while (wait_pid == -1 && errno == EINTR);\n\n\tif (wait_pid == -1) {\n\t\tERROR(\"waitpid failure\");\n\t\treturn -1;\n\t}\n\n\treturn wstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "output",
            "12",
            "f->f"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"popen failed\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_popen",
          "args": [
            "cmd"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_popen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "469-567",
          "snippet": "extern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern struct lxc_popen_FILE *lxc_popen(const char *command)\n{\n\tstruct lxc_popen_FILE *fp = NULL;\n\tint parent_end = -1, child_end = -1;\n\tint pipe_fds[2];\n\tpid_t child_pid;\n\n\tint r = pipe2(pipe_fds, O_CLOEXEC);\n\n\tif (r < 0) {\n\t\tERROR(\"pipe2 failure\");\n\t\treturn NULL;\n\t}\n\n\tparent_end = pipe_fds[0];\n\tchild_end = pipe_fds[1];\n\n\tchild_pid = fork();\n\n\tif (child_pid == 0) {\n\t\t/* child */\n\t\tint child_std_end = STDOUT_FILENO;\n\n\t\tif (child_end != child_std_end) {\n\t\t\t/* dup2() doesn't dup close-on-exec flag */\n\t\t\tdup2(child_end, child_std_end);\n\n\t\t\t/* it's safe not to close child_end here\n\t\t\t * as it's marked close-on-exec anyway\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * The descriptor is already the one we will use.\n\t\t\t * But it must not be marked close-on-exec.\n\t\t\t * Undo the effects.\n\t\t\t */\n\t\t\tif (fcntl(child_end, F_SETFD, 0) != 0) {\n\t\t\t\tSYSERROR(\"Failed to remove FD_CLOEXEC from fd.\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Unblock signals.\n\t\t * This is the main/only reason\n\t\t * why we do our lousy popen() emulation.\n\t\t */\n\t\t{\n\t\t\tsigset_t mask;\n\t\t\tsigfillset(&mask);\n\t\t\tsigprocmask(SIG_UNBLOCK, &mask, NULL);\n\t\t}\n\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n\t\texit(127);\n\t}\n\n\t/* parent */\n\n\tclose(child_end);\n\tchild_end = -1;\n\n\tif (child_pid < 0) {\n\t\tERROR(\"fork failure\");\n\t\tgoto error;\n\t}\n\n\tfp = calloc(1, sizeof(*fp));\n\tif (!fp) {\n\t\tERROR(\"failed to allocate memory\");\n\t\tgoto error;\n\t}\n\n\tfp->f = fdopen(parent_end, \"r\");\n\tif (!fp->f) {\n\t\tERROR(\"fdopen failure\");\n\t\tgoto error;\n\t}\n\n\tfp->child_pid = child_pid;\n\n\treturn fp;\n\nerror:\n\n\tif (fp) {\n\t\tif (fp->f) {\n\t\t\tfclose(fp->f);\n\t\t\tparent_end = -1; /* so we do not close it second time */\n\t\t}\n\n\t\tfree(fp);\n\t}\n\n\tif (parent_end != -1)\n\t\tclose(parent_end);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "len",
            "lvscmd",
            "path"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lvscmd"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_compare_lv_attr(const char *path, int pos, const char expected)\n{\n\tstruct lxc_popen_FILE *f;\n\tint ret, len, status, start=0;\n\tchar *cmd, output[12];\n\tconst char *lvscmd = \"lvs --unbuffered --noheadings -o lv_attr %s 2>/dev/null\";\n\n\tlen = strlen(lvscmd) + strlen(path) - 1;\n\tcmd = alloca(len);\n\n\tret = snprintf(cmd, len, lvscmd, path);\n\tif (ret < 0 || ret >= len)\n\t\treturn -1;\n\n\tf = lxc_popen(cmd);\n\n\tif (f == NULL) {\n\t\tSYSERROR(\"popen failed\");\n\t\treturn -1;\n\t}\n\n\tret = fgets(output, 12, f->f) == NULL;\n\n\tstatus = lxc_pclose(f);\n\n\tif (ret || WEXITSTATUS(status))\n\t\t// Assume either vg or lvs do not exist, default\n\t\t// comparison to false.\n\t\treturn 0;\n\n\tlen = strlen(output);\n\twhile(start < len && output[start] == ' ') start++;\n\n\tif (start + pos < len && output[start + pos] == expected)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lvm_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "175-182",
    "snippet": "int lvm_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"lvm\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "bdev->dest"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "175-182",
          "snippet": "int lvm_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"lvm\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"lvm\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"lvm\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
  },
  {
    "function_name": "lvm_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "164-173",
    "snippet": "int lvm_mount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"lvm\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\t/* if we might pass in data sometime, then we'll have to enrich\n\t * mount_unknown_fs */\n\treturn mount_unknown_fs(bdev->src, bdev->dest, bdev->mntopts);\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_unknown_fs",
          "args": [
            "bdev->src",
            "bdev->dest",
            "bdev->mntopts"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "mount_unknown_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "739-782",
          "snippet": "int mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bdev *bdev_get(const char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic struct bdev *bdev_get(const char *type);\n\nint mount_unknown_fs(const char *rootfs, const char *target,\n\t\tconst char *options)\n{\n\tstruct cbarg {\n\t\tconst char *rootfs;\n\t\tconst char *target;\n\t\tconst char *options;\n\t} cbarg = {\n\t\t.rootfs = rootfs,\n\t\t.target = target,\n\t\t.options = options,\n\t};\n\n\t/*\n\t * find the filesystem type with brute force:\n\t * first we check with /etc/filesystems, in case the modules\n\t * are auto-loaded and fall back to the supported kernel fs\n\t */\n\tchar *fsfile[] = {\n\t\t\"/etc/filesystems\",\n\t\t\"/proc/filesystems\",\n\t};\n\n\tsize_t i;\n\tfor (i = 0; i < sizeof(fsfile) / sizeof(fsfile[0]); i++) {\n\n\t\tint ret;\n\n\t\tif (access(fsfile[i], F_OK))\n\t\t\tcontinue;\n\n\t\tret = lxc_file_for_each_line(fsfile[i], find_fstype_cb, &cbarg);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"failed to parse '%s'\", fsfile[i]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tERROR(\"failed to determine fs type for '%s'\", rootfs);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "bdev->type",
            "\"lvm\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_mount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"lvm\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\t/* if we might pass in data sometime, then we'll have to enrich\n\t * mount_unknown_fs */\n\treturn mount_unknown_fs(bdev->src, bdev->dest, bdev->mntopts);\n}"
  },
  {
    "function_name": "lvm_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "132-162",
    "snippet": "int lvm_detect(const char *path)\n{\n\tchar devp[MAXPATHLEN], buf[4];\n\tFILE *fout;\n\tint ret;\n\tstruct stat statbuf;\n\n\tif (strncmp(path, \"lvm:\", 4) == 0)\n\t\treturn 1; // take their word for it\n\n\tret = stat(path, &statbuf);\n\tif (ret != 0)\n\t\treturn 0;\n\tif (!S_ISBLK(statbuf.st_mode))\n\t\treturn 0;\n\n\tret = snprintf(devp, MAXPATHLEN, \"/sys/dev/block/%d:%d/dm/uuid\",\n\t\t\tmajor(statbuf.st_rdev), minor(statbuf.st_rdev));\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"lvm uuid pathname too long\");\n\t\treturn 0;\n\t}\n\tfout = fopen(devp, \"r\");\n\tif (!fout)\n\t\treturn 0;\n\tret = fread(buf, 1, 4, fout);\n\tfclose(fout);\n\tif (ret != 4 || strncmp(buf, \"LVM-\", 4) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"LVM-\"",
            "4"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fout"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "4",
            "fout"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "devp",
            "\"r\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lvm uuid pathname too long\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "devp",
            "MAXPATHLEN",
            "\"/sys/dev/block/%d:%d/dm/uuid\"",
            "major(statbuf.st_rdev)",
            "minor(statbuf.st_rdev)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "statbuf.st_rdev"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "statbuf.st_rdev"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "statbuf.st_mode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&statbuf"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"lvm:\"",
            "4"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_detect(const char *path)\n{\n\tchar devp[MAXPATHLEN], buf[4];\n\tFILE *fout;\n\tint ret;\n\tstruct stat statbuf;\n\n\tif (strncmp(path, \"lvm:\", 4) == 0)\n\t\treturn 1; // take their word for it\n\n\tret = stat(path, &statbuf);\n\tif (ret != 0)\n\t\treturn 0;\n\tif (!S_ISBLK(statbuf.st_mode))\n\t\treturn 0;\n\n\tret = snprintf(devp, MAXPATHLEN, \"/sys/dev/block/%d:%d/dm/uuid\",\n\t\t\tmajor(statbuf.st_rdev), minor(statbuf.st_rdev));\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"lvm uuid pathname too long\");\n\t\treturn 0;\n\t}\n\tfout = fopen(devp, \"r\");\n\tif (!fout)\n\t\treturn 0;\n\tret = fread(buf, 1, 4, fout);\n\tfclose(fout);\n\tif (ret != 4 || strncmp(buf, \"LVM-\", 4) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "do_lvm_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
    "lines": "66-125",
    "snippet": "static int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}",
    "includes": [
      "#    include <sys/sysmacros.h>",
      "#    include <sys/mkdev.h>",
      "#include \"utils.h\"",
      "#include \"lxclvm.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"bdev.h\"",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <inttypes.h> /* Required for PRIu64 to work. */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"execlp\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lvcreate\"",
            "\"lvcreate\"",
            "\"--thinpool\"",
            "tp",
            "\"-V\"",
            "sz",
            "vg",
            "\"-n\"",
            "lv",
            "(char *)NULL"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"lvcreate\"",
            "\"lvcreate\"",
            "\"-L\"",
            "sz",
            "vg",
            "\"-n\"",
            "lv",
            "(char *)NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LVM_SUPPRESS_FD_WARNINGS\"",
            "\"1\"",
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"got %d for thin pool at path: %s\"",
            "ret",
            "tp"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvm_is_thin_pool",
          "args": [
            "tp"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lvm_is_thin_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxclvm.c",
          "lines": "228-231",
          "snippet": "int lvm_is_thin_pool(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 0, 't');\n}",
          "includes": [
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"utils.h\"",
            "#include \"lxclvm.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint lvm_is_thin_pool(const char *path)\n{\n\treturn lvm_compare_lv_attr(path, 0, 't');\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tp",
            "len",
            "\"%s/%s\"",
            "pathdup",
            "thinpool"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "thinpool"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathdup"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "pathdup",
            "'/'"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "pathdup",
            "'/'"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sz",
            "24",
            "\"%\"PRIu64\"b\"",
            "size"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed fork\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"utils.h\"\n#include \"lxclvm.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nstatic int do_lvm_create(const char *path, uint64_t size,\n\t\t\t     const char *thinpool)\n{\n\tint ret, pid, len;\n\tchar sz[24], *pathdup, *vg, *lv, *tp = NULL;\n\n\tif ((pid = fork()) < 0) {\n\t\tSYSERROR(\"failed fork\");\n\t\treturn -1;\n\t}\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\t// specify bytes to lvcreate\n\tret = snprintf(sz, 24, \"%\"PRIu64\"b\", size);\n\tif (ret < 0 || ret >= 24)\n\t\texit(EXIT_FAILURE);\n\n\tpathdup = strdup(path);\n\tif (!pathdup)\n\t\texit(EXIT_FAILURE);\n\n\tlv = strrchr(pathdup, '/');\n\tif (!lv)\n\t\texit(EXIT_FAILURE);\n\n\t*lv = '\\0';\n\tlv++;\n\n\tvg = strrchr(pathdup, '/');\n\tif (!vg)\n\t\texit(EXIT_FAILURE);\n\tvg++;\n\n\tif (thinpool) {\n\t\tlen = strlen(pathdup) + strlen(thinpool) + 2;\n\t\ttp = alloca(len);\n\n\t\tret = snprintf(tp, len, \"%s/%s\", pathdup, thinpool);\n\t\tif (ret < 0 || ret >= len)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = lvm_is_thin_pool(tp);\n\t\tINFO(\"got %d for thin pool at path: %s\", ret, tp);\n\t\tif (ret < 0)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (!ret)\n\t\t\ttp = NULL;\n\t}\n\n\t(void)setenv(\"LVM_SUPPRESS_FD_WARNINGS\", \"1\", 1);\n\tif (!tp)\n\t    execlp(\"lvcreate\", \"lvcreate\", \"-L\", sz, vg, \"-n\", lv, (char *)NULL);\n\telse\n\t    execlp(\"lvcreate\", \"lvcreate\", \"--thinpool\", tp, \"-V\", sz, vg, \"-n\", lv, (char *)NULL);\n\n\tSYSERROR(\"execlp\");\n\texit(EXIT_FAILURE);\n}"
  }
]