[
  {
    "function_name": "ls_field_width",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "1187-1239",
    "snippet": "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht)\n{\n\tconst struct ls *m;\n\tsize_t i, len = 0;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->name) {\n\t\t\tlen = strlen(m->name) + m->nestlvl;\n\t\t\tif (len > lht->name_length)\n\t\t\t\tlht->name_length = len;\n\t\t}\n\n\t\tif (m->state) {\n\t\t\tlen = strlen(m->state);\n\t\t\tif (len > lht->state_length)\n\t\t\t\tlht->state_length = len;\n\t\t}\n\n\t\tif (m->interface) {\n\t\t\tlen = strlen(m->interface);\n\t\t\tif (len > lht->interface_length)\n\t\t\t\tlht->interface_length = len;\n\t\t}\n\n\t\tif (m->groups) {\n\t\t\tlen = strlen(m->groups);\n\t\t\tif (len > lht->groups_length)\n\t\t\t\tlht->groups_length = len;\n\t\t}\n\t\tif (m->ipv4) {\n\t\t\tlen = strlen(m->ipv4);\n\t\t\tif (len > lht->ipv4_length)\n\t\t\t\tlht->ipv4_length = len;\n\t\t}\n\n\t\tif (m->ipv6) {\n\t\t\tlen = strlen(m->ipv6);\n\t\t\tif (len > lht->ipv6_length)\n\t\t\t\tlht->ipv6_length = len;\n\t\t}\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->ram)) > lht->ram_length)\n\t\t\tlht->ram_length = len;\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->swap)) > lht->swap_length)\n\t\t\tlht->swap_length = len;\n\n\t\tif (m->init != -1) {\n\t\t\tif ((len = snprintf(NULL, 0, \"%d\", m->init)) > lht->init_length)\n\t\t\t\tlht->init_length = len;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%d\"",
            "m->init"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%.2f\"",
            "m->swap"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%.2f\"",
            "m->ram"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->ipv6"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->ipv4"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->groups"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->interface"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->state"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->name"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht)\n{\n\tconst struct ls *m;\n\tsize_t i, len = 0;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->name) {\n\t\t\tlen = strlen(m->name) + m->nestlvl;\n\t\t\tif (len > lht->name_length)\n\t\t\t\tlht->name_length = len;\n\t\t}\n\n\t\tif (m->state) {\n\t\t\tlen = strlen(m->state);\n\t\t\tif (len > lht->state_length)\n\t\t\t\tlht->state_length = len;\n\t\t}\n\n\t\tif (m->interface) {\n\t\t\tlen = strlen(m->interface);\n\t\t\tif (len > lht->interface_length)\n\t\t\t\tlht->interface_length = len;\n\t\t}\n\n\t\tif (m->groups) {\n\t\t\tlen = strlen(m->groups);\n\t\t\tif (len > lht->groups_length)\n\t\t\t\tlht->groups_length = len;\n\t\t}\n\t\tif (m->ipv4) {\n\t\t\tlen = strlen(m->ipv4);\n\t\t\tif (len > lht->ipv4_length)\n\t\t\t\tlht->ipv4_length = len;\n\t\t}\n\n\t\tif (m->ipv6) {\n\t\t\tlen = strlen(m->ipv6);\n\t\t\tif (len > lht->ipv6_length)\n\t\t\t\tlht->ipv6_length = len;\n\t\t}\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->ram)) > lht->ram_length)\n\t\t\tlht->ram_length = len;\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->swap)) > lht->swap_length)\n\t\t\tlht->swap_length = len;\n\n\t\tif (m->init != -1) {\n\t\t\tif ((len = snprintf(NULL, 0, \"%d\", m->init)) > lht->init_length)\n\t\t\t\tlht->init_length = len;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ls_deserialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "1119-1185",
    "snippet": "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len)\n{\n\tstruct ls *n;\n\tsize_t sublen = 0;\n\tssize_t nbytes = 0;\n\n\t/* get length */\n\tnbytes = sizeof(sublen);\n\tif (lxc_read_nointr(rpipefd, &sublen, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\twhile (sublen-- > 0) {\n\t\tn = ls_new(m, len);\n\t\tif (!n)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->ram);\n\t\tif (lxc_read_nointr(rpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->swap);\n\t\tif (lxc_read_nointr(rpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->init);\n\t\tif (lxc_read_nointr(rpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->autostart);\n\t\tif (lxc_read_nointr(rpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->running);\n\t\tif (lxc_read_nointr(rpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->nestlvl);\n\t\tif (lxc_read_nointr(rpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\t/* NAME */\n\t\tif (ls_recv_str(rpipefd, &n->name) < 0)\n\t\t\treturn -1;\n\n\t\t/* STATE */\n\t\tif (ls_recv_str(rpipefd, &n->state) < 0)\n\t\t\treturn -1;\n\n\t\t/* GROUPS */\n\t\tif (ls_recv_str(rpipefd, &n->groups) < 0)\n\t\t\treturn -1;\n\n\t\t/* INTERFACE */\n\t\tif (ls_recv_str(rpipefd, &n->interface) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV4 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv4) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV6 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv6) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls_recv_str",
          "args": [
            "rpipefd",
            "&n->ipv6"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ls_recv_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "1103-1117",
          "snippet": "static int ls_recv_str(int fd, char **buf)\n{\n\tsize_t slen = 0;\n\tif (lxc_read_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\t*buf = malloc(sizeof(char) * (slen + 1));\n\t\tif (!*buf)\n\t\t\treturn -1;\n\t\tif (lxc_read_nointr(fd, *buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t\t(*buf)[slen] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_recv_str(int fd, char **buf);",
            "static int ls_send_str(int fd, const char *buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_recv_str(int fd, char **buf);\nstatic int ls_send_str(int fd, const char *buf);\n\nstatic int ls_recv_str(int fd, char **buf)\n{\n\tsize_t slen = 0;\n\tif (lxc_read_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\t*buf = malloc(sizeof(char) * (slen + 1));\n\t\tif (!*buf)\n\t\t\treturn -1;\n\t\tif (lxc_read_nointr(fd, *buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t\t(*buf)[slen] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "rpipefd",
            "&n->nestlvl",
            "(size_t)nbytes"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_new",
          "args": [
            "m",
            "len"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ls_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "735-750",
          "snippet": "static struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len)\n{\n\tstruct ls *n;\n\tsize_t sublen = 0;\n\tssize_t nbytes = 0;\n\n\t/* get length */\n\tnbytes = sizeof(sublen);\n\tif (lxc_read_nointr(rpipefd, &sublen, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\twhile (sublen-- > 0) {\n\t\tn = ls_new(m, len);\n\t\tif (!n)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->ram);\n\t\tif (lxc_read_nointr(rpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->swap);\n\t\tif (lxc_read_nointr(rpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->init);\n\t\tif (lxc_read_nointr(rpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->autostart);\n\t\tif (lxc_read_nointr(rpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->running);\n\t\tif (lxc_read_nointr(rpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->nestlvl);\n\t\tif (lxc_read_nointr(rpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\t/* NAME */\n\t\tif (ls_recv_str(rpipefd, &n->name) < 0)\n\t\t\treturn -1;\n\n\t\t/* STATE */\n\t\tif (ls_recv_str(rpipefd, &n->state) < 0)\n\t\t\treturn -1;\n\n\t\t/* GROUPS */\n\t\tif (ls_recv_str(rpipefd, &n->groups) < 0)\n\t\t\treturn -1;\n\n\t\t/* INTERFACE */\n\t\tif (ls_recv_str(rpipefd, &n->interface) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV4 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv4) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV6 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv6) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_recv_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "1103-1117",
    "snippet": "static int ls_recv_str(int fd, char **buf)\n{\n\tsize_t slen = 0;\n\tif (lxc_read_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\t*buf = malloc(sizeof(char) * (slen + 1));\n\t\tif (!*buf)\n\t\t\treturn -1;\n\t\tif (lxc_read_nointr(fd, *buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t\t(*buf)[slen] = '\\0';\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_recv_str(int fd, char **buf);",
      "static int ls_send_str(int fd, const char *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_read_nointr",
          "args": [
            "fd",
            "*buf",
            "slen"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "337-345",
          "snippet": "ssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_read_nointr(int fd, void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (slen + 1)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_recv_str(int fd, char **buf);\nstatic int ls_send_str(int fd, const char *buf);\n\nstatic int ls_recv_str(int fd, char **buf)\n{\n\tsize_t slen = 0;\n\tif (lxc_read_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\t*buf = malloc(sizeof(char) * (slen + 1));\n\t\tif (!*buf)\n\t\t\treturn -1;\n\t\tif (lxc_read_nointr(fd, *buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t\t(*buf)[slen] = '\\0';\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "1050-1101",
    "snippet": "static int ls_serialize(int wpipefd, struct ls *n)\n{\n\tssize_t nbytes = sizeof(n->ram);\n\tif (lxc_write_nointr(wpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->swap);\n\tif (lxc_write_nointr(wpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->init);\n\tif (lxc_write_nointr(wpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->autostart);\n\tif (lxc_write_nointr(wpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->running);\n\tif (lxc_write_nointr(wpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->nestlvl);\n\tif (lxc_write_nointr(wpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\t/* NAME */\n\tif (ls_send_str(wpipefd, n->name) < 0)\n\t\treturn -1;\n\n\t/* STATE */\n\tif (ls_send_str(wpipefd, n->state) < 0)\n\t\treturn -1;\n\n\t/* GROUPS */\n\tif (ls_send_str(wpipefd, n->groups) < 0)\n\t\treturn -1;\n\n\t/* INTERFACE */\n\tif (ls_send_str(wpipefd, n->interface) < 0)\n\t\treturn -1;\n\n\t/* IPV4 */\n\tif (ls_send_str(wpipefd, n->ipv4) < 0)\n\t\treturn -1;\n\n\t/* IPV6 */\n\tif (ls_send_str(wpipefd, n->ipv6) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls_send_str",
          "args": [
            "wpipefd",
            "n->ipv6"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ls_send_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "1036-1048",
          "snippet": "static int ls_send_str(int fd, const char *buf)\n{\n\tsize_t slen = 0;\n\tif (buf)\n\t\tslen = strlen(buf);\n\tif (lxc_write_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\tif (lxc_write_nointr(fd, buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_recv_str(int fd, char **buf);",
            "static int ls_send_str(int fd, const char *buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_recv_str(int fd, char **buf);\nstatic int ls_send_str(int fd, const char *buf);\n\nstatic int ls_send_str(int fd, const char *buf)\n{\n\tsize_t slen = 0;\n\tif (buf)\n\t\tslen = strlen(buf);\n\tif (lxc_write_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\tif (lxc_write_nointr(fd, buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "wpipefd",
            "&n->nestlvl",
            "(size_t)nbytes"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic int ls_serialize(int wpipefd, struct ls *n)\n{\n\tssize_t nbytes = sizeof(n->ram);\n\tif (lxc_write_nointr(wpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->swap);\n\tif (lxc_write_nointr(wpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->init);\n\tif (lxc_write_nointr(wpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->autostart);\n\tif (lxc_write_nointr(wpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->running);\n\tif (lxc_write_nointr(wpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->nestlvl);\n\tif (lxc_write_nointr(wpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\t/* NAME */\n\tif (ls_send_str(wpipefd, n->name) < 0)\n\t\treturn -1;\n\n\t/* STATE */\n\tif (ls_send_str(wpipefd, n->state) < 0)\n\t\treturn -1;\n\n\t/* GROUPS */\n\tif (ls_send_str(wpipefd, n->groups) < 0)\n\t\treturn -1;\n\n\t/* INTERFACE */\n\tif (ls_send_str(wpipefd, n->interface) < 0)\n\t\treturn -1;\n\n\t/* IPV4 */\n\tif (ls_send_str(wpipefd, n->ipv4) < 0)\n\t\treturn -1;\n\n\t/* IPV6 */\n\tif (ls_send_str(wpipefd, n->ipv6) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_send_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "1036-1048",
    "snippet": "static int ls_send_str(int fd, const char *buf)\n{\n\tsize_t slen = 0;\n\tif (buf)\n\t\tslen = strlen(buf);\n\tif (lxc_write_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\tif (lxc_write_nointr(fd, buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_recv_str(int fd, char **buf);",
      "static int ls_send_str(int fd, const char *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "fd",
            "buf",
            "slen"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_recv_str(int fd, char **buf);\nstatic int ls_send_str(int fd, const char *buf);\n\nstatic int ls_send_str(int fd, const char *buf)\n{\n\tsize_t slen = 0;\n\tif (buf)\n\t\tslen = strlen(buf);\n\tif (lxc_write_nointr(fd, &slen, sizeof(slen)) != sizeof(slen))\n\t\treturn -1;\n\tif (slen > 0) {\n\t\tif (lxc_write_nointr(fd, buf, slen) != (ssize_t)slen)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_remove_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "997-1034",
    "snippet": "static int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc)\n{\n\tint ret = -1;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\trundir = get_rundir();\n\tif (!rundir)\n\t\tgoto out;\n\n\t/* Avoid doing unnecessary work if we can. */\n\tif (recalc) {\n\t\tsize_t newlen = strlen(path) + strlen(name) + strlen(rundir) + /* / + lxc + / + lock + / + / = */ 11 + 1;\n\t\tif (newlen > *len_lockpath) {\n\t\t\tchar *tmp = realloc(*lockpath, newlen * 2);\n\t\t\tif (!tmp)\n\t\t\t\tgoto out;\n\t\t\t*lockpath = tmp;\n\t\t\t*len_lockpath = newlen * 2;\n\t\t}\n\t}\n\n\tint check = snprintf(*lockpath, *len_lockpath, \"%s/lxc/lock/%s/%s\", rundir, path, name);\n\tif (check < 0 || (size_t)check >= *len_lockpath)\n\t\tgoto out;\n\n\tlxc_rmdir_onedev(*lockpath, NULL);\n\tret = 0;\n\nout:\n\tfree(rundir);\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rundir"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_rmdir_onedev",
          "args": [
            "*lockpath",
            "NULL"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "203-220",
          "snippet": "extern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nextern int lxc_rmdir_onedev(char *path, const char *exclude)\n{\n\tstruct stat mystat;\n\tbool onedev = true;\n\n\tif (is_native_overlayfs(path)) {\n\t\tonedev = false;\n\t}\n\n\tif (lstat(path, &mystat) < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tERROR(\"%s: failed to stat %s\", __func__, path);\n\t\treturn -1;\n\t}\n\n\treturn _recursive_rmdir(path, mystat.st_dev, exclude, 0, onedev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "*lockpath",
            "*len_lockpath",
            "\"%s/lxc/lock/%s/%s\"",
            "rundir",
            "path",
            "name"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*lockpath",
            "newlen * 2"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rundir"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rundir",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "get_rundir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "264-291",
          "snippet": "char *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc);\n\nstatic int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc)\n{\n\tint ret = -1;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\trundir = get_rundir();\n\tif (!rundir)\n\t\tgoto out;\n\n\t/* Avoid doing unnecessary work if we can. */\n\tif (recalc) {\n\t\tsize_t newlen = strlen(path) + strlen(name) + strlen(rundir) + /* / + lxc + / + lock + / + / = */ 11 + 1;\n\t\tif (newlen > *len_lockpath) {\n\t\t\tchar *tmp = realloc(*lockpath, newlen * 2);\n\t\t\tif (!tmp)\n\t\t\t\tgoto out;\n\t\t\t*lockpath = tmp;\n\t\t\t*len_lockpath = newlen * 2;\n\t\t}\n\t}\n\n\tint check = snprintf(*lockpath, *len_lockpath, \"%s/lxc/lock/%s/%s\", rundir, path, name);\n\tif (check < 0 || (size_t)check >= *len_lockpath)\n\t\tgoto out;\n\n\tlxc_rmdir_onedev(*lockpath, NULL);\n\tret = 0;\n\nout:\n\tfree(rundir);\n\treturn ret;\n}"
  },
  {
    "function_name": "ls_get_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "962-995",
    "snippet": "static int ls_get_wrapper(void *wrap)\n{\n\tint ret = -1;\n\tsize_t len = 0;\n\tstruct wrapargs *wargs = (struct wrapargs *)wrap;\n\tstruct ls *m = NULL, *n = NULL;\n\n\t/* close pipe */\n\tclose(wargs->pipefd[0]);\n\n\t/* &(char *){NULL} is no magic. It's just a compound literal which\n\t * allows us to avoid keeping a pointless variable around. */\n\tls_get(&m, &len, wargs->args, \"\", wargs->parent, wargs->nestlvl, &(char *){NULL}, 0, wargs->grps_must, wargs->grps_must_len);\n\tif (!m)\n\t\tgoto out;\n\n\t/* send length */\n\tif (lxc_write_nointr(wargs->pipefd[1], &len, sizeof(len)) <= 0)\n\t\tgoto out;\n\n\tsize_t i;\n\tfor (i = 0, n = m; i < len; i++, n++) {\n\t\tif (ls_serialize(wargs->pipefd[1], n) == -1)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\tshutdown(wargs->pipefd[1], SHUT_RDWR);\n\tclose(wargs->pipefd[1]);\n\tls_free(m, len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);",
      "static int ls_get_wrapper(void *wrap);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls_free",
          "args": [
            "m",
            "len"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ls_free_arr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "317-323",
          "snippet": "static void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "wargs->pipefd[1]"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "wargs->pipefd[1]",
            "SHUT_RDWR"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1602-1631",
          "snippet": "static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_serialize",
          "args": [
            "wargs->pipefd[1]",
            "n"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ls_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "1050-1101",
          "snippet": "static int ls_serialize(int wpipefd, struct ls *n)\n{\n\tssize_t nbytes = sizeof(n->ram);\n\tif (lxc_write_nointr(wpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->swap);\n\tif (lxc_write_nointr(wpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->init);\n\tif (lxc_write_nointr(wpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->autostart);\n\tif (lxc_write_nointr(wpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->running);\n\tif (lxc_write_nointr(wpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->nestlvl);\n\tif (lxc_write_nointr(wpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\t/* NAME */\n\tif (ls_send_str(wpipefd, n->name) < 0)\n\t\treturn -1;\n\n\t/* STATE */\n\tif (ls_send_str(wpipefd, n->state) < 0)\n\t\treturn -1;\n\n\t/* GROUPS */\n\tif (ls_send_str(wpipefd, n->groups) < 0)\n\t\treturn -1;\n\n\t/* INTERFACE */\n\tif (ls_send_str(wpipefd, n->interface) < 0)\n\t\treturn -1;\n\n\t/* IPV4 */\n\tif (ls_send_str(wpipefd, n->ipv4) < 0)\n\t\treturn -1;\n\n\t/* IPV6 */\n\tif (ls_send_str(wpipefd, n->ipv6) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic int ls_serialize(int wpipefd, struct ls *n)\n{\n\tssize_t nbytes = sizeof(n->ram);\n\tif (lxc_write_nointr(wpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->swap);\n\tif (lxc_write_nointr(wpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->init);\n\tif (lxc_write_nointr(wpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->autostart);\n\tif (lxc_write_nointr(wpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->running);\n\tif (lxc_write_nointr(wpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\tnbytes = sizeof(n->nestlvl);\n\tif (lxc_write_nointr(wpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\t/* NAME */\n\tif (ls_send_str(wpipefd, n->name) < 0)\n\t\treturn -1;\n\n\t/* STATE */\n\tif (ls_send_str(wpipefd, n->state) < 0)\n\t\treturn -1;\n\n\t/* GROUPS */\n\tif (ls_send_str(wpipefd, n->groups) < 0)\n\t\treturn -1;\n\n\t/* INTERFACE */\n\tif (ls_send_str(wpipefd, n->interface) < 0)\n\t\treturn -1;\n\n\t/* IPV4 */\n\tif (ls_send_str(wpipefd, n->ipv4) < 0)\n\t\treturn -1;\n\n\t/* IPV6 */\n\tif (ls_send_str(wpipefd, n->ipv6) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_write_nointr",
          "args": [
            "wargs->pipefd[1]",
            "&len",
            "sizeof(len)"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get",
          "args": [
            "&m",
            "&len",
            "wargs->args",
            "\"\"",
            "wargs->parent",
            "wargs->nestlvl",
            "&(char *){NULL}",
            "0",
            "wargs->grps_must",
            "wargs->grps_must_len"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "325-579",
          "snippet": "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_NESTLVL 5"
          ],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static char *ls_get_ips(struct lxc_container *c, const char *inet);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\n#define MAX_NESTLVL 5\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);\nstatic int ls_get_wrapper(void *wrap);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic int ls_get_wrapper(void *wrap)\n{\n\tint ret = -1;\n\tsize_t len = 0;\n\tstruct wrapargs *wargs = (struct wrapargs *)wrap;\n\tstruct ls *m = NULL, *n = NULL;\n\n\t/* close pipe */\n\tclose(wargs->pipefd[0]);\n\n\t/* &(char *){NULL} is no magic. It's just a compound literal which\n\t * allows us to avoid keeping a pointless variable around. */\n\tls_get(&m, &len, wargs->args, \"\", wargs->parent, wargs->nestlvl, &(char *){NULL}, 0, wargs->grps_must, wargs->grps_must_len);\n\tif (!m)\n\t\tgoto out;\n\n\t/* send length */\n\tif (lxc_write_nointr(wargs->pipefd[1], &len, sizeof(len)) <= 0)\n\t\tgoto out;\n\n\tsize_t i;\n\tfor (i = 0, n = m; i < len; i++, n++) {\n\t\tif (ls_serialize(wargs->pipefd[1], n) == -1)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\tshutdown(wargs->pipefd[1], SHUT_RDWR);\n\tclose(wargs->pipefd[1]);\n\tls_free(m, len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "my_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "908-960",
    "snippet": "static int my_parser(struct lxc_arguments *args, int c, char *arg)\n{\n\tchar *invalid;\n\tunsigned long int m, n = MAX_NESTLVL;\n\tswitch (c) {\n\tcase '1':\n\t\targs->ls_line = true;\n\t\tbreak;\n\tcase 'f':\n\t\targs->ls_fancy = true;\n\t\tbreak;\n\tcase LS_ACTIVE:\n\t\targs->ls_active = true;\n\t\tbreak;\n\tcase LS_FROZEN:\n\t\targs->ls_frozen = true;\n\t\tbreak;\n\tcase LS_RUNNING:\n\t\targs->ls_running = true;\n\t\tbreak;\n\tcase LS_STOPPED:\n\t\targs->ls_stopped = true;\n\t\tbreak;\n\tcase LS_NESTING:\n\t\t/* In case strtoul() receives a string that represents a\n\t\t * negative number it will return ULONG_MAX - the number that\n\t\t * the string represents if the number the string represents is\n\t\t * < ULONG_MAX and ULONG_MAX otherwise. But it will consider\n\t\t * this valid input and not set errno. So we check manually if\n\t\t * the first character of num_string == '-'. Otherwise the\n\t\t * default level remains set. */\n\t\tif (arg && !(*arg == '-')) {\n\t\t\terrno = 0;\n\t\t\tm = strtoul(arg, &invalid, 0);\n\t\t\t/* ls_nesting has type unsigned int. */\n\t\t\tif (!errno && (*invalid == '\\0') && (m <= UINT_MAX))\n\t\t\t\tn = m;\n\t\t}\n\t\targs->ls_nesting = n;\n\t\tbreak;\n\tcase 'g':\n\t\targs->groups = arg;\n\t\tbreak;\n\tcase LS_FILTER:\n\t\targs->ls_filter = arg;\n\t\tbreak;\n\tcase 'F':\n\t\targs->ls_fancy_format = arg;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define LS_FILTER 6",
      "#define LS_NESTING 5",
      "#define LS_RUNNING 4",
      "#define LS_ACTIVE 3",
      "#define LS_STOPPED 2",
      "#define LS_FROZEN 1",
      "#define MAX_NESTLVL 5"
    ],
    "globals_used": [
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);",
      "static int ls_serialize(int wpipefd, struct ls *n);",
      "static int my_parser(struct lxc_arguments *args, int c, char *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg",
            "&invalid",
            "0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\n#define LS_FILTER 6\n#define LS_NESTING 5\n#define LS_RUNNING 4\n#define LS_ACTIVE 3\n#define LS_STOPPED 2\n#define LS_FROZEN 1\n#define MAX_NESTLVL 5\n\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic int ls_serialize(int wpipefd, struct ls *n);\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg);\n\nstatic int my_parser(struct lxc_arguments *args, int c, char *arg)\n{\n\tchar *invalid;\n\tunsigned long int m, n = MAX_NESTLVL;\n\tswitch (c) {\n\tcase '1':\n\t\targs->ls_line = true;\n\t\tbreak;\n\tcase 'f':\n\t\targs->ls_fancy = true;\n\t\tbreak;\n\tcase LS_ACTIVE:\n\t\targs->ls_active = true;\n\t\tbreak;\n\tcase LS_FROZEN:\n\t\targs->ls_frozen = true;\n\t\tbreak;\n\tcase LS_RUNNING:\n\t\targs->ls_running = true;\n\t\tbreak;\n\tcase LS_STOPPED:\n\t\targs->ls_stopped = true;\n\t\tbreak;\n\tcase LS_NESTING:\n\t\t/* In case strtoul() receives a string that represents a\n\t\t * negative number it will return ULONG_MAX - the number that\n\t\t * the string represents if the number the string represents is\n\t\t * < ULONG_MAX and ULONG_MAX otherwise. But it will consider\n\t\t * this valid input and not set errno. So we check manually if\n\t\t * the first character of num_string == '-'. Otherwise the\n\t\t * default level remains set. */\n\t\tif (arg && !(*arg == '-')) {\n\t\t\terrno = 0;\n\t\t\tm = strtoul(arg, &invalid, 0);\n\t\t\t/* ls_nesting has type unsigned int. */\n\t\t\tif (!errno && (*invalid == '\\0') && (m <= UINT_MAX))\n\t\t\t\tn = m;\n\t\t}\n\t\targs->ls_nesting = n;\n\t\tbreak;\n\tcase 'g':\n\t\targs->groups = arg;\n\t\tbreak;\n\tcase LS_FILTER:\n\t\targs->ls_filter = arg;\n\t\tbreak;\n\tcase 'F':\n\t\targs->ls_fancy_format = arg;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ls_print_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "873-906",
    "snippet": "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tstruct ls *m = NULL;\n\n\t/* print header */\n\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\tprintf(\"\\n\");\n\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->nestlvl > 0) {\n\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t} else {\n\t\t     printf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t}\n\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv6_length",
            "m->ipv6 ? m->ipv6 : \"-\""
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv4_length",
            "m->ipv4 ? m->ipv4 : \"-\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->groups_length",
            "m->groups ? m->groups : \"-\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*d \"",
            "lht->autostart_length",
            "m->autostart"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->state_length",
            "m->state ? m->state : \"-\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length",
            "m->name ? m->name : \"-\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length - m->nestlvl",
            "m->name ? m->name : \"-\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%*s\"",
            "m->nestlvl",
            "\"\\\\\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv6_length",
            "\"IPV6\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv4_length",
            "\"IPV4\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->groups_length",
            "\"GROUPS\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->autostart_length",
            "\"AUTOSTART\""
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->state_length",
            "\"STATE\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length",
            "\"NAME\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tstruct ls *m = NULL;\n\n\t/* print header */\n\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\tprintf(\"\\n\");\n\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->nestlvl > 0) {\n\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t} else {\n\t\t     printf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t}\n\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "ls_print_fancy_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "780-871",
    "snippet": "static void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tchar **tmp = lxc_string_split_and_trim(fancy_fmt, ',');\n\tif (!tmp)\n\t\treturn;\n\n\tchar **s;\n\t/* Check for invalid keys. */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") && strcasecmp(*s, \"STATE\") &&\n\t\t\t\tstrcasecmp(*s, \"PID\") && strcasecmp(*s, \"RAM\") &&\n\t\t\t\tstrcasecmp(*s, \"SWAP\") && strcasecmp(*s, \"AUTOSTART\") &&\n\t\t\t\tstrcasecmp(*s, \"GROUPS\") && strcasecmp(*s, \"INTERFACE\") &&\n\t\t\t\tstrcasecmp(*s, \"IPV4\") && strcasecmp(*s, \"IPV6\")) {\n\t\t\tfprintf(stderr, \"Invalid key: %s\\n\", *s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* print header */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") == 0)\n\t\t\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\t\telse if (strcasecmp(*s, \"STATE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\t\telse if (strcasecmp(*s, \"PID\") == 0)\n\t\t\tprintf(\"%-*s \", lht->init_length, \"PID\");\n\t\telse if (strcasecmp(*s, \"RAM\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ram_length + 2, \"RAM\");\n\t\telse if (strcasecmp(*s, \"SWAP\") == 0)\n\t\t\tprintf(\"%-*s \", lht->swap_length + 2, \"SWAP\");\n\t\telse if (strcasecmp(*s, \"AUTOSTART\") == 0)\n\t\t\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\t\telse if (strcasecmp(*s, \"GROUPS\") == 0)\n\t\t\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\t\telse if (strcasecmp(*s, \"INTERFACE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->interface_length, \"INTERFACE\");\n\t\telse if (strcasecmp(*s, \"IPV4\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\t\telse if (strcasecmp(*s, \"IPV6\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\t}\n\tprintf(\"\\n\");\n\n\tstruct ls *m = NULL;\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfor (s = tmp; s && *s; s++) {\n\t\t\tif (strcasecmp(*s, \"NAME\") == 0) {\n\t\t\t\tif (m->nestlvl > 0) {\n\t\t\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t\t\t}\n\t\t\t} else if (strcasecmp(*s, \"STATE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"PID\") == 0) {\n\t\t\t\tif (m->init > 0)\n\t\t\t\t\tprintf(\"%-*d \", lht->init_length, m->init);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s \", lht->init_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"RAM\") == 0) {\n\t\t\t\tif ((m->ram >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->ram_length, m->ram);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->ram_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"SWAP\") == 0) {\n\t\t\t\tif ((m->swap >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->swap_length, m->swap);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->swap_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"AUTOSTART\") == 0) {\n\t\t\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\t\t} else if (strcasecmp(*s, \"GROUPS\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"INTERFACE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->interface_length, m->interface ? m->interface : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV4\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV6\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt);",
      "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv6_length",
            "m->ipv6 ? m->ipv6 : \"-\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV6\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv4_length",
            "m->ipv4 ? m->ipv4 : \"-\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV4\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->interface_length",
            "m->interface ? m->interface : \"-\""
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"INTERFACE\""
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->groups_length",
            "m->groups ? m->groups : \"-\""
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"GROUPS\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*d \"",
            "lht->autostart_length",
            "m->autostart"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"AUTOSTART\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s   \"",
            "lht->swap_length",
            "\"-\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%*.2fMB \"",
            "lht->swap_length",
            "m->swap"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"SWAP\""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s   \"",
            "lht->ram_length",
            "\"-\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%*.2fMB \"",
            "lht->ram_length",
            "m->ram"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"RAM\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->init_length",
            "\"-\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*d \"",
            "lht->init_length",
            "m->init"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"PID\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->state_length",
            "m->state ? m->state : \"-\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"STATE\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length",
            "m->name ? m->name : \"-\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length - m->nestlvl",
            "m->name ? m->name : \"-\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%*s\"",
            "m->nestlvl",
            "\"\\\\\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"NAME\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv6_length",
            "\"IPV6\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV6\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ipv4_length",
            "\"IPV4\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV4\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->interface_length",
            "\"INTERFACE\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"INTERFACE\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->groups_length",
            "\"GROUPS\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"GROUPS\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->autostart_length",
            "\"AUTOSTART\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"AUTOSTART\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->swap_length + 2",
            "\"SWAP\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"SWAP\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->ram_length + 2",
            "\"RAM\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"RAM\""
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->init_length",
            "\"PID\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"PID\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->state_length",
            "\"STATE\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"STATE\""
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s \"",
            "lht->name_length",
            "\"NAME\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"NAME\""
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid key: %s\\n\"",
            "*s"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV6\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"IPV4\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"INTERFACE\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"GROUPS\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"AUTOSTART\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"SWAP\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"RAM\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"PID\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"STATE\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "*s",
            "\"NAME\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_split_and_trim",
          "args": [
            "fancy_fmt",
            "','"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tchar **tmp = lxc_string_split_and_trim(fancy_fmt, ',');\n\tif (!tmp)\n\t\treturn;\n\n\tchar **s;\n\t/* Check for invalid keys. */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") && strcasecmp(*s, \"STATE\") &&\n\t\t\t\tstrcasecmp(*s, \"PID\") && strcasecmp(*s, \"RAM\") &&\n\t\t\t\tstrcasecmp(*s, \"SWAP\") && strcasecmp(*s, \"AUTOSTART\") &&\n\t\t\t\tstrcasecmp(*s, \"GROUPS\") && strcasecmp(*s, \"INTERFACE\") &&\n\t\t\t\tstrcasecmp(*s, \"IPV4\") && strcasecmp(*s, \"IPV6\")) {\n\t\t\tfprintf(stderr, \"Invalid key: %s\\n\", *s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* print header */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") == 0)\n\t\t\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\t\telse if (strcasecmp(*s, \"STATE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\t\telse if (strcasecmp(*s, \"PID\") == 0)\n\t\t\tprintf(\"%-*s \", lht->init_length, \"PID\");\n\t\telse if (strcasecmp(*s, \"RAM\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ram_length + 2, \"RAM\");\n\t\telse if (strcasecmp(*s, \"SWAP\") == 0)\n\t\t\tprintf(\"%-*s \", lht->swap_length + 2, \"SWAP\");\n\t\telse if (strcasecmp(*s, \"AUTOSTART\") == 0)\n\t\t\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\t\telse if (strcasecmp(*s, \"GROUPS\") == 0)\n\t\t\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\t\telse if (strcasecmp(*s, \"INTERFACE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->interface_length, \"INTERFACE\");\n\t\telse if (strcasecmp(*s, \"IPV4\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\t\telse if (strcasecmp(*s, \"IPV6\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\t}\n\tprintf(\"\\n\");\n\n\tstruct ls *m = NULL;\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfor (s = tmp; s && *s; s++) {\n\t\t\tif (strcasecmp(*s, \"NAME\") == 0) {\n\t\t\t\tif (m->nestlvl > 0) {\n\t\t\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t\t\t}\n\t\t\t} else if (strcasecmp(*s, \"STATE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"PID\") == 0) {\n\t\t\t\tif (m->init > 0)\n\t\t\t\t\tprintf(\"%-*d \", lht->init_length, m->init);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s \", lht->init_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"RAM\") == 0) {\n\t\t\t\tif ((m->ram >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->ram_length, m->ram);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->ram_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"SWAP\") == 0) {\n\t\t\t\tif ((m->swap >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->swap_length, m->swap);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->swap_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"AUTOSTART\") == 0) {\n\t\t\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\t\t} else if (strcasecmp(*s, \"GROUPS\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"INTERFACE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->interface_length, m->interface ? m->interface : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV4\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV6\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "ls_print_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "752-778",
    "snippet": "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t size, size_t termwidth, bool list)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tsize_t i, len = 0;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (list) {\n\t\t\tprintf(\"%s\\n\", m->name ? m->name : \"-\");\n\t\t} else {\n\t\t\tprintf(\"%-*s\", lht->name_length, m->name ? m->name : \"-\");\n\t\t\tlen += lht->name_length;\n\t\t\tif ((len + lht->name_length) >= termwidth) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprintf(\" \");\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t}\n\tif (len > 0)\n\t\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-*s\"",
            "lht->name_length",
            "m->name ? m->name : \"-\""
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "m->name ? m->name : \"-\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t size, size_t termwidth, bool list)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tsize_t i, len = 0;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (list) {\n\t\t\tprintf(\"%s\\n\", m->name ? m->name : \"-\");\n\t\t} else {\n\t\t\tprintf(\"%-*s\", lht->name_length, m->name ? m->name : \"-\");\n\t\t\tlen += lht->name_length;\n\t\t\tif ((len + lht->name_length) >= termwidth) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprintf(\" \");\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t}\n\tif (len > 0)\n\t\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "ls_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "735-750",
    "snippet": "static struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*ls",
            "(*size + 1) * sizeof(struct ls)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}"
  },
  {
    "function_name": "ls_has_all_grps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "702-733",
    "snippet": "static bool ls_has_all_grps(const char *has, char **must, size_t must_len)\n{\n\tbool bret = false;\n\n\tif (!has && must)\n\t\treturn false;\n\telse if (!must)\n\t\treturn true;\n\n\tchar **tmp_has = lxc_string_split_and_trim(has, ',');\n\tsize_t tmp_has_len = lxc_array_len((void **)tmp_has);\n\n\t/* Don't do any unnecessary work. */\n\tif (must_len > tmp_has_len)\n\t\tgoto out;\n\n\tsize_t i, j;\n\tfor (i = 0; i < must_len; i++) {\n\t\tfor (j = 0; j < tmp_has_len; j++)\n\t\t\tif (strcmp(must[i], tmp_has[j]) == 0)\n\t\t\t\tbreak;\n\t\tif (j == tmp_has_len)\n\t\t\tbreak;\n\t}\n\tif (i == must_len)\n\t\tbret = true;\n\nout:\n\tlxc_free_array((void **)tmp_has, free);\n\n\treturn bret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ls_has_all_grps(const char *has, char **must, size_t must_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)tmp_has",
            "free"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "must[i]",
            "tmp_has[j]"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)tmp_has"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split_and_trim",
          "args": [
            "has",
            "','"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic bool ls_has_all_grps(const char *has, char **must, size_t must_len);\n\nstatic bool ls_has_all_grps(const char *has, char **must, size_t must_len)\n{\n\tbool bret = false;\n\n\tif (!has && must)\n\t\treturn false;\n\telse if (!must)\n\t\treturn true;\n\n\tchar **tmp_has = lxc_string_split_and_trim(has, ',');\n\tsize_t tmp_has_len = lxc_array_len((void **)tmp_has);\n\n\t/* Don't do any unnecessary work. */\n\tif (must_len > tmp_has_len)\n\t\tgoto out;\n\n\tsize_t i, j;\n\tfor (i = 0; i < must_len; i++) {\n\t\tfor (j = 0; j < tmp_has_len; j++)\n\t\t\tif (strcmp(must[i], tmp_has[j]) == 0)\n\t\t\t\tbreak;\n\t\tif (j == tmp_has_len)\n\t\t\tbreak;\n\t}\n\tif (i == must_len)\n\t\tbret = true;\n\nout:\n\tlxc_free_array((void **)tmp_has, free);\n\n\treturn bret;\n}"
  },
  {
    "function_name": "ls_get_term_width",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "690-700",
    "snippet": "static unsigned int ls_get_term_width(void)\n{\n\tstruct winsize ws;\n\tif (((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)) ||\n\t    (ws.ws_col == 0))\n\t\treturn 0;\n\n\treturn ws.ws_col;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ls_get_term_width(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "STDIN_FILENO",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "STDERR_FILENO",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "STDOUT_FILENO",
            "TIOCGWINSZ",
            "&ws"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic unsigned int ls_get_term_width(void);\n\nstatic unsigned int ls_get_term_width(void)\n{\n\tstruct winsize ws;\n\tif (((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)) ||\n\t    (ws.ws_col == 0))\n\t\treturn 0;\n\n\treturn ws.ws_col;\n}"
  },
  {
    "function_name": "ls_get_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "662-688",
    "snippet": "static double ls_get_swap(struct lxc_container *c)\n{\n\tunsigned long long int num = 0;\n\tchar *stat = ls_get_cgroup_item(c, \"memory.stat\");\n\tif (!stat)\n\t\tgoto out;\n\n\tchar *swap = strstr(stat, \"\\nswap\");\n\tif (!swap)\n\t\tgoto out;\n\n\tswap = 1 + swap + 4 + 1; // start_of_swap_value = '\\n' + strlen(swap) + ' '\n\n\tchar *tmp = strchr(swap, '\\n'); // find end of swap value\n\tif (!tmp)\n\t\tgoto out;\n\n\t*tmp = '\\0';\n\n\tnum = strtoull(swap, NULL, 0);\n\tnum = num / 1024 / 1024;\n\nout:\n\tfree(stat);\n\n\treturn num;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "stat"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "swap",
            "NULL",
            "0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "swap",
            "'\\n'"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "stat",
            "\"\\nswap\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_get_cgroup_item",
          "args": [
            "c",
            "\"memory.stat\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_cgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "581-597",
          "snippet": "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic double ls_get_swap(struct lxc_container *c)\n{\n\tunsigned long long int num = 0;\n\tchar *stat = ls_get_cgroup_item(c, \"memory.stat\");\n\tif (!stat)\n\t\tgoto out;\n\n\tchar *swap = strstr(stat, \"\\nswap\");\n\tif (!swap)\n\t\tgoto out;\n\n\tswap = 1 + swap + 4 + 1; // start_of_swap_value = '\\n' + strlen(swap) + ' '\n\n\tchar *tmp = strchr(swap, '\\n'); // find end of swap value\n\tif (!tmp)\n\t\tgoto out;\n\n\t*tmp = '\\0';\n\n\tnum = strtoull(swap, NULL, 0);\n\tnum = num / 1024 / 1024;\n\nout:\n\tfree(stat);\n\n\treturn num;\n}"
  },
  {
    "function_name": "ls_get_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "642-653",
    "snippet": "static char *ls_get_interface(struct lxc_container *c)\n{\n\tchar **interfaces = c->get_interfaces(c);\n\tif (!interfaces)\n\t\treturn NULL;\n\n\tchar *interface = lxc_string_join(\", \", (const char **)interfaces, false);\n\n\tlxc_free_array((void **)interfaces, free);\n\n\treturn interface;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)interfaces",
            "free"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\", \"",
            "(const char **)interfaces",
            "false"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_interfaces",
          "args": [
            "c"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_interface(struct lxc_container *c)\n{\n\tchar **interfaces = c->get_interfaces(c);\n\tif (!interfaces)\n\t\treturn NULL;\n\n\tchar *interface = lxc_string_join(\", \", (const char **)interfaces, false);\n\n\tlxc_free_array((void **)interfaces, free);\n\n\treturn interface;\n}"
  },
  {
    "function_name": "ls_get_ips",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "630-640",
    "snippet": "static char *ls_get_ips(struct lxc_container *c, const char *inet)\n{\n\tchar *ips = NULL;\n\tchar **iptmp = c->get_ips(c, NULL, inet, 0);\n\tif (iptmp)\n\t\tips = lxc_string_join(\", \", (const char **)iptmp, false);\n\n\tlxc_free_array((void **)iptmp, free);\n\n\treturn ips;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *ls_get_ips(struct lxc_container *c, const char *inet);",
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)iptmp",
            "free"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\", \"",
            "(const char **)iptmp",
            "false"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_ips",
          "args": [
            "c",
            "NULL",
            "inet",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet)\n{\n\tchar *ips = NULL;\n\tchar **iptmp = c->get_ips(c, NULL, inet, 0);\n\tif (iptmp)\n\t\tips = lxc_string_join(\", \", (const char **)iptmp, false);\n\n\tlxc_free_array((void **)iptmp, free);\n\n\treturn ips;\n}"
  },
  {
    "function_name": "ls_get_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "599-628",
    "snippet": "static char *ls_get_groups(struct lxc_container *c, bool running)\n{\n\tsize_t len = 0;\n\tchar *val = NULL;\n\n\tif (running)\n\t\tval = c->get_running_config_item(c, \"lxc.group\");\n\telse\n\t\tlen = c->get_config_item(c, \"lxc.group\", NULL, 0);\n\n\tif (!val && (len > 0)) {\n\t\tval = malloc((len + 1) * sizeof(*val));\n\t\tif ((size_t)c->get_config_item(c, \"lxc.group\", val, len + 1) != len) {\n\t\t\tfree(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (val) {\n\t\tchar *tmp;\n\t\tif ((tmp = strrchr(val, '\\n')))\n\t\t\t*tmp = '\\0';\n\n\t\ttmp = lxc_string_replace(\"\\n\", \", \", val);\n\t\tfree(val);\n\t\tval = tmp;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);",
      "static int ls_serialize(int wpipefd, struct ls *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_replace",
          "args": [
            "\"\\n\"",
            "\", \"",
            "val"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "601-654",
          "snippet": "char *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_replace(const char *needle, const char *replacement, const char *haystack)\n{\n\tssize_t len = -1, saved_len = -1;\n\tchar *result = NULL;\n\tsize_t replacement_len = strlen(replacement);\n\tsize_t needle_len = strlen(needle);\n\n\t/* should be executed exactly twice */\n\twhile (len == -1 || result == NULL) {\n\t\tchar *p;\n\t\tchar *last_p;\n\t\tssize_t part_len;\n\n\t\tif (len != -1) {\n\t\t\tresult = calloc(1, len + 1);\n\t\t\tif (!result)\n\t\t\t\treturn NULL;\n\t\t\tsaved_len = len;\n\t\t}\n\n\t\tlen = 0;\n\n\t\tfor (last_p = (char *)haystack, p = strstr(last_p, needle); p; last_p = p, p = strstr(last_p, needle)) {\n\t\t\tpart_len = (ssize_t)(p - last_p);\n\t\t\tif (result && part_len > 0)\n\t\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\t\tlen += part_len;\n\t\t\tif (result && replacement_len > 0)\n\t\t\t\tmemcpy(&result[len], replacement, replacement_len);\n\t\t\tlen += replacement_len;\n\t\t\tp += needle_len;\n\t\t}\n\t\tpart_len = strlen(last_p);\n\t\tif (result && part_len > 0)\n\t\t\tmemcpy(&result[len], last_p, part_len);\n\t\tlen += part_len;\n\t}\n\n\t/* make sure we did the same thing twice,\n\t * once for calculating length, the other\n\t * time for copying data */\n\tif (saved_len != len) {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\t/* make sure we didn't overwrite any buffer,\n\t * due to calloc the string should be 0-terminated */\n\tif (result[len] != '\\0') {\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "val",
            "'\\n'"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "\"lxc.group\"",
            "val",
            "len + 1"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len + 1) * sizeof(*val)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "\"lxc.group\"",
            "NULL",
            "0"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "\"lxc.group\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic char *ls_get_groups(struct lxc_container *c, bool running)\n{\n\tsize_t len = 0;\n\tchar *val = NULL;\n\n\tif (running)\n\t\tval = c->get_running_config_item(c, \"lxc.group\");\n\telse\n\t\tlen = c->get_config_item(c, \"lxc.group\", NULL, 0);\n\n\tif (!val && (len > 0)) {\n\t\tval = malloc((len + 1) * sizeof(*val));\n\t\tif ((size_t)c->get_config_item(c, \"lxc.group\", val, len + 1) != len) {\n\t\t\tfree(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (val) {\n\t\tchar *tmp;\n\t\tif ((tmp = strrchr(val, '\\n')))\n\t\t\t*tmp = '\\0';\n\n\t\ttmp = lxc_string_replace(\"\\n\", \", \", val);\n\t\tfree(val);\n\t\tval = tmp;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "ls_get_cgroup_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "581-597",
    "snippet": "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item);",
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "item",
            "val",
            "len + 1"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len + 1) * sizeof(*val)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_cgroup_item",
          "args": [
            "c",
            "item",
            "NULL",
            "0"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "ls_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "325-579",
    "snippet": "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_NESTLVL 5"
    ],
    "globals_used": [
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);",
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static char *ls_get_ips(struct lxc_container *c, const char *inet);",
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*lockpath"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_free_arr",
          "args": [
            "containers",
            "num"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ls_free_arr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "317-323",
          "snippet": "static void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_container_put",
          "args": [
            "c"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "312-325",
          "snippet": "int lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint lxc_container_put(struct lxc_container *c)\n{\n\tif (!c)\n\t\treturn -1;\n\tif (container_mem_lock(c))\n\t\treturn -1;\n\tif (--c->numthreads < 1) {\n\t\tcontainer_mem_unlock(c);\n\t\tlxc_container_free(c);\n\t\treturn 1;\n\t}\n\tcontainer_mem_unlock(c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_remove_lock",
          "args": [
            "path",
            "name",
            "lockpath",
            "&len_lockpath",
            "false"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ls_remove_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "997-1034",
          "snippet": "static int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc)\n{\n\tint ret = -1;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\trundir = get_rundir();\n\tif (!rundir)\n\t\tgoto out;\n\n\t/* Avoid doing unnecessary work if we can. */\n\tif (recalc) {\n\t\tsize_t newlen = strlen(path) + strlen(name) + strlen(rundir) + /* / + lxc + / + lock + / + / = */ 11 + 1;\n\t\tif (newlen > *len_lockpath) {\n\t\t\tchar *tmp = realloc(*lockpath, newlen * 2);\n\t\t\tif (!tmp)\n\t\t\t\tgoto out;\n\t\t\t*lockpath = tmp;\n\t\t\t*len_lockpath = newlen * 2;\n\t\t}\n\t}\n\n\tint check = snprintf(*lockpath, *len_lockpath, \"%s/lxc/lock/%s/%s\", rundir, path, name);\n\tif (check < 0 || (size_t)check >= *len_lockpath)\n\t\tgoto out;\n\n\tlxc_rmdir_onedev(*lockpath, NULL);\n\tret = 0;\n\nout:\n\tfree(rundir);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc);\n\nstatic int ls_remove_lock(const char *path, const char *name,\n\t\tchar **lockpath, size_t *len_lockpath, bool recalc)\n{\n\tint ret = -1;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\trundir = get_rundir();\n\tif (!rundir)\n\t\tgoto out;\n\n\t/* Avoid doing unnecessary work if we can. */\n\tif (recalc) {\n\t\tsize_t newlen = strlen(path) + strlen(name) + strlen(rundir) + /* / + lxc + / + lock + / + / = */ 11 + 1;\n\t\tif (newlen > *len_lockpath) {\n\t\t\tchar *tmp = realloc(*lockpath, newlen * 2);\n\t\t\tif (!tmp)\n\t\t\t\tgoto out;\n\t\t\t*lockpath = tmp;\n\t\t\t*len_lockpath = newlen * 2;\n\t\t}\n\t}\n\n\tint check = snprintf(*lockpath, *len_lockpath, \"%s/lxc/lock/%s/%s\", rundir, path, name);\n\tif (check < 0 || (size_t)check >= *len_lockpath)\n\t\tgoto out;\n\n\tlxc_rmdir_onedev(*lockpath, NULL);\n\tret = 0;\n\nout:\n\tfree(rundir);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get",
          "args": [
            "m",
            "size",
            "args",
            "newpath",
            "l->name",
            "lvl + 1",
            "lockpath",
            "len_lockpath",
            "grps_must",
            "grps_must_len"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "325-579",
          "snippet": "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lxc_append_paths",
          "args": [
            "basepath",
            "curr_path"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_append_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "768-785",
          "snippet": "char *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_append_paths(const char *first, const char *second)\n{\n\tsize_t len = strlen(first) + strlen(second) + 1;\n\tconst char *pattern = \"%s%s\";\n\tchar *result = NULL;\n\n\tif (second[0] != '/') {\n\t\tlen += 1;\n\t\tpattern = \"%s/%s\";\n\t}\n\n\tresult = calloc(1, len);\n\tif (!result)\n\t\treturn NULL;\n\n\tsnprintf(result, len, pattern, first, second);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get_config_item",
          "args": [
            "c",
            "\"lxc.rootfs\"",
            "running"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "295-315",
          "snippet": "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running)\n{\n\tif (running)\n\t\treturn c->get_running_config_item(c, item);\n\n\tsize_t len = c->get_config_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_config_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running)\n{\n\tif (running)\n\t\treturn c->get_running_config_item(c, item);\n\n\tsize_t len = c->get_config_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_config_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "wargs.pipefd[0]"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "wargs.pipefd[0]",
            "SHUT_RDWR"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "do_lxcapi_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1602-1631",
          "snippet": "static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstatic bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)\n{\n\tbool retv;\n\tpid_t pid;\n\tint haltsignal = SIGPWR;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (!do_lxcapi_is_running(c))\n\t\treturn true;\n\tpid = do_lxcapi_init_pid(c);\n\tif (pid <= 0)\n\t\treturn true;\n\n\t/* Detect whether we should send SIGRTMIN + 3 (e.g. systemd). */\n\tif (task_blocking_signal(pid, (SIGRTMIN + 3)))\n\t\thaltsignal = (SIGRTMIN + 3);\n\n\tif (c->lxc_conf && c->lxc_conf->haltsignal)\n\t\thaltsignal = c->lxc_conf->haltsignal;\n\n\tINFO(\"Using signal number '%d' as halt signal.\", haltsignal);\n\n\tif (kill(pid, haltsignal) < 0)\n\t\tWARN(\"Could not send signal %d to pid %d.\", haltsignal, pid);\n\n\tretv = do_lxcapi_wait(c, \"STOPPED\", timeout);\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "out"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_deserialize",
          "args": [
            "wargs.pipefd[0]",
            "m",
            "size"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ls_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "1119-1185",
          "snippet": "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len)\n{\n\tstruct ls *n;\n\tsize_t sublen = 0;\n\tssize_t nbytes = 0;\n\n\t/* get length */\n\tnbytes = sizeof(sublen);\n\tif (lxc_read_nointr(rpipefd, &sublen, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\twhile (sublen-- > 0) {\n\t\tn = ls_new(m, len);\n\t\tif (!n)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->ram);\n\t\tif (lxc_read_nointr(rpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->swap);\n\t\tif (lxc_read_nointr(rpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->init);\n\t\tif (lxc_read_nointr(rpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->autostart);\n\t\tif (lxc_read_nointr(rpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->running);\n\t\tif (lxc_read_nointr(rpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->nestlvl);\n\t\tif (lxc_read_nointr(rpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\t/* NAME */\n\t\tif (ls_recv_str(rpipefd, &n->name) < 0)\n\t\t\treturn -1;\n\n\t\t/* STATE */\n\t\tif (ls_recv_str(rpipefd, &n->state) < 0)\n\t\t\treturn -1;\n\n\t\t/* GROUPS */\n\t\tif (ls_recv_str(rpipefd, &n->groups) < 0)\n\t\t\treturn -1;\n\n\t\t/* INTERFACE */\n\t\tif (ls_recv_str(rpipefd, &n->interface) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV4 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv4) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV6 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv6) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len)\n{\n\tstruct ls *n;\n\tsize_t sublen = 0;\n\tssize_t nbytes = 0;\n\n\t/* get length */\n\tnbytes = sizeof(sublen);\n\tif (lxc_read_nointr(rpipefd, &sublen, (size_t)nbytes) != nbytes)\n\t\treturn -1;\n\n\twhile (sublen-- > 0) {\n\t\tn = ls_new(m, len);\n\t\tif (!n)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->ram);\n\t\tif (lxc_read_nointr(rpipefd, &n->ram, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->swap);\n\t\tif (lxc_read_nointr(rpipefd, &n->swap, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->init);\n\t\tif (lxc_read_nointr(rpipefd, &n->init, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->autostart);\n\t\tif (lxc_read_nointr(rpipefd, &n->autostart, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->running);\n\t\tif (lxc_read_nointr(rpipefd, &n->running, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\tnbytes = sizeof(n->nestlvl);\n\t\tif (lxc_read_nointr(rpipefd, &n->nestlvl, (size_t)nbytes) != nbytes)\n\t\t\treturn -1;\n\n\t\t/* NAME */\n\t\tif (ls_recv_str(rpipefd, &n->name) < 0)\n\t\t\treturn -1;\n\n\t\t/* STATE */\n\t\tif (ls_recv_str(rpipefd, &n->state) < 0)\n\t\t\treturn -1;\n\n\t\t/* GROUPS */\n\t\tif (ls_recv_str(rpipefd, &n->groups) < 0)\n\t\t\treturn -1;\n\n\t\t/* INTERFACE */\n\t\tif (ls_recv_str(rpipefd, &n->interface) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV4 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv4) < 0)\n\t\t\treturn -1;\n\n\t\t/* IPV6 */\n\t\tif (ls_recv_str(rpipefd, &n->ipv6) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->attach",
          "args": [
            "c",
            "ls_get_wrapper",
            "&wargs",
            "&aopt",
            "&out"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM | SOCK_CLOEXEC",
            "0",
            "wargs.pipefd"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_get_swap",
          "args": [
            "c"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "662-688",
          "snippet": "static double ls_get_swap(struct lxc_container *c)\n{\n\tunsigned long long int num = 0;\n\tchar *stat = ls_get_cgroup_item(c, \"memory.stat\");\n\tif (!stat)\n\t\tgoto out;\n\n\tchar *swap = strstr(stat, \"\\nswap\");\n\tif (!swap)\n\t\tgoto out;\n\n\tswap = 1 + swap + 4 + 1; // start_of_swap_value = '\\n' + strlen(swap) + ' '\n\n\tchar *tmp = strchr(swap, '\\n'); // find end of swap value\n\tif (!tmp)\n\t\tgoto out;\n\n\t*tmp = '\\0';\n\n\tnum = strtoull(swap, NULL, 0);\n\tnum = num / 1024 / 1024;\n\nout:\n\tfree(stat);\n\n\treturn num;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic double ls_get_swap(struct lxc_container *c)\n{\n\tunsigned long long int num = 0;\n\tchar *stat = ls_get_cgroup_item(c, \"memory.stat\");\n\tif (!stat)\n\t\tgoto out;\n\n\tchar *swap = strstr(stat, \"\\nswap\");\n\tif (!swap)\n\t\tgoto out;\n\n\tswap = 1 + swap + 4 + 1; // start_of_swap_value = '\\n' + strlen(swap) + ' '\n\n\tchar *tmp = strchr(swap, '\\n'); // find end of swap value\n\tif (!tmp)\n\t\tgoto out;\n\n\t*tmp = '\\0';\n\n\tnum = strtoull(swap, NULL, 0);\n\tnum = num / 1024 / 1024;\n\nout:\n\tfree(stat);\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "tmp",
            "NULL",
            "0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_get_cgroup_item",
          "args": [
            "c",
            "\"memory.usage_in_bytes\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_cgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "581-597",
          "snippet": "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item)\n{\n\tsize_t len = c->get_cgroup_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_cgroup_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get_ips",
          "args": [
            "c",
            "\"inet6\""
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_ips",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "630-640",
          "snippet": "static char *ls_get_ips(struct lxc_container *c, const char *inet)\n{\n\tchar *ips = NULL;\n\tchar **iptmp = c->get_ips(c, NULL, inet, 0);\n\tif (iptmp)\n\t\tips = lxc_string_join(\", \", (const char **)iptmp, false);\n\n\tlxc_free_array((void **)iptmp, free);\n\n\treturn ips;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *ls_get_ips(struct lxc_container *c, const char *inet);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet)\n{\n\tchar *ips = NULL;\n\tchar **iptmp = c->get_ips(c, NULL, inet, 0);\n\tif (iptmp)\n\t\tips = lxc_string_join(\", \", (const char **)iptmp, false);\n\n\tlxc_free_array((void **)iptmp, free);\n\n\treturn ips;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get_interface",
          "args": [
            "c"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "642-653",
          "snippet": "static char *ls_get_interface(struct lxc_container *c)\n{\n\tchar **interfaces = c->get_interfaces(c);\n\tif (!interfaces)\n\t\treturn NULL;\n\n\tchar *interface = lxc_string_join(\", \", (const char **)interfaces, false);\n\n\tlxc_free_array((void **)interfaces, free);\n\n\treturn interface;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_interface(struct lxc_container *c)\n{\n\tchar **interfaces = c->get_interfaces(c);\n\tif (!interfaces)\n\t\treturn NULL;\n\n\tchar *interface = lxc_string_join(\", \", (const char **)interfaces, false);\n\n\tlxc_free_array((void **)interfaces, free);\n\n\treturn interface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->init_pid",
          "args": [
            "c"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG",
          "args": [
            "\"Wrong value for 'lxc.start.auto = %d'.\"",
            "astart"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "\"Could not parse value for 'lxc.start.auto'.\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_safe_uint",
          "args": [
            "tmp",
            "&astart"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_safe_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1985-2003",
          "snippet": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno > 0)\n\t\treturn -errno;\n\n\tif (!err || err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "state_tmp"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->may_control",
          "args": [
            "c"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_new",
          "args": [
            "m",
            "size"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ls_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "735-750",
          "snippet": "static struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic struct ls *ls_new(struct ls **ls, size_t *size)\n{\n\tstruct ls *m, *n;\n\n\tn = realloc(*ls, (*size + 1) * sizeof(struct ls));\n\tif (!n)\n\t\treturn NULL;\n\n\t*ls = n;\n\tm = *ls + *size;\n\t(*size)++;\n\n\t*m = (struct ls){.name = NULL, .init = -1};\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_has_all_grps",
          "args": [
            "grp_tmp",
            "grps_must",
            "grps_must_len"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ls_has_all_grps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "702-733",
          "snippet": "static bool ls_has_all_grps(const char *has, char **must, size_t must_len)\n{\n\tbool bret = false;\n\n\tif (!has && must)\n\t\treturn false;\n\telse if (!must)\n\t\treturn true;\n\n\tchar **tmp_has = lxc_string_split_and_trim(has, ',');\n\tsize_t tmp_has_len = lxc_array_len((void **)tmp_has);\n\n\t/* Don't do any unnecessary work. */\n\tif (must_len > tmp_has_len)\n\t\tgoto out;\n\n\tsize_t i, j;\n\tfor (i = 0; i < must_len; i++) {\n\t\tfor (j = 0; j < tmp_has_len; j++)\n\t\t\tif (strcmp(must[i], tmp_has[j]) == 0)\n\t\t\t\tbreak;\n\t\tif (j == tmp_has_len)\n\t\t\tbreak;\n\t}\n\tif (i == must_len)\n\t\tbret = true;\n\nout:\n\tlxc_free_array((void **)tmp_has, free);\n\n\treturn bret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ls_has_all_grps(const char *has, char **must, size_t must_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic bool ls_has_all_grps(const char *has, char **must, size_t must_len);\n\nstatic bool ls_has_all_grps(const char *has, char **must, size_t must_len)\n{\n\tbool bret = false;\n\n\tif (!has && must)\n\t\treturn false;\n\telse if (!must)\n\t\treturn true;\n\n\tchar **tmp_has = lxc_string_split_and_trim(has, ',');\n\tsize_t tmp_has_len = lxc_array_len((void **)tmp_has);\n\n\t/* Don't do any unnecessary work. */\n\tif (must_len > tmp_has_len)\n\t\tgoto out;\n\n\tsize_t i, j;\n\tfor (i = 0; i < must_len; i++) {\n\t\tfor (j = 0; j < tmp_has_len; j++)\n\t\t\tif (strcmp(must[i], tmp_has[j]) == 0)\n\t\t\t\tbreak;\n\t\tif (j == tmp_has_len)\n\t\t\tbreak;\n\t}\n\tif (i == must_len)\n\t\tbret = true;\n\nout:\n\tlxc_free_array((void **)tmp_has, free);\n\n\treturn bret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get_groups",
          "args": [
            "c",
            "running"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "599-628",
          "snippet": "static char *ls_get_groups(struct lxc_container *c, bool running)\n{\n\tsize_t len = 0;\n\tchar *val = NULL;\n\n\tif (running)\n\t\tval = c->get_running_config_item(c, \"lxc.group\");\n\telse\n\t\tlen = c->get_config_item(c, \"lxc.group\", NULL, 0);\n\n\tif (!val && (len > 0)) {\n\t\tval = malloc((len + 1) * sizeof(*val));\n\t\tif ((size_t)c->get_config_item(c, \"lxc.group\", val, len + 1) != len) {\n\t\t\tfree(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (val) {\n\t\tchar *tmp;\n\t\tif ((tmp = strrchr(val, '\\n')))\n\t\t\t*tmp = '\\0';\n\n\t\ttmp = lxc_string_replace(\"\\n\", \", \", val);\n\t\tfree(val);\n\t\tval = tmp;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic char *ls_get_groups(struct lxc_container *c, bool running)\n{\n\tsize_t len = 0;\n\tchar *val = NULL;\n\n\tif (running)\n\t\tval = c->get_running_config_item(c, \"lxc.group\");\n\telse\n\t\tlen = c->get_config_item(c, \"lxc.group\", NULL, 0);\n\n\tif (!val && (len > 0)) {\n\t\tval = malloc((len + 1) * sizeof(*val));\n\t\tif ((size_t)c->get_config_item(c, \"lxc.group\", val, len + 1) != len) {\n\t\t\tfree(val);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (val) {\n\t\tchar *tmp;\n\t\tif ((tmp = strrchr(val, '\\n')))\n\t\t\t*tmp = '\\0';\n\n\t\ttmp = lxc_string_replace(\"\\n\", \", \", val);\n\t\tfree(val);\n\t\tval = tmp;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "state_tmp",
            "\"STOPPED\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "state_tmp",
            "\"FROZEN\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_running",
          "args": [
            "c"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->state",
          "args": [
            "c"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->is_defined",
          "args": [
            "c"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_container_new",
          "args": [
            "name",
            "path"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_container_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4099-4218",
          "snippet": "struct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nstruct lxc_container *lxc_container_new(const char *name, const char *configpath)\n{\n\tstruct lxc_container *c;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tc = malloc(sizeof(*c));\n\tif (!c) {\n\t\tfprintf(stderr, \"failed to malloc lxc_container\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(c, 0, sizeof(*c));\n\n\tif (configpath)\n\t\tc->config_path = strdup(configpath);\n\telse\n\t\tc->config_path = strdup(lxc_global_config_value(\"lxc.lxcpath\"));\n\n\tif (!c->config_path) {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\tgoto err;\n\t}\n\n\tremove_trailing_slashes(c->config_path);\n\tc->name = malloc(strlen(name)+1);\n\tif (!c->name) {\n\t\tfprintf(stderr, \"Error allocating lxc_container name\\n\");\n\t\tgoto err;\n\t}\n\tstrcpy(c->name, name);\n\n\tc->numthreads = 1;\n\tif (!(c->slock = lxc_newlock(c->config_path, name))) {\n\t\tfprintf(stderr, \"failed to create lock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!(c->privlock = lxc_newlock(NULL, NULL))) {\n\t\tfprintf(stderr, \"failed to alloc privlock\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!set_config_filename(c)) {\n\t\tfprintf(stderr, \"Error allocating config file pathname\\n\");\n\t\tgoto err;\n\t}\n\n\tif (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))\n\t\tgoto err;\n\n\tif (ongoing_create(c) == 2) {\n\t\tERROR(\"Error: %s creation was not completed\", c->name);\n\t\tcontainer_destroy(c);\n\t\tlxcapi_clear_config(c);\n\t}\n\tc->daemonize = true;\n\tc->pidfile = NULL;\n\n\t// assign the member functions\n\tc->is_defined = lxcapi_is_defined;\n\tc->state = lxcapi_state;\n\tc->is_running = lxcapi_is_running;\n\tc->freeze = lxcapi_freeze;\n\tc->unfreeze = lxcapi_unfreeze;\n\tc->console = lxcapi_console;\n\tc->console_getfd = lxcapi_console_getfd;\n\tc->init_pid = lxcapi_init_pid;\n\tc->load_config = lxcapi_load_config;\n\tc->want_daemonize = lxcapi_want_daemonize;\n\tc->want_close_all_fds = lxcapi_want_close_all_fds;\n\tc->start = lxcapi_start;\n\tc->startl = lxcapi_startl;\n\tc->stop = lxcapi_stop;\n\tc->config_file_name = lxcapi_config_file_name;\n\tc->wait = lxcapi_wait;\n\tc->set_config_item = lxcapi_set_config_item;\n\tc->destroy = lxcapi_destroy;\n\tc->destroy_with_snapshots = lxcapi_destroy_with_snapshots;\n\tc->rename = lxcapi_rename;\n\tc->save_config = lxcapi_save_config;\n\tc->get_keys = lxcapi_get_keys;\n\tc->create = lxcapi_create;\n\tc->createl = lxcapi_createl;\n\tc->shutdown = lxcapi_shutdown;\n\tc->reboot = lxcapi_reboot;\n\tc->clear_config = lxcapi_clear_config;\n\tc->clear_config_item = lxcapi_clear_config_item;\n\tc->get_config_item = lxcapi_get_config_item;\n\tc->get_running_config_item = lxcapi_get_running_config_item;\n\tc->get_cgroup_item = lxcapi_get_cgroup_item;\n\tc->set_cgroup_item = lxcapi_set_cgroup_item;\n\tc->get_config_path = lxcapi_get_config_path;\n\tc->set_config_path = lxcapi_set_config_path;\n\tc->clone = lxcapi_clone;\n\tc->get_interfaces = lxcapi_get_interfaces;\n\tc->get_ips = lxcapi_get_ips;\n\tc->attach = lxcapi_attach;\n\tc->attach_run_wait = lxcapi_attach_run_wait;\n\tc->attach_run_waitl = lxcapi_attach_run_waitl;\n\tc->snapshot = lxcapi_snapshot;\n\tc->snapshot_list = lxcapi_snapshot_list;\n\tc->snapshot_restore = lxcapi_snapshot_restore;\n\tc->snapshot_destroy = lxcapi_snapshot_destroy;\n\tc->snapshot_destroy_all = lxcapi_snapshot_destroy_all;\n\tc->may_control = lxcapi_may_control;\n\tc->add_device_node = lxcapi_add_device_node;\n\tc->remove_device_node = lxcapi_remove_device_node;\n\tc->attach_interface = lxcapi_attach_interface;\n\tc->detach_interface = lxcapi_detach_interface;\n\tc->checkpoint = lxcapi_checkpoint;\n\tc->restore = lxcapi_restore;\n\tc->migrate = lxcapi_migrate;\n\n\treturn c;\n\nerr:\n\tlxc_container_free(c);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "&preg",
            "name",
            "0",
            "NULL",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "&preg",
            "tmp",
            "REG_NOSUB | REG_EXTENDED"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_all_containers",
          "args": [
            "path",
            "&containers",
            "NULL"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "list_all_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4446-4526",
          "snippet": "int list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_all_containers(const char *lxcpath, char ***nret,\n\t\t\tstruct lxc_container ***cret)\n{\n\tint i, ret, active_cnt, ct_cnt, ct_list_cnt;\n\tchar **active_name;\n\tchar **ct_name;\n\tstruct lxc_container **ct_list = NULL;\n\n\tct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);\n\tif (ct_cnt < 0)\n\t\treturn ct_cnt;\n\n\tactive_cnt = list_active_containers(lxcpath, &active_name, NULL);\n\tif (active_cnt < 0) {\n\t\tret = active_cnt;\n\t\tgoto free_ct_name;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tif (!array_contains(&ct_name, active_name[i], ct_cnt)) {\n\t\t\tif (!add_to_array(&ct_name, active_name[i], ct_cnt)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto free_active_name;\n\t\t\t}\n\t\t\tct_cnt++;\n\t\t}\n\t\tfree(active_name[i]);\n\t\tactive_name[i] = NULL;\n\t}\n\tfree(active_name);\n\tactive_name = NULL;\n\tactive_cnt = 0;\n\n\tfor (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {\n\t\tstruct lxc_container *c;\n\n\t\tc = lxc_container_new(ct_name[i], lxcpath);\n\t\tif (!c) {\n\t\t\tWARN(\"Container %s:%s could not be loaded\", lxcpath, ct_name[i]);\n\t\t\tremove_from_array(&ct_name, ct_name[i], ct_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {\n\t\t\tlxc_container_put(c);\n\t\t\tret = -1;\n\t\t\tgoto free_ct_list;\n\t\t}\n\t\tct_list_cnt++;\n\t}\n\n\tif (cret)\n\t\t*cret = ct_list;\n\n\tif (nret)\n\t\t*nret = ct_name;\n\telse {\n\t\tret = ct_cnt;\n\t\tgoto free_ct_name;\n\t}\n\treturn ct_cnt;\n\nfree_ct_list:\n\tfor (i = 0; i < ct_list_cnt; i++) {\n\t\tlxc_container_put(ct_list[i]);\n\t}\n\tfree(ct_list);\n\nfree_active_name:\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tfree(active_name[i]);\n\t}\n\tfree(active_name);\n\nfree_ct_name:\n\tfor (i = 0; i < ct_cnt; i++) {\n\t\tfree(ct_name[i]);\n\t}\n\tfree(ct_name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_active_containers",
          "args": [
            "path",
            "&containers",
            "NULL"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "list_active_containers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "4321-4444",
          "snippet": "int list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_lxcapi_destroy(struct lxc_container *c);",
            "static const char *lxcapi_get_config_path(struct lxc_container *c);",
            "static bool container_destroy(struct lxc_container *c);",
            "static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic bool do_lxcapi_destroy(struct lxc_container *c);\nstatic const char *lxcapi_get_config_path(struct lxc_container *c);\nstatic bool container_destroy(struct lxc_container *c);\nstatic bool lxcapi_snapshot_destroy_all(struct lxc_container *c);\n\nint list_active_containers(const char *lxcpath, char ***nret,\n\t\t\t   struct lxc_container ***cret)\n{\n\tint i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;\n\tint lxcpath_len;\n\tchar *line = NULL;\n\tchar **ct_name = NULL;\n\tsize_t len = 0;\n\tstruct lxc_container *c = NULL;\n\tbool is_hashed;\n\n\tif (!lxcpath)\n\t\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tlxcpath_len = strlen(lxcpath);\n\n\tif (cret)\n\t\t*cret = NULL;\n\tif (nret)\n\t\t*nret = NULL;\n\n\tFILE *f = fopen(\"/proc/net/unix\", \"r\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &len, f) != -1) {\n\n\t\tchar *p = strrchr(line, ' '), *p2;\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (*p != 0x40)\n\t\t\tcontinue;\n\t\tp++;\n\n\t\tis_hashed = false;\n\t\tif (strncmp(p, lxcpath, lxcpath_len) == 0) {\n\t\t\tp += lxcpath_len;\n\t\t} else if (strncmp(p, \"lxc/\", 4) == 0) {\n\t\t\tp += 4;\n\t\t\tis_hashed = true;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*p == '/')\n\t\t\tp++;\n\n\t\t// Now p is the start of lxc_name\n\t\tp2 = strchr(p, '/');\n\t\tif (!p2 || strncmp(p2, \"/command\", 8) != 0)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\n\t\tif (is_hashed) {\n\t\t\tif (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)\n\t\t\t\tcontinue;\n\t\t\tp = lxc_cmd_get_name(p);\n\t\t}\n\n\t\tif (array_contains(&ct_name, p, ct_name_cnt))\n\t\t\tcontinue;\n\n\t\tif (!add_to_array(&ct_name, p, ct_name_cnt))\n\t\t\tgoto free_cret_list;\n\n\t\tct_name_cnt++;\n\n\t\tif (!cret)\n\t\t\tcontinue;\n\n\t\tc = lxc_container_new(p, lxcpath);\n\t\tif (!c) {\n\t\t\tINFO(\"Container %s:%s is running but could not be loaded\",\n\t\t\t\tlxcpath, p);\n\t\t\tremove_from_array(&ct_name, p, ct_name_cnt--);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is an anonymous container, then is_defined *can*\n\t\t * return false.  So we don't do that check.  Count on the\n\t\t * fact that the command socket exists.\n\t\t */\n\n\t\tif (!add_to_clist(cret, c, cret_cnt, true)) {\n\t\t\tlxc_container_put(c);\n\t\t\tgoto free_cret_list;\n\t\t}\n\t\tcret_cnt++;\n\t}\n\n\tif (nret && cret && cret_cnt != ct_name_cnt) {\n\t\tif (c)\n\t\t\tlxc_container_put(c);\n\t\tgoto free_cret_list;\n\t}\n\n\tret = ct_name_cnt;\n\tif (nret)\n\t\t*nret = ct_name;\n\telse\n\t\tgoto free_ct_name;\n\tgoto out;\n\nfree_cret_list:\n\tif (cret && *cret) {\n\t\tfor (i = 0; i < cret_cnt; i++)\n\t\t\tlxc_container_put((*cret)[i]);\n\t\tfree(*cret);\n\t}\n\nfree_ct_name:\n\tif (ct_name) {\n\t\tfor (i = 0; i < ct_name_cnt; i++)\n\t\t\tfree(ct_name[i]);\n\t\tfree(ct_name);\n\t}\n\nout:\n\tfree(line);\n\n\tfclose(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_exists",
          "args": [
            "path"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "dir_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1059-1069",
          "snippet": "bool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool dir_exists(const char *path)\n{\n\tstruct stat sb;\n\tint ret;\n\n\tret = stat(path, &sb);\n\tif (ret < 0)\n\t\t// could be something other than eexist, just say no\n\t\treturn false;\n\treturn S_ISDIR(sb.st_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\n#define MAX_NESTLVL 5\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ls_free_arr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "317-323",
    "snippet": "static void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "arr"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}"
  },
  {
    "function_name": "ls_get_config_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "295-315",
    "snippet": "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running)\n{\n\tif (running)\n\t\treturn c->get_running_config_item(c, item);\n\n\tsize_t len = c->get_config_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_config_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
      "static char *ls_get_cgroup_item(struct lxc_container *c, const char *item);",
      "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
      "static char *ls_get_groups(struct lxc_container *c, bool running);",
      "static double ls_get_swap(struct lxc_container *c);",
      "static char *ls_get_interface(struct lxc_container *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "item",
            "val",
            "len + 1"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(len + 1) * sizeof(*val)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_config_item",
          "args": [
            "c",
            "item",
            "NULL",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->get_running_config_item",
          "args": [
            "c",
            "item"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic char *ls_get_cgroup_item(struct lxc_container *c, const char *item);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\n\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running)\n{\n\tif (running)\n\t\treturn c->get_running_config_item(c, item);\n\n\tsize_t len = c->get_config_item(c, item, NULL, 0);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tchar *val = malloc((len + 1) * sizeof(*val));\n\tif (!val)\n\t\treturn NULL;\n\n\tif ((size_t)c->get_config_item(c, item, val, len + 1) != len) {\n\t\tfree(val);\n\t\tval = NULL;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "ls_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "280-293",
    "snippet": "static void ls_free(struct ls *l, size_t size)\n{\n\tsize_t i;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfree(m->groups);\n\t\tfree(m->interface);\n\t\tfree(m->ipv4);\n\t\tfree(m->ipv6);\n\t\tfree(m->name);\n\t\tfree(m->state);\n\t}\n\tfree(l);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ls_free(struct ls *l, size_t size);",
      "static void ls_free_arr(char **arr, size_t size);",
      "static struct ls *ls_new(struct ls **ls, size_t *size);",
      "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "l"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_free(struct ls *l, size_t size)\n{\n\tsize_t i;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfree(m->groups);\n\t\tfree(m->interface);\n\t\tfree(m->ipv4);\n\t\tfree(m->ipv6);\n\t\tfree(m->name);\n\t\tfree(m->state);\n\t}\n\tfree(l);\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
    "lines": "203-278",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret = EXIT_FAILURE;\n\t/*\n\t * The lxc parser requires that my_args.name is set. So let's satisfy\n\t * that condition by setting a dummy name which is never used.\n\t */\n\tmy_args.name  = \"\";\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\t/*\n\t * We set the first argument that usually takes my_args.name to NULL so\n\t * that the log is only used when the user specifies a file.\n\t */\n\tif (lxc_log_init(NULL, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tstruct lengths max_len = {\n\t\t/* default header length */\n\t\t.name_length = 4,      /* NAME */\n\t\t.state_length = 5,     /* STATE */\n\t\t.groups_length = 6,    /* GROUPS */\n\t\t.interface_length = 9, /* INTERFACE */\n\t\t.ipv4_length = 4,      /* IPV4 */\n\t\t.ipv6_length = 4,      /* IPV6 */\n\t\t.init_length = 3,      /* PID */\n\t\t.ram_length = 3,       /* RAM */\n\t\t.swap_length = 4,      /* SWAP */\n\t\t.autostart_length = 9, /* AUTOSTART */\n\t};\n\n\tchar **grps = NULL;\n\tsize_t ngrps = 0;\n\tif (my_args.groups) {\n\t\tgrps = lxc_string_split_and_trim(my_args.groups, ',');\n\t\tngrps = lxc_array_len((void **)grps);\n\t}\n\n\tstruct ls *ls_arr = NULL;\n\tsize_t ls_size = 0;\n\t/* &(char *){NULL} is no magic. It's just a compound literal which\n\t * avoids having a pointless variable in main() that serves no purpose\n\t * here. */\n\tint status = ls_get(&ls_arr, &ls_size, &my_args, \"\", NULL, 0, &(char *){NULL}, 0, grps, ngrps);\n\tif (!ls_arr && status == 0)\n\t\t/* We did not fail. There was just nothing to do. */\n\t\texit(EXIT_SUCCESS);\n\telse if (!ls_arr || status == -1)\n\t\tgoto out;\n\n\tls_field_width(ls_arr, ls_size, &max_len);\n\tif (my_args.ls_fancy && !my_args.ls_fancy_format) {\n\t\tls_print_table(ls_arr, &max_len, ls_size);\n\t} else if (my_args.ls_fancy && my_args.ls_fancy_format) {\n\t\tls_print_fancy_format(ls_arr, &max_len, ls_size, my_args.ls_fancy_format);\n\t} else {\n\t\tunsigned int cols = 0;\n\t\tif (!my_args.ls_line)\n\t\t\tcols = ls_get_term_width();\n\t\tls_print_names(ls_arr, &max_len, ls_size, cols, my_args.ls_line);\n\t}\n\n\tret = EXIT_SUCCESS;\n\nout:\n\tls_free(ls_arr, ls_size);\n\tlxc_free_array((void **)grps, free);\n\n\texit(ret);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"confile.h\"",
      "#include \"conf.h\"",
      "#include \"arguments.h\"",
      "#include <lxc/lxccontainer.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/ioctl.h>",
      "#include <unistd.h>",
      "#include <termios.h>",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <regex.h>",
      "#include <getopt.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ls_get_term_width(void);",
      "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-ls\",\n\t.help = \"\\n\\\n[-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n[-1] [-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n[-f] [-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n\\n\\\nlxc-ls list containers\\n\\\n\\n\\\nOptions :\\n\\\n  -1, --line         show one entry per line\\n\\\n  -f, --fancy        use a fancy, column-based output\\n\\\n  -F, --fancy-format comma separated list of columns to show in the fancy output\\n\\\n                     valid columns are: NAME, STATE, PID, RAM, SWAP, AUTOSTART,\\n\\\n                     GROUPS, INTERFACE, IPV4 and IPV6\\n\\\n  --active           list only active containers\\n\\\n  --running          list only running containers\\n\\\n  --frozen           list only frozen containers\\n\\\n  --stopped          list only stopped containers\\n\\\n  --nesting=NUM      list nested containers up to NUM (default is 5) levels of nesting\\n\\\n  --filter=REGEX     filter container names by regular expression\\n\\\n  -g --groups        comma separated list of groups a container must have to be displayed\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.ls_nesting = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_free_array",
          "args": [
            "(void **)grps",
            "free"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_free_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "886-892",
          "snippet": "void lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nvoid lxc_free_array(void **array, lxc_free_fn element_free_fn)\n{\n\tvoid **p;\n\tfor (p = array; p && *p; p++)\n\t\telement_free_fn(*p);\n\tfree((void*)array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_free",
          "args": [
            "ls_arr",
            "ls_size"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ls_free_arr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "317-323",
          "snippet": "static void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_free_arr(char **arr, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size; i++)\n\t\tfree(arr[i]);\n\tfree(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_print_names",
          "args": [
            "ls_arr",
            "&max_len",
            "ls_size",
            "cols",
            "my_args.ls_line"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ls_print_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "752-778",
          "snippet": "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t size, size_t termwidth, bool list)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tsize_t i, len = 0;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (list) {\n\t\t\tprintf(\"%s\\n\", m->name ? m->name : \"-\");\n\t\t} else {\n\t\t\tprintf(\"%-*s\", lht->name_length, m->name ? m->name : \"-\");\n\t\t\tlen += lht->name_length;\n\t\t\tif ((len + lht->name_length) >= termwidth) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprintf(\" \");\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t}\n\tif (len > 0)\n\t\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t size, size_t termwidth, bool list)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tsize_t i, len = 0;\n\tstruct ls *m = NULL;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (list) {\n\t\t\tprintf(\"%s\\n\", m->name ? m->name : \"-\");\n\t\t} else {\n\t\t\tprintf(\"%-*s\", lht->name_length, m->name ? m->name : \"-\");\n\t\t\tlen += lht->name_length;\n\t\t\tif ((len + lht->name_length) >= termwidth) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tprintf(\" \");\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t}\n\tif (len > 0)\n\t\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_get_term_width",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get_term_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "690-700",
          "snippet": "static unsigned int ls_get_term_width(void)\n{\n\tstruct winsize ws;\n\tif (((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)) ||\n\t    (ws.ws_col == 0))\n\t\treturn 0;\n\n\treturn ws.ws_col;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int ls_get_term_width(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic unsigned int ls_get_term_width(void);\n\nstatic unsigned int ls_get_term_width(void)\n{\n\tstruct winsize ws;\n\tif (((ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) == -1) &&\n\t     (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)) ||\n\t    (ws.ws_col == 0))\n\t\treturn 0;\n\n\treturn ws.ws_col;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_print_fancy_format",
          "args": [
            "ls_arr",
            "&max_len",
            "ls_size",
            "my_args.ls_fancy_format"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ls_print_fancy_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "780-871",
          "snippet": "static void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tchar **tmp = lxc_string_split_and_trim(fancy_fmt, ',');\n\tif (!tmp)\n\t\treturn;\n\n\tchar **s;\n\t/* Check for invalid keys. */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") && strcasecmp(*s, \"STATE\") &&\n\t\t\t\tstrcasecmp(*s, \"PID\") && strcasecmp(*s, \"RAM\") &&\n\t\t\t\tstrcasecmp(*s, \"SWAP\") && strcasecmp(*s, \"AUTOSTART\") &&\n\t\t\t\tstrcasecmp(*s, \"GROUPS\") && strcasecmp(*s, \"INTERFACE\") &&\n\t\t\t\tstrcasecmp(*s, \"IPV4\") && strcasecmp(*s, \"IPV6\")) {\n\t\t\tfprintf(stderr, \"Invalid key: %s\\n\", *s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* print header */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") == 0)\n\t\t\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\t\telse if (strcasecmp(*s, \"STATE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\t\telse if (strcasecmp(*s, \"PID\") == 0)\n\t\t\tprintf(\"%-*s \", lht->init_length, \"PID\");\n\t\telse if (strcasecmp(*s, \"RAM\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ram_length + 2, \"RAM\");\n\t\telse if (strcasecmp(*s, \"SWAP\") == 0)\n\t\t\tprintf(\"%-*s \", lht->swap_length + 2, \"SWAP\");\n\t\telse if (strcasecmp(*s, \"AUTOSTART\") == 0)\n\t\t\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\t\telse if (strcasecmp(*s, \"GROUPS\") == 0)\n\t\t\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\t\telse if (strcasecmp(*s, \"INTERFACE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->interface_length, \"INTERFACE\");\n\t\telse if (strcasecmp(*s, \"IPV4\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\t\telse if (strcasecmp(*s, \"IPV6\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\t}\n\tprintf(\"\\n\");\n\n\tstruct ls *m = NULL;\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfor (s = tmp; s && *s; s++) {\n\t\t\tif (strcasecmp(*s, \"NAME\") == 0) {\n\t\t\t\tif (m->nestlvl > 0) {\n\t\t\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t\t\t}\n\t\t\t} else if (strcasecmp(*s, \"STATE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"PID\") == 0) {\n\t\t\t\tif (m->init > 0)\n\t\t\t\t\tprintf(\"%-*d \", lht->init_length, m->init);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s \", lht->init_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"RAM\") == 0) {\n\t\t\t\tif ((m->ram >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->ram_length, m->ram);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->ram_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"SWAP\") == 0) {\n\t\t\t\tif ((m->swap >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->swap_length, m->swap);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->swap_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"AUTOSTART\") == 0) {\n\t\t\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\t\t} else if (strcasecmp(*s, \"GROUPS\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"INTERFACE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->interface_length, m->interface ? m->interface : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV4\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV6\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt);",
            "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_fancy_format(struct ls *l, struct lengths *lht,\n\t\tsize_t size, const char *fancy_fmt)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tchar **tmp = lxc_string_split_and_trim(fancy_fmt, ',');\n\tif (!tmp)\n\t\treturn;\n\n\tchar **s;\n\t/* Check for invalid keys. */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") && strcasecmp(*s, \"STATE\") &&\n\t\t\t\tstrcasecmp(*s, \"PID\") && strcasecmp(*s, \"RAM\") &&\n\t\t\t\tstrcasecmp(*s, \"SWAP\") && strcasecmp(*s, \"AUTOSTART\") &&\n\t\t\t\tstrcasecmp(*s, \"GROUPS\") && strcasecmp(*s, \"INTERFACE\") &&\n\t\t\t\tstrcasecmp(*s, \"IPV4\") && strcasecmp(*s, \"IPV6\")) {\n\t\t\tfprintf(stderr, \"Invalid key: %s\\n\", *s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* print header */\n\tfor (s = tmp; s && *s; s++) {\n\t\tif (strcasecmp(*s, \"NAME\") == 0)\n\t\t\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\t\telse if (strcasecmp(*s, \"STATE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\t\telse if (strcasecmp(*s, \"PID\") == 0)\n\t\t\tprintf(\"%-*s \", lht->init_length, \"PID\");\n\t\telse if (strcasecmp(*s, \"RAM\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ram_length + 2, \"RAM\");\n\t\telse if (strcasecmp(*s, \"SWAP\") == 0)\n\t\t\tprintf(\"%-*s \", lht->swap_length + 2, \"SWAP\");\n\t\telse if (strcasecmp(*s, \"AUTOSTART\") == 0)\n\t\t\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\t\telse if (strcasecmp(*s, \"GROUPS\") == 0)\n\t\t\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\t\telse if (strcasecmp(*s, \"INTERFACE\") == 0)\n\t\t\tprintf(\"%-*s \", lht->interface_length, \"INTERFACE\");\n\t\telse if (strcasecmp(*s, \"IPV4\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\t\telse if (strcasecmp(*s, \"IPV6\") == 0)\n\t\t\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\t}\n\tprintf(\"\\n\");\n\n\tstruct ls *m = NULL;\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tfor (s = tmp; s && *s; s++) {\n\t\t\tif (strcasecmp(*s, \"NAME\") == 0) {\n\t\t\t\tif (m->nestlvl > 0) {\n\t\t\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t\t\t}\n\t\t\t} else if (strcasecmp(*s, \"STATE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"PID\") == 0) {\n\t\t\t\tif (m->init > 0)\n\t\t\t\t\tprintf(\"%-*d \", lht->init_length, m->init);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s \", lht->init_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"RAM\") == 0) {\n\t\t\t\tif ((m->ram >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->ram_length, m->ram);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->ram_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"SWAP\") == 0) {\n\t\t\t\tif ((m->swap >= 0) && m->running)\n\t\t\t\t\tprintf(\"%*.2fMB \", lht->swap_length, m->swap);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%-*s   \", lht->swap_length, \"-\");\n\t\t\t} else if (strcasecmp(*s, \"AUTOSTART\") == 0) {\n\t\t\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\t\t} else if (strcasecmp(*s, \"GROUPS\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"INTERFACE\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->interface_length, m->interface ? m->interface : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV4\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\t\t} else if (strcasecmp(*s, \"IPV6\") == 0) {\n\t\t\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_print_table",
          "args": [
            "ls_arr",
            "&max_len",
            "ls_size"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ls_print_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "873-906",
          "snippet": "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tstruct ls *m = NULL;\n\n\t/* print header */\n\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\tprintf(\"\\n\");\n\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->nestlvl > 0) {\n\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t} else {\n\t\t     printf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t}\n\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);",
            "static int ls_serialize(int wpipefd, struct ls *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_names(struct ls *l, struct lengths *lht,\n\t\tsize_t ls_arr, size_t termwidth, bool list);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\nstatic int ls_serialize(int wpipefd, struct ls *n);\n\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size)\n{\n\t/* If list is empty do nothing. */\n\tif (size == 0)\n\t\treturn;\n\n\tstruct ls *m = NULL;\n\n\t/* print header */\n\tprintf(\"%-*s \", lht->name_length, \"NAME\");\n\tprintf(\"%-*s \", lht->state_length, \"STATE\");\n\tprintf(\"%-*s \", lht->autostart_length, \"AUTOSTART\");\n\tprintf(\"%-*s \", lht->groups_length, \"GROUPS\");\n\tprintf(\"%-*s \", lht->ipv4_length, \"IPV4\");\n\tprintf(\"%-*s \", lht->ipv6_length, \"IPV6\");\n\tprintf(\"\\n\");\n\n\tsize_t i;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->nestlvl > 0) {\n\t\t\tprintf(\"%*s\", m->nestlvl, \"\\\\\");\n\t\t\tprintf(\"%-*s \", lht->name_length - m->nestlvl, m->name ? m->name : \"-\");\n\t\t} else {\n\t\t     printf(\"%-*s \", lht->name_length, m->name ? m->name : \"-\");\n\t\t}\n\t\tprintf(\"%-*s \", lht->state_length, m->state ? m->state : \"-\");\n\t\tprintf(\"%-*d \", lht->autostart_length, m->autostart);\n\t\tprintf(\"%-*s \", lht->groups_length, m->groups ? m->groups : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv4_length, m->ipv4 ? m->ipv4 : \"-\");\n\t\tprintf(\"%-*s \", lht->ipv6_length, m->ipv6 ? m->ipv6 : \"-\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ls_field_width",
          "args": [
            "ls_arr",
            "ls_size",
            "&max_len"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ls_field_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "1187-1239",
          "snippet": "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht)\n{\n\tconst struct ls *m;\n\tsize_t i, len = 0;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->name) {\n\t\t\tlen = strlen(m->name) + m->nestlvl;\n\t\t\tif (len > lht->name_length)\n\t\t\t\tlht->name_length = len;\n\t\t}\n\n\t\tif (m->state) {\n\t\t\tlen = strlen(m->state);\n\t\t\tif (len > lht->state_length)\n\t\t\t\tlht->state_length = len;\n\t\t}\n\n\t\tif (m->interface) {\n\t\t\tlen = strlen(m->interface);\n\t\t\tif (len > lht->interface_length)\n\t\t\t\tlht->interface_length = len;\n\t\t}\n\n\t\tif (m->groups) {\n\t\t\tlen = strlen(m->groups);\n\t\t\tif (len > lht->groups_length)\n\t\t\t\tlht->groups_length = len;\n\t\t}\n\t\tif (m->ipv4) {\n\t\t\tlen = strlen(m->ipv4);\n\t\t\tif (len > lht->ipv4_length)\n\t\t\t\tlht->ipv4_length = len;\n\t\t}\n\n\t\tif (m->ipv6) {\n\t\t\tlen = strlen(m->ipv6);\n\t\t\tif (len > lht->ipv6_length)\n\t\t\t\tlht->ipv6_length = len;\n\t\t}\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->ram)) > lht->ram_length)\n\t\t\tlht->ram_length = len;\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->swap)) > lht->swap_length)\n\t\t\tlht->swap_length = len;\n\n\t\tif (m->init != -1) {\n\t\t\tif ((len = snprintf(NULL, 0, \"%d\", m->init)) > lht->init_length)\n\t\t\t\tlht->init_length = len;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ls_deserialize(int rpipefd, struct ls **m, size_t *len);",
            "static void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);",
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic int ls_deserialize(int rpipefd, struct ls **m, size_t *len);\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht);\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic void ls_field_width(const struct ls *l, const size_t size,\n\t\tstruct lengths *lht)\n{\n\tconst struct ls *m;\n\tsize_t i, len = 0;\n\tfor (i = 0, m = l; i < size; i++, m++) {\n\t\tif (m->name) {\n\t\t\tlen = strlen(m->name) + m->nestlvl;\n\t\t\tif (len > lht->name_length)\n\t\t\t\tlht->name_length = len;\n\t\t}\n\n\t\tif (m->state) {\n\t\t\tlen = strlen(m->state);\n\t\t\tif (len > lht->state_length)\n\t\t\t\tlht->state_length = len;\n\t\t}\n\n\t\tif (m->interface) {\n\t\t\tlen = strlen(m->interface);\n\t\t\tif (len > lht->interface_length)\n\t\t\t\tlht->interface_length = len;\n\t\t}\n\n\t\tif (m->groups) {\n\t\t\tlen = strlen(m->groups);\n\t\t\tif (len > lht->groups_length)\n\t\t\t\tlht->groups_length = len;\n\t\t}\n\t\tif (m->ipv4) {\n\t\t\tlen = strlen(m->ipv4);\n\t\t\tif (len > lht->ipv4_length)\n\t\t\t\tlht->ipv4_length = len;\n\t\t}\n\n\t\tif (m->ipv6) {\n\t\t\tlen = strlen(m->ipv6);\n\t\t\tif (len > lht->ipv6_length)\n\t\t\t\tlht->ipv6_length = len;\n\t\t}\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->ram)) > lht->ram_length)\n\t\t\tlht->ram_length = len;\n\n\t\tif ((len = snprintf(NULL, 0, \"%.2f\", m->swap)) > lht->swap_length)\n\t\t\tlht->swap_length = len;\n\n\t\tif (m->init != -1) {\n\t\t\tif ((len = snprintf(NULL, 0, \"%d\", m->init)) > lht->init_length)\n\t\t\t\tlht->init_length = len;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls_get",
          "args": [
            "&ls_arr",
            "&ls_size",
            "&my_args",
            "\"\"",
            "NULL",
            "0",
            "&(char *){NULL}",
            "0",
            "grps",
            "ngrps"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ls_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_ls.c",
          "lines": "325-579",
          "snippet": "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"confile.h\"",
            "#include \"conf.h\"",
            "#include \"arguments.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <regex.h>",
            "#include <getopt.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_NESTLVL 5"
          ],
          "globals_used": [
            "static void ls_free(struct ls *l, size_t size);",
            "static void ls_free_arr(char **arr, size_t size);",
            "static int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);",
            "static char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);",
            "static char *ls_get_groups(struct lxc_container *c, bool running);",
            "static char *ls_get_ips(struct lxc_container *c, const char *inet);",
            "static double ls_get_swap(struct lxc_container *c);",
            "static char *ls_get_interface(struct lxc_container *c);",
            "static struct ls *ls_new(struct ls **ls, size_t *size);",
            "static void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\n#define MAX_NESTLVL 5\n\nstatic void ls_free(struct ls *l, size_t size);\nstatic void ls_free_arr(char **arr, size_t size);\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len);\nstatic char *ls_get_config_item(struct lxc_container *c, const char *item,\n\t\tbool running);\nstatic char *ls_get_groups(struct lxc_container *c, bool running);\nstatic char *ls_get_ips(struct lxc_container *c, const char *inet);\nstatic double ls_get_swap(struct lxc_container *c);\nstatic char *ls_get_interface(struct lxc_container *c);\nstatic struct ls *ls_new(struct ls **ls, size_t *size);\nstatic void ls_print_table(struct ls *l, struct lengths *lht,\n\t\tsize_t size);\n\nstatic int ls_get(struct ls **m, size_t *size, const struct lxc_arguments *args,\n\t\tconst char *basepath, const char *parent, unsigned int lvl,\n\t\tchar **lockpath, size_t len_lockpath, char **grps_must,\n\t\tsize_t grps_must_len)\n{\n\t/* As ls_get() is non-tail recursive we face the inherent danger of\n\t * blowing up the stack at some level of nesting. To have at least some\n\t * security we define MAX_NESTLVL to be 5. That should be sufficient for\n\t * most users. The argument lvl can be used to keep track of the level\n\t * of nesting we are at. If lvl is greater than the allowed default\n\t * level or the level the user specified on the command line we return\n\t * and unwind the stack. */\n\tif (lvl > args->ls_nesting)\n\t\treturn 0;\n\n\tint num = 0, ret = -1;\n\tchar **containers = NULL;\n\t/* If we, at some level of nesting, encounter a stopped container but\n\t * want to retrieve nested containers we need to build an absolute path\n\t * beginning from it. Initially, at nesting level 0, basepath will\n\t * simply be the empty string and path will simply be whatever the\n\t * default lxcpath or the path the user gave us is.  Basepath will also\n\t * be the empty string in case we encounter a running container since we\n\t * can simply attach to its namespace to retrieve nested containers. */\n\tchar *path = lxc_append_paths(basepath, args->lxcpath[0]);\n\tif (!path)\n\t\tgoto out;\n\n\tif (!dir_exists(path)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Do not do more work than is necessary right from the start. */\n\tif (args->ls_active || (args->ls_active && args->ls_frozen))\n\t\tnum = list_active_containers(path, &containers, NULL);\n\telse\n\t\tnum = list_all_containers(path, &containers, NULL);\n\tif (num == -1) {\n\t\tnum = 0;\n\t\tgoto out;\n\t}\n\n\tchar *tmp = NULL;\n\tint check;\n\tstruct ls *l = NULL;\n\tstruct lxc_container *c = NULL;\n\tsize_t i;\n\tfor (i = 0; i < (size_t)num; i++) {\n\t\tchar *name = containers[i];\n\n\t\t/* Filter container names by regex the user gave us. */\n\t\tif (args->ls_filter || args->argc == 1) {\n\t\t\tregex_t preg;\n\t\t\ttmp = args->ls_filter ? args->ls_filter : args->argv[0];\n\t\t\tcheck = regcomp(&preg, tmp, REG_NOSUB | REG_EXTENDED);\n\t\t\tif (check == REG_ESPACE) /* we're out of memory */\n\t\t\t\tgoto out;\n\t\t\telse if (check != 0)\n\t\t\t\tcontinue;\n\t\t\tcheck = regexec(&preg, name, 0, NULL, 0);\n\t\t\tregfree(&preg);\n\t\t\tif (check != 0)\n\t\t\t\tcontinue;\n\t\t}\n\n \t\terrno = 0;\n\t\tc = lxc_container_new(name, path);\n \t\tif ((errno == ENOMEM) && !c)\n \t\t\tgoto out;\n \t\telse if (!c)\n \t\t\tcontinue;\n\n\t\tif (!c->is_defined(c))\n\t\t\tgoto put_and_next;\n\n\t\t/* This does not allocate memory so no worries about freeing it\n\t\t * when we goto next or out. */\n\t\tconst char *state_tmp = c->state(c);\n\t\tif (!state_tmp)\n\t\t\tstate_tmp = \"UNKNOWN\";\n\n\t\tif (args->ls_running && !c->is_running(c))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_frozen && !args->ls_active && strcmp(state_tmp, \"FROZEN\"))\n\t\t\tgoto put_and_next;\n\n\t\tif (args->ls_stopped && strcmp(state_tmp, \"STOPPED\"))\n\t\t\tgoto put_and_next;\n\n\t\tbool running = c->is_running(c);\n\n\t\tchar *grp_tmp = ls_get_groups(c, running);\n\t\tif (!ls_has_all_grps(grp_tmp, grps_must, grps_must_len)) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* Now it makes sense to allocate memory. */\n\t\tl = ls_new(m, size);\n\t\tif (!l) {\n\t\t\tfree(grp_tmp);\n\t\t\tgoto put_and_next;\n\t\t}\n\n\t\t/* How deeply nested are we? */\n\t\tl->nestlvl = lvl;\n\n\t\tl->groups = grp_tmp;\n\n\t\tl->running = running;\n\n\t\tif (parent && args->ls_nesting && (args->ls_line || !args->ls_fancy))\n\t\t\t/* Prepend the name of the container with all its parents when\n\t\t\t * the user requests it. */\n\t\t\tl->name = lxc_append_paths(parent, name);\n\t\telse\n\t\t\t/* Otherwise simply record the name. */\n\t\t\tl->name = strdup(name);\n\t\tif (!l->name)\n\t\t\tgoto put_and_next;\n\n\t\t/* Do not record stuff the user did not explictly request. */\n\t\tif (args->ls_fancy) {\n\t\t\t/* Maybe we should even consider the name sensitive and\n\t\t\t * hide it when you're not allowed to control the\n\t\t\t * container. */\n\t\t\tif (!c->may_control(c))\n\t\t\t\tgoto put_and_next;\n\n\t\t\tl->state = strdup(state_tmp);\n\t\t\tif (!l->state)\n\t\t\t\tgoto put_and_next;\n\n\t\t\ttmp = ls_get_config_item(c, \"lxc.start.auto\", running);\n\t\t\tif (tmp) {\n\t\t\t\tunsigned int astart = 0;\n\t\t\t\tif (lxc_safe_uint(tmp, &astart) < 0)\n\t\t\t\t\tWARN(\"Could not parse value for 'lxc.start.auto'.\");\n\t\t\t\tif (astart > 1)\n\t\t\t\t\tDEBUG(\"Wrong value for 'lxc.start.auto = %d'.\", astart);\n\t\t\t\tl->autostart = astart == 1 ? true : false;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\tif (running) {\n\t\t\t\tl->init = c->init_pid(c);\n\n\t\t\t\tl->interface = ls_get_interface(c);\n\n\t\t\t\tl->ipv4 = ls_get_ips(c, \"inet\");\n\n\t\t\t\tl->ipv6 = ls_get_ips(c, \"inet6\");\n\n\t\t\t\ttmp = ls_get_cgroup_item(c, \"memory.usage_in_bytes\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\tl->ram = strtoull(tmp, NULL, 0);\n\t\t\t\t\tl->ram = l->ram / 1024 /1024;\n\t\t\t\t\tfree(tmp);\n\t\t\t\t}\n\n\t\t\t\tl->swap = ls_get_swap(c);\n\t\t\t}\n\t\t}\n\n\t\t/* Get nested containers: Only do this after we have gathered\n\t\t * all other information we need. */\n\t\tif (args->ls_nesting && running) {\n\t\t\tstruct wrapargs wargs = (struct wrapargs){.args = NULL};\n\t\t\t/* Open a socket so that the child can communicate with us. */\n\t\t\tcheck = socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, wargs.pipefd);\n\t\t\tif (check == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Set the next nesting level. */\n\t\t\twargs.nestlvl = lvl + 1;\n\t\t\t/* Send in the parent for the next nesting level. */\n\t\t\twargs.parent = l->name;\n\t\t\twargs.args = args;\n\t\t\twargs.grps_must = grps_must;\n\t\t\twargs.grps_must_len = grps_must_len;\n\n\t\t\tpid_t out;\n\n\t\t\tlxc_attach_options_t aopt = LXC_ATTACH_OPTIONS_DEFAULT;\n\t\t\taopt.env_policy = LXC_ATTACH_CLEAR_ENV;\n\n\t\t\t/* fork(): Attach to the namespace of the container and\n\t\t\t * run ls_get() in it which is called in ls_get_wrapper(). */\n\t\t\tcheck = c->attach(c, ls_get_wrapper, &wargs, &aopt, &out);\n\t\t\t/* close the socket */\n\t\t\tclose(wargs.pipefd[1]);\n\n\t\t\t/* Retrieve all information we want from the child. */\n\t\t\tif (check == 0)\n\t\t\t\tif (ls_deserialize(wargs.pipefd[0], m, size) == -1)\n\t\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Wait for the child to finish. */\n\t\t\twait_for_pid(out);\n\n\t\t\t/* We've done all the communication we need so shutdown\n\t\t\t * the socket and close it. */\n\t\t\tshutdown(wargs.pipefd[0], SHUT_RDWR);\n\t\t\tclose(wargs.pipefd[0]);\n\t\t} else if (args->ls_nesting && !running) {\n\t\t\t/* This way of extracting the rootfs is not safe since\n\t\t\t * it will return very different things depending on the\n\t\t\t * storage backend that is used for the container. We\n\t\t\t * need a path-extractor function. We face the same\n\t\t\t * problem with the ovl_mkdir() function in\n\t\t\t * lxcoverlay.{c,h}. */\n\t\t\tchar *curr_path = ls_get_config_item(c, \"lxc.rootfs\", running);\n\t\t\tif (!curr_path)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* Since the container is not running and we cannot\n\t\t\t * attach to it we need another strategy to retrieve\n\t\t\t * nested containers. What we do is simply create a\n\t\t\t * growing path which will lead us into the rootfs of\n\t\t\t * the next container where it stores its containers. */\n\t\t\tchar *newpath = lxc_append_paths(basepath, curr_path);\n\t\t\tfree(curr_path);\n\t\t\tif (!newpath)\n\t\t\t\tgoto put_and_next;\n\n\t\t\t/* We want to remove all locks we create under\n\t\t\t * /run/lxc/lock so we create a string pointing us to\n\t\t\t * the lock path for the current container. */\n\t\t\tif (ls_remove_lock(path, name, lockpath, &len_lockpath, true) == -1)\n\t\t\t\tgoto put_and_next;\n\n\t\t\tls_get(m, size, args, newpath, l->name, lvl + 1, lockpath, len_lockpath, grps_must, grps_must_len);\n\t\t\tfree(newpath);\n\n\t\t\t/* Remove the lock. No need to check for failure here. */\n\t\t\tls_remove_lock(path, name, lockpath, &len_lockpath, false);\n\t\t}\n\nput_and_next:\n\t\tlxc_container_put(c);\n\t}\n\tret = 0;\n\nout:\n\tls_free_arr(containers, num);\n\tfree(path);\n\t/* lockpath is shared amongst all non-fork()ing recursive calls to\n\t * ls_get() so only free it on the uppermost level. */\n\tif (lvl == 0)\n\t\tfree(*lockpath);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_array_len",
          "args": [
            "(void **)grps"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "923-932",
          "snippet": "size_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nsize_t lxc_array_len(void **array)\n{\n\tvoid **p;\n\tsize_t result = 0;\n\n\tfor (p = array; p && *p; p++)\n\t\tresult++;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_string_split_and_trim",
          "args": [
            "my_args.groups",
            "','"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_split_and_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "845-884",
          "snippet": "char **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar **lxc_string_split_and_trim(const char *string, char _sep)\n{\n\tchar *token, *str, *saveptr = NULL;\n\tchar sep[2] = { _sep, '\\0' };\n\tchar **result = NULL;\n\tsize_t result_capacity = 0;\n\tsize_t result_count = 0;\n\tint r, saved_errno;\n\tsize_t i = 0;\n\n\tif (!string)\n\t\treturn calloc(1, sizeof(char *));\n\n\tstr = alloca(strlen(string)+1);\n\tstrcpy(str, string);\n\tfor (; (token = strtok_r(str, sep, &saveptr)); str = NULL) {\n\t\twhile (token[0] == ' ' || token[0] == '\\t')\n\t\t\ttoken++;\n\t\ti = strlen(token);\n\t\twhile (i > 0 && (token[i - 1] == ' ' || token[i - 1] == '\\t')) {\n\t\t\ttoken[i - 1] = '\\0';\n\t\t\ti--;\n\t\t}\n\t\tr = lxc_grow_array((void ***)&result, &result_capacity, result_count + 1, 16);\n\t\tif (r < 0)\n\t\t\tgoto error_out;\n\t\tresult[result_count] = strdup(token);\n\t\tif (!result[result_count])\n\t\t\tgoto error_out;\n\t\tresult_count++;\n\t}\n\n\t/* if we allocated too much, reduce it */\n\treturn realloc(result, (result_count + 1) * sizeof(char *));\nerror_out:\n\tsaved_errno = errno;\n\tlxc_free_array((void **)result, free);\n\terrno = saved_errno;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_options_no_override",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_options_no_override",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "685-689",
          "snippet": "extern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_quiet_specified;",
            "static int lxc_loglevel_specified;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_quiet_specified;\nstatic int lxc_loglevel_specified;\n\nextern void lxc_log_options_no_override()\n{\n\tlxc_quiet_specified = 1;\n\tlxc_loglevel_specified = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_init",
          "args": [
            "NULL",
            "my_args.log_file",
            "my_args.log_priority",
            "my_args.progname",
            "my_args.quiet",
            "my_args.lxcpath[0]"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "546-615",
          "snippet": "extern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int lxc_log_fd = -1;",
            "int lxc_quiet_specified;",
            "int lxc_log_use_global_fd;",
            "static int lxc_loglevel_specified;",
            "static char *log_vmname = NULL;",
            "static struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};",
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nint lxc_log_fd = -1;\nint lxc_quiet_specified;\nint lxc_log_use_global_fd;\nstatic int lxc_loglevel_specified;\nstatic char *log_vmname = NULL;\nstatic struct lxc_log_appender log_appender_stderr = {\n\t.name\t\t= \"stderr\",\n\t.append\t\t= log_append_stderr,\n\t.next\t\t= NULL,\n};\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_init(const char *name, const char *file,\n\t\t\tconst char *priority, const char *prefix, int quiet,\n\t\t\tconst char *lxcpath)\n{\n\tint lxc_priority = LXC_LOG_PRIORITY_ERROR;\n\tint ret;\n\n\tif (lxc_log_fd != -1) {\n\t\tWARN(\"lxc_log_init called with log already initialized\");\n\t\treturn 0;\n\t}\n\n\tif (priority)\n\t\tlxc_priority = lxc_log_priority_to_int(priority);\n\n\tif (!lxc_loglevel_specified) {\n\t\tlxc_log_category_lxc.priority = lxc_priority;\n\t\tlxc_loglevel_specified = 1;\n\t}\n\n\tif (!lxc_quiet_specified) {\n\t\tif (!quiet)\n\t\t\tlxc_log_category_lxc.appender->next = &log_appender_stderr;\n\t}\n\n\tif (prefix)\n\t\tlxc_log_set_prefix(prefix);\n\n\tif (name)\n\t\tlog_vmname = strdup(name);\n\n\tif (file) {\n\t\tif (strcmp(file, \"none\") == 0)\n\t\t\treturn 0;\n\t\tret = __lxc_log_set_file(file, 1);\n\t\tlxc_log_use_global_fd = 1;\n\t} else {\n\t\t/* if no name was specified, there nothing to do */\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tret = -1;\n\n\t\tif (!lxcpath)\n\t\t\tlxcpath = LOGPATH;\n\n\t\t/* try LOGPATH if lxcpath is the default for the privileged containers */\n\t\tif (!geteuid() && strcmp(LXCPATH, lxcpath) == 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\n\t\t/* try in lxcpath */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, lxcpath, 1);\n\n\t\t/* try LOGPATH in case its writable by the caller */\n\t\tif (ret < 0)\n\t\t\tret = _lxc_log_set_file(name, NULL, 0);\n\t}\n\n\t/*\n\t * If !file, that is, if the user did not request this logpath, then\n\t * ignore failures and continue logging to console\n\t */\n\tif (!file && ret != 0) {\n\t\tINFO(\"Ignoring failure to open default logfile.\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_arguments_parse",
          "args": [
            "&my_args",
            "argc",
            "argv"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_arguments_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/arguments.c",
          "lines": "182-252",
          "snippet": "extern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"arguments.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <errno.h>",
            "#include <ctype.h>\t\t/* for isprint() */",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"utils.h\"\n#include \"arguments.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <ctype.h>\t\t/* for isprint() */\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int lxc_arguments_parse(struct lxc_arguments *args,\n\t\t\t       int argc, char * const argv[])\n{\n\tchar shortopts[256];\n\tint  ret = 0;\n\n\tret = build_shortopts(args->options, shortopts, sizeof(shortopts));\n\tif (ret < 0) {\n\t\tlxc_error(args, \"build_shortopts() failed : %s\",\n\t\t\t  strerror(errno));\n\t\treturn ret;\n\t}\n\n\twhile (1)  {\n\t\tint c, index = 0;\n\n\t\tc = getopt_long(argc, argv, shortopts, args->options, &index);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase 'n': \targs->name = optarg; break;\n\t\tcase 'o':\targs->log_file = optarg; break;\n\t\tcase 'l':\targs->log_priority = optarg; break;\n\t\tcase 'q':\targs->quiet = 1; break;\n\t\tcase OPT_RCFILE: args->rcfile = optarg; break;\n\t\tcase 'P':\n\t\t\tremove_trailing_slashes(optarg);\n\t\t\tret = lxc_arguments_lxcpath_add(args, optarg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase OPT_USAGE: print_usage(args->options, args);\n\t\tcase OPT_VERSION: print_version();\n\t\tcase '?':\tprint_help(args, 1);\n\t\tcase 'h': \tprint_help(args, 0);\n\t\tdefault:\n\t\t\tif (args->parser) {\n\t\t\t\tret = args->parser(args, c, optarg);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Reclaim the remaining command arguments\n\t */\n\targs->argv = &argv[optind];\n\targs->argc = argc - optind;\n\n\t/* If no lxcpaths were given, use default */\n\tif (!args->lxcpath_cnt) {\n\t\tret = lxc_arguments_lxcpath_add(args, lxc_global_config_value(\"lxc.lxcpath\"));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Check the command options */\n\n\tif (!args->name && strcmp(args->progname, \"lxc-autostart\") != 0) {\n\t\tlxc_error(args, \"missing container name, use --name option\");\n\t\treturn -1;\n\t}\n\n\tif (args->checker)\n\t\tret = args->checker(args);\nerror:\n\tif (ret)\n\t\tlxc_error(args, \"could not parse command line\");\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"confile.h\"\n#include \"conf.h\"\n#include \"arguments.h\"\n#include <lxc/lxccontainer.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <termios.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <regex.h>\n#include <getopt.h>\n#include \"config.h\"\n\nstatic unsigned int ls_get_term_width(void);\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-ls\",\n\t.help = \"\\n\\\n[-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n[-1] [-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n[-f] [-P lxcpath] [--active] [--running] [--frozen] [--stopped] [--nesting] [-g groups] [--filter regex]\\n\\\n\\n\\\nlxc-ls list containers\\n\\\n\\n\\\nOptions :\\n\\\n  -1, --line         show one entry per line\\n\\\n  -f, --fancy        use a fancy, column-based output\\n\\\n  -F, --fancy-format comma separated list of columns to show in the fancy output\\n\\\n                     valid columns are: NAME, STATE, PID, RAM, SWAP, AUTOSTART,\\n\\\n                     GROUPS, INTERFACE, IPV4 and IPV6\\n\\\n  --active           list only active containers\\n\\\n  --running          list only running containers\\n\\\n  --frozen           list only frozen containers\\n\\\n  --stopped          list only stopped containers\\n\\\n  --nesting=NUM      list nested containers up to NUM (default is 5) levels of nesting\\n\\\n  --filter=REGEX     filter container names by regular expression\\n\\\n  -g --groups        comma separated list of groups a container must have to be displayed\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.ls_nesting = 0,\n};\n\nint main(int argc, char *argv[])\n{\n\tint ret = EXIT_FAILURE;\n\t/*\n\t * The lxc parser requires that my_args.name is set. So let's satisfy\n\t * that condition by setting a dummy name which is never used.\n\t */\n\tmy_args.name  = \"\";\n\tif (lxc_arguments_parse(&my_args, argc, argv))\n\t\texit(EXIT_FAILURE);\n\n\tif (!my_args.log_file)\n\t\tmy_args.log_file = \"none\";\n\n\t/*\n\t * We set the first argument that usually takes my_args.name to NULL so\n\t * that the log is only used when the user specifies a file.\n\t */\n\tif (lxc_log_init(NULL, my_args.log_file, my_args.log_priority,\n\t\t\t my_args.progname, my_args.quiet, my_args.lxcpath[0]))\n\t\texit(EXIT_FAILURE);\n\tlxc_log_options_no_override();\n\n\tstruct lengths max_len = {\n\t\t/* default header length */\n\t\t.name_length = 4,      /* NAME */\n\t\t.state_length = 5,     /* STATE */\n\t\t.groups_length = 6,    /* GROUPS */\n\t\t.interface_length = 9, /* INTERFACE */\n\t\t.ipv4_length = 4,      /* IPV4 */\n\t\t.ipv6_length = 4,      /* IPV6 */\n\t\t.init_length = 3,      /* PID */\n\t\t.ram_length = 3,       /* RAM */\n\t\t.swap_length = 4,      /* SWAP */\n\t\t.autostart_length = 9, /* AUTOSTART */\n\t};\n\n\tchar **grps = NULL;\n\tsize_t ngrps = 0;\n\tif (my_args.groups) {\n\t\tgrps = lxc_string_split_and_trim(my_args.groups, ',');\n\t\tngrps = lxc_array_len((void **)grps);\n\t}\n\n\tstruct ls *ls_arr = NULL;\n\tsize_t ls_size = 0;\n\t/* &(char *){NULL} is no magic. It's just a compound literal which\n\t * avoids having a pointless variable in main() that serves no purpose\n\t * here. */\n\tint status = ls_get(&ls_arr, &ls_size, &my_args, \"\", NULL, 0, &(char *){NULL}, 0, grps, ngrps);\n\tif (!ls_arr && status == 0)\n\t\t/* We did not fail. There was just nothing to do. */\n\t\texit(EXIT_SUCCESS);\n\telse if (!ls_arr || status == -1)\n\t\tgoto out;\n\n\tls_field_width(ls_arr, ls_size, &max_len);\n\tif (my_args.ls_fancy && !my_args.ls_fancy_format) {\n\t\tls_print_table(ls_arr, &max_len, ls_size);\n\t} else if (my_args.ls_fancy && my_args.ls_fancy_format) {\n\t\tls_print_fancy_format(ls_arr, &max_len, ls_size, my_args.ls_fancy_format);\n\t} else {\n\t\tunsigned int cols = 0;\n\t\tif (!my_args.ls_line)\n\t\t\tcols = ls_get_term_width();\n\t\tls_print_names(ls_arr, &max_len, ls_size, cols, my_args.ls_line);\n\t}\n\n\tret = EXIT_SUCCESS;\n\nout:\n\tls_free(ls_arr, ls_size);\n\tlxc_free_array((void **)grps, free);\n\n\texit(ret);\n}"
  }
]