[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
    "lines": "152-280",
    "snippet": "int main(int argc, char *argv[])\n{\n\tchar *del;\n\tchar **it, **args;\n\tint opt, status;\n\tint ret;\n\tchar *namespaces = NULL;\n\tint flags = 0, daemonize = 0;\n\tuid_t uid = 0; /* valid only if (flags & CLONE_NEWUSER) */\n\tpid_t pid;\n\tstruct my_iflist *tmpif, *my_iflist = NULL;\n\tstruct start_arg start_arg = {\n\t\t.args = &args,\n\t\t.uid = &uid,\n\t\t.setuid = false,\n\t\t.flags = &flags,\n\t\t.want_hostname = NULL,\n\t\t.want_default_mounts = 0,\n\t};\n\n\twhile ((opt = getopt(argc, argv, \"s:u:hH:i:dM\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tnamespaces = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (!(tmpif = malloc(sizeof(*tmpif)))) {\n\t\t\t\tperror(\"malloc\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttmpif->mi_ifname = optarg;\n\t\t\ttmpif->mi_next = my_iflist;\n\t\t\tmy_iflist = tmpif;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdaemonize = 1;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tstart_arg.want_default_mounts = 1;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tstart_arg.want_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (!lookup_user(optarg, &uid))\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\tstart_arg.setuid = true;\n\t\t}\n\t}\n\n\tif (argv[optind] == NULL) {\n\t\tERROR(\"a command to execute in the new namespace is required\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs = &argv[optind];\n\n\tret = lxc_caps_init();\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\t/* The identifiers for namespaces used with lxc-unshare as given on the\n\t * manpage do not align with the standard identifiers. This affects\n\t * network, mount, and uts namespaces. The standard identifiers are:\n\t * \"mnt\", \"uts\", and \"net\" whereas lxc-unshare uses \"MOUNT\", \"UTSNAME\",\n\t * and \"NETWORK\". So let's use some cheap memmove()s to replace them by\n\t * their standard identifiers. Let's illustrate this with an example:\n\t * Assume the string:\n\t *\n\t *\t\"IPC|MOUNT|PID\"\n\t *\n\t * then we memmove()\n\t *\n\t *\tdest: del + 1 == ONT|PID\n\t *\tsrc:  del + 3 == NT|PID\n\t */\n\twhile ((del = strstr(namespaces, \"MOUNT\")))\n\t\tmemmove(del + 1, del + 3, strlen(del) - 2);\n\n\tfor (it = (char *[]){\"NETWORK\", \"UTSNAME\", NULL}; it && *it; it++)\n\t\twhile ((del = strstr(namespaces, *it)))\n\t\t\tmemmove(del + 3, del + 7, strlen(del) - 6);\n\n\tret = lxc_fill_namespace_flags(namespaces, &flags);\n\tif (ret)\n\t\tusage(argv[0]);\n\n\tif (!(flags & CLONE_NEWNET) && my_iflist) {\n\t\tERROR(\"-i <interfacename> needs -s NETWORK option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!(flags & CLONE_NEWUTS) && start_arg.want_hostname) {\n\t\tERROR(\"-H <hostname> needs -s UTSNAME option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!(flags & CLONE_NEWNS) && start_arg.want_default_mounts) {\n\t\tERROR(\"-M needs -s MOUNT option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid = lxc_clone(do_start, &start_arg, flags);\n\tif (pid < 0) {\n\t\tERROR(\"failed to clone\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (my_iflist) {\n\t\tfor (tmpif = my_iflist; tmpif; tmpif = tmpif->mi_next) {\n\t\t\tif (lxc_netdev_move_by_name(tmpif->mi_ifname, pid, NULL) < 0)\n\t\t\t\tfprintf(stderr,\"Could not move interface %s into container %d: %s\\n\", tmpif->mi_ifname, pid, strerror(errno));\n\t\t}\n\t}\n\n\tif (daemonize)\n\t\texit(EXIT_SUCCESS);\n\n\tif (waitpid(pid, &status, 0) < 0) {\n\t\tERROR(\"failed to wait for '%d'\", pid);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Call exit() directly on this function because it retuns an exit code. */\n\texit(lxc_error_set_and_log(pid, status));\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netinet/in.h>",
      "#include <libgen.h>",
      "#include <getopt.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "lxc_error_set_and_log(pid, status)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_error_set_and_log",
          "args": [
            "pid",
            "status"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_error_set_and_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/error.c",
          "lines": "42-58",
          "snippet": "extern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"error.h\"\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nextern int  lxc_error_set_and_log(int pid, int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status)) {\n\t\tret = WEXITSTATUS(status);\n\t\tif (ret)\n\t\t\tINFO(\"Child <%d> ended on error (%d).\", pid, ret);\n\t}\n\n\tif (WIFSIGNALED(status)) {\n\t\tint signal = WTERMSIG(status);\n\t\tINFO(\"Child <%d> ended on signal (%d).\", pid, signal);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to wait for '%d'\"",
            "pid"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not move interface %s into container %d: %s\\n\"",
            "tmpif->mi_ifname",
            "pid",
            "strerror(errno)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_netdev_move_by_name",
          "args": [
            "tmpif->mi_ifname",
            "pid",
            "NULL"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_netdev_move_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "240-256",
          "snippet": "int lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint lxc_netdev_move_by_name(const char *ifname, pid_t pid, const char* newname)\n{\n\tint index;\n\tchar *physname;\n\n\tif (!ifname)\n\t\treturn -EINVAL;\n\n\tindex = if_nametoindex(ifname);\n\tif (!index)\n\t\treturn -EINVAL;\n\n\tif ((physname = is_wlan(ifname)))\n\t\treturn lxc_netdev_move_wlan(physname, ifname, pid, newname);\n\n\treturn lxc_netdev_move_by_index(index, pid, newname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to clone\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_clone",
          "args": [
            "do_start",
            "&start_arg",
            "flags"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "49-70",
          "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"-M needs -s MOUNT option\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"-H <hostname> needs -s UTSNAME option\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"-i <interfacename> needs -s NETWORK option\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "argv[0]"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
          "lines": "69-81",
          "snippet": "static void usage(char *cmd)\n{\n\tfprintf(stderr, \"%s <options> command [command_arguments]\\n\", basename(cmd));\n\tfprintf(stderr, \"Options are:\\n\");\n\tfprintf(stderr, \"\\t -s flags   : ORed list of flags to unshare:\\n\" \\\n\t\t\t\"\\t           MOUNT, PID, UTSNAME, IPC, USER, NETWORK\\n\");\n\tfprintf(stderr, \"\\t -u <id>      : new id to be set if -s USER is specified\\n\");\n\tfprintf(stderr, \"\\t -i <iface>   : Interface name to be moved into container (presumably with NETWORK unsharing set)\\n\");\n\tfprintf(stderr, \"\\t -H <hostname>: Set the hostname in the container\\n\");\n\tfprintf(stderr, \"\\t -d           : Daemonize (do not wait for container to exit)\\n\");\n\tfprintf(stderr, \"\\t -M           : Remount default fs inside container (/proc /dev/shm /dev/mqueue)\\n\");\n\t_exit(EXIT_SUCCESS);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netinet/in.h>",
            "#include <libgen.h>",
            "#include <getopt.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void usage(char *cmd)\n{\n\tfprintf(stderr, \"%s <options> command [command_arguments]\\n\", basename(cmd));\n\tfprintf(stderr, \"Options are:\\n\");\n\tfprintf(stderr, \"\\t -s flags   : ORed list of flags to unshare:\\n\" \\\n\t\t\t\"\\t           MOUNT, PID, UTSNAME, IPC, USER, NETWORK\\n\");\n\tfprintf(stderr, \"\\t -u <id>      : new id to be set if -s USER is specified\\n\");\n\tfprintf(stderr, \"\\t -i <iface>   : Interface name to be moved into container (presumably with NETWORK unsharing set)\\n\");\n\tfprintf(stderr, \"\\t -H <hostname>: Set the hostname in the container\\n\");\n\tfprintf(stderr, \"\\t -d           : Daemonize (do not wait for container to exit)\\n\");\n\tfprintf(stderr, \"\\t -M           : Remount default fs inside container (/proc /dev/shm /dev/mqueue)\\n\");\n\t_exit(EXIT_SUCCESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_fill_namespace_flags",
          "args": [
            "namespaces",
            "&flags"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_fill_namespace_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "109-131",
          "snippet": "int lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nint lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "del + 3",
            "del + 7",
            "strlen(del) - 6"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "del"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "namespaces",
            "*it"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "del + 1",
            "del + 3",
            "strlen(del) - 2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "del"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "namespaces",
            "\"MOUNT\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_caps_init",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_caps_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/caps.h",
          "lines": "47-49",
          "snippet": "static inline int lxc_caps_init(void) {\n\treturn 0;\n}",
          "includes": [
            "#include <sys/capability.h>",
            "#include <stdbool.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/capability.h>\n#include <stdbool.h>\n#include \"config.h\"\n\nstatic inline int lxc_caps_init(void) {\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"a command to execute in the new namespace is required\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user",
          "args": [
            "optarg",
            "&uid"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
          "lines": "83-110",
          "snippet": "static bool lookup_user(const char *optarg, uid_t *uid)\n{\n\tchar name[MAXPATHLEN];\n\tstruct passwd *pwent = NULL;\n\n\tif (!optarg || (optarg[0] == '\\0'))\n\t\treturn false;\n\n\tif (sscanf(optarg, \"%u\", uid) < 1) {\n\t\t/* not a uid -- perhaps a username */\n\t\tif (sscanf(optarg, \"%s\", name) < 1)\n\t\t\treturn false;\n\n\t\tpwent = getpwnam(name);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid username %s\", name);\n\t\t\treturn false;\n\t\t}\n\t\t*uid = pwent->pw_uid;\n\t} else {\n\t\tpwent = getpwuid(*uid);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid uid %u\", *uid);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netinet/in.h>",
            "#include <libgen.h>",
            "#include <getopt.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lookup_user(const char *optarg, uid_t *uid)\n{\n\tchar name[MAXPATHLEN];\n\tstruct passwd *pwent = NULL;\n\n\tif (!optarg || (optarg[0] == '\\0'))\n\t\treturn false;\n\n\tif (sscanf(optarg, \"%u\", uid) < 1) {\n\t\t/* not a uid -- perhaps a username */\n\t\tif (sscanf(optarg, \"%s\", name) < 1)\n\t\t\treturn false;\n\n\t\tpwent = getpwnam(name);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid username %s\", name);\n\t\t\treturn false;\n\t\t}\n\t\t*uid = pwent->pw_uid;\n\t} else {\n\t\tpwent = getpwuid(*uid);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid uid %u\", *uid);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"malloc\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmpif)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"s:u:hH:i:dM\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint main(int argc, char *argv[])\n{\n\tchar *del;\n\tchar **it, **args;\n\tint opt, status;\n\tint ret;\n\tchar *namespaces = NULL;\n\tint flags = 0, daemonize = 0;\n\tuid_t uid = 0; /* valid only if (flags & CLONE_NEWUSER) */\n\tpid_t pid;\n\tstruct my_iflist *tmpif, *my_iflist = NULL;\n\tstruct start_arg start_arg = {\n\t\t.args = &args,\n\t\t.uid = &uid,\n\t\t.setuid = false,\n\t\t.flags = &flags,\n\t\t.want_hostname = NULL,\n\t\t.want_default_mounts = 0,\n\t};\n\n\twhile ((opt = getopt(argc, argv, \"s:u:hH:i:dM\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tnamespaces = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (!(tmpif = malloc(sizeof(*tmpif)))) {\n\t\t\t\tperror(\"malloc\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttmpif->mi_ifname = optarg;\n\t\t\ttmpif->mi_next = my_iflist;\n\t\t\tmy_iflist = tmpif;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdaemonize = 1;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tstart_arg.want_default_mounts = 1;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tstart_arg.want_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (!lookup_user(optarg, &uid))\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\tstart_arg.setuid = true;\n\t\t}\n\t}\n\n\tif (argv[optind] == NULL) {\n\t\tERROR(\"a command to execute in the new namespace is required\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\targs = &argv[optind];\n\n\tret = lxc_caps_init();\n\tif (ret)\n\t\texit(EXIT_FAILURE);\n\n\t/* The identifiers for namespaces used with lxc-unshare as given on the\n\t * manpage do not align with the standard identifiers. This affects\n\t * network, mount, and uts namespaces. The standard identifiers are:\n\t * \"mnt\", \"uts\", and \"net\" whereas lxc-unshare uses \"MOUNT\", \"UTSNAME\",\n\t * and \"NETWORK\". So let's use some cheap memmove()s to replace them by\n\t * their standard identifiers. Let's illustrate this with an example:\n\t * Assume the string:\n\t *\n\t *\t\"IPC|MOUNT|PID\"\n\t *\n\t * then we memmove()\n\t *\n\t *\tdest: del + 1 == ONT|PID\n\t *\tsrc:  del + 3 == NT|PID\n\t */\n\twhile ((del = strstr(namespaces, \"MOUNT\")))\n\t\tmemmove(del + 1, del + 3, strlen(del) - 2);\n\n\tfor (it = (char *[]){\"NETWORK\", \"UTSNAME\", NULL}; it && *it; it++)\n\t\twhile ((del = strstr(namespaces, *it)))\n\t\t\tmemmove(del + 3, del + 7, strlen(del) - 6);\n\n\tret = lxc_fill_namespace_flags(namespaces, &flags);\n\tif (ret)\n\t\tusage(argv[0]);\n\n\tif (!(flags & CLONE_NEWNET) && my_iflist) {\n\t\tERROR(\"-i <interfacename> needs -s NETWORK option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!(flags & CLONE_NEWUTS) && start_arg.want_hostname) {\n\t\tERROR(\"-H <hostname> needs -s UTSNAME option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!(flags & CLONE_NEWNS) && start_arg.want_default_mounts) {\n\t\tERROR(\"-M needs -s MOUNT option\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid = lxc_clone(do_start, &start_arg, flags);\n\tif (pid < 0) {\n\t\tERROR(\"failed to clone\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (my_iflist) {\n\t\tfor (tmpif = my_iflist; tmpif; tmpif = tmpif->mi_next) {\n\t\t\tif (lxc_netdev_move_by_name(tmpif->mi_ifname, pid, NULL) < 0)\n\t\t\t\tfprintf(stderr,\"Could not move interface %s into container %d: %s\\n\", tmpif->mi_ifname, pid, strerror(errno));\n\t\t}\n\t}\n\n\tif (daemonize)\n\t\texit(EXIT_SUCCESS);\n\n\tif (waitpid(pid, &status, 0) < 0) {\n\t\tERROR(\"failed to wait for '%d'\", pid);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Call exit() directly on this function because it retuns an exit code. */\n\texit(lxc_error_set_and_log(pid, status));\n}"
  },
  {
    "function_name": "do_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
    "lines": "122-150",
    "snippet": "static int do_start(void *arg)\n{\n\tstruct start_arg *start_arg = arg;\n\tchar **args = *start_arg->args;\n\tint flags = *start_arg->flags;\n\tuid_t uid = *start_arg->uid;\n\tint want_default_mounts = start_arg->want_default_mounts;\n\tconst char *want_hostname = start_arg->want_hostname;\n\n\tif ((flags & CLONE_NEWNS) && want_default_mounts)\n\t\tlxc_setup_fs();\n\n\tif ((flags & CLONE_NEWUTS) && want_hostname)\n\t\tif (sethostname(want_hostname, strlen(want_hostname)) < 0) {\n\t\t\tERROR(\"failed to set hostname %s: %s\", want_hostname, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t// Setuid is useful even without a new user id space\n\tif (start_arg->setuid && setuid(uid)) {\n\t\tERROR(\"failed to set uid %d: %s\", uid, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texecvp(args[0], args);\n\n\tERROR(\"failed to exec: '%s': %s\", args[0], strerror(errno));\n\treturn 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netinet/in.h>",
      "#include <libgen.h>",
      "#include <getopt.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to exec: '%s': %s\"",
            "args[0]",
            "strerror(errno)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "args[0]",
            "args"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set uid %d: %s\"",
            "uid",
            "strerror(errno)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "uid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to set hostname %s: %s\"",
            "want_hostname",
            "strerror(errno)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sethostname",
          "args": [
            "want_hostname",
            "strlen(want_hostname)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sethostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
          "lines": "50-58",
          "snippet": "static int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\nreturn syscall(__NR_sethostname, name, len);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netinet/in.h>",
            "#include <libgen.h>",
            "#include <getopt.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\nreturn syscall(__NR_sethostname, name, len);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "want_hostname"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_setup_fs",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setup_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "45-68",
          "snippet": "extern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nextern void lxc_setup_fs(void)\n{\n\tif (mount_fs(\"proc\", \"/proc\", \"proc\"))\n\t\tINFO(\"failed to remount proc\");\n\n\t/* if /dev has been populated by us, /dev/shm does not exist */\n\tif (access(\"/dev/shm\", F_OK) && mkdir(\"/dev/shm\", 0777))\n\t\tINFO(\"failed to create /dev/shm\");\n\n\t/* if we can't mount /dev/shm, continue anyway */\n\tif (mount_fs(\"shmfs\", \"/dev/shm\", \"tmpfs\"))\n\t\tINFO(\"failed to mount /dev/shm\");\n\n\t/* If we were able to mount /dev/shm, then /dev exists */\n\t/* Sure, but it's read-only per config :) */\n\tif (access(\"/dev/mqueue\", F_OK) && mkdir(\"/dev/mqueue\", 0666)) {\n\t\tDEBUG(\"failed to create '/dev/mqueue'\");\n\t\treturn;\n\t}\n\n\t/* continue even without posix message queue support */\n\tif (mount_fs(\"mqueue\", \"/dev/mqueue\", \"mqueue\"))\n\t\tINFO(\"failed to mount /dev/mqueue\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int do_start(void *arg)\n{\n\tstruct start_arg *start_arg = arg;\n\tchar **args = *start_arg->args;\n\tint flags = *start_arg->flags;\n\tuid_t uid = *start_arg->uid;\n\tint want_default_mounts = start_arg->want_default_mounts;\n\tconst char *want_hostname = start_arg->want_hostname;\n\n\tif ((flags & CLONE_NEWNS) && want_default_mounts)\n\t\tlxc_setup_fs();\n\n\tif ((flags & CLONE_NEWUTS) && want_hostname)\n\t\tif (sethostname(want_hostname, strlen(want_hostname)) < 0) {\n\t\t\tERROR(\"failed to set hostname %s: %s\", want_hostname, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t// Setuid is useful even without a new user id space\n\tif (start_arg->setuid && setuid(uid)) {\n\t\tERROR(\"failed to set uid %d: %s\", uid, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texecvp(args[0], args);\n\n\tERROR(\"failed to exec: '%s': %s\", args[0], strerror(errno));\n\treturn 1;\n}"
  },
  {
    "function_name": "lookup_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
    "lines": "83-110",
    "snippet": "static bool lookup_user(const char *optarg, uid_t *uid)\n{\n\tchar name[MAXPATHLEN];\n\tstruct passwd *pwent = NULL;\n\n\tif (!optarg || (optarg[0] == '\\0'))\n\t\treturn false;\n\n\tif (sscanf(optarg, \"%u\", uid) < 1) {\n\t\t/* not a uid -- perhaps a username */\n\t\tif (sscanf(optarg, \"%s\", name) < 1)\n\t\t\treturn false;\n\n\t\tpwent = getpwnam(name);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid username %s\", name);\n\t\t\treturn false;\n\t\t}\n\t\t*uid = pwent->pw_uid;\n\t} else {\n\t\tpwent = getpwuid(*uid);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid uid %u\", *uid);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netinet/in.h>",
      "#include <libgen.h>",
      "#include <getopt.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"invalid uid %u\"",
            "*uid"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "*uid"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"invalid username %s\"",
            "name"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "optarg",
            "\"%s\"",
            "name"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "optarg",
            "\"%u\"",
            "uid"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic bool lookup_user(const char *optarg, uid_t *uid)\n{\n\tchar name[MAXPATHLEN];\n\tstruct passwd *pwent = NULL;\n\n\tif (!optarg || (optarg[0] == '\\0'))\n\t\treturn false;\n\n\tif (sscanf(optarg, \"%u\", uid) < 1) {\n\t\t/* not a uid -- perhaps a username */\n\t\tif (sscanf(optarg, \"%s\", name) < 1)\n\t\t\treturn false;\n\n\t\tpwent = getpwnam(name);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid username %s\", name);\n\t\t\treturn false;\n\t\t}\n\t\t*uid = pwent->pw_uid;\n\t} else {\n\t\tpwent = getpwuid(*uid);\n\t\tif (!pwent) {\n\t\t\tERROR(\"invalid uid %u\", *uid);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
    "lines": "69-81",
    "snippet": "static void usage(char *cmd)\n{\n\tfprintf(stderr, \"%s <options> command [command_arguments]\\n\", basename(cmd));\n\tfprintf(stderr, \"Options are:\\n\");\n\tfprintf(stderr, \"\\t -s flags   : ORed list of flags to unshare:\\n\" \\\n\t\t\t\"\\t           MOUNT, PID, UTSNAME, IPC, USER, NETWORK\\n\");\n\tfprintf(stderr, \"\\t -u <id>      : new id to be set if -s USER is specified\\n\");\n\tfprintf(stderr, \"\\t -i <iface>   : Interface name to be moved into container (presumably with NETWORK unsharing set)\\n\");\n\tfprintf(stderr, \"\\t -H <hostname>: Set the hostname in the container\\n\");\n\tfprintf(stderr, \"\\t -d           : Daemonize (do not wait for container to exit)\\n\");\n\tfprintf(stderr, \"\\t -M           : Remount default fs inside container (/proc /dev/shm /dev/mqueue)\\n\");\n\t_exit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netinet/in.h>",
      "#include <libgen.h>",
      "#include <getopt.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -M           : Remount default fs inside container (/proc /dev/shm /dev/mqueue)\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -d           : Daemonize (do not wait for container to exit)\\n\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -H <hostname>: Set the hostname in the container\\n\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -i <iface>   : Interface name to be moved into container (presumably with NETWORK unsharing set)\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -u <id>      : new id to be set if -s USER is specified\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\t -s flags   : ORed list of flags to unshare:\\n\" \\\n\t\t\t\"\\t           MOUNT, PID, UTSNAME, IPC, USER, NETWORK\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Options are:\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s <options> command [command_arguments]\\n\"",
            "basename(cmd)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "cmd"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "lxcbasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "1064-1070",
          "snippet": "static char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic char *lxcbasename(char *path)\n{\n\tchar *p = path + strlen(path) - 1;\n\twhile (*p != '/' && p > path)\n\t\tp--;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void usage(char *cmd)\n{\n\tfprintf(stderr, \"%s <options> command [command_arguments]\\n\", basename(cmd));\n\tfprintf(stderr, \"Options are:\\n\");\n\tfprintf(stderr, \"\\t -s flags   : ORed list of flags to unshare:\\n\" \\\n\t\t\t\"\\t           MOUNT, PID, UTSNAME, IPC, USER, NETWORK\\n\");\n\tfprintf(stderr, \"\\t -u <id>      : new id to be set if -s USER is specified\\n\");\n\tfprintf(stderr, \"\\t -i <iface>   : Interface name to be moved into container (presumably with NETWORK unsharing set)\\n\");\n\tfprintf(stderr, \"\\t -H <hostname>: Set the hostname in the container\\n\");\n\tfprintf(stderr, \"\\t -d           : Daemonize (do not wait for container to exit)\\n\");\n\tfprintf(stderr, \"\\t -M           : Remount default fs inside container (/proc /dev/shm /dev/mqueue)\\n\");\n\t_exit(EXIT_SUCCESS);\n}"
  },
  {
    "function_name": "sethostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_unshare.c",
    "lines": "50-58",
    "snippet": "static int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\nreturn syscall(__NR_sethostname, name, len);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"namespace.h\"",
      "#include \"log.h\"",
      "#include \"error.h\"",
      "#include \"cgroup.h\"",
      "#include \"caps.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netinet/in.h>",
      "#include <libgen.h>",
      "#include <getopt.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_sethostname",
            "name",
            "len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netinet/in.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int sethostname(const char * name, size_t len)\n{\n#ifdef __NR_sethostname\nreturn syscall(__NR_sethostname, name, len);\n#else\nerrno = ENOSYS;\nreturn -1;\n#endif\n}"
  }
]