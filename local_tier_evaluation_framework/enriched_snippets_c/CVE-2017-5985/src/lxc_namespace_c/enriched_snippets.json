[
  {
    "function_name": "lxc_fill_namespace_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
    "lines": "109-131",
    "snippet": "int lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <alloca.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"|\"",
            "&saveptr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_namespace_2_cloneflag",
          "args": [
            "token"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_namespace_2_cloneflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
          "lines": "98-107",
          "snippet": "int lxc_namespace_2_cloneflag(char *namespace)\n{\n\tint i;\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (!strcasecmp(ns_info[i].proc_name, namespace))\n\t\t\treturn ns_info[i].clone_flag;\n\n\tERROR(\"Invalid namespace name: %s.\", namespace);\n\treturn -1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"namespace.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <alloca.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct ns_info ns_info[LXC_NS_MAX] = {\n\t[LXC_NS_USER] = {\"user\", CLONE_NEWUSER, \"CLONE_NEWUSER\"},\n\t[LXC_NS_MNT] = {\"mnt\", CLONE_NEWNS, \"CLONE_NEWNS\"},\n\t[LXC_NS_PID] = {\"pid\", CLONE_NEWPID, \"CLONE_NEWPID\"},\n\t[LXC_NS_UTS] = {\"uts\", CLONE_NEWUTS, \"CLONE_NEWUTS\"},\n\t[LXC_NS_IPC] = {\"ipc\", CLONE_NEWIPC, \"CLONE_NEWIPC\"},\n\t[LXC_NS_NET] = {\"net\", CLONE_NEWNET, \"CLONE_NEWNET\"},\n\t[LXC_NS_CGROUP] = {\"cgroup\", CLONE_NEWCGROUP, \"CLONE_NEWCGROUP\"}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nconst struct ns_info ns_info[LXC_NS_MAX] = {\n\t[LXC_NS_USER] = {\"user\", CLONE_NEWUSER, \"CLONE_NEWUSER\"},\n\t[LXC_NS_MNT] = {\"mnt\", CLONE_NEWNS, \"CLONE_NEWNS\"},\n\t[LXC_NS_PID] = {\"pid\", CLONE_NEWPID, \"CLONE_NEWPID\"},\n\t[LXC_NS_UTS] = {\"uts\", CLONE_NEWUTS, \"CLONE_NEWUTS\"},\n\t[LXC_NS_IPC] = {\"ipc\", CLONE_NEWIPC, \"CLONE_NEWIPC\"},\n\t[LXC_NS_NET] = {\"net\", CLONE_NEWNET, \"CLONE_NEWNET\"},\n\t[LXC_NS_CGROUP] = {\"cgroup\", CLONE_NEWCGROUP, \"CLONE_NEWCGROUP\"}\n};\n\nint lxc_namespace_2_cloneflag(char *namespace)\n{\n\tint i;\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (!strcasecmp(ns_info[i].proc_name, namespace))\n\t\t\treturn ns_info[i].clone_flag;\n\n\tERROR(\"Invalid namespace name: %s.\", namespace);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "flaglist",
            "\"|\"",
            "&saveptr"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"At least one namespace is needed.\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nint lxc_fill_namespace_flags(char *flaglist, int *flags)\n{\n\tchar *token, *saveptr = NULL;\n\tint aflag;\n\n\tif (!flaglist) {\n\t\tERROR(\"At least one namespace is needed.\");\n\t\treturn -1;\n\t}\n\n\ttoken = strtok_r(flaglist, \"|\", &saveptr);\n\twhile (token) {\n\n\t\taflag = lxc_namespace_2_cloneflag(token);\n\t\tif (aflag < 0)\n\t\t\treturn -1;\n\n\t\t*flags |= aflag;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_namespace_2_cloneflag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
    "lines": "98-107",
    "snippet": "int lxc_namespace_2_cloneflag(char *namespace)\n{\n\tint i;\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (!strcasecmp(ns_info[i].proc_name, namespace))\n\t\t\treturn ns_info[i].clone_flag;\n\n\tERROR(\"Invalid namespace name: %s.\", namespace);\n\treturn -1;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <alloca.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct ns_info ns_info[LXC_NS_MAX] = {\n\t[LXC_NS_USER] = {\"user\", CLONE_NEWUSER, \"CLONE_NEWUSER\"},\n\t[LXC_NS_MNT] = {\"mnt\", CLONE_NEWNS, \"CLONE_NEWNS\"},\n\t[LXC_NS_PID] = {\"pid\", CLONE_NEWPID, \"CLONE_NEWPID\"},\n\t[LXC_NS_UTS] = {\"uts\", CLONE_NEWUTS, \"CLONE_NEWUTS\"},\n\t[LXC_NS_IPC] = {\"ipc\", CLONE_NEWIPC, \"CLONE_NEWIPC\"},\n\t[LXC_NS_NET] = {\"net\", CLONE_NEWNET, \"CLONE_NEWNET\"},\n\t[LXC_NS_CGROUP] = {\"cgroup\", CLONE_NEWCGROUP, \"CLONE_NEWCGROUP\"}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Invalid namespace name: %s.\"",
            "namespace"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ns_info[i].proc_name",
            "namespace"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nconst struct ns_info ns_info[LXC_NS_MAX] = {\n\t[LXC_NS_USER] = {\"user\", CLONE_NEWUSER, \"CLONE_NEWUSER\"},\n\t[LXC_NS_MNT] = {\"mnt\", CLONE_NEWNS, \"CLONE_NEWNS\"},\n\t[LXC_NS_PID] = {\"pid\", CLONE_NEWPID, \"CLONE_NEWPID\"},\n\t[LXC_NS_UTS] = {\"uts\", CLONE_NEWUTS, \"CLONE_NEWUTS\"},\n\t[LXC_NS_IPC] = {\"ipc\", CLONE_NEWIPC, \"CLONE_NEWIPC\"},\n\t[LXC_NS_NET] = {\"net\", CLONE_NEWNET, \"CLONE_NEWNET\"},\n\t[LXC_NS_CGROUP] = {\"cgroup\", CLONE_NEWCGROUP, \"CLONE_NEWCGROUP\"}\n};\n\nint lxc_namespace_2_cloneflag(char *namespace)\n{\n\tint i;\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\tif (!strcasecmp(ns_info[i].proc_name, namespace))\n\t\t\treturn ns_info[i].clone_flag;\n\n\tERROR(\"Invalid namespace name: %s.\", namespace);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
    "lines": "49-70",
    "snippet": "pid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <alloca.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to clone (%#x): %s.\"",
            "flags",
            "strerror(errno)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone",
          "args": [
            "do_clone",
            "stack  + stack_size",
            "flags | SIGCHLD",
            "&clone_arg"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "517-537",
          "snippet": "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};",
            "static int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);",
            "static int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);",
            "static int do_clone_rename(struct lxc_container *c, char *newname);",
            "static int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic struct lxc_arguments my_args = {\n\t.progname = \"lxc-copy\",\n\t.help = \"\\n\\\n--name=NAME [-P lxcpath] -N newname [-p newpath] [-B backingstorage] [-s] [-K] [-M] [-L size [unit]] -- hook options\\n\\\n--name=NAME [-P lxcpath] [-N newname] [-p newpath] [-B backingstorage] -e [-d] [-D] [-K] [-M] [-m {bind,aufs,overlay}=/src:/dest] -- hook options\\n\\\n--name=NAME [-P lxcpath] -N newname -R\\n\\\n\\n\\\nlxc-copy clone a container\\n\\\n\\n\\\nOptions :\\n\\\n  -n, --name=NAME           NAME of the container\\n\\\n  -N, --newname=NEWNAME     NEWNAME for the restored container\\n\\\n  -p, --newpath=NEWPATH     NEWPATH for the container to be stored\\n\\\n  -R, --rename              rename container\\n\\\n  -s, --snapshot            create snapshot instead of clone\\n\\\n  -F, --foreground          start with current tty attached to /dev/console\\n\\\n  -d, --daemon              daemonize the container (default)\\n\\\n  -e, --ephemeral           start ephemeral container\\n\\\n  -m, --mount               directory to mount into container, either \\n\\\n                            {bind,aufs,overlay}=/src-path or {bind,aufs,overlay}=/src-path:/dst-path\\n\\\n  -B, --backingstorage=TYPE backingstorage type for the container\\n\\\n  -t, --tmpfs               place ephemeral container on a tmpfs\\n\\\n                            (WARNING: On reboot all changes made to the container will be lost.)\\n\\\n  -L, --fssize              size of the new block device for block device containers\\n\\\n  -D, --keedata             pass together with -e start a persistent snapshot \\n\\\n  -K, --keepname            keep the hostname of the original container\\n\\\n  --  hook options          arguments passed to the hook program\\n\\\n  -M, --keepmac             keep the MAC address of the original container\\n\\\n  --rcfile=FILE             Load configuration file FILE\\n\",\n\t.options = my_longopts,\n\t.parser = my_parser,\n\t.task = CLONE,\n\t.daemonize = 1,\n\t.quiet = false,\n\t.tmpfs = false,\n};\nstatic int do_clone(struct lxc_container *c, char *newname, char *newpath,\n\t\t    int flags, char *bdevtype, uint64_t fssize, enum task task,\n\t\t    char **args);\nstatic int do_clone_ephemeral(struct lxc_container *c,\n\t\t\t      struct lxc_arguments *arg, char **args,\n\t\t\t      int flags);\nstatic int do_clone_rename(struct lxc_container *c, char *newname);\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args);\n\nstatic int do_clone_task(struct lxc_container *c, enum task task, int flags,\n\t\t\t char **args)\n{\n\tint ret = 0;\n\n\tswitch (task) {\n\tcase DESTROY:\n\t\tret = do_clone_ephemeral(c, &my_args, args, flags);\n\t\tbreak;\n\tcase RENAME:\n\t\tret = do_clone_rename(c, my_args.newname);\n\t\tbreak;\n\tdefault:\n\t\tret = do_clone(c, my_args.newname, my_args.newpath, flags,\n\t\t\t       my_args.bdevtype, my_args.fssize, my_args.task,\n\t\t\t       args);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clone2",
          "args": [
            "do_clone",
            "stack",
            "stack_size",
            "flags | SIGCHLD",
            "&clone_arg"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "stack_size"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_PAGESIZE"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\npid_t lxc_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tstruct clone_arg clone_arg = {\n\t\t.fn = fn,\n\t\t.arg = arg,\n\t};\n\n\tsize_t stack_size = sysconf(_SC_PAGESIZE);\n\tvoid *stack = alloca(stack_size);\n\tpid_t ret;\n\n#ifdef __ia64__\n\tret = __clone2(do_clone, stack,\n\t\t       stack_size, flags | SIGCHLD, &clone_arg);\n#else\n\tret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &clone_arg);\n#endif\n\tif (ret < 0)\n\t\tERROR(\"Failed to clone (%#x): %s.\", flags, strerror(errno));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/namespace.c",
    "lines": "43-47",
    "snippet": "static int do_clone(void *arg)\n{\n\tstruct clone_arg *clone_arg = arg;\n\treturn clone_arg->fn(clone_arg->arg);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"namespace.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <sys/param.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <alloca.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clone_arg->fn",
          "args": [
            "clone_arg->arg"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"namespace.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <signal.h>\n#include <errno.h>\n#include <alloca.h>\n#include <unistd.h>\n\nstatic int do_clone(void *arg)\n{\n\tstruct clone_arg *clone_arg = arg;\n\treturn clone_arg->fn(clone_arg->arg);\n}"
  }
]