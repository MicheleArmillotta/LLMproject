[
  {
    "function_name": "__criu_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "1181-1234",
    "snippet": "bool __criu_restore(struct lxc_container *c, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tint status, nread;\n\tint pipefd[2];\n\tchar *criu_version = NULL;\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to restore\");\n\t\treturn false;\n\t}\n\n\tif (pipe(pipefd)) {\n\t\tERROR(\"failed to create pipe\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tclose(pipefd[0]);\n\t\t// this never returns\n\t\tdo_restore(c, pipefd[1], opts, criu_version);\n\t}\n\n\tclose(pipefd[1]);\n\n\tnread = read(pipefd[0], &status, sizeof(status));\n\tclose(pipefd[0]);\n\tif (sizeof(status) != nread) {\n\t\tERROR(\"reading status from pipe failed\");\n\t\tgoto err_wait;\n\t}\n\n\t// If the criu process was killed or exited nonzero, wait() for the\n\t// handler, since the restore process died. Otherwise, we don't need to\n\t// wait, since the child becomes the monitor process.\n\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\tgoto err_wait;\n\treturn true;\n\nerr_wait:\n\tif (wait_for_pid(pid))\n\t\tERROR(\"restore process died\");\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"restore process died\""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"reading status from pipe failed\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefd[0]"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipefd[0]",
            "&status",
            "sizeof(status)"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_restore",
          "args": [
            "c",
            "pipefd[1]",
            "opts",
            "criu_version"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "do_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "780-1008",
          "snippet": "static void do_restore(struct lxc_container *c, int status_pipe, struct migrate_opts *opts, char *criu_version)\n{\n\tpid_t pid;\n\tstruct lxc_handler *handler;\n\tint status, fd;\n\tint pipes[2] = {-1, -1};\n\n\t/* Try to detach from the current controlling tty if it exists.\n\t * Othwerise, lxc_init (via lxc_console) will attach the container's\n\t * console output to the current tty, which is probably not what any\n\t * library user wants, and if they do, they can just manually configure\n\t * it :)\n\t */\n\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, TIOCNOTTY, NULL) < 0)\n\t\t\tSYSERROR(\"couldn't detach from tty\");\n\t\tclose(fd);\n\t}\n\n\thandler = lxc_init(c->name, c->lxc_conf, c->config_path);\n\tif (!handler)\n\t\tgoto out;\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"failed initing cgroups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"failed creating groups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!restore_net_info(c)) {\n\t\tERROR(\"failed restoring network info\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out_fini_handler;\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_rootfs *rootfs;\n\t\tint flags;\n\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tclose(pipes[0]);\n\t\tpipes[0] = -1;\n\n\t\tif (unshare(CLONE_NEWNS))\n\t\t\tgoto out_fini_handler;\n\n\t\t/* CRIU needs the lxc root bind mounted so that it is the root of some\n\t\t * mount. */\n\t\trootfs = &c->lxc_conf->rootfs;\n\n\t\tif (rootfs_is_blockdev(c->lxc_conf)) {\n\t\t\tif (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)\n\t\t\t\tgoto out_fini_handler;\n\t\t} else {\n\t\t\tif (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)\n\t\t\t\tgoto out_fini_handler;\n\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\t\t\tSYSERROR(\"remount / to private failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tif (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {\n\t\t\t\trmdir(rootfs->mount);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\n\t\tos.pipefd = pipes[1];\n\t\tos.action = \"restore\";\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_fd = c->lxc_conf->console.slave;\n\t\tos.criu_version = criu_version;\n\t\tos.handler = handler;\n\n\t\tif (os.console_fd >= 0) {\n\t\t\t/* Twiddle the FD_CLOEXEC bit. We want to pass this FD to criu\n\t\t\t * via --inherit-fd, so we don't want it to close.\n\t\t\t */\n\t\t\tflags = fcntl(os.console_fd, F_GETFD);\n\t\t\tif (flags < 0) {\n\t\t\t\tSYSERROR(\"F_GETFD failed: %d\", os.console_fd);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tflags &= ~FD_CLOEXEC;\n\n\t\t\tif (fcntl(os.console_fd, F_SETFD, flags) < 0) {\n\t\t\t\tSYSERROR(\"F_SETFD failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\t\tos.console_name = c->lxc_conf->console.name;\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\tumount(rootfs->mount);\n\t\trmdir(rootfs->mount);\n\t\tgoto out_fini_handler;\n\t} else {\n\t\tint ret;\n\t\tchar title[2048];\n\n\t\tclose(pipes[1]);\n\t\tpipes[1] = -1;\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tchar buf[4096];\n\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tint n;\n\n\t\t\t\tn = read(pipes[0], buf, sizeof(buf));\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tSYSERROR(\"failed reading from criu stderr\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (n == sizeof(buf))\n\t\t\t\t\tn--;\n\t\t\t\tbuf[n] = 0;\n\n\t\t\t\tERROR(\"criu process exited %d, output:\\n%s\", WEXITSTATUS(status), buf);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t} else {\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"/proc/self/task/%lu/children\", (unsigned long)syscall(__NR_gettid));\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\t\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tFILE *f = fopen(buf, \"r\");\n\t\t\t\tif (!f) {\n\t\t\t\t\tSYSERROR(\"couldn't read restore's children file %s\", buf);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tret = fscanf(f, \"%d\", (int*) &handler->pid);\n\t\t\t\tfclose(f);\n\t\t\t\tif (ret != 1) {\n\t\t\t\t\tERROR(\"reading restore pid failed\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (lxc_set_state(c->name, handler, RUNNING)) {\n\t\t\t\t\tERROR(\"error setting running state after restore\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tERROR(\"CRIU was killed with signal %d\", WTERMSIG(status));\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tclose(pipes[0]);\n\n\t\tret = write(status_pipe, &status, sizeof(status));\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tif (sizeof(status) != ret) {\n\t\t\tSYSERROR(\"failed to write all of status\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\t/*\n\t\t * See comment in lxcapi_start; we don't care if these\n\t\t * fail because it's just a beauty thing. We just\n\t\t * assign the return here to silence potential.\n\t\t */\n\t\tret = snprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tret = setproctitle(title);\n\n\t\tret = lxc_poll(c->name, handler);\n\t\tif (ret)\n\t\t\tlxc_abort(c->name, handler);\n\t\tlxc_fini(c->name, handler);\n\t\texit(ret);\n\t}\n\nout_fini_handler:\n\tif (pipes[0] >= 0)\n\t\tclose(pipes[0]);\n\tif (pipes[1] >= 0)\n\t\tclose(pipes[1]);\n\n\tlxc_fini(c->name, handler);\n\nout:\n\tif (status_pipe >= 0) {\n\t\t/* ensure getting here was a failure, e.g. if we failed to\n\t\t * parse the child pid or something, even after a successful\n\t\t * restore\n\t\t */\n\t\tif (!status)\n\t\t\tstatus = 1;\n\t\tif (write(status_pipe, &status, sizeof(status)) != sizeof(status)) {\n\t\t\tSYSERROR(\"writing status failed\");\n\t\t}\n\t\tclose(status_pipe);\n\t}\n\n\texit(1);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic void do_restore(struct lxc_container *c, int status_pipe, struct migrate_opts *opts, char *criu_version)\n{\n\tpid_t pid;\n\tstruct lxc_handler *handler;\n\tint status, fd;\n\tint pipes[2] = {-1, -1};\n\n\t/* Try to detach from the current controlling tty if it exists.\n\t * Othwerise, lxc_init (via lxc_console) will attach the container's\n\t * console output to the current tty, which is probably not what any\n\t * library user wants, and if they do, they can just manually configure\n\t * it :)\n\t */\n\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, TIOCNOTTY, NULL) < 0)\n\t\t\tSYSERROR(\"couldn't detach from tty\");\n\t\tclose(fd);\n\t}\n\n\thandler = lxc_init(c->name, c->lxc_conf, c->config_path);\n\tif (!handler)\n\t\tgoto out;\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"failed initing cgroups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"failed creating groups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!restore_net_info(c)) {\n\t\tERROR(\"failed restoring network info\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out_fini_handler;\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_rootfs *rootfs;\n\t\tint flags;\n\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tclose(pipes[0]);\n\t\tpipes[0] = -1;\n\n\t\tif (unshare(CLONE_NEWNS))\n\t\t\tgoto out_fini_handler;\n\n\t\t/* CRIU needs the lxc root bind mounted so that it is the root of some\n\t\t * mount. */\n\t\trootfs = &c->lxc_conf->rootfs;\n\n\t\tif (rootfs_is_blockdev(c->lxc_conf)) {\n\t\t\tif (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)\n\t\t\t\tgoto out_fini_handler;\n\t\t} else {\n\t\t\tif (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)\n\t\t\t\tgoto out_fini_handler;\n\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\t\t\tSYSERROR(\"remount / to private failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tif (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {\n\t\t\t\trmdir(rootfs->mount);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\n\t\tos.pipefd = pipes[1];\n\t\tos.action = \"restore\";\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_fd = c->lxc_conf->console.slave;\n\t\tos.criu_version = criu_version;\n\t\tos.handler = handler;\n\n\t\tif (os.console_fd >= 0) {\n\t\t\t/* Twiddle the FD_CLOEXEC bit. We want to pass this FD to criu\n\t\t\t * via --inherit-fd, so we don't want it to close.\n\t\t\t */\n\t\t\tflags = fcntl(os.console_fd, F_GETFD);\n\t\t\tif (flags < 0) {\n\t\t\t\tSYSERROR(\"F_GETFD failed: %d\", os.console_fd);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tflags &= ~FD_CLOEXEC;\n\n\t\t\tif (fcntl(os.console_fd, F_SETFD, flags) < 0) {\n\t\t\t\tSYSERROR(\"F_SETFD failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\t\tos.console_name = c->lxc_conf->console.name;\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\tumount(rootfs->mount);\n\t\trmdir(rootfs->mount);\n\t\tgoto out_fini_handler;\n\t} else {\n\t\tint ret;\n\t\tchar title[2048];\n\n\t\tclose(pipes[1]);\n\t\tpipes[1] = -1;\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tchar buf[4096];\n\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tint n;\n\n\t\t\t\tn = read(pipes[0], buf, sizeof(buf));\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tSYSERROR(\"failed reading from criu stderr\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (n == sizeof(buf))\n\t\t\t\t\tn--;\n\t\t\t\tbuf[n] = 0;\n\n\t\t\t\tERROR(\"criu process exited %d, output:\\n%s\", WEXITSTATUS(status), buf);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t} else {\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"/proc/self/task/%lu/children\", (unsigned long)syscall(__NR_gettid));\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\t\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tFILE *f = fopen(buf, \"r\");\n\t\t\t\tif (!f) {\n\t\t\t\t\tSYSERROR(\"couldn't read restore's children file %s\", buf);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tret = fscanf(f, \"%d\", (int*) &handler->pid);\n\t\t\t\tfclose(f);\n\t\t\t\tif (ret != 1) {\n\t\t\t\t\tERROR(\"reading restore pid failed\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (lxc_set_state(c->name, handler, RUNNING)) {\n\t\t\t\t\tERROR(\"error setting running state after restore\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tERROR(\"CRIU was killed with signal %d\", WTERMSIG(status));\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tclose(pipes[0]);\n\n\t\tret = write(status_pipe, &status, sizeof(status));\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tif (sizeof(status) != ret) {\n\t\t\tSYSERROR(\"failed to write all of status\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\t/*\n\t\t * See comment in lxcapi_start; we don't care if these\n\t\t * fail because it's just a beauty thing. We just\n\t\t * assign the return here to silence potential.\n\t\t */\n\t\tret = snprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tret = setproctitle(title);\n\n\t\tret = lxc_poll(c->name, handler);\n\t\tif (ret)\n\t\t\tlxc_abort(c->name, handler);\n\t\tlxc_fini(c->name, handler);\n\t\texit(ret);\n\t}\n\nout_fini_handler:\n\tif (pipes[0] >= 0)\n\t\tclose(pipes[0]);\n\tif (pipes[1] >= 0)\n\t\tclose(pipes[1]);\n\n\tlxc_fini(c->name, handler);\n\nout:\n\tif (status_pipe >= 0) {\n\t\t/* ensure getting here was a failure, e.g. if we failed to\n\t\t * parse the child pid or something, even after a successful\n\t\t * restore\n\t\t */\n\t\tif (!status)\n\t\t\tstatus = 1;\n\t\tif (write(status_pipe, &status, sizeof(status)) != sizeof(status)) {\n\t\t\tSYSERROR(\"writing status failed\");\n\t\t}\n\t\tclose(status_pipe);\n\t}\n\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to create pipe\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefd"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Must be root to restore\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "criu_ok",
          "args": [
            "c",
            "&criu_version"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "criu_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "717-745",
          "snippet": "static bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nbool __criu_restore(struct lxc_container *c, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tint status, nread;\n\tint pipefd[2];\n\tchar *criu_version = NULL;\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to restore\");\n\t\treturn false;\n\t}\n\n\tif (pipe(pipefd)) {\n\t\tERROR(\"failed to create pipe\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tclose(pipefd[0]);\n\t\t// this never returns\n\t\tdo_restore(c, pipefd[1], opts, criu_version);\n\t}\n\n\tclose(pipefd[1]);\n\n\tnread = read(pipefd[0], &status, sizeof(status));\n\tclose(pipefd[0]);\n\tif (sizeof(status) != nread) {\n\t\tERROR(\"reading status from pipe failed\");\n\t\tgoto err_wait;\n\t}\n\n\t// If the criu process was killed or exited nonzero, wait() for the\n\t// handler, since the restore process died. Otherwise, we don't need to\n\t// wait, since the child becomes the monitor process.\n\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\tgoto err_wait;\n\treturn true;\n\nerr_wait:\n\tif (wait_for_pid(pid))\n\t\tERROR(\"restore process died\");\n\treturn false;\n}"
  },
  {
    "function_name": "__criu_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "1164-1179",
    "snippet": "bool __criu_dump(struct lxc_container *c, struct migrate_opts *opts)\n{\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/inventory.img\", opts->directory);\n\tif (ret < 0 || ret >= sizeof(path))\n\t\treturn false;\n\n\tif (access(path, F_OK) == 0) {\n\t\tERROR(\"please use a fresh directory for the dump directory\");\n\t\treturn false;\n\t}\n\n\treturn do_dump(c, \"dump\", opts);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dump",
          "args": [
            "c",
            "\"dump\"",
            "opts"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "do_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "1062-1157",
          "snippet": "static bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"please use a fresh directory for the dump directory\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path",
            "F_OK"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/inventory.img\"",
            "opts->directory"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nbool __criu_dump(struct lxc_container *c, struct migrate_opts *opts)\n{\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/inventory.img\", opts->directory);\n\tif (ret < 0 || ret >= sizeof(path))\n\t\treturn false;\n\n\tif (access(path, F_OK) == 0) {\n\t\tERROR(\"please use a fresh directory for the dump directory\");\n\t\treturn false;\n\t}\n\n\treturn do_dump(c, \"dump\", opts);\n}"
  },
  {
    "function_name": "__criu_pre_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "1159-1162",
    "snippet": "bool __criu_pre_dump(struct lxc_container *c, struct migrate_opts *opts)\n{\n\treturn do_dump(c, \"pre-dump\", opts);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dump",
          "args": [
            "c",
            "\"pre-dump\"",
            "opts"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "do_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "1062-1157",
          "snippet": "static bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nbool __criu_pre_dump(struct lxc_container *c, struct migrate_opts *opts)\n{\n\treturn do_dump(c, \"pre-dump\", opts);\n}"
  },
  {
    "function_name": "do_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "1062-1157",
    "snippet": "static bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "opts->directory"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2332-2336",
          "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "criuout[1]"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"criu output: %s\"",
            "buf"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unknown dump exit %d\"",
            "status"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"dump signaled with %d\"",
            "WTERMSIG(status)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"dump failed with %d\"",
            "WEXITSTATUS(status)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"read\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "criuout[0]",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"waitpid\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_criu",
          "args": [
            "&os"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "exec_criu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "129-606",
          "snippet": "static void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [
            "#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"",
            "#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\n#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"\n#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\"\n\nstatic void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_tty_major_minor",
          "args": [
            "opts->directory",
            "c",
            "os.tty_id",
            "sizeof(os.tty_id)"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "save_tty_major_minor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "1010-1059",
          "snippet": "static int save_tty_major_minor(char *directory, struct lxc_container *c, char *tty_id, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\tstruct stat sb;\n\n\tif (c->lxc_conf->console.path && !strcmp(c->lxc_conf->console.path, \"none\")) {\n\t\ttty_id[0] = 0;\n\t\treturn 0;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"/proc/%d/root/dev/console\", c->init_pid(c));\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = stat(path, &sb);\n\tif (ret < 0) {\n\t\tSYSERROR(\"stat of %s failed\", path);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(tty_id, len, \"tty[%llx:%llx]\",\n\t\t\t\t\t(long long unsigned) sb.st_rdev,\n\t\t\t\t\t(long long unsigned) sb.st_dev);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = fprintf(f, \"%s\", tty_id);\n\tfclose(f);\n\tif (ret < 0)\n\t\tSYSERROR(\"failed to write to %s\", path);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic int save_tty_major_minor(char *directory, struct lxc_container *c, char *tty_id, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\tstruct stat sb;\n\n\tif (c->lxc_conf->console.path && !strcmp(c->lxc_conf->console.path, \"none\")) {\n\t\ttty_id[0] = 0;\n\t\treturn 0;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"/proc/%d/root/dev/console\", c->init_pid(c));\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = stat(path, &sb);\n\tif (ret < 0) {\n\t\tSYSERROR(\"stat of %s failed\", path);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(tty_id, len, \"tty[%llx:%llx]\",\n\t\t\t\t\t(long long unsigned) sb.st_rdev,\n\t\t\t\t\t(long long unsigned) sb.st_dev);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = fprintf(f, \"%s\", tty_id);\n\tfclose(f);\n\tif (ret < 0)\n\t\tSYSERROR(\"failed to write to %s\", path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to cgroup_init()\""
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init",
          "args": [
            "&h"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "60-72",
          "snippet": "bool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"fork failed\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir_p",
          "args": [
            "opts->directory",
            "0700"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe() failed\""
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "criuout"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "criu_ok",
          "args": [
            "c",
            "&criu_version"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "criu_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "717-745",
          "snippet": "static bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool do_dump(struct lxc_container *c, char *mode, struct migrate_opts *opts)\n{\n\tpid_t pid;\n\tchar *criu_version = NULL;\n\tint criuout[2];\n\n\tif (!criu_ok(c, &criu_version))\n\t\treturn false;\n\n\tif (pipe(criuout) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tif (mkdir_p(opts->directory, 0700) < 0)\n\t\tgoto fail;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork failed\");\n\t\tgoto fail;\n\t}\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_handler h;\n\n\t\tclose(criuout[0]);\n\n\t\th.name = c->name;\n\t\tif (!cgroup_init(&h)) {\n\t\t\tERROR(\"failed to cgroup_init()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tos.pipefd = criuout[1];\n\t\tos.action = mode;\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_name = c->lxc_conf->console.path;\n\t\tos.criu_version = criu_version;\n\n\t\tif (save_tty_major_minor(opts->directory, c, os.tty_id, sizeof(os.tty_id)) < 0)\n\t\t\texit(1);\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\texit(1);\n\t} else {\n\t\tint status;\n\t\tssize_t n;\n\t\tchar buf[4096];\n\t\tbool ret;\n\n\t\tclose(criuout[1]);\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tclose(criuout[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\tn = read(criuout[0], buf, sizeof(buf));\n\t\tclose(criuout[0]);\n\t\tif (n < 0) {\n\t\t\tSYSERROR(\"read\");\n\t\t\tn = 0;\n\t\t}\n\t\tbuf[n] = 0;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tERROR(\"dump failed with %d\", WEXITSTATUS(status));\n\t\t\t\tret = false;\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tERROR(\"dump signaled with %d\", WTERMSIG(status));\n\t\t\tret = false;\n\t\t} else {\n\t\t\tERROR(\"unknown dump exit %d\", status);\n\t\t\tret = false;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tERROR(\"criu output: %s\", buf);\n\t\treturn ret;\n\t}\nfail:\n\tclose(criuout[0]);\n\tclose(criuout[1]);\n\trmdir(opts->directory);\n\treturn false;\n}"
  },
  {
    "function_name": "save_tty_major_minor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "1010-1059",
    "snippet": "static int save_tty_major_minor(char *directory, struct lxc_container *c, char *tty_id, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\tstruct stat sb;\n\n\tif (c->lxc_conf->console.path && !strcmp(c->lxc_conf->console.path, \"none\")) {\n\t\ttty_id[0] = 0;\n\t\treturn 0;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"/proc/%d/root/dev/console\", c->init_pid(c));\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = stat(path, &sb);\n\tif (ret < 0) {\n\t\tSYSERROR(\"stat of %s failed\", path);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(tty_id, len, \"tty[%llx:%llx]\",\n\t\t\t\t\t(long long unsigned) sb.st_rdev,\n\t\t\t\t\t(long long unsigned) sb.st_dev);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = fprintf(f, \"%s\", tty_id);\n\tfclose(f);\n\tif (ret < 0)\n\t\tSYSERROR(\"failed to write to %s\", path);\n\treturn ret;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to write to %s\"",
            "path"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\"",
            "tty_id"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to open %s\"",
            "path"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"w\""
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf'd too many characters: %d\"",
            "ret"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tty_id",
            "len",
            "\"tty[%llx:%llx]\"",
            "(long long unsigned) sb.st_rdev",
            "(long long unsigned) sb.st_dev"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf'd too many characters: %d\"",
            "ret"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/tty.info\"",
            "directory"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"stat of %s failed\"",
            "path"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sb"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf'd too many chacters: %d\"",
            "ret"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"/proc/%d/root/dev/console\"",
            "c->init_pid(c)"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->init_pid",
          "args": [
            "c"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->lxc_conf->console.path",
            "\"none\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic int save_tty_major_minor(char *directory, struct lxc_container *c, char *tty_id, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\tstruct stat sb;\n\n\tif (c->lxc_conf->console.path && !strcmp(c->lxc_conf->console.path, \"none\")) {\n\t\ttty_id[0] = 0;\n\t\treturn 0;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"/proc/%d/root/dev/console\", c->init_pid(c));\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = stat(path, &sb);\n\tif (ret < 0) {\n\t\tSYSERROR(\"stat of %s failed\", path);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(tty_id, len, \"tty[%llx:%llx]\",\n\t\t\t\t\t(long long unsigned) sb.st_rdev,\n\t\t\t\t\t(long long unsigned) sb.st_dev);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"w\");\n\tif (!f) {\n\t\tSYSERROR(\"failed to open %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = fprintf(f, \"%s\", tty_id);\n\tfclose(f);\n\tif (ret < 0)\n\t\tSYSERROR(\"failed to write to %s\", path);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "780-1008",
    "snippet": "static void do_restore(struct lxc_container *c, int status_pipe, struct migrate_opts *opts, char *criu_version)\n{\n\tpid_t pid;\n\tstruct lxc_handler *handler;\n\tint status, fd;\n\tint pipes[2] = {-1, -1};\n\n\t/* Try to detach from the current controlling tty if it exists.\n\t * Othwerise, lxc_init (via lxc_console) will attach the container's\n\t * console output to the current tty, which is probably not what any\n\t * library user wants, and if they do, they can just manually configure\n\t * it :)\n\t */\n\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, TIOCNOTTY, NULL) < 0)\n\t\t\tSYSERROR(\"couldn't detach from tty\");\n\t\tclose(fd);\n\t}\n\n\thandler = lxc_init(c->name, c->lxc_conf, c->config_path);\n\tif (!handler)\n\t\tgoto out;\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"failed initing cgroups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"failed creating groups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!restore_net_info(c)) {\n\t\tERROR(\"failed restoring network info\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out_fini_handler;\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_rootfs *rootfs;\n\t\tint flags;\n\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tclose(pipes[0]);\n\t\tpipes[0] = -1;\n\n\t\tif (unshare(CLONE_NEWNS))\n\t\t\tgoto out_fini_handler;\n\n\t\t/* CRIU needs the lxc root bind mounted so that it is the root of some\n\t\t * mount. */\n\t\trootfs = &c->lxc_conf->rootfs;\n\n\t\tif (rootfs_is_blockdev(c->lxc_conf)) {\n\t\t\tif (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)\n\t\t\t\tgoto out_fini_handler;\n\t\t} else {\n\t\t\tif (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)\n\t\t\t\tgoto out_fini_handler;\n\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\t\t\tSYSERROR(\"remount / to private failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tif (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {\n\t\t\t\trmdir(rootfs->mount);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\n\t\tos.pipefd = pipes[1];\n\t\tos.action = \"restore\";\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_fd = c->lxc_conf->console.slave;\n\t\tos.criu_version = criu_version;\n\t\tos.handler = handler;\n\n\t\tif (os.console_fd >= 0) {\n\t\t\t/* Twiddle the FD_CLOEXEC bit. We want to pass this FD to criu\n\t\t\t * via --inherit-fd, so we don't want it to close.\n\t\t\t */\n\t\t\tflags = fcntl(os.console_fd, F_GETFD);\n\t\t\tif (flags < 0) {\n\t\t\t\tSYSERROR(\"F_GETFD failed: %d\", os.console_fd);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tflags &= ~FD_CLOEXEC;\n\n\t\t\tif (fcntl(os.console_fd, F_SETFD, flags) < 0) {\n\t\t\t\tSYSERROR(\"F_SETFD failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\t\tos.console_name = c->lxc_conf->console.name;\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\tumount(rootfs->mount);\n\t\trmdir(rootfs->mount);\n\t\tgoto out_fini_handler;\n\t} else {\n\t\tint ret;\n\t\tchar title[2048];\n\n\t\tclose(pipes[1]);\n\t\tpipes[1] = -1;\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tchar buf[4096];\n\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tint n;\n\n\t\t\t\tn = read(pipes[0], buf, sizeof(buf));\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tSYSERROR(\"failed reading from criu stderr\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (n == sizeof(buf))\n\t\t\t\t\tn--;\n\t\t\t\tbuf[n] = 0;\n\n\t\t\t\tERROR(\"criu process exited %d, output:\\n%s\", WEXITSTATUS(status), buf);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t} else {\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"/proc/self/task/%lu/children\", (unsigned long)syscall(__NR_gettid));\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\t\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tFILE *f = fopen(buf, \"r\");\n\t\t\t\tif (!f) {\n\t\t\t\t\tSYSERROR(\"couldn't read restore's children file %s\", buf);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tret = fscanf(f, \"%d\", (int*) &handler->pid);\n\t\t\t\tfclose(f);\n\t\t\t\tif (ret != 1) {\n\t\t\t\t\tERROR(\"reading restore pid failed\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (lxc_set_state(c->name, handler, RUNNING)) {\n\t\t\t\t\tERROR(\"error setting running state after restore\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tERROR(\"CRIU was killed with signal %d\", WTERMSIG(status));\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tclose(pipes[0]);\n\n\t\tret = write(status_pipe, &status, sizeof(status));\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tif (sizeof(status) != ret) {\n\t\t\tSYSERROR(\"failed to write all of status\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\t/*\n\t\t * See comment in lxcapi_start; we don't care if these\n\t\t * fail because it's just a beauty thing. We just\n\t\t * assign the return here to silence potential.\n\t\t */\n\t\tret = snprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tret = setproctitle(title);\n\n\t\tret = lxc_poll(c->name, handler);\n\t\tif (ret)\n\t\t\tlxc_abort(c->name, handler);\n\t\tlxc_fini(c->name, handler);\n\t\texit(ret);\n\t}\n\nout_fini_handler:\n\tif (pipes[0] >= 0)\n\t\tclose(pipes[0]);\n\tif (pipes[1] >= 0)\n\t\tclose(pipes[1]);\n\n\tlxc_fini(c->name, handler);\n\nout:\n\tif (status_pipe >= 0) {\n\t\t/* ensure getting here was a failure, e.g. if we failed to\n\t\t * parse the child pid or something, even after a successful\n\t\t * restore\n\t\t */\n\t\tif (!status)\n\t\t\tstatus = 1;\n\t\tif (write(status_pipe, &status, sizeof(status)) != sizeof(status)) {\n\t\t\tSYSERROR(\"writing status failed\");\n\t\t}\n\t\tclose(status_pipe);\n\t}\n\n\texit(1);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "status_pipe"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"writing status failed\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "status_pipe",
            "&status",
            "sizeof(status)"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_fini",
          "args": [
            "c->name",
            "handler"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "509-588",
          "snippet": "void lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_fini(const char *name, struct lxc_handler *handler)\n{\n\tint i, rc;\n\tpid_t self = getpid();\n\tchar *namespaces[LXC_NS_MAX+1];\n\tsize_t namespace_count = 0;\n\n\t/* The STOPPING state is there for future cleanup code which can take\n\t * awhile.\n\t */\n\tlxc_set_state(name, handler, STOPPING);\n\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\trc = asprintf(&namespaces[namespace_count], \"%s:/proc/%d/fd/%d\",\n\t\t\t              ns_info[i].proc_name, self, handler->nsfd[i]);\n\t\t\tif (rc == -1) {\n\t\t\t\tSYSERROR(\"Failed to allocate memory.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++namespace_count;\n\t\t}\n\t}\n\tnamespaces[namespace_count] = NULL;\n\n\tif (handler->conf->reboot && setenv(\"LXC_TARGET\", \"reboot\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=reboot.\");\n\n\tif (!handler->conf->reboot && setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\n\tif (run_lxc_hooks(name, \"stop\", handler->conf, handler->lxcpath, namespaces))\n\t\tERROR(\"Failed to run lxc.hook.stop for container \\\"%s\\\".\", name);\n\n\twhile (namespace_count--)\n\t\tfree(namespaces[namespace_count]);\n\tfor (i = 0; i < LXC_NS_MAX; i++) {\n\t\tif (handler->nsfd[i] != -1) {\n\t\t\tclose(handler->nsfd[i]);\n\t\t\thandler->nsfd[i] = -1;\n\t\t}\n\t}\n\n\tif (handler->netnsfd >= 0) {\n\t\tclose(handler->netnsfd);\n\t\thandler->netnsfd = -1;\n\t}\n\n\tlxc_set_state(name, handler, STOPPED);\n\n\tif (run_lxc_hooks(name, \"post-stop\", handler->conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.post-stop for container \\\"%s\\\".\", name);\n\t\tif (handler->conf->reboot) {\n\t\t\tWARN(\"Container will be stopped instead of rebooted.\");\n\t\t\thandler->conf->reboot = 0;\n\t\t\tif (setenv(\"LXC_TARGET\", \"stop\", 1))\n\t\t\t\tWARN(\"Failed to set environment variable: LXC_TARGET=stop.\");\n\t\t}\n\t}\n\n\t/* Reset mask set by setup_signal_fd. */\n\tif (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))\n\t\tWARN(\"Failed to restore signal mask.\");\n\n\tlxc_console_delete(&handler->conf->console);\n\tlxc_delete_tty(&handler->conf->tty_info);\n\tclose(handler->conf->maincmd_fd);\n\thandler->conf->maincmd_fd = -1;\n\tfree(handler->name);\n\tif (handler->ttysock[0] != -1) {\n\t\tclose(handler->ttysock[0]);\n\t\tclose(handler->ttysock[1]);\n\t}\n\n\tif (handler->conf->ephemeral == 1 && handler->conf->reboot != 1)\n\t\tlxc_destroy_container_on_signal(handler, name);\n\n\tcgroup_destroy(handler);\n\tfree(handler);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_abort",
          "args": [
            "c->name",
            "handler"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "590-600",
          "snippet": "void lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nvoid lxc_abort(const char *name, struct lxc_handler *handler)\n{\n\tint ret, status;\n\n\tlxc_set_state(name, handler, ABORTING);\n\tif (handler->pid > 0)\n\t\tkill(handler->pid, SIGKILL);\n\twhile ((ret = waitpid(-1, &status, 0)) > 0) {\n\t\t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_poll",
          "args": [
            "c->name",
            "handler"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "351-397",
          "snippet": "int lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_poll(const char *name, struct lxc_handler *handler)\n{\n\tint sigfd = handler->sigfd;\n\tint pid = handler->pid;\n\tstruct lxc_epoll_descr descr;\n\n\tif (lxc_mainloop_open(&descr)) {\n\t\tERROR(\"Failed to create LXC mainloop.\");\n\t\tgoto out_sigfd;\n\t}\n\n\tif (lxc_mainloop_add_handler(&descr, sigfd, signal_handler, &pid)) {\n\t\tERROR(\"Failed to add signal handler with file descriptor %d to LXC mainloop.\", sigfd);\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_console_mainloop_add(&descr, handler->conf)) {\n\t\tERROR(\"Failed to add console handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (lxc_cmd_mainloop_add(name, &descr, handler)) {\n\t\tERROR(\"Failed to add command handler to LXC mainloop.\");\n\t\tgoto out_mainloop_open;\n\t}\n\n\tif (handler->conf->need_utmp_watch) {\n\t\t#if HAVE_LIBCAP\n\t\tif (lxc_utmp_mainloop_add(&descr, handler)) {\n\t\t\tERROR(\"Failed to add utmp handler to LXC mainloop.\");\n\t\t\tgoto out_mainloop_open;\n\t\t}\n\t\t#else\n\t\t\tDEBUG(\"Not starting utmp handler as CAP_SYS_BOOT cannot be dropped without capabilities support.\");\n\t\t#endif\n\t}\n\n\treturn lxc_mainloop(&descr, -1);\n\nout_mainloop_open:\n\tlxc_mainloop_close(&descr);\n\nout_sigfd:\n\tclose(sigfd);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setproctitle",
          "args": [
            "title"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1411-1509",
          "snippet": "int setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define PR_SET_MM_MAP 14",
            "#define PR_SET_MM 35"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define PR_SET_MM_MAP 14\n#define PR_SET_MM 35\n\nint setproctitle(char *title)\n{\n\tstatic char *proctitle = NULL;\n\tchar buf[2048], *tmp;\n\tFILE *f;\n\tint i, len, ret = 0;\n\n\t/* We don't really need to know all of this stuff, but unfortunately\n\t * PR_SET_MM_MAP requires us to set it all at once, so we have to\n\t * figure it out anyway.\n\t */\n\tunsigned long start_data, end_data, start_brk, start_code, end_code,\n\t\t\tstart_stack, arg_start, arg_end, env_start, env_end,\n\t\t\tbrk_val;\n\tstruct prctl_mm_map prctl_map;\n\n\tf = fopen_cloexec(\"/proc/self/stat\", \"r\");\n\tif (!f) {\n\t\treturn -1;\n\t}\n\n\ttmp = fgets(buf, sizeof(buf), f);\n\tfclose(f);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\t/* Skip the first 25 fields, column 26-28 are start_code, end_code,\n\t * and start_stack */\n\ttmp = strchr(buf, ' ');\n\tfor (i = 0; i < 24; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu\", &start_code, &end_code, &start_stack);\n\tif (i != 3)\n\t\treturn -1;\n\n\t/* Skip the next 19 fields, column 45-51 are start_data to arg_end */\n\tfor (i = 0; i < 19; i++) {\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\ttmp = strchr(tmp+1, ' ');\n\t}\n\n\tif (!tmp)\n\t\treturn -1;\n\n\ti = sscanf(tmp, \"%lu %lu %lu %*u %*u %lu %lu\",\n\t\t&start_data,\n\t\t&end_data,\n\t\t&start_brk,\n\t\t&env_start,\n\t\t&env_end);\n\tif (i != 5)\n\t\treturn -1;\n\n\t/* Include the null byte here, because in the calculations below we\n\t * want to have room for it. */\n\tlen = strlen(title) + 1;\n\n\tproctitle = realloc(proctitle, len);\n\tif (!proctitle)\n\t\treturn -1;\n\n\targ_start = (unsigned long) proctitle;\n\targ_end = arg_start + len;\n\n\tbrk_val = syscall(__NR_brk, 0);\n\n\tprctl_map = (struct prctl_mm_map) {\n\t\t.start_code = start_code,\n\t\t.end_code = end_code,\n\t\t.start_stack = start_stack,\n\t\t.start_data = start_data,\n\t\t.end_data = end_data,\n\t\t.start_brk = start_brk,\n\t\t.brk = brk_val,\n\t\t.arg_start = arg_start,\n\t\t.arg_end = arg_end,\n\t\t.env_start = env_start,\n\t\t.env_end = env_end,\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\n\tret = prctl(PR_SET_MM, PR_SET_MM_MAP, (long) &prctl_map, sizeof(prctl_map), 0);\n\tif (ret == 0)\n\t\tstrcpy((char*)arg_start, title);\n\telse\n\t\tINFO(\"setting cmdline failed - %s\", strerror(errno));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "title",
            "sizeof(title)",
            "\"[lxc monitor] %s %s\"",
            "c->config_path",
            "c->name"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to write all of status\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"CRIU was killed with signal %d\"",
            "WTERMSIG(status)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"error setting running state after restore\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_set_state",
          "args": [
            "c->name",
            "handler",
            "RUNNING"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "344-349",
          "snippet": "int lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint lxc_set_state(const char *name, struct lxc_handler *handler, lxc_state_t state)\n{\n\thandler->state = state;\n\tlxc_monitor_send_state(name, state, handler->lxcpath);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"reading restore pid failed\""
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\"",
            "(int*) &handler->pid"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"couldn't read restore's children file %s\"",
            "buf"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "buf",
            "\"r\""
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf'd too many characters: %d\"",
            "ret"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"/proc/self/task/%lu/children\"",
            "(unsigned long)syscall(__NR_gettid)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_gettid"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"criu process exited %d, output:\\n%s\"",
            "WEXITSTATUS(status)",
            "buf"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed reading from criu stderr\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipes[0]",
            "buf",
            "sizeof(buf)"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"waitpid\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "rootfs->mount"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_rmdir_onedev_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxccontainer.c",
          "lines": "2332-2336",
          "snippet": "static int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include \"version.h\"",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"sync.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxccontainer.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"console.h\"",
            "#include \"confile.h\"",
            "#include \"commands.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include \"version.h\"\n#include \"utils.h\"\n#include \"state.h\"\n#include \"sync.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"lxccontainer.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"console.h\"\n#include \"confile.h\"\n#include \"commands.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcoverlay.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <sched.h>\n#include <pthread.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nstatic int lxc_rmdir_onedev_wrapper(void *data)\n{\n\tchar *arg = (char *) data;\n\treturn lxc_rmdir_onedev(arg, \"snaps\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount",
          "args": [
            "rootfs->mount"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "rbd_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/lxcrbd.c",
          "lines": "174-181",
          "snippet": "int rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <inttypes.h> /* Required for PRIu64 to work. */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h> /* Required for PRIu64 to work. */\n\nint rbd_umount(struct bdev *bdev)\n{\n\tif (strcmp(bdev->type, \"rbd\"))\n\t\treturn -22;\n\tif (!bdev->src || !bdev->dest)\n\t\treturn -22;\n\treturn umount(bdev->dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_criu",
          "args": [
            "&os"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "exec_criu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "129-606",
          "snippet": "static void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [
            "#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"",
            "#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\n#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"\n#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\"\n\nstatic void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"F_SETFD failed\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "os.console_fd",
            "F_SETFD",
            "flags"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"F_GETFD failed: %d\"",
            "os.console_fd"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "os.console_fd",
            "F_GETFD"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "rootfs->path",
            "rootfs->mount",
            "NULL",
            "MS_BIND",
            "NULL"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"remount / to private failed\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "rootfs->mount",
            "0755"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "241-262",
          "snippet": "extern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern int mkdir_p(const char *dir, mode_t mode)\n{\n\tconst char *tmp = dir;\n\tconst char *orig = dir;\n\tchar *makeme;\n\n\tdo {\n\t\tdir = tmp + strspn(tmp, \"/\");\n\t\ttmp = dir + strcspn(dir, \"/\");\n\t\tmakeme = strndup(orig, dir - orig);\n\t\tif (*makeme) {\n\t\t\tif (mkdir(makeme, mode) && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"failed to create directory '%s'\", makeme);\n\t\t\t\tfree(makeme);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(makeme);\n\t} while(tmp != dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_rootfs_setup",
          "args": [
            "c->lxc_conf",
            "c->name",
            "c->config_path"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "do_rootfs_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3740-3769",
          "snippet": "int do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint do_rootfs_setup(struct lxc_conf *conf, const char *name, const char *lxcpath)\n{\n\tif (conf->rootfs_setup) {\n\t\t/*\n\t\t * rootfs was set up in another namespace.  bind-mount it\n\t\t * to give us a mount in our own ns so we can pivot_root to it\n\t\t */\n\t\tconst char *path = conf->rootfs.mount;\n\t\tif (mount(path, path, \"rootfs\", MS_BIND, NULL) < 0) {\n\t\t\tERROR(\"Failed to bind-mount container / onto itself\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tremount_all_slave();\n\n\tif (run_lxc_hooks(name, \"pre-mount\", conf, lxcpath, NULL)) {\n\t\tERROR(\"failed to run pre-mount hooks for container '%s'.\", name);\n\t\treturn -1;\n\t}\n\n\tif (setup_rootfs(conf)) {\n\t\tERROR(\"failed to setup rootfs for '%s'\", name);\n\t\treturn -1;\n\t}\n\n\tconf->rootfs_setup = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rootfs_is_blockdev",
          "args": [
            "c->lxc_conf"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "rootfs_is_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/bdev/bdev.c",
          "lines": "784-805",
          "snippet": "bool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"namespace.h\"",
            "#include \"lxczfs.h\"",
            "#include \"lxcrsync.h\"",
            "#include \"lxcrbd.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxcnbd.h\"",
            "#include \"lxcloop.h\"",
            "#include \"lxclvm.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcdir.h\"",
            "#include \"lxcbtrfs.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"config.h\"",
            "#include \"conf.h\"",
            "#include \"bdev.h\"",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <sched.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"parse.h\"\n#include \"namespace.h\"\n#include \"lxczfs.h\"\n#include \"lxcrsync.h\"\n#include \"lxcrbd.h\"\n#include \"lxcoverlay.h\"\n#include \"lxcnbd.h\"\n#include \"lxcloop.h\"\n#include \"lxclvm.h\"\n#include \"lxclock.h\"\n#include \"lxcdir.h\"\n#include \"lxcbtrfs.h\"\n#include \"lxcaufs.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"config.h\"\n#include \"conf.h\"\n#include \"bdev.h\"\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sched.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n\nbool rootfs_is_blockdev(struct lxc_conf *conf)\n{\n\tconst struct bdev_type *q;\n\tstruct stat st;\n\tint ret;\n\n\tif (!conf->rootfs.path || strcmp(conf->rootfs.path, \"/\") == 0 ||\n\t\tstrlen(conf->rootfs.path) == 0)\n\t\treturn false;\n\n\tret = stat(conf->rootfs.path, &st);\n\tif (ret == 0 && S_ISBLK(st.st_mode))\n\t\treturn true;\n\tq = bdev_query(conf, conf->rootfs.path);\n\tif (!q)\n\t\treturn false;\n\tif (strcmp(q->name, \"lvm\") == 0 ||\n\t\tstrcmp(q->name, \"loop\") == 0 ||\n\t\tstrcmp(q->name, \"nbd\") == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe() failed\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipes"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_clone_flags",
          "args": [
            "handler"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_clone_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1049-1072",
          "snippet": "void resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nvoid resolve_clone_flags(struct lxc_handler *handler)\n{\n\thandler->clone_flags = CLONE_NEWPID | CLONE_NEWNS;\n\n\tif (!lxc_list_empty(&handler->conf->id_map))\n\t\thandler->clone_flags |= CLONE_NEWUSER;\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_NET] == -1) {\n\t\tif (!lxc_requests_empty_network(handler))\n\t\t\thandler->clone_flags |= CLONE_NEWNET;\n\t} else {\n\t\tINFO(\"Inheriting a NET namespace.\");\n\t}\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_IPC] == -1)\n\t\thandler->clone_flags |= CLONE_NEWIPC;\n\telse\n\t\tINFO(\"Inheriting an IPC namespace.\");\n\n\tif (handler->conf->inherit_ns_fd[LXC_NS_UTS] == -1)\n\t\thandler->clone_flags |= CLONE_NEWUTS;\n\telse\n\t\tINFO(\"Inheriting a UTS namespace.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed restoring network info\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_net_info",
          "args": [
            "c"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "restore_net_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "747-776",
          "snippet": "static bool restore_net_info(struct lxc_container *c)\n{\n\tstruct lxc_list *it;\n\tbool has_error = true;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *netdev = it->elem;\n\t\tchar template[IFNAMSIZ];\n\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\n\t\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tnetdev->priv.veth_attr.pair = lxc_mkifname(template);\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tgoto out_unlock;\n\t}\n\n\thas_error = false;\n\nout_unlock:\n\tcontainer_mem_unlock(c);\n\treturn !has_error;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool restore_net_info(struct lxc_container *c)\n{\n\tstruct lxc_list *it;\n\tbool has_error = true;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *netdev = it->elem;\n\t\tchar template[IFNAMSIZ];\n\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\n\t\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tnetdev->priv.veth_attr.pair = lxc_mkifname(template);\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tgoto out_unlock;\n\t}\n\n\thas_error = false;\n\nout_unlock:\n\tcontainer_mem_unlock(c);\n\treturn !has_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed creating groups\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_create",
          "args": [
            "handler"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_create_legacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "101-106",
          "snippet": "bool cgroup_create_legacy(struct lxc_handler *handler)\n{\n\tif (ops && ops->create_legacy)\n\t\treturn ops->create_legacy(handler->cgroup_data, handler->pid);\n\treturn true;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_create_legacy(struct lxc_handler *handler)\n{\n\tif (ops && ops->create_legacy)\n\t\treturn ops->create_legacy(handler->cgroup_data, handler->pid);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed initing cgroups\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init",
          "args": [
            "handler"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "60-72",
          "snippet": "bool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_init(struct lxc_handler *handler)\n{\n\tif (handler->cgroup_data) {\n\t\tERROR(\"cgroup_init called on already inited handler\");\n\t\treturn true;\n\t}\n\n\tif (ops) {\n\t\tINFO(\"cgroup driver %s initing for %s\", ops->name, handler->name);\n\t\thandler->cgroup_data = ops->init(handler->name);\n\t}\n\treturn handler->cgroup_data != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_init",
          "args": [
            "c->name",
            "c->lxc_conf",
            "c->config_path"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "399-507",
          "snippet": "struct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nstruct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)\n{\n\tint i;\n\tstruct lxc_handler *handler;\n\n\thandler = malloc(sizeof(*handler));\n\tif (!handler)\n\t\treturn NULL;\n\n\tmemset(handler, 0, sizeof(*handler));\n\n\thandler->ttysock[0] = handler->ttysock[1] = -1;\n\thandler->conf = conf;\n\thandler->lxcpath = lxcpath;\n\thandler->pinfd = -1;\n\n\tfor (i = 0; i < LXC_NS_MAX; i++)\n\t\thandler->nsfd[i] = -1;\n\n\tlsm_init();\n\n\thandler->name = strdup(name);\n\tif (!handler->name) {\n\t\tERROR(\"Failed to allocate memory.\");\n\t\tgoto out_free;\n\t}\n\n\tif (lxc_cmd_init(name, handler, lxcpath))\n\t\tgoto out_free_name;\n\n\tif (lxc_read_seccomp_config(conf) != 0) {\n\t\tERROR(\"Failed loading seccomp policy.\");\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Begin by setting the state to STARTING. */\n\tif (lxc_set_state(name, handler, STARTING)) {\n\t\tERROR(\"Failed to set state for container \\\"%s\\\" to \\\"%s\\\".\", name, lxc_state2str(STARTING));\n\t\tgoto out_close_maincmd_fd;\n\t}\n\n\t/* Start of environment variable setup for hooks. */\n\tif (name && setenv(\"LXC_NAME\", name, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_NAME=%s.\", name);\n\n\tif (conf->rcfile && setenv(\"LXC_CONFIG_FILE\", conf->rcfile, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONFIG_FILE=%s.\", conf->rcfile);\n\n\tif (conf->rootfs.mount && setenv(\"LXC_ROOTFS_MOUNT\", conf->rootfs.mount, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_MOUNT=%s.\", conf->rootfs.mount);\n\n\tif (conf->rootfs.path && setenv(\"LXC_ROOTFS_PATH\", conf->rootfs.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_ROOTFS_PATH=%s.\", conf->rootfs.path);\n\n\tif (conf->console.path && setenv(\"LXC_CONSOLE\", conf->console.path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE=%s.\", conf->console.path);\n\n\tif (conf->console.log_path && setenv(\"LXC_CONSOLE_LOGPATH\", conf->console.log_path, 1))\n\t\tSYSERROR(\"Failed to set environment variable: LXC_CONSOLE_LOGPATH=%s.\", conf->console.log_path);\n\n\tif (setenv(\"LXC_CGNS_AWARE\", \"1\", 1))\n\t\tSYSERROR(\"Failed to set environment variable LXC_CGNS_AWARE=1.\");\n\t/* End of environment variable setup for hooks. */\n\n\tif (run_lxc_hooks(name, \"pre-start\", conf, handler->lxcpath, NULL)) {\n\t\tERROR(\"Failed to run lxc.hook.pre-start for container \\\"%s\\\".\", name);\n\t\tgoto out_aborting;\n\t}\n\n\t/* The signal fd has to be created before forking otherwise if the child\n\t * process exits before we setup the signal fd, the event will be lost\n\t * and the command will be stuck.\n\t */\n\thandler->sigfd = setup_signal_fd(&handler->oldmask);\n\tif (handler->sigfd < 0) {\n\t\tERROR(\"Failed to setup SIGCHLD fd handler.\");\n\t\tgoto out_delete_tty;\n\t}\n\n\t/* Do this after setting up signals since it might unblock SIGWINCH. */\n\tif (lxc_console_create(conf)) {\n\t\tERROR(\"Failed to create console for container \\\"%s\\\".\", name);\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tif (ttys_shift_ids(conf) < 0) {\n\t\tERROR(\"Failed to shift tty into container.\");\n\t\tgoto out_restore_sigmask;\n\t}\n\n\tINFO(\"Container \\\"%s\\\" is initialized.\", name);\n\treturn handler;\n\nout_restore_sigmask:\n\tsigprocmask(SIG_SETMASK, &handler->oldmask, NULL);\nout_delete_tty:\n\tlxc_delete_tty(&conf->tty_info);\nout_aborting:\n\tlxc_set_state(name, handler, ABORTING);\nout_close_maincmd_fd:\n\tclose(conf->maincmd_fd);\n\tconf->maincmd_fd = -1;\nout_free_name:\n\tfree(handler->name);\n\thandler->name = NULL;\nout_free:\n\tfree(handler);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"couldn't detach from tty\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCNOTTY",
            "NULL"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/tty\"",
            "O_RDWR"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "genetlink_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/genl.c",
          "lines": "106-116",
          "snippet": "extern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"genl.h\"",
            "#include \"nl.h\"",
            "#include <linux/rtnetlink.h>",
            "#include <linux/genetlink.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/socket.h>",
            "#include <stdio.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"genl.h\"\n#include \"nl.h\"\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <string.h>\n\nextern int genetlink_open(struct genl_handler *handler, const char *family)\n{\n\tint ret;\n\thandler->family = genetlink_resolve_family(family);\n\tif (handler->family < 0)\n\t\treturn handler->family;\n\n\tret = netlink_open(&handler->nlh, NETLINK_GENERIC);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic void do_restore(struct lxc_container *c, int status_pipe, struct migrate_opts *opts, char *criu_version)\n{\n\tpid_t pid;\n\tstruct lxc_handler *handler;\n\tint status, fd;\n\tint pipes[2] = {-1, -1};\n\n\t/* Try to detach from the current controlling tty if it exists.\n\t * Othwerise, lxc_init (via lxc_console) will attach the container's\n\t * console output to the current tty, which is probably not what any\n\t * library user wants, and if they do, they can just manually configure\n\t * it :)\n\t */\n\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, TIOCNOTTY, NULL) < 0)\n\t\t\tSYSERROR(\"couldn't detach from tty\");\n\t\tclose(fd);\n\t}\n\n\thandler = lxc_init(c->name, c->lxc_conf, c->config_path);\n\tif (!handler)\n\t\tgoto out;\n\n\tif (!cgroup_init(handler)) {\n\t\tERROR(\"failed initing cgroups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!cgroup_create(handler)) {\n\t\tERROR(\"failed creating groups\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tif (!restore_net_info(c)) {\n\t\tERROR(\"failed restoring network info\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tresolve_clone_flags(handler);\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\tgoto out_fini_handler;\n\t}\n\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out_fini_handler;\n\n\tif (pid == 0) {\n\t\tstruct criu_opts os;\n\t\tstruct lxc_rootfs *rootfs;\n\t\tint flags;\n\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tclose(pipes[0]);\n\t\tpipes[0] = -1;\n\n\t\tif (unshare(CLONE_NEWNS))\n\t\t\tgoto out_fini_handler;\n\n\t\t/* CRIU needs the lxc root bind mounted so that it is the root of some\n\t\t * mount. */\n\t\trootfs = &c->lxc_conf->rootfs;\n\n\t\tif (rootfs_is_blockdev(c->lxc_conf)) {\n\t\t\tif (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)\n\t\t\t\tgoto out_fini_handler;\n\t\t} else {\n\t\t\tif (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)\n\t\t\t\tgoto out_fini_handler;\n\n\t\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\t\t\tSYSERROR(\"remount / to private failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tif (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {\n\t\t\t\trmdir(rootfs->mount);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\n\t\tos.pipefd = pipes[1];\n\t\tos.action = \"restore\";\n\t\tos.user = opts;\n\t\tos.c = c;\n\t\tos.console_fd = c->lxc_conf->console.slave;\n\t\tos.criu_version = criu_version;\n\t\tos.handler = handler;\n\n\t\tif (os.console_fd >= 0) {\n\t\t\t/* Twiddle the FD_CLOEXEC bit. We want to pass this FD to criu\n\t\t\t * via --inherit-fd, so we don't want it to close.\n\t\t\t */\n\t\t\tflags = fcntl(os.console_fd, F_GETFD);\n\t\t\tif (flags < 0) {\n\t\t\t\tSYSERROR(\"F_GETFD failed: %d\", os.console_fd);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\n\t\t\tflags &= ~FD_CLOEXEC;\n\n\t\t\tif (fcntl(os.console_fd, F_SETFD, flags) < 0) {\n\t\t\t\tSYSERROR(\"F_SETFD failed\");\n\t\t\t\tgoto out_fini_handler;\n\t\t\t}\n\t\t}\n\t\tos.console_name = c->lxc_conf->console.name;\n\n\t\t/* exec_criu() returning is an error */\n\t\texec_criu(&os);\n\t\tumount(rootfs->mount);\n\t\trmdir(rootfs->mount);\n\t\tgoto out_fini_handler;\n\t} else {\n\t\tint ret;\n\t\tchar title[2048];\n\n\t\tclose(pipes[1]);\n\t\tpipes[1] = -1;\n\n\t\tpid_t w = waitpid(pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tSYSERROR(\"waitpid\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tchar buf[4096];\n\n\t\t\tif (WEXITSTATUS(status)) {\n\t\t\t\tint n;\n\n\t\t\t\tn = read(pipes[0], buf, sizeof(buf));\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tSYSERROR(\"failed reading from criu stderr\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (n == sizeof(buf))\n\t\t\t\t\tn--;\n\t\t\t\tbuf[n] = 0;\n\n\t\t\t\tERROR(\"criu process exited %d, output:\\n%s\", WEXITSTATUS(status), buf);\n\t\t\t\tgoto out_fini_handler;\n\t\t\t} else {\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"/proc/self/task/%lu/children\", (unsigned long)syscall(__NR_gettid));\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\t\t\tERROR(\"snprintf'd too many characters: %d\", ret);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tFILE *f = fopen(buf, \"r\");\n\t\t\t\tif (!f) {\n\t\t\t\t\tSYSERROR(\"couldn't read restore's children file %s\", buf);\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tret = fscanf(f, \"%d\", (int*) &handler->pid);\n\t\t\t\tfclose(f);\n\t\t\t\tif (ret != 1) {\n\t\t\t\t\tERROR(\"reading restore pid failed\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\n\t\t\t\tif (lxc_set_state(c->name, handler, RUNNING)) {\n\t\t\t\t\tERROR(\"error setting running state after restore\");\n\t\t\t\t\tgoto out_fini_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tERROR(\"CRIU was killed with signal %d\", WTERMSIG(status));\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\tclose(pipes[0]);\n\n\t\tret = write(status_pipe, &status, sizeof(status));\n\t\tclose(status_pipe);\n\t\tstatus_pipe = -1;\n\n\t\tif (sizeof(status) != ret) {\n\t\t\tSYSERROR(\"failed to write all of status\");\n\t\t\tgoto out_fini_handler;\n\t\t}\n\n\t\t/*\n\t\t * See comment in lxcapi_start; we don't care if these\n\t\t * fail because it's just a beauty thing. We just\n\t\t * assign the return here to silence potential.\n\t\t */\n\t\tret = snprintf(title, sizeof(title), \"[lxc monitor] %s %s\", c->config_path, c->name);\n\t\tret = setproctitle(title);\n\n\t\tret = lxc_poll(c->name, handler);\n\t\tif (ret)\n\t\t\tlxc_abort(c->name, handler);\n\t\tlxc_fini(c->name, handler);\n\t\texit(ret);\n\t}\n\nout_fini_handler:\n\tif (pipes[0] >= 0)\n\t\tclose(pipes[0]);\n\tif (pipes[1] >= 0)\n\t\tclose(pipes[1]);\n\n\tlxc_fini(c->name, handler);\n\nout:\n\tif (status_pipe >= 0) {\n\t\t/* ensure getting here was a failure, e.g. if we failed to\n\t\t * parse the child pid or something, even after a successful\n\t\t * restore\n\t\t */\n\t\tif (!status)\n\t\t\tstatus = 1;\n\t\tif (write(status_pipe, &status, sizeof(status)) != sizeof(status)) {\n\t\t\tSYSERROR(\"writing status failed\");\n\t\t}\n\t\tclose(status_pipe);\n\t}\n\n\texit(1);\n}"
  },
  {
    "function_name": "restore_net_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "747-776",
    "snippet": "static bool restore_net_info(struct lxc_container *c)\n{\n\tstruct lxc_list *it;\n\tbool has_error = true;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *netdev = it->elem;\n\t\tchar template[IFNAMSIZ];\n\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\n\t\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tnetdev->priv.veth_attr.pair = lxc_mkifname(template);\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tgoto out_unlock;\n\t}\n\n\thas_error = false;\n\nout_unlock:\n\tcontainer_mem_unlock(c);\n\treturn !has_error;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_mem_unlock",
          "args": [
            "c"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "347-350",
          "snippet": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_mkifname",
          "args": [
            "template"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_mkifname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1507-1566",
          "snippet": "char *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char padchar[] =\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nchar *lxc_mkifname(char *template)\n{\n\tchar *name = NULL;\n\tsize_t i = 0;\n\tFILE *urandom;\n\tunsigned int seed;\n\tstruct ifaddrs *ifaddr, *ifa;\n\tint ifexists = 0;\n\n\t/* Get all the network interfaces */\n\tgetifaddrs(&ifaddr);\n\n\t/* Initialize the random number generator */\n\turandom = fopen (\"/dev/urandom\", \"r\");\n\tif (urandom != NULL) {\n\t\tif (fread (&seed, sizeof(seed), 1, urandom) <= 0)\n\t\t\tseed = time(0);\n\t\tfclose(urandom);\n\t}\n\telse\n\t\tseed = time(0);\n\n#ifndef HAVE_RAND_R\n\tsrand(seed);\n#endif\n\n\t/* Generate random names until we find one that doesn't exist */\n\twhile(1) {\n\t\tifexists = 0;\n\t\tname = strdup(template);\n\n\t\tif (name == NULL)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < strlen(name); i++) {\n\t\t\tif (name[i] == 'X') {\n#ifdef HAVE_RAND_R\n\t\t\t\tname[i] = padchar[rand_r(&seed) % (strlen(padchar) - 1)];\n#else\n\t\t\t\tname[i] = padchar[rand() % (strlen(padchar) - 1)];\n#endif\n\t\t\t}\n\t\t}\n\n\t\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (strcmp(ifa->ifa_name, name) == 0) {\n\t\t\t\tifexists = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ifexists == 0)\n\t\t\tbreak;\n\n\t\tfree(name);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "template",
            "sizeof(template)",
            "\"vethXXXXXX\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&c->lxc_conf->network"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_mem_lock",
          "args": [
            "c"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "container_mem_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "342-345",
          "snippet": "int container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint container_mem_lock(struct lxc_container *c)\n{\n\treturn lxclock(c->privlock, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool restore_net_info(struct lxc_container *c)\n{\n\tstruct lxc_list *it;\n\tbool has_error = true;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *netdev = it->elem;\n\t\tchar template[IFNAMSIZ];\n\n\t\tif (netdev->type != LXC_NET_VETH)\n\t\t\tcontinue;\n\n\t\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tnetdev->priv.veth_attr.pair = lxc_mkifname(template);\n\n\t\tif (!netdev->priv.veth_attr.pair)\n\t\t\tgoto out_unlock;\n\t}\n\n\thas_error = false;\n\nout_unlock:\n\tcontainer_mem_unlock(c);\n\treturn !has_error;\n}"
  },
  {
    "function_name": "criu_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "717-745",
    "snippet": "static bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Found un-dumpable network: %s (%s)\"",
            "lxc_net_type_to_str(n->type)",
            "n->name"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_net_type_to_str",
          "args": [
            "n->type"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_net_type_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/network.c",
          "lines": "1497-1502",
          "snippet": "const char *lxc_net_type_to_str(int type)\n{\n\tif (type < 0 || type > LXC_NET_MAXCONFTYPE)\n\t\treturn NULL;\n\treturn lxc_network_types[type];\n}",
          "includes": [
            "#include <../include/ifaddrs.h>",
            "#include <ifaddrs.h>",
            "#include \"utils.h\"",
            "#include \"conf.h\"",
            "#include \"network.h\"",
            "#include \"nl.h\"",
            "#include <linux/sockios.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/netlink.h>",
            "#include <netinet/in.h>",
            "#include <net/ethernet.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <arpa/inet.h>",
            "#include <sys/inotify.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* const lxc_network_types[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_EMPTY]   = \"empty\",\n\t[LXC_NET_VETH]    = \"veth\",\n\t[LXC_NET_MACVLAN] = \"macvlan\",\n\t[LXC_NET_PHYS]    = \"phys\",\n\t[LXC_NET_VLAN]    = \"vlan\",\n\t[LXC_NET_NONE]    = \"none\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/ifaddrs.h>\n#include <ifaddrs.h>\n#include \"utils.h\"\n#include \"conf.h\"\n#include \"network.h\"\n#include \"nl.h\"\n#include <linux/sockios.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <netinet/in.h>\n#include <net/ethernet.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* const lxc_network_types[LXC_NET_MAXCONFTYPE + 1] = {\n\t[LXC_NET_EMPTY]   = \"empty\",\n\t[LXC_NET_VETH]    = \"veth\",\n\t[LXC_NET_MACVLAN] = \"macvlan\",\n\t[LXC_NET_PHYS]    = \"phys\",\n\t[LXC_NET_VLAN]    = \"vlan\",\n\t[LXC_NET_NONE]    = \"none\",\n};\n\nconst char *lxc_net_type_to_str(int type)\n{\n\tif (type < 0 || type > LXC_NET_MAXCONFTYPE)\n\t\treturn NULL;\n\treturn lxc_network_types[type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&c->lxc_conf->network"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Must be root to checkpoint\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "criu_version_ok",
          "args": [
            "criu_version"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "criu_version_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "620-713",
          "snippet": "static bool criu_version_ok(char **version)\n{\n\tint pipes[2];\n\tpid_t pid;\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork() failed\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tchar *args[] = { \"criu\", \"--version\", NULL };\n\t\tchar *path;\n\t\tclose(pipes[0]);\n\n\t\tclose(STDERR_FILENO);\n\t\tif (dup2(pipes[1], STDOUT_FILENO) < 0)\n\t\t\texit(1);\n\n\t\tpath = on_path(\"criu\", NULL);\n\t\tif (!path)\n\t\t\texit(1);\n\n\t\texecv(path, args);\n\t\texit(1);\n\t} else {\n\t\tFILE *f;\n\t\tchar *tmp;\n\t\tint patch;\n\n\t\tclose(pipes[1]);\n\t\tif (wait_for_pid(pid) < 0) {\n\t\t\tclose(pipes[0]);\n\t\t\tSYSERROR(\"execing criu failed, is it installed?\");\n\t\t\treturn false;\n\t\t}\n\n\t\tf = fdopen(pipes[0], \"r\");\n\t\tif (!f) {\n\t\t\tclose(pipes[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\ttmp = malloc(1024);\n\t\tif (!tmp) {\n\t\t\tfclose(f);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fscanf(f, \"Version: %1023[^\\n]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '\\n')\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_VERSION) >= 0)\n\t\t\tgoto version_match;\n\n\t\tif (fscanf(f, \"GitID: v%1023[^-]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '-')\n\t\t\tgoto version_error;\n\n\t\tif (fscanf(f, \"%d\", &patch) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_GITID_VERSION) < 0)\n\t\t\tgoto version_error;\n\n\t\tif (patch < CRIU_GITID_PATCHLEVEL)\n\t\t\tgoto version_error;\n\nversion_match:\n\t\tfclose(f);\n\t\tif (!version)\n\t\t\tfree(tmp);\n\t\telse\n\t\t\t*version = tmp;\n\t\treturn true;\n\nversion_error:\n\t\tfclose(f);\n\t\tfree(tmp);\n\t\tERROR(\"must have criu \" CRIU_VERSION \" or greater to checkpoint/restore\");\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [
            "#define CRIU_GITID_PATCHLEVEL\t0",
            "#define CRIU_GITID_VERSION\t\"2.0\"",
            "#define CRIU_VERSION\t\t\"2.0\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\n#define CRIU_GITID_PATCHLEVEL\t0\n#define CRIU_GITID_VERSION\t\"2.0\"\n#define CRIU_VERSION\t\t\"2.0\"\n\nstatic bool criu_version_ok(char **version)\n{\n\tint pipes[2];\n\tpid_t pid;\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork() failed\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tchar *args[] = { \"criu\", \"--version\", NULL };\n\t\tchar *path;\n\t\tclose(pipes[0]);\n\n\t\tclose(STDERR_FILENO);\n\t\tif (dup2(pipes[1], STDOUT_FILENO) < 0)\n\t\t\texit(1);\n\n\t\tpath = on_path(\"criu\", NULL);\n\t\tif (!path)\n\t\t\texit(1);\n\n\t\texecv(path, args);\n\t\texit(1);\n\t} else {\n\t\tFILE *f;\n\t\tchar *tmp;\n\t\tint patch;\n\n\t\tclose(pipes[1]);\n\t\tif (wait_for_pid(pid) < 0) {\n\t\t\tclose(pipes[0]);\n\t\t\tSYSERROR(\"execing criu failed, is it installed?\");\n\t\t\treturn false;\n\t\t}\n\n\t\tf = fdopen(pipes[0], \"r\");\n\t\tif (!f) {\n\t\t\tclose(pipes[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\ttmp = malloc(1024);\n\t\tif (!tmp) {\n\t\t\tfclose(f);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fscanf(f, \"Version: %1023[^\\n]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '\\n')\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_VERSION) >= 0)\n\t\t\tgoto version_match;\n\n\t\tif (fscanf(f, \"GitID: v%1023[^-]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '-')\n\t\t\tgoto version_error;\n\n\t\tif (fscanf(f, \"%d\", &patch) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_GITID_VERSION) < 0)\n\t\t\tgoto version_error;\n\n\t\tif (patch < CRIU_GITID_PATCHLEVEL)\n\t\t\tgoto version_error;\n\nversion_match:\n\t\tfclose(f);\n\t\tif (!version)\n\t\t\tfree(tmp);\n\t\telse\n\t\t\t*version = tmp;\n\t\treturn true;\n\nversion_error:\n\t\tfclose(f);\n\t\tfree(tmp);\n\t\tERROR(\"must have criu \" CRIU_VERSION \" or greater to checkpoint/restore\");\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic bool criu_ok(struct lxc_container *c, char **criu_version)\n{\n\tstruct lxc_list *it;\n\n\tif (!criu_version_ok(criu_version))\n\t\treturn false;\n\n\tif (geteuid()) {\n\t\tERROR(\"Must be root to checkpoint\");\n\t\treturn false;\n\t}\n\n\t/* We only know how to restore containers with veth networks. */\n\tlxc_list_for_each(it, &c->lxc_conf->network) {\n\t\tstruct lxc_netdev *n = it->elem;\n\t\tswitch(n->type) {\n\t\tcase LXC_NET_VETH:\n\t\tcase LXC_NET_NONE:\n\t\tcase LXC_NET_EMPTY:\n\t\tcase LXC_NET_MACVLAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(\"Found un-dumpable network: %s (%s)\", lxc_net_type_to_str(n->type), n->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "criu_version_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "620-713",
    "snippet": "static bool criu_version_ok(char **version)\n{\n\tint pipes[2];\n\tpid_t pid;\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork() failed\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tchar *args[] = { \"criu\", \"--version\", NULL };\n\t\tchar *path;\n\t\tclose(pipes[0]);\n\n\t\tclose(STDERR_FILENO);\n\t\tif (dup2(pipes[1], STDOUT_FILENO) < 0)\n\t\t\texit(1);\n\n\t\tpath = on_path(\"criu\", NULL);\n\t\tif (!path)\n\t\t\texit(1);\n\n\t\texecv(path, args);\n\t\texit(1);\n\t} else {\n\t\tFILE *f;\n\t\tchar *tmp;\n\t\tint patch;\n\n\t\tclose(pipes[1]);\n\t\tif (wait_for_pid(pid) < 0) {\n\t\t\tclose(pipes[0]);\n\t\t\tSYSERROR(\"execing criu failed, is it installed?\");\n\t\t\treturn false;\n\t\t}\n\n\t\tf = fdopen(pipes[0], \"r\");\n\t\tif (!f) {\n\t\t\tclose(pipes[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\ttmp = malloc(1024);\n\t\tif (!tmp) {\n\t\t\tfclose(f);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fscanf(f, \"Version: %1023[^\\n]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '\\n')\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_VERSION) >= 0)\n\t\t\tgoto version_match;\n\n\t\tif (fscanf(f, \"GitID: v%1023[^-]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '-')\n\t\t\tgoto version_error;\n\n\t\tif (fscanf(f, \"%d\", &patch) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_GITID_VERSION) < 0)\n\t\t\tgoto version_error;\n\n\t\tif (patch < CRIU_GITID_PATCHLEVEL)\n\t\t\tgoto version_error;\n\nversion_match:\n\t\tfclose(f);\n\t\tif (!version)\n\t\t\tfree(tmp);\n\t\telse\n\t\t\t*version = tmp;\n\t\treturn true;\n\nversion_error:\n\t\tfclose(f);\n\t\tfree(tmp);\n\t\tERROR(\"must have criu \" CRIU_VERSION \" or greater to checkpoint/restore\");\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [
      "#define CRIU_GITID_PATCHLEVEL\t0",
      "#define CRIU_GITID_VERSION\t\"2.0\"",
      "#define CRIU_VERSION\t\t\"2.0\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"must have criu \" CRIU_VERSION \" or greater to checkpoint/restore\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "CRIU_GITID_VERSION"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%d\"",
            "&patch"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"GitID: v%1023[^-]s\"",
            "tmp"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "CRIU_VERSION"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"Version: %1023[^\\n]s\"",
            "tmp"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1024"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipes[0]"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "pipes[0]",
            "\"r\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"execing criu failed, is it installed?\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_pid",
          "args": [
            "pid"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "311-325",
          "snippet": "int lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_wait_for_pid_status(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "path",
            "args"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"criu\"",
            "NULL"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pipes[1]",
            "STDOUT_FILENO"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"fork() failed\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"pipe() failed\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipes"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\n#define CRIU_GITID_PATCHLEVEL\t0\n#define CRIU_GITID_VERSION\t\"2.0\"\n#define CRIU_VERSION\t\t\"2.0\"\n\nstatic bool criu_version_ok(char **version)\n{\n\tint pipes[2];\n\tpid_t pid;\n\n\tif (pipe(pipes) < 0) {\n\t\tSYSERROR(\"pipe() failed\");\n\t\treturn false;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tSYSERROR(\"fork() failed\");\n\t\treturn false;\n\t}\n\n\tif (pid == 0) {\n\t\tchar *args[] = { \"criu\", \"--version\", NULL };\n\t\tchar *path;\n\t\tclose(pipes[0]);\n\n\t\tclose(STDERR_FILENO);\n\t\tif (dup2(pipes[1], STDOUT_FILENO) < 0)\n\t\t\texit(1);\n\n\t\tpath = on_path(\"criu\", NULL);\n\t\tif (!path)\n\t\t\texit(1);\n\n\t\texecv(path, args);\n\t\texit(1);\n\t} else {\n\t\tFILE *f;\n\t\tchar *tmp;\n\t\tint patch;\n\n\t\tclose(pipes[1]);\n\t\tif (wait_for_pid(pid) < 0) {\n\t\t\tclose(pipes[0]);\n\t\t\tSYSERROR(\"execing criu failed, is it installed?\");\n\t\t\treturn false;\n\t\t}\n\n\t\tf = fdopen(pipes[0], \"r\");\n\t\tif (!f) {\n\t\t\tclose(pipes[0]);\n\t\t\treturn false;\n\t\t}\n\n\t\ttmp = malloc(1024);\n\t\tif (!tmp) {\n\t\t\tfclose(f);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fscanf(f, \"Version: %1023[^\\n]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '\\n')\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_VERSION) >= 0)\n\t\t\tgoto version_match;\n\n\t\tif (fscanf(f, \"GitID: v%1023[^-]s\", tmp) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (fgetc(f) != '-')\n\t\t\tgoto version_error;\n\n\t\tif (fscanf(f, \"%d\", &patch) != 1)\n\t\t\tgoto version_error;\n\n\t\tif (strcmp(tmp, CRIU_GITID_VERSION) < 0)\n\t\t\tgoto version_error;\n\n\t\tif (patch < CRIU_GITID_PATCHLEVEL)\n\t\t\tgoto version_error;\n\nversion_match:\n\t\tfclose(f);\n\t\tif (!version)\n\t\t\tfree(tmp);\n\t\telse\n\t\t\t*version = tmp;\n\t\treturn true;\n\nversion_error:\n\t\tfclose(f);\n\t\tfree(tmp);\n\t\tERROR(\"must have criu \" CRIU_VERSION \" or greater to checkpoint/restore\");\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "exec_criu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "129-606",
    "snippet": "static void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [
      "#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"",
      "#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "opts->pipefd"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"dup2 stderr failed\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "opts->pipefd",
            "STDERR_FILENO"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"dup2 stdout failed\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "opts->pipefd",
            "STDOUT_FILENO"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INFO",
          "args": [
            "\"execing: %s\"",
            "buf"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "sizeof(buf) - pos",
            "\"%s \"",
            "argv[i]"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "buf"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--veth-pair\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--external\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"unexpected network type %d\"",
            "n->type"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"macvlan[%s]:%s\"",
            "eth",
            "n->link"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"no host interface for macvlan %s\"",
            "n->name"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "eth",
            "veth"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "eth",
            "veth",
            "n->link"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "eth",
            "sizeof(eth)",
            "\"eth%d\"",
            "netnr"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "eth",
            "n->name",
            "sizeof(eth)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "n->name"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->criu_version",
            "CRIU_EXTERNAL_NOT_VETH"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_for_each",
          "args": [
            "it",
            "&opts->c->lxc_conf->network"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "argv",
            "(argc + additional + 1) * sizeof(*argv)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "must_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgfsng.c",
          "lines": "116-124",
          "snippet": "static void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"log.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <grp.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"log.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <grp.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include \"config.h\"\n\nstatic void *must_realloc(void *orig, size_t sz)\n{\n\tvoid *ret;\n\n\tdo {\n\t\tret = realloc(orig, sz);\n\t} while (!ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_len",
          "args": [
            "&opts->c->lxc_conf->network"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "159-168",
          "snippet": "static inline size_t lxc_list_len(struct lxc_list *list)\n{\n\t size_t i = 0;\n\t struct lxc_list *iter;\n\t lxc_list_for_each(iter, list) {\n\t\ti++;\n\t }\n\n\t return i;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline size_t lxc_list_len(struct lxc_list *list)\n{\n\t size_t i = 0;\n\t struct lxc_list *iter;\n\t lxc_list_for_each(iter, list) {\n\t\ti++;\n\t }\n\n\t return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "buf"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--lsm-profile\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"selinux:%s\"",
            "lxc_conf->lsm_se_context"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"apparmor:%s\"",
            "lxc_conf->lsm_aa_profile"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "buf"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--ext-mount-map\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"sprintf'd too many bytes\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"console:%s\"",
            "opts->console_name"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "buf"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--inherit-fd\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"fd[%d]:%s\"",
            "opts->console_fd",
            "tty_info"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"lxc.console configured on source host but not target\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--restore-sibling\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--restore-detached\""
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->c->lxc_conf->rootfs.mount"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--root\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"restore\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--leave-running\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "ghost_limit"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--ghost-limit\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to print ghost limit %\"PRIu64",
            "opts->user->ghost_limit"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ghost_limit",
            "\"%\"PRIu64",
            "opts->user->ghost_limit"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--force-irmap\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->user->pageserver_port"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--port\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->user->pageserver_address"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--address\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--page-server\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--track-mem\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->user->predump_dir"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--prev-images-dir\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->tty_id"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--external\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"/dev/console:console\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--ext-mount-map\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "log"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--freeze-cgroup\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--skip-in-flight\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->criu_version",
            "CRIU_IN_FLIGHT_SUPPORT"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "log",
            "sizeof(log)",
            "\"/sys/fs/cgroup/freezer/%s\"",
            "freezer_relative"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed getting freezer path\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_cmd_get_cgroup_path",
          "args": [
            "opts->c->name",
            "opts->c->config_path",
            "\"freezer\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_cgroup_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "444-472",
          "snippet": "char *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nchar *lxc_cmd_get_cgroup_path(const char *name, const char *lxcpath,\n\tconst char *subsystem)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = {\n\t\t\t.cmd = LXC_CMD_GET_CGROUP,\n\t\t\t.datalen = strlen(subsystem)+1,\n\t\t\t.data = subsystem,\n\t\t},\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn NULL;\n\t}\n\n\tif (cmd.rsp.ret < 0 || cmd.rsp.datalen < 0) {\n\t\tERROR(\"Command %s failed for container \\\"%s\\\": %s.\",\n\t\t      lxc_cmd_str(cmd.req.cmd), name, strerror(-cmd.rsp.ret));\n\t\treturn NULL;\n\t}\n\n\treturn cmd.rsp.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "pid"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"-t\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pid",
            "\"%d\"",
            "opts->c->init_pid(opts->c)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opts->c->init_pid",
          "args": [
            "opts->c"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"pre-dump\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "mnts"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "arg"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--ext-mount-map\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf failed\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "mnts"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "arg",
            "sizeof(arg)",
            "fmt",
            "key",
            "val"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_mntopts",
          "args": [
            "mntent.mnt_opts",
            "&flags",
            "&mntdata"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "parse_mntopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1629-1666",
          "snippet": "int parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint parse_mntopts(const char *mntopts, unsigned long *mntflags,\n\t\t\t char **mntdata)\n{\n\tchar *s, *data;\n\tchar *p, *saveptr = NULL;\n\n\t*mntdata = NULL;\n\t*mntflags = 0L;\n\n\tif (!mntopts)\n\t\treturn 0;\n\n\ts = strdup(mntopts);\n\tif (!s) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\treturn -1;\n\t}\n\n\tdata = malloc(strlen(s) + 1);\n\tif (!data) {\n\t\tSYSERROR(\"failed to allocate memory\");\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\t*data = 0;\n\n\tfor (p = strtok_r(s, \",\", &saveptr); p != NULL;\n\t     p = strtok_r(NULL, \",\", &saveptr))\n\t\tparse_mntopt(p, mntflags, &data);\n\n\tif (*data)\n\t\t*mntdata = data;\n\telse\n\t\tfree(data);\n\tfree(s);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getmntent_r",
          "args": [
            "mnts",
            "&mntent",
            "buf",
            "sizeof(buf)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "getmntent_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "76-132",
          "snippet": "struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstruct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_anonymous_mount_file",
          "args": [
            "&opts->c->lxc_conf->mount_list"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "make_anonymous_mount_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "2011-2049",
          "snippet": "FILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MFD_CLOEXEC 0x0001U"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\n#define MFD_CLOEXEC 0x0001U\n\nFILE *make_anonymous_mount_file(struct lxc_list *mount)\n{\n\tint ret;\n\tchar *mount_entry;\n\tstruct lxc_list *iterator;\n\tFILE *file;\n\tint fd = -1;\n\n\tfd = memfd_create(\"lxc_mount_file\", MFD_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOSYS)\n\t\t\treturn NULL;\n\t\tfile = tmpfile();\n\t} else {\n\t\tfile = fdopen(fd, \"r+\");\n\t}\n\n\tif (!file) {\n\t\tint saved_errno = errno;\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tERROR(\"Could not create mount entry file: %s.\", strerror(saved_errno));\n\t\treturn NULL;\n\t}\n\n\tlxc_list_for_each(iterator, mount) {\n\t\tmount_entry = iterator->elem;\n\t\tret = fprintf(file, \"%s\\n\", mount_entry);\n\t\tif (ret < strlen(mount_entry))\n\t\t\tWARN(\"Could not write mount entry to anonymous mount file.\");\n\t}\n\n\tif (fseek(file, 0, SEEK_SET) < 0) {\n\t\tfclose(file);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->user->action_script"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--action-script\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"-vvvvvv\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "buf"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--cgroup-root\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"sprintf of cgroup root arg failed\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s:%s\"",
            "fullname",
            "path"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to join controllers\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_string_join",
          "args": [
            "\",\"",
            "(const char **) controllers",
            "false"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_string_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "664-688",
          "snippet": "char *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *lxc_string_join(const char *sep, const char **parts, bool use_as_prefix)\n{\n\tchar *result;\n\tchar **p;\n\tsize_t sep_len = strlen(sep);\n\tsize_t result_len = use_as_prefix * sep_len;\n\n\t/* calculate new string length */\n\tfor (p = (char **)parts; *p; p++)\n\t\tresult_len += (p > (char **)parts) * sep_len + strlen(*p);\n\n\tresult = calloc(result_len + 1, 1);\n\tif (!result)\n\t\treturn NULL;\n\n\tif (use_as_prefix)\n\t\tstrcpy(result, sep);\n\tfor (p = (char **)parts; *p; p++) {\n\t\tif (p > (char **)parts)\n\t\t\tstrcat(result, sep);\n\t\tstrcat(result, *p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to deslashify %s\"",
            "path"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_deslashify",
          "args": [
            "&path"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_deslashify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "725-766",
          "snippet": "bool lxc_deslashify(char **path)\n{\n\tbool ret = false;\n\tchar *p;\n\tchar **parts = NULL;\n\tsize_t n, len;\n\n\tparts = lxc_normalize_path(*path);\n\tif (!parts)\n\t\treturn false;\n\n\t/* We'll end up here if path == \"///\" or path == \"\". */\n\tif (!*parts) {\n\t\tlen = strlen(*path);\n\t\tif (!len) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\tn = strcspn(*path, \"/\");\n\t\tif (n == len) {\n\t\t\tp = strdup(\"/\");\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\tfree(*path);\n\t\t\t*path = p;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tp = lxc_string_join(\"/\", (const char **)parts, **path == '/');\n\tif (!p)\n\t\tgoto out;\n\n\tfree(*path);\n\t*path = p;\n\tret = true;\n\nout:\n\tlxc_free_array((void **)parts, free);\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nbool lxc_deslashify(char **path)\n{\n\tbool ret = false;\n\tchar *p;\n\tchar **parts = NULL;\n\tsize_t n, len;\n\n\tparts = lxc_normalize_path(*path);\n\tif (!parts)\n\t\treturn false;\n\n\t/* We'll end up here if path == \"///\" or path == \"\". */\n\tif (!*parts) {\n\t\tlen = strlen(*path);\n\t\tif (!len) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t\tn = strcspn(*path, \"/\");\n\t\tif (n == len) {\n\t\t\tp = strdup(\"/\");\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\tfree(*path);\n\t\t\t*path = p;\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tp = lxc_string_join(\"/\", (const char **)parts, **path == '/');\n\tif (!p)\n\t\tgoto out;\n\n\tfree(*path);\n\t*path = p;\n\tret = true;\n\nout:\n\tlxc_free_array((void **)parts, free);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"strdup failed\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to get cgroup path for %s\"",
            "controllers[0]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_cgroup",
          "args": [
            "opts->handler",
            "controllers[0]"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "108-113",
          "snippet": "const char *cgroup_get_cgroup(struct lxc_handler *handler, const char *subsystem)\n{\n\tif (ops)\n\t\treturn ops->get_cgroup(handler->cgroup_data, subsystem);\n\treturn NULL;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nconst char *cgroup_get_cgroup(struct lxc_handler *handler, const char *subsystem)\n{\n\tif (ops)\n\t\treturn ops->get_cgroup(handler->cgroup_data, subsystem);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to get cgroup path for %s\"",
            "controllers[0]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"pre-dump\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to get hierarchy %d\"",
            "i"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_hierarchies",
          "args": [
            "i",
            "&controllers"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_hierarchies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "130-136",
          "snippet": "bool cgroup_get_hierarchies(int n, char ***out)\n{\n\tif (!ops)\n\t\treturn false;\n\n\treturn ops->get_hierarchies(n, out);\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nbool cgroup_get_hierarchies(int n, char ***out)\n{\n\tif (!ops)\n\t\treturn false;\n\n\treturn ops->get_hierarchies(n, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_num_hierarchies",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_num_hierarchies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/cgroups/cgroup.c",
          "lines": "122-128",
          "snippet": "int cgroup_num_hierarchies(void)\n{\n\tif (!ops)\n\t\treturn -1;\n\n\treturn ops->num_hierarchies();\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"log.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_ops *ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct cgroup_ops *ops = NULL;\n\nint cgroup_num_hierarchies(void)\n{\n\tif (!ops)\n\t\treturn -1;\n\n\treturn ops->num_hierarchies();\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "log"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"-o\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->user->directory"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"-D\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"tracefs\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--enable-fs\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"hugetlbfs\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--enable-fs\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--enable-external-masters\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--enable-external-sharing\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"auto\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--ext-mount-map\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--manage-cgroups=full\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--link-remap\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--file-locks\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "\"--tcp-established\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_ARG",
          "args": [
            "opts->action"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Couldn't find criu binary\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_path",
          "args": [
            "\"criu\"",
            "NULL"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "on_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1202-1238",
          "snippet": "char *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool btrfs_try_remove_subvol(const char *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nextern bool btrfs_try_remove_subvol(const char *path);\n\nchar *on_path(char *cmd, const char *rootfs) {\n\tchar *path = NULL;\n\tchar *entry = NULL;\n\tchar *saveptr = NULL;\n\tchar cmdpath[MAXPATHLEN];\n\tint ret;\n\n\tpath = getenv(\"PATH\");\n\tif (!path)\n\t\treturn NULL;\n\n\tpath = strdup(path);\n\tif (!path)\n\t\treturn NULL;\n\n\tentry = strtok_r(path, \":\", &saveptr);\n\twhile (entry) {\n\t\tif (rootfs)\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s/%s\", rootfs, entry, cmd);\n\t\telse\n\t\t\tret = snprintf(cmdpath, MAXPATHLEN, \"%s/%s\", entry, cmd);\n\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\tgoto next_loop;\n\n\t\tif (access(cmdpath, X_OK) == 0) {\n\t\t\tfree(path);\n\t\t\treturn strdup(cmdpath);\n\t\t}\n\nnext_loop:\n\t\tentry = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tfree(path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "argv",
            "0",
            "static_args * sizeof(*argv)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "static_args * sizeof(*argv)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"logfile name too long\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "log",
            "PATH_MAX",
            "\"%s/%s.log\"",
            "opts->user->directory",
            "opts->action"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_tty_major_minor",
          "args": [
            "opts->user->directory",
            "tty_info",
            "sizeof(tty_info)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "load_tty_major_minor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
          "lines": "94-127",
          "snippet": "static int load_tty_major_minor(char *directory, char *output, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\t/* This means we're coming from a liblxc which didn't export\n\t\t * the tty info. In this case they had to have lxc.console =\n\t\t * none, so there's no problem restoring.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\n\t\tSYSERROR(\"couldn't open %s\", path);\n\t\treturn -1;\n\t}\n\n\tif (!fgets(output, len, f)) {\n\t\tfclose(f);\n\t\tSYSERROR(\"couldn't read %s\", path);\n\t\treturn -1;\n\t}\n\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include \"utils.h\"",
            "#include \"network.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"criu.h\"",
            "#include \"commands.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"bdev.h\"",
            "#include \"config.h\"",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/mount.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sched.h>",
            "#include <linux/limits.h>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic int load_tty_major_minor(char *directory, char *output, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\t/* This means we're coming from a liblxc which didn't export\n\t\t * the tty info. In this case they had to have lxc.console =\n\t\t * none, so there's no problem restoring.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\n\t\tSYSERROR(\"couldn't open %s\", path);\n\t\treturn -1;\n\t}\n\n\tif (!fgets(output, len, f)) {\n\t\tfclose(f);\n\t\tSYSERROR(\"couldn't read %s\", path);\n\t\treturn -1;\n\t}\n\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"restore\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"pre-dump\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opts->action",
            "\"dump\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"failed to escape cgroups\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_escape",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\n#define CRIU_EXTERNAL_NOT_VETH\t\"2.8\"\n#define CRIU_IN_FLIGHT_SUPPORT\t\"2.4\"\n\nstatic void exec_criu(struct criu_opts *opts)\n{\n\tchar **argv, log[PATH_MAX];\n\tint static_args = 23, argc = 0, i, ret;\n\tint netnr = 0;\n\tstruct lxc_list *it;\n\tFILE *mnts;\n\tstruct mntent mntent;\n\n\tchar buf[4096], tty_info[32];\n\tsize_t pos;\n\n\t/* If we are currently in a cgroup /foo/bar, and the container is in a\n\t * cgroup /lxc/foo, lxcfs will give us an ENOENT if some task in the\n\t * container has an open fd that points to one of the cgroup files\n\t * (systemd always opens its \"root\" cgroup). So, let's escape to the\n\t * /actual/ root cgroup so that lxcfs thinks criu has enough rights to\n\t * see all cgroups.\n\t */\n\tif (!cgroup_escape()) {\n\t\tERROR(\"failed to escape cgroups\");\n\t\treturn;\n\t}\n\n\t/* The command line always looks like:\n\t * criu $(action) --tcp-established --file-locks --link-remap \\\n\t * --manage-cgroups=full --action-script foo.sh -D $(directory) \\\n\t * -o $(directory)/$(action).log --ext-mount-map auto\n\t * --enable-external-sharing --enable-external-masters\n\t * --enable-fs hugetlbfs --enable-fs tracefs --ext-mount-map console:/dev/pts/n\n\t * +1 for final NULL */\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\t/* -t pid --freeze-cgroup /lxc/ct */\n\t\tstatic_args += 4;\n\n\t\t/* --prev-images-dir <path-to-directory-A-relative-to-B> */\n\t\tif (opts->user->predump_dir)\n\t\t\tstatic_args += 2;\n\n\t\t/* --page-server --address <address> --port <port> */\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port)\n\t\t\tstatic_args += 5;\n\n\t\t/* --leave-running (only for final dump) */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tstatic_args++;\n\n\t\t/* --external tty[88,4] */\n\t\tif (opts->tty_id[0])\n\t\t\tstatic_args += 2;\n\n\t\t/* --force-irmap */\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tstatic_args++;\n\n\t\t/* --ghost-limit 1024 */\n\t\tif (opts->user->ghost_limit)\n\t\t\tstatic_args += 2;\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\t/* --root $(lxc_mount_point) --restore-detached\n\t\t * --restore-sibling\n\t\t * --lsm-profile apparmor:whatever\n\t\t */\n\t\tstatic_args += 6;\n\n\t\ttty_info[0] = 0;\n\t\tif (load_tty_major_minor(opts->user->directory, tty_info, sizeof(tty_info)))\n\t\t\treturn;\n\n\t\t/* --inherit-fd fd[%d]:tty[%s] */\n\t\tif (tty_info[0])\n\t\t\tstatic_args += 2;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (cgroup_num_hierarchies() > 0)\n\t\tstatic_args += 2 * cgroup_num_hierarchies();\n\n\tif (opts->user->verbose)\n\t\tstatic_args++;\n\n\tif (opts->user->action_script)\n\t\tstatic_args += 2;\n\n\tstatic_args += 2 * lxc_list_len(&opts->c->lxc_conf->mount_list);\n\n\tret = snprintf(log, PATH_MAX, \"%s/%s.log\", opts->user->directory, opts->action);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"logfile name too long\");\n\t\treturn;\n\t}\n\n\targv = malloc(static_args * sizeof(*argv));\n\tif (!argv)\n\t\treturn;\n\n\tmemset(argv, 0, static_args * sizeof(*argv));\n\n#define DECLARE_ARG(arg) \t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (arg == NULL) {\t\t\t\t\\\n\t\t\tERROR(\"Got NULL argument for criu\");\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t\targv[argc++] = strdup(arg);\t\t\t\\\n\t\tif (!argv[argc-1])\t\t\t\t\\\n\t\t\tgoto err;\t\t\t\t\\\n\t} while (0)\n\n\targv[argc++] = on_path(\"criu\", NULL);\n\tif (!argv[argc-1]) {\n\t\tERROR(\"Couldn't find criu binary\");\n\t\tgoto err;\n\t}\n\n\tDECLARE_ARG(opts->action);\n\tDECLARE_ARG(\"--tcp-established\");\n\tDECLARE_ARG(\"--file-locks\");\n\tDECLARE_ARG(\"--link-remap\");\n\tDECLARE_ARG(\"--manage-cgroups=full\");\n\tDECLARE_ARG(\"--ext-mount-map\");\n\tDECLARE_ARG(\"auto\");\n\tDECLARE_ARG(\"--enable-external-sharing\");\n\tDECLARE_ARG(\"--enable-external-masters\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"hugetlbfs\");\n\tDECLARE_ARG(\"--enable-fs\");\n\tDECLARE_ARG(\"tracefs\");\n\tDECLARE_ARG(\"-D\");\n\tDECLARE_ARG(opts->user->directory);\n\tDECLARE_ARG(\"-o\");\n\tDECLARE_ARG(log);\n\n\tfor (i = 0; i < cgroup_num_hierarchies(); i++) {\n\t\tchar **controllers = NULL, *fullname;\n\t\tchar *path;\n\n\t\tif (!cgroup_get_hierarchies(i, &controllers)) {\n\t\t\tERROR(\"failed to get hierarchy %d\", i);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if we are in a dump, we have to ask the monitor process what\n\t\t * the right cgroup is. if this is a restore, we can just use\n\t\t * the handler the restore task created.\n\t\t */\n\t\tif (!strcmp(opts->action, \"dump\") || !strcmp(opts->action, \"pre-dump\")) {\n\t\t\tpath = lxc_cmd_get_cgroup_path(opts->c->name, opts->c->config_path, controllers[0]);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *p;\n\n\t\t\tp = cgroup_get_cgroup(opts->handler, controllers[0]);\n\t\t\tif (!p) {\n\t\t\t\tERROR(\"failed to get cgroup path for %s\", controllers[0]);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpath = strdup(p);\n\t\t\tif (!path) {\n\t\t\t\tERROR(\"strdup failed\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!lxc_deslashify(&path)) {\n\t\t\tERROR(\"failed to deslashify %s\", path);\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfullname = lxc_string_join(\",\", (const char **) controllers, false);\n\t\tif (!fullname) {\n\t\t\tERROR(\"failed to join controllers\");\n\t\t\tfree(path);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sprintf(buf, \"%s:%s\", fullname, path);\n\t\tfree(path);\n\t\tfree(fullname);\n\t\tif (ret < 0 || ret >= sizeof(buf)) {\n\t\t\tERROR(\"sprintf of cgroup root arg failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--cgroup-root\");\n\t\tDECLARE_ARG(buf);\n\t}\n\n\tif (opts->user->verbose)\n\t\tDECLARE_ARG(\"-vvvvvv\");\n\n\tif (opts->user->action_script) {\n\t\tDECLARE_ARG(\"--action-script\");\n\t\tDECLARE_ARG(opts->user->action_script);\n\t}\n\n\tmnts = make_anonymous_mount_file(&opts->c->lxc_conf->mount_list);\n\tif (!mnts)\n\t\tgoto err;\n\n\twhile (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {\n\t\tchar *fmt, *key, *val, *mntdata;\n\t\tchar arg[2 * PATH_MAX + 2];\n\t\tunsigned long flags;\n\n\t\tif (parse_mntopts(mntent.mnt_opts, &flags, &mntdata) < 0)\n\t\t\tgoto err;\n\n\t\tfree(mntdata);\n\n\t\t/* only add --ext-mount-map for actual bind mounts */\n\t\tif (!(flags & MS_BIND))\n\t\t\tcontinue;\n\n\t\tif (strcmp(opts->action, \"dump\") == 0) {\n\t\t\tfmt = \"/%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_dir;\n\t\t} else {\n\t\t\tfmt = \"%s:%s\";\n\t\t\tkey = mntent.mnt_dir;\n\t\t\tval = mntent.mnt_fsname;\n\t\t}\n\n\t\tret = snprintf(arg, sizeof(arg), fmt, key, val);\n\t\tif (ret < 0 || ret >= sizeof(arg)) {\n\t\t\tfclose(mnts);\n\t\t\tERROR(\"snprintf failed\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\tDECLARE_ARG(arg);\n\t}\n\tfclose(mnts);\n\n\tif (strcmp(opts->action, \"dump\") == 0 || strcmp(opts->action, \"pre-dump\") == 0) {\n\t\tchar pid[32], *freezer_relative;\n\n\t\tif (sprintf(pid, \"%d\", opts->c->init_pid(opts->c)) < 0)\n\t\t\tgoto err;\n\n\t\tDECLARE_ARG(\"-t\");\n\t\tDECLARE_ARG(pid);\n\n\t\tfreezer_relative = lxc_cmd_get_cgroup_path(opts->c->name,\n\t\t\t\t\t\t\t   opts->c->config_path,\n\t\t\t\t\t\t\t   \"freezer\");\n\t\tif (!freezer_relative) {\n\t\t\tERROR(\"failed getting freezer path\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snprintf(log, sizeof(log), \"/sys/fs/cgroup/freezer/%s\", freezer_relative);\n\t\tif (ret < 0 || ret >= sizeof(log))\n\t\t\tgoto err;\n\n\t\tif (!opts->user->disable_skip_in_flight &&\n\t\t\t\tstrcmp(opts->criu_version, CRIU_IN_FLIGHT_SUPPORT) >= 0)\n\t\t\tDECLARE_ARG(\"--skip-in-flight\");\n\n\t\tDECLARE_ARG(\"--freeze-cgroup\");\n\t\tDECLARE_ARG(log);\n\n\t\tif (opts->tty_id[0]) {\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(\"/dev/console:console\");\n\n\t\t\tDECLARE_ARG(\"--external\");\n\t\t\tDECLARE_ARG(opts->tty_id);\n\t\t}\n\n\t\tif (opts->user->predump_dir) {\n\t\t\tDECLARE_ARG(\"--prev-images-dir\");\n\t\t\tDECLARE_ARG(opts->user->predump_dir);\n\t\t\tDECLARE_ARG(\"--track-mem\");\n\t\t}\n\n\t\tif (opts->user->pageserver_address && opts->user->pageserver_port) {\n\t\t\tDECLARE_ARG(\"--page-server\");\n\t\t\tDECLARE_ARG(\"--address\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_address);\n\t\t\tDECLARE_ARG(\"--port\");\n\t\t\tDECLARE_ARG(opts->user->pageserver_port);\n\t\t}\n\n\t\tif (!opts->user->preserves_inodes)\n\t\t\tDECLARE_ARG(\"--force-irmap\");\n\n\t\tif (opts->user->ghost_limit) {\n\t\t\tchar ghost_limit[32];\n\n\t\t\tret = sprintf(ghost_limit, \"%\"PRIu64, opts->user->ghost_limit);\n\t\t\tif (ret < 0 || ret >= sizeof(ghost_limit)) {\n\t\t\t\tERROR(\"failed to print ghost limit %\"PRIu64, opts->user->ghost_limit);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tDECLARE_ARG(\"--ghost-limit\");\n\t\t\tDECLARE_ARG(ghost_limit);\n\t\t}\n\n\t\t/* only for final dump */\n\t\tif (strcmp(opts->action, \"dump\") == 0 && !opts->user->stop)\n\t\t\tDECLARE_ARG(\"--leave-running\");\n\t} else if (strcmp(opts->action, \"restore\") == 0) {\n\t\tvoid *m;\n\t\tint additional;\n\t\tstruct lxc_conf *lxc_conf = opts->c->lxc_conf;\n\n\t\tDECLARE_ARG(\"--root\");\n\t\tDECLARE_ARG(opts->c->lxc_conf->rootfs.mount);\n\t\tDECLARE_ARG(\"--restore-detached\");\n\t\tDECLARE_ARG(\"--restore-sibling\");\n\n\t\tif (tty_info[0]) {\n\t\t\tif (opts->console_fd < 0) {\n\t\t\t\tERROR(\"lxc.console configured on source host but not target\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = snprintf(buf, sizeof(buf), \"fd[%d]:%s\", opts->console_fd, tty_info);\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--inherit-fd\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\t\tif (opts->console_name) {\n\t\t\tif (snprintf(buf, sizeof(buf), \"console:%s\", opts->console_name) < 0) {\n\t\t\t\tSYSERROR(\"sprintf'd too many bytes\");\n\t\t\t}\n\t\t\tDECLARE_ARG(\"--ext-mount-map\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tif (lxc_conf->lsm_aa_profile || lxc_conf->lsm_se_context) {\n\n\t\t\tif (lxc_conf->lsm_aa_profile)\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"apparmor:%s\", lxc_conf->lsm_aa_profile);\n\t\t\telse\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"selinux:%s\", lxc_conf->lsm_se_context);\n\n\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\tgoto err;\n\n\t\t\tDECLARE_ARG(\"--lsm-profile\");\n\t\t\tDECLARE_ARG(buf);\n\t\t}\n\n\t\tadditional = lxc_list_len(&opts->c->lxc_conf->network) * 2;\n\n\t\tm = realloc(argv, (argc + additional + 1) * sizeof(*argv));\n\t\tif (!m)\n\t\t\tgoto err;\n\t\targv = m;\n\n\t\tlxc_list_for_each(it, &opts->c->lxc_conf->network) {\n\t\t\tchar eth[128], *veth;\n\t\t\tchar *fmt;\n\t\t\tstruct lxc_netdev *n = it->elem;\n\t\t\tbool external_not_veth;\n\n\t\t\tif (strcmp(opts->criu_version, CRIU_EXTERNAL_NOT_VETH) >= 0) {\n\t\t\t\t/* Since criu version 2.8 the usage of --veth-pair\n\t\t\t\t * has been deprecated:\n\t\t\t\t * git tag --contains f2037e6d3445fc400\n\t\t\t\t * v2.8 */\n\t\t\t\texternal_not_veth = true;\n\t\t\t} else {\n\t\t\t\texternal_not_veth = false;\n\t\t\t}\n\n\t\t\tif (n->name) {\n\t\t\t\tif (strlen(n->name) >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t\tstrncpy(eth, n->name, sizeof(eth));\n\t\t\t} else {\n\t\t\t\tret = snprintf(eth, sizeof(eth), \"eth%d\", netnr);\n\t\t\t\tif (ret < 0 || ret >= sizeof(eth))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (n->type) {\n\t\t\tcase LXC_NET_VETH:\n\t\t\t\tveth = n->priv.veth_attr.pair;\n\n\t\t\t\tif (n->link) {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s@%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s@%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth, n->link);\n\t\t\t\t} else {\n\t\t\t\t\tif (external_not_veth)\n\t\t\t\t\t\tfmt = \"veth[%s]:%s\";\n\t\t\t\t\telse\n\t\t\t\t\t\tfmt = \"%s=%s\";\n\n\t\t\t\t\tret = snprintf(buf, sizeof(buf), fmt, eth, veth);\n\t\t\t\t}\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_MACVLAN:\n\t\t\t\tif (!n->link) {\n\t\t\t\t\tERROR(\"no host interface for macvlan %s\", n->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tret = snprintf(buf, sizeof(buf), \"macvlan[%s]:%s\", eth, n->link);\n\t\t\t\tif (ret < 0 || ret >= sizeof(buf))\n\t\t\t\t\tgoto err;\n\t\t\t\tbreak;\n\t\t\tcase LXC_NET_NONE:\n\t\t\tcase LXC_NET_EMPTY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we have screened for this earlier... */\n\t\t\t\tERROR(\"unexpected network type %d\", n->type);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (external_not_veth)\n\t\t\t\tDECLARE_ARG(\"--external\");\n\t\t\telse\n\t\t\t\tDECLARE_ARG(\"--veth-pair\");\n\t\t\tDECLARE_ARG(buf);\n\t\t\tnetnr++;\n\t\t}\n\n\t}\n\n\targv[argc] = NULL;\n\n\tbuf[0] = 0;\n\tpos = 0;\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tret = snprintf(buf + pos, sizeof(buf) - pos, \"%s \", argv[i]);\n\t\tif (ret < 0 || ret >= sizeof(buf) - pos)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpos += ret;\n\t}\n\n\tINFO(\"execing: %s\", buf);\n\n\t/* before criu inits its log, it sometimes prints things to stdout/err;\n\t * let's be sure we capture that.\n\t */\n\tif (dup2(opts->pipefd, STDOUT_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stdout failed\");\n\t\tgoto err;\n\t}\n\n\tif (dup2(opts->pipefd, STDERR_FILENO) < 0) {\n\t\tSYSERROR(\"dup2 stderr failed\");\n\t\tgoto err;\n\t}\n\n\tclose(opts->pipefd);\n\n#undef DECLARE_ARG\n\texecv(argv[0], argv);\nerr:\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}"
  },
  {
    "function_name": "load_tty_major_minor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/criu.c",
    "lines": "94-127",
    "snippet": "static int load_tty_major_minor(char *directory, char *output, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\t/* This means we're coming from a liblxc which didn't export\n\t\t * the tty info. In this case they had to have lxc.console =\n\t\t * none, so there's no problem restoring.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\n\t\tSYSERROR(\"couldn't open %s\", path);\n\t\treturn -1;\n\t}\n\n\tif (!fgets(output, len, f)) {\n\t\tfclose(f);\n\t\tSYSERROR(\"couldn't read %s\", path);\n\t\treturn -1;\n\t}\n\n\tfclose(f);\n\treturn 0;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <../include/lxcmntent.h>",
      "#include \"utils.h\"",
      "#include \"network.h\"",
      "#include \"lxclock.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"criu.h\"",
      "#include \"commands.h\"",
      "#include \"conf.h\"",
      "#include \"cgroup.h\"",
      "#include \"bdev.h\"",
      "#include \"config.h\"",
      "#include <unistd.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/mount.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sched.h>",
      "#include <linux/limits.h>",
      "#include <inttypes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"couldn't read %s\"",
            "path"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "output",
            "len",
            "f"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"couldn't open %s\"",
            "path"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"snprintf'd too many chacters: %d\"",
            "ret"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/tty.info\"",
            "directory"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include \"utils.h\"\n#include \"network.h\"\n#include \"lxclock.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"criu.h\"\n#include \"commands.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"bdev.h\"\n#include \"config.h\"\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sched.h>\n#include <linux/limits.h>\n#include <inttypes.h>\n\nstatic int load_tty_major_minor(char *directory, char *output, int len)\n{\n\tFILE *f;\n\tchar path[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/tty.info\", directory);\n\tif (ret < 0 || ret >= sizeof(path)) {\n\t\tERROR(\"snprintf'd too many chacters: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\t/* This means we're coming from a liblxc which didn't export\n\t\t * the tty info. In this case they had to have lxc.console =\n\t\t * none, so there's no problem restoring.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\n\t\tSYSERROR(\"couldn't open %s\", path);\n\t\treturn -1;\n\t}\n\n\tif (!fgets(output, len, f)) {\n\t\tfclose(f);\n\t\tSYSERROR(\"couldn't read %s\", path);\n\t\treturn -1;\n\t}\n\n\tfclose(f);\n\treturn 0;\n}"
  }
]