[
  {
    "function_name": "lxc_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/execute.c",
    "lines": "113-126",
    "snippet": "int lxc_execute(const char *name, char *const argv[], int quiet,\n\t\tstruct lxc_conf *conf, const char *lxcpath, bool backgrounded)\n{\n\tstruct execute_args args = {\n\t\t.argv = argv,\n\t\t.quiet = quiet\n\t};\n\n\tif (lxc_check_inherited(conf, false, -1))\n\t\treturn -1;\n\n\tconf->is_execute = 1;\n\treturn __lxc_start(name, conf, &execute_start_ops, &args, lxcpath, backgrounded);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"start.h\"",
      "#include \"log.h\"",
      "#include \"conf.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_operations execute_start_ops = {\n\t.start = execute_start,\n\t.post_start = execute_post_start\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lxc_start",
          "args": [
            "name",
            "conf",
            "&execute_start_ops",
            "&args",
            "lxcpath",
            "backgrounded"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__lxc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "1320-1447",
          "snippet": "int __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);",
            "static int lxc_rmdir_onedev_wrapper(void *data);",
            "static void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\nstatic int lxc_rmdir_onedev_wrapper(void *data);\nstatic void lxc_destroy_container_on_signal(struct lxc_handler *handler,\n\t\t\t\t\t    const char *name);\n\nint __lxc_start(const char *name, struct lxc_conf *conf,\n\t\tstruct lxc_operations* ops, void *data, const char *lxcpath,\n\t\tbool backgrounded)\n{\n\tstruct lxc_handler *handler;\n\tint err = -1;\n\tint status;\n\tbool removed_all_netdevs = true;\n\n\thandler = lxc_init(name, conf, lxcpath);\n\tif (!handler) {\n\t\tERROR(\"Failed to initialize container \\\"%s\\\".\", name);\n\t\treturn -1;\n\t}\n\thandler->ops = ops;\n\thandler->data = data;\n\thandler->backgrounded = backgrounded;\n\thandler->netnsfd = -1;\n\n\tif (must_drop_cap_sys_boot(handler->conf)) {\n\t\t#if HAVE_LIBCAP\n\t\tDEBUG(\"Dropping CAP_SYS_BOOT capability.\");\n\t\t#else\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT capability as capabilities aren't supported.\");\n\t\t#endif\n\t} else {\n\t\tDEBUG(\"Not dropping CAP_SYS_BOOT or watching utmp.\");\n\t\thandler->conf->need_utmp_watch = 0;\n\t}\n\n\tif (!attach_block_device(handler->conf)) {\n\t\tERROR(\"Failed to attach block device.\");\n\t\tgoto out_fini_nonet;\n\t}\n\n\tif (geteuid() == 0 && !lxc_list_empty(&conf->id_map)) {\n\t\t/* If the backing store is a device, mount it here and now. */\n\t\tif (rootfs_is_blockdev(conf)) {\n\t\t\tif (unshare(CLONE_NEWNS) < 0) {\n\t\t\t\tERROR(\"Failed to unshare CLONE_NEWNS.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Unshared CLONE_NEWNS.\");\n\n\t\t\tremount_all_slave();\n\t\t\tif (do_rootfs_setup(conf, name, lxcpath) < 0) {\n\t\t\t\tERROR(\"Error setting up rootfs mount as root before spawn.\");\n\t\t\t\tgoto out_fini_nonet;\n\t\t\t}\n\t\t\tINFO(\"Set up container rootfs as host root.\");\n\t\t}\n\t}\n\n\terr = lxc_spawn(handler);\n\tif (err) {\n\t\tERROR(\"Failed to spawn container \\\"%s\\\".\", name);\n\t\tgoto out_detach_blockdev;\n\t}\n\n\thandler->conf->reboot = 0;\n\n\terr = lxc_poll(name, handler);\n\tif (err) {\n\t\tERROR(\"LXC mainloop exited with error: %d.\", err);\n\t\tif (handler->netnsfd >= 0) {\n\t\t\tclose(handler->netnsfd);\n\t\t\thandler->netnsfd = -1;\n\t\t}\n\t\tgoto out_abort;\n\t}\n\n\twhile (waitpid(handler->pid, &status, 0) < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t/* If the child process exited but was not signaled, it didn't call\n\t * reboot. This should mean it was an lxc-execute which simply exited.\n\t * In any case, treat it as a 'halt'.\n\t */\n\tif (WIFSIGNALED(status)) {\n\t\tswitch(WTERMSIG(status)) {\n\t\tcase SIGINT: /* halt */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is halting.\", name);\n\t\t\tbreak;\n\t\tcase SIGHUP: /* reboot */\n\t\t\tDEBUG(\"Container \\\"%s\\\" is rebooting.\", name);\n\t\t\thandler->conf->reboot = 1;\n\t\t\tbreak;\n\t\tcase SIGSYS: /* seccomp */\n\t\t\tDEBUG(\"Container \\\"%s\\\" violated its seccomp policy.\", name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG(\"Unknown exit status for container \\\"%s\\\" init %d.\", name, WTERMSIG(status));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDEBUG(\"Pushing physical nics back to host namespace\");\n\tlxc_restore_phys_nics_to_netns(handler->netnsfd, handler->conf);\n\n\tDEBUG(\"Tearing down virtual network devices used by container \\\"%s\\\".\", name);\n\tremoved_all_netdevs = lxc_delete_network(handler);\n\n\tif (handler->pinfd >= 0) {\n\t\tclose(handler->pinfd);\n\t\thandler->pinfd = -1;\n\t}\n\n\tlxc_monitor_send_exit_code(name, status, handler->lxcpath);\n\terr =  lxc_error_set_and_log(handler->pid, status);\nout_fini:\n\tif (!removed_all_netdevs) {\n\t\tDEBUG(\"Failed tearing down network devices used by container. Trying again!\");\n\t\tremoved_all_netdevs = lxc_delete_network(handler);\n\t\tif (!removed_all_netdevs)\n\t\t\tDEBUG(\"Failed tearing down network devices used by container. Not trying again!\");\n\t}\n\nout_detach_blockdev:\n\tdetach_block_device(handler->conf);\n\nout_fini_nonet:\n\tlxc_fini(name, handler);\n\treturn err;\n\nout_abort:\n\tlxc_abort(name, handler);\n\tgoto out_fini;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_check_inherited",
          "args": [
            "conf",
            "false",
            "-1"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_check_inherited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/start.c",
          "lines": "198-257",
          "snippet": "int lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"sync.h\"",
            "#include \"start.h\"",
            "#include \"namespace.h\"",
            "#include \"monitor.h\"",
            "#include \"mainloop.h\"",
            "#include \"lxcutmp.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"console.h\"",
            "#include \"conf.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <sys/capability.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <alloca.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool do_destroy_container(struct lxc_conf *conf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"sync.h\"\n#include \"start.h\"\n#include \"namespace.h\"\n#include \"monitor.h\"\n#include \"mainloop.h\"\n#include \"lxcutmp.h\"\n#include \"lxcseccomp.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"console.h\"\n#include \"conf.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <sys/capability.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <poll.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <alloca.h>\n#include \"config.h\"\n\nstatic bool do_destroy_container(struct lxc_conf *conf);\n\nint lxc_check_inherited(struct lxc_conf *conf, bool closeall, int fd_to_ignore)\n{\n\tstruct dirent *direntp;\n\tint fd, fddir;\n\tDIR *dir;\n\n\tif (conf && conf->close_all_fds)\n\t\tcloseall = true;\n\nrestart:\n\tdir = opendir(\"/proc/self/fd\");\n\tif (!dir) {\n\t\tWARN(\"Failed to open directory: %m.\");\n\t\treturn -1;\n\t}\n\n\tfddir = dirfd(dir);\n\n\twhile ((direntp = readdir(dir))) {\n\t\tif (!direntp)\n\t\t\tbreak;\n\n\t\tif (!strcmp(direntp->d_name, \".\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tif (lxc_safe_int(direntp->d_name, &fd) < 0) {\n\t\t\tINFO(\"Could not parse file descriptor for: %s\", direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd == fddir || fd == lxc_log_fd || fd == fd_to_ignore)\n\t\t\tcontinue;\n\n\t\tif (current_config && fd == current_config->logfd)\n\t\t\tcontinue;\n\n\t\tif (match_fd(fd))\n\t\t\tcontinue;\n\n\t\tif (closeall) {\n\t\t\tclose(fd);\n\t\t\tclosedir(dir);\n\t\t\tINFO(\"Closed inherited fd: %d.\", fd);\n\t\t\tgoto restart;\n\t\t}\n\t\tWARN(\"Inherited fd: %d.\", fd);\n\t}\n\n\t/* Only enable syslog at this point to avoid the above logging function\n\t * to open a new fd and make the check_inherited function enter an\n\t * infinite loop.\n\t */\n\tlxc_log_enable_syslog();\n\n\tclosedir(dir); /* cannot fail */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic struct lxc_operations execute_start_ops = {\n\t.start = execute_start,\n\t.post_start = execute_post_start\n};\n\nint lxc_execute(const char *name, char *const argv[], int quiet,\n\t\tstruct lxc_conf *conf, const char *lxcpath, bool backgrounded)\n{\n\tstruct execute_args args = {\n\t\t.argv = argv,\n\t\t.quiet = quiet\n\t};\n\n\tif (lxc_check_inherited(conf, false, -1))\n\t\treturn -1;\n\n\tconf->is_execute = 1;\n\treturn __lxc_start(name, conf, &execute_start_ops, &args, lxcpath, backgrounded);\n}"
  },
  {
    "function_name": "execute_post_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/execute.c",
    "lines": "101-106",
    "snippet": "static int execute_post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct execute_args *my_args = data;\n\tNOTICE(\"'%s' started with pid '%d'\", my_args->argv[0], handler->pid);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"start.h\"",
      "#include \"log.h\"",
      "#include \"conf.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"'%s' started with pid '%d'\"",
            "my_args->argv[0]",
            "handler->pid"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int execute_post_start(struct lxc_handler *handler, void* data)\n{\n\tstruct execute_args *my_args = data;\n\tNOTICE(\"'%s' started with pid '%d'\", my_args->argv[0], handler->pid);\n\treturn 0;\n}"
  },
  {
    "function_name": "execute_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/execute.c",
    "lines": "42-99",
    "snippet": "static int execute_start(struct lxc_handler *handler, void* data)\n{\n\tint j, i = 0;\n\tstruct execute_args *my_args = data;\n\tchar **argv;\n\tint argc = 0, argc_add;\n\tchar *initpath;\n\n\twhile (my_args->argv[argc++]);\n\n\targc_add = 4;\n\tif (my_args->quiet)\n\t\targc_add++;\n\tif (!handler->conf->rootfs.path) {\n\t\targc_add += 4;\n\t\tif (lxc_log_has_valid_level())\n\t\t\targc_add += 2;\n\t}\n\n\targv = malloc((argc + argc_add) * sizeof(*argv));\n\tif (!argv)\n\t\tgoto out1;\n\n\tinitpath = choose_init(NULL);\n\tif (!initpath) {\n\t\tERROR(\"Failed to find an lxc-init or init.lxc\");\n\t\tgoto out2;\n\t}\n\targv[i++] = initpath;\n\tif (my_args->quiet)\n\t\targv[i++] = \"--quiet\";\n\tif (!handler->conf->rootfs.path) {\n\t\targv[i++] = \"--name\";\n\t\targv[i++] = (char *)handler->name;\n\t\targv[i++] = \"--lxcpath\";\n\t\targv[i++] = (char *)handler->lxcpath;\n\n\t\tif (lxc_log_has_valid_level()) {\n\t\t\targv[i++] = \"--logpriority\";\n\t\t\targv[i++] = (char *)\n\t\t\t\tlxc_log_priority_to_string(lxc_log_get_level());\n\t\t}\n\t}\n\targv[i++] = \"--\";\n\tfor (j = 0; j < argc; j++)\n\t\targv[i++] = my_args->argv[j];\n\targv[i++] = NULL;\n\n\tNOTICE(\"exec'ing '%s'\", my_args->argv[0]);\n\n\texecvp(argv[0], argv);\n\tSYSERROR(\"failed to exec %s\", argv[0]);\n\tfree(initpath);\nout2:\n\tfree(argv);\nout1:\n\treturn 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"start.h\"",
      "#include \"log.h\"",
      "#include \"conf.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SYSERROR",
          "args": [
            "\"failed to exec %s\"",
            "argv[0]"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTICE",
          "args": [
            "\"exec'ing '%s'\"",
            "my_args->argv[0]"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_log_priority_to_string",
          "args": [
            "lxc_log_get_level()"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_priority_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.h",
          "lines": "141-156",
          "snippet": "static inline const char* lxc_log_priority_to_string(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_TRACE:\treturn \"TRACE\";\n\tcase LXC_LOG_PRIORITY_DEBUG:\treturn \"DEBUG\";\n\tcase LXC_LOG_PRIORITY_INFO:\treturn \"INFO\";\n\tcase LXC_LOG_PRIORITY_NOTICE:\treturn \"NOTICE\";\n\tcase LXC_LOG_PRIORITY_WARN:\treturn \"WARN\";\n\tcase LXC_LOG_PRIORITY_ERROR:\treturn \"ERROR\";\n\tcase LXC_LOG_PRIORITY_CRIT:\treturn \"CRIT\";\n\tcase LXC_LOG_PRIORITY_ALERT:\treturn \"ALERT\";\n\tcase LXC_LOG_PRIORITY_FATAL:\treturn \"FATAL\";\n\tdefault:\n\t\treturn \"NOTSET\";\n\t}\n}",
          "includes": [
            "#include \"conf.h\"",
            "#include <time.h>",
            "#include <syslog.h>",
            "#include <stdbool.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <sys/time.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conf.h\"\n#include <time.h>\n#include <syslog.h>\n#include <stdbool.h>\n#include <strings.h>\n#include <string.h>\n#include <sys/time.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline const char* lxc_log_priority_to_string(int priority)\n{\n\tswitch (priority) {\n\tcase LXC_LOG_PRIORITY_TRACE:\treturn \"TRACE\";\n\tcase LXC_LOG_PRIORITY_DEBUG:\treturn \"DEBUG\";\n\tcase LXC_LOG_PRIORITY_INFO:\treturn \"INFO\";\n\tcase LXC_LOG_PRIORITY_NOTICE:\treturn \"NOTICE\";\n\tcase LXC_LOG_PRIORITY_WARN:\treturn \"WARN\";\n\tcase LXC_LOG_PRIORITY_ERROR:\treturn \"ERROR\";\n\tcase LXC_LOG_PRIORITY_CRIT:\treturn \"CRIT\";\n\tcase LXC_LOG_PRIORITY_ALERT:\treturn \"ALERT\";\n\tcase LXC_LOG_PRIORITY_FATAL:\treturn \"FATAL\";\n\tdefault:\n\t\treturn \"NOTSET\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_get_level",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "632-635",
          "snippet": "extern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nstruct lxc_log_category lxc_log_category_lxc = {\n\t.name\t\t= \"lxc\",\n\t.priority\t= LXC_LOG_PRIORITY_ERROR,\n\t.appender\t= &log_appender_logfile,\n\t.parent\t\t= &log_root\n};\n\nextern int lxc_log_get_level(void)\n{\n\treturn lxc_log_category_lxc.priority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_log_has_valid_level",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_log_has_valid_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/log.c",
          "lines": "637-643",
          "snippet": "extern bool lxc_log_has_valid_level(void)\n{\n\tint log_level = lxc_log_get_level();\n\tif (log_level < 0 || log_level >= LXC_LOG_PRIORITY_NOTSET)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"caps.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <string.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"caps.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <time.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\nextern bool lxc_log_has_valid_level(void)\n{\n\tint log_level = lxc_log_get_level();\n\tif (log_level < 0 || log_level >= LXC_LOG_PRIORITY_NOTSET)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to find an lxc-init or init.lxc\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "choose_init",
          "args": [
            "NULL"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "choose_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1255-1348",
          "snippet": "char *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nchar *choose_init(const char *rootfs)\n{\n\tchar *retv = NULL;\n\tconst char *empty = \"\",\n\t\t   *tmp;\n\tint ret, env_set = 0;\n\tstruct stat mystat;\n\n\tif (!getenv(\"PATH\")) {\n\t\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 0))\n\t\t\tSYSERROR(\"Failed to setenv\");\n\t\tenv_set = 1;\n\t}\n\n\tretv = on_path(\"init.lxc\", rootfs);\n\n\tif (env_set) {\n\t\tif (unsetenv(\"PATH\"))\n\t\t\tSYSERROR(\"Failed to unsetenv\");\n\t}\n\n\tif (retv)\n\t\treturn retv;\n\n\tretv = malloc(PATH_MAX);\n\tif (!retv)\n\t\treturn NULL;\n\n\tif (rootfs)\n\t\ttmp = rootfs;\n\telse\n\t\ttmp = empty;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, SBINDIR, \"/init.lxc\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/%s/%s\", tmp, LXCINITDIR, \"/lxc/lxc-init\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/usr/lib/lxc/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\tret = snprintf(retv, PATH_MAX, \"%s/sbin/lxc-init\", tmp);\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tERROR(\"pathname too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\n\t/*\n\t * Last resort, look for the statically compiled init.lxc which we\n\t * hopefully bind-mounted in.\n\t * If we are called during container setup, and we get to this point,\n\t * then the init.lxc.static from the host will need to be bind-mounted\n\t * in.  So we return NULL here to indicate that.\n\t */\n\tif (rootfs)\n\t\tgoto out1;\n\n\tret = snprintf(retv, PATH_MAX, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Nonsense - name /lxc.init.static too long\");\n\t\tgoto out1;\n\t}\n\tret = stat(retv, &mystat);\n\tif (ret == 0)\n\t\treturn retv;\n\nout1:\n\tfree(retv);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(argc + argc_add) * sizeof(*argv)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"start.h\"\n#include \"log.h\"\n#include \"conf.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int execute_start(struct lxc_handler *handler, void* data)\n{\n\tint j, i = 0;\n\tstruct execute_args *my_args = data;\n\tchar **argv;\n\tint argc = 0, argc_add;\n\tchar *initpath;\n\n\twhile (my_args->argv[argc++]);\n\n\targc_add = 4;\n\tif (my_args->quiet)\n\t\targc_add++;\n\tif (!handler->conf->rootfs.path) {\n\t\targc_add += 4;\n\t\tif (lxc_log_has_valid_level())\n\t\t\targc_add += 2;\n\t}\n\n\targv = malloc((argc + argc_add) * sizeof(*argv));\n\tif (!argv)\n\t\tgoto out1;\n\n\tinitpath = choose_init(NULL);\n\tif (!initpath) {\n\t\tERROR(\"Failed to find an lxc-init or init.lxc\");\n\t\tgoto out2;\n\t}\n\targv[i++] = initpath;\n\tif (my_args->quiet)\n\t\targv[i++] = \"--quiet\";\n\tif (!handler->conf->rootfs.path) {\n\t\targv[i++] = \"--name\";\n\t\targv[i++] = (char *)handler->name;\n\t\targv[i++] = \"--lxcpath\";\n\t\targv[i++] = (char *)handler->lxcpath;\n\n\t\tif (lxc_log_has_valid_level()) {\n\t\t\targv[i++] = \"--logpriority\";\n\t\t\targv[i++] = (char *)\n\t\t\t\tlxc_log_priority_to_string(lxc_log_get_level());\n\t\t}\n\t}\n\targv[i++] = \"--\";\n\tfor (j = 0; j < argc; j++)\n\t\targv[i++] = my_args->argv[j];\n\targv[i++] = NULL;\n\n\tNOTICE(\"exec'ing '%s'\", my_args->argv[0]);\n\n\texecvp(argv[0], argv);\n\tSYSERROR(\"failed to exec %s\", argv[0]);\n\tfree(initpath);\nout2:\n\tfree(argv);\nout1:\n\treturn 1;\n}"
  }
]