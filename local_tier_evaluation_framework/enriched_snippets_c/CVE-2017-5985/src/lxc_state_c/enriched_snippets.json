[
  {
    "function_name": "lxc_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
    "lines": "108-197",
    "snippet": "extern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}",
    "includes": [
      "#include \"start.h\"",
      "#include \"monitor.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_monitor_close",
          "args": [
            "fd"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "151-154",
          "snippet": "int lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_close(int fd)\n{\n\treturn close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "lxcname",
            "msg.name"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_REALTIME",
            "&tspec"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_monitor_read_timeout",
          "args": [
            "fd",
            "&msg",
            "timeout"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_read_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "266-275",
          "snippet": "int lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_read_timeout(int fd, struct lxc_msg *msg, int timeout)\n{\n\tstruct pollfd fds;\n\n\tfds.fd = fd;\n\tfds.events = POLLIN | POLLPRI;\n\tfds.revents = 0;\n\n\treturn lxc_monitor_read_fdset(&fds, 1, msg, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_gettime",
          "args": [
            "CLOCK_REALTIME",
            "&tspec"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_getstate",
          "args": [
            "lxcname",
            "lxcpath"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_getstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "72-80",
          "snippet": "lxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nlxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitor_open",
          "args": [
            "lxcpath"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitor_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "190-232",
          "snippet": "int lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint lxc_monitor_open(const char *lxcpath)\n{\n\tstruct sockaddr_un addr;\n\tint fd;\n\tsize_t retry;\n\tsize_t len;\n\tint ret = 0, backoff_ms[] = {10, 50, 100};\n\n\tif (lxc_monitor_sock_name(lxcpath, &addr) < 0)\n\t\treturn -1;\n\n\tfd = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tERROR(\"Failed to create socket: %s.\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tlen = strlen(&addr.sun_path[1]) + 1;\n\tif (len >= sizeof(addr.sun_path) - 1) {\n\t\tret = -1;\n\t\terrno = ENAMETOOLONG;\n\t\tgoto on_error;\n\t}\n\n\tfor (retry = 0; retry < sizeof(backoff_ms) / sizeof(backoff_ms[0]); retry++) {\n\t\tret = connect(fd, (struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path) + len);\n\t\tif (ret == 0 || errno != ECONNREFUSED)\n\t\t\tbreak;\n\t\tERROR(\"Failed to connect to monitor socket. Retrying in %d ms.\", backoff_ms[retry]);\n\t\tusleep(backoff_ms[retry] * 1000);\n\t}\n\n\tif (ret < 0) {\n\t\tERROR(\"Failed to connect to monitor socket: %s.\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\treturn fd;\n\non_error:\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_monitord_spawn",
          "args": [
            "lxcpath"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_monitord_spawn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/monitor.c",
          "lines": "287-372",
          "snippet": "int lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"monitor.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"af_unix.h\"",
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <poll.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [
            "#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"state.h\"\n#include \"monitor.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"af_unix.h\"\n#include \"config.h\"\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <poll.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define LXC_MONITORD_PATH LIBEXECDIR \"/lxc/lxc-monitord\"\n\nint lxc_monitord_spawn(const char *lxcpath)\n{\n\tint ret;\n\tint pipefd[2];\n\tchar pipefd_str[LXC_NUMSTRLEN64];\n\tpid_t pid1, pid2;\n\n\tchar *const args[] = {\n\t    LXC_MONITORD_PATH,\n\t    (char *)lxcpath,\n\t    pipefd_str,\n\t    NULL,\n\t};\n\n\t/* double fork to avoid zombies when monitord exits */\n\tpid1 = fork();\n\tif (pid1 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\treturn -1;\n\t}\n\n\tif (pid1) {\n\t\tDEBUG(\"Going to wait for pid %d.\", pid1);\n\t\tif (waitpid(pid1, NULL, 0) != pid1)\n\t\t\treturn -1;\n\t\tDEBUG(\"Finished waiting on pid %d.\", pid1);\n\t\treturn 0;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tSYSERROR(\"Failed to create pipe.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpid2 = fork();\n\tif (pid2 < 0) {\n\t\tSYSERROR(\"Failed to fork().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (pid2) {\n\t\tDEBUG(\"Trying to sync with child process.\");\n\t\tchar c;\n\t\t/* Wait for daemon to create socket. */\n\t\tclose(pipefd[1]);\n\n\t\t/* Sync with child, we're ignoring the return from read\n\t\t * because regardless if it works or not, either way we've\n\t\t * synced with the child process. the if-empty-statement\n\t\t * construct is to quiet the warn-unused-result warning.\n\t\t */\n\t\tif (read(pipefd[0], &c, 1))\n\t\t\t;\n\n\t\tclose(pipefd[0]);\n\n\t\tDEBUG(\"Successfully synced with child process.\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (setsid() < 0) {\n\t\tSYSERROR(\"Failed to setsid().\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tlxc_check_inherited(NULL, true, pipefd[1]);\n\tif (null_stdfds() < 0) {\n\t\tSYSERROR(\"Failed to dup2() standard file descriptors to /dev/null.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[0]);\n\n\tret = snprintf(pipefd_str, LXC_NUMSTRLEN64, \"%d\", pipefd[1]);\n\tif (ret < 0 || ret >= LXC_NUMSTRLEN64) {\n\t\tERROR(\"Failed to create pid argument to pass to monitord.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tDEBUG(\"Using pipe file descriptor %d for monitord.\", pipefd[1]);\n\n\texecvp(args[0], args);\n\tERROR(\"Failed to exec lxc-monitord.\");\n\n\texit(EXIT_FAILURE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillwaitedstates",
          "args": [
            "states",
            "s"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fillwaitedstates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "82-106",
          "snippet": "static int fillwaitedstates(const char *strstates, int *states)\n{\n\tchar *token, *saveptr = NULL;\n\tchar *strstates_dup = strdup(strstates);\n\tint state;\n\n\tif (!strstates_dup)\n\t\treturn -1;\n\n\ttoken = strtok_r(strstates_dup, \"|\", &saveptr);\n\twhile (token) {\n\n\t\tstate = lxc_str2state(token);\n\t\tif (state < 0) {\n\t\t\tfree(strstates_dup);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstates[state] = 1;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\tfree(strstates_dup);\n\treturn 0;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int fillwaitedstates(const char *strstates, int *states)\n{\n\tchar *token, *saveptr = NULL;\n\tchar *strstates_dup = strdup(strstates);\n\tint state;\n\n\tif (!strstates_dup)\n\t\treturn -1;\n\n\ttoken = strtok_r(strstates_dup, \"|\", &saveptr);\n\twhile (token) {\n\n\t\tstate = lxc_str2state(token);\n\t\tif (state < 0) {\n\t\t\tfree(strstates_dup);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstates[state] = 1;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\tfree(strstates_dup);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int lxc_wait(const char *lxcname, const char *states, int timeout,\n\t\t    const char *lxcpath)\n{\n\tstruct lxc_msg msg;\n\tint state, ret;\n\tint s[MAX_STATE] = {0}, fd;\n\n\tif (fillwaitedstates(states, s))\n\t\treturn -1;\n\n\tif (lxc_monitord_spawn(lxcpath))\n\t\treturn -1;\n\n\tfd = lxc_monitor_open(lxcpath);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t/*\n\t * if container present,\n\t * then check if already in requested state\n\t */\n\tret = -1;\n\tstate = lxc_getstate(lxcname, lxcpath);\n\tif (state < 0) {\n\t\tgoto out_close;\n\t} else if ((state >= 0) && (s[state])) {\n\t\tret = 0;\n\t\tgoto out_close;\n\t}\n\n\tfor (;;) {\n\t\tint64_t elapsed_time, curtime = 0;\n\t\tstruct timespec tspec;\n\t\tint stop = 0;\n\t\tint retval;\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\tcurtime = tspec.tv_sec;\n\t\t}\n\t\tif (lxc_monitor_read_timeout(fd, &msg, timeout) < 0) {\n\t\t\t/* try again if select interrupted by signal */\n\t\t\tif (errno != EINTR)\n\t\t\t\tgoto out_close;\n\t\t}\n\n\t\tif (timeout != -1) {\n\t\t\tretval = clock_gettime(CLOCK_REALTIME, &tspec);\n\t\t\tif (retval)\n\t\t\t\tgoto out_close;\n\t\t\telapsed_time = tspec.tv_sec - curtime;\n\t\t\tif (timeout - elapsed_time <= 0)\n\t\t\t\tstop = 1;\n\t\t\ttimeout -= elapsed_time;\n\t\t}\n\n\t\tif (strcmp(lxcname, msg.name)) {\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (msg.type) {\n\t\tcase lxc_msg_state:\n\t\t\tif (msg.value < 0 || msg.value >= MAX_STATE)\n\t\t\t\tgoto out_close;\n\n\t\t\tif (s[msg.value]) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (stop) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out_close;\n\t\t\t}\n\t\t\t/* just ignore garbage */\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_close:\n\tlxc_monitor_close(fd);\n\treturn ret;\n}"
  },
  {
    "function_name": "fillwaitedstates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
    "lines": "82-106",
    "snippet": "static int fillwaitedstates(const char *strstates, int *states)\n{\n\tchar *token, *saveptr = NULL;\n\tchar *strstates_dup = strdup(strstates);\n\tint state;\n\n\tif (!strstates_dup)\n\t\treturn -1;\n\n\ttoken = strtok_r(strstates_dup, \"|\", &saveptr);\n\twhile (token) {\n\n\t\tstate = lxc_str2state(token);\n\t\tif (state < 0) {\n\t\t\tfree(strstates_dup);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstates[state] = 1;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\tfree(strstates_dup);\n\treturn 0;\n}",
    "includes": [
      "#include \"start.h\"",
      "#include \"monitor.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "strstates_dup"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_seccomp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/seccomp.c",
          "lines": "776-786",
          "snippet": "void lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}",
          "includes": [
            "#include \"lxcseccomp.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include <sys/utsname.h>",
            "#include <sys/mount.h>",
            "#include <seccomp.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxcseccomp.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include <sys/utsname.h>\n#include <sys/mount.h>\n#include <seccomp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nvoid lxc_seccomp_free(struct lxc_conf *conf)\n{\n\tfree(conf->seccomp);\n\tconf->seccomp = NULL;\n#if HAVE_SCMP_FILTER_CTX\n\tif (conf->seccomp_ctx) {\n\t\tseccomp_release(conf->seccomp_ctx);\n\t\tconf->seccomp_ctx = NULL;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"|\"",
            "&saveptr"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_str2state",
          "args": [
            "token"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_str2state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
          "lines": "59-70",
          "snippet": "lxc_state_t lxc_str2state(const char *state)\n{\n\tsize_t len;\n\tlxc_state_t i;\n\tlen = sizeof(strstate)/sizeof(strstate[0]);\n\tfor (i = 0; i < len; i++)\n\t\tif (!strcmp(strstate[i], state))\n\t\t\treturn i;\n\n\tERROR(\"invalid state '%s'\", state);\n\treturn -1;\n}",
          "includes": [
            "#include \"start.h\"",
            "#include \"monitor.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"config.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/file.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nlxc_state_t lxc_str2state(const char *state)\n{\n\tsize_t len;\n\tlxc_state_t i;\n\tlen = sizeof(strstate)/sizeof(strstate[0]);\n\tfor (i = 0; i < len; i++)\n\t\tif (!strcmp(strstate[i], state))\n\t\t\treturn i;\n\n\tERROR(\"invalid state '%s'\", state);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "strstates_dup",
            "\"|\"",
            "&saveptr"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "strstates"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic int fillwaitedstates(const char *strstates, int *states)\n{\n\tchar *token, *saveptr = NULL;\n\tchar *strstates_dup = strdup(strstates);\n\tint state;\n\n\tif (!strstates_dup)\n\t\treturn -1;\n\n\ttoken = strtok_r(strstates_dup, \"|\", &saveptr);\n\twhile (token) {\n\n\t\tstate = lxc_str2state(token);\n\t\tif (state < 0) {\n\t\t\tfree(strstates_dup);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstates[state] = 1;\n\n\t\ttoken = strtok_r(NULL, \"|\", &saveptr);\n\t}\n\tfree(strstates_dup);\n\treturn 0;\n}"
  },
  {
    "function_name": "lxc_getstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
    "lines": "72-80",
    "snippet": "lxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}",
    "includes": [
      "#include \"start.h\"",
      "#include \"monitor.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_cmd_get_state",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_cmd_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/commands.c",
          "lines": "558-580",
          "snippet": "lxc_state_t lxc_cmd_get_state(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_STATE }\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0 && stopped)\n\t\treturn STOPPED;\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Container \\\"%s\\\" is in \\\"%s\\\" state.\", name,\n\t      lxc_state2str(PTR_TO_INT(cmd.rsp.data)));\n\treturn PTR_TO_INT(cmd.rsp.data);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"af_unix.h\"",
            "#include \"mainloop.h\"",
            "#include \"confile.h\"",
            "#include \"console.h\"",
            "#include \"commands.h\"",
            "#include \"cgroup.h\"",
            "#include \"utils.h\"",
            "#include \"start.h\"\t/* for struct lxc_handler */",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include <stdlib.h>",
            "#include <malloc.h>",
            "#include <sys/param.h>",
            "#include <sys/un.h>",
            "#include <inttypes.h>",
            "#include <sys/socket.h>",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"af_unix.h\"\n#include \"mainloop.h\"\n#include \"confile.h\"\n#include \"console.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include \"utils.h\"\n#include \"start.h\"\t/* for struct lxc_handler */\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include <stdlib.h>\n#include <malloc.h>\n#include <sys/param.h>\n#include <sys/un.h>\n#include <inttypes.h>\n#include <sys/socket.h>\n#include <poll.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n\nlxc_state_t lxc_cmd_get_state(const char *name, const char *lxcpath)\n{\n\tint ret, stopped;\n\tstruct lxc_cmd_rr cmd = {\n\t\t.req = { .cmd = LXC_CMD_GET_STATE }\n\t};\n\n\tret = lxc_cmd(name, &cmd, &stopped, lxcpath, NULL);\n\tif (ret < 0 && stopped)\n\t\treturn STOPPED;\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (!ret) {\n\t\tWARN(\"Container \\\"%s\\\" has stopped before sending its state.\", name);\n\t\treturn -1;\n\t}\n\n\tDEBUG(\"Container \\\"%s\\\" is in \\\"%s\\\" state.\", name,\n\t      lxc_state2str(PTR_TO_INT(cmd.rsp.data)));\n\treturn PTR_TO_INT(cmd.rsp.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_state",
          "args": [
            "name",
            "lxcpath"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/freezer.c",
          "lines": "42-51",
          "snippet": "lxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}",
          "includes": [
            "#include \"lxc.h\"",
            "#include \"log.h\"",
            "#include \"monitor.h\"",
            "#include \"state.h\"",
            "#include \"error.h\"",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc.h\"\n#include \"log.h\"\n#include \"monitor.h\"\n#include \"state.h\"\n#include \"error.h\"\n#include <sys/param.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nlxc_state_t freezer_state(const char *name, const char *lxcpath)\n{\n\tchar v[100];\n\tif (lxc_cgroup_get(\"freezer.state\", v, 100, name, lxcpath) < 0)\n\t\treturn -1;\n\n\tif (v[strlen(v)-1] == '\\n')\n\t\tv[strlen(v)-1] = '\\0';\n\treturn lxc_str2state(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nlxc_state_t lxc_getstate(const char *name, const char *lxcpath)\n{\n\textern lxc_state_t freezer_state(const char *name, const char *lxcpath);\n\n\tlxc_state_t state = freezer_state(name, lxcpath);\n\tif (state != FROZEN && state != FREEZING)\n\t\tstate = lxc_cmd_get_state(name, lxcpath);\n\treturn state;\n}"
  },
  {
    "function_name": "lxc_str2state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
    "lines": "59-70",
    "snippet": "lxc_state_t lxc_str2state(const char *state)\n{\n\tsize_t len;\n\tlxc_state_t i;\n\tlen = sizeof(strstate)/sizeof(strstate[0]);\n\tfor (i = 0; i < len; i++)\n\t\tif (!strcmp(strstate[i], state))\n\t\t\treturn i;\n\n\tERROR(\"invalid state '%s'\", state);\n\treturn -1;\n}",
    "includes": [
      "#include \"start.h\"",
      "#include \"monitor.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"invalid state '%s'\"",
            "state"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstate[i]",
            "state"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nlxc_state_t lxc_str2state(const char *state)\n{\n\tsize_t len;\n\tlxc_state_t i;\n\tlen = sizeof(strstate)/sizeof(strstate[0]);\n\tfor (i = 0; i < len; i++)\n\t\tif (!strcmp(strstate[i], state))\n\t\t\treturn i;\n\n\tERROR(\"invalid state '%s'\", state);\n\treturn -1;\n}"
  },
  {
    "function_name": "lxc_state2str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/state.c",
    "lines": "52-57",
    "snippet": "const char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}",
    "includes": [
      "#include \"start.h\"",
      "#include \"monitor.h\"",
      "#include \"lxc.h\"",
      "#include \"log.h\"",
      "#include \"config.h\"",
      "#include \"commands.h\"",
      "#include \"cgroup.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/file.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"start.h\"\n#include \"monitor.h\"\n#include \"lxc.h\"\n#include \"log.h\"\n#include \"config.h\"\n#include \"commands.h\"\n#include \"cgroup.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/file.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n\nstatic const char * const strstate[] = {\n\t\"STOPPED\", \"STARTING\", \"RUNNING\", \"STOPPING\",\n\t\"ABORTING\", \"FREEZING\", \"FROZEN\", \"THAWED\",\n};\n\nconst char *lxc_state2str(lxc_state_t state)\n{\n\tif (state < STOPPED || state > MAX_STATE - 1)\n\t\treturn NULL;\n\treturn strstate[state];\n}"
  }
]