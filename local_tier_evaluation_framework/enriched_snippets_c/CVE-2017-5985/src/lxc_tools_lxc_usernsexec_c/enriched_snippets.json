[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "265-385",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint c;\n\tunsigned long flags = CLONE_NEWUSER | CLONE_NEWNS;\n\tchar ttyname0[256], ttyname1[256], ttyname2[256];\n\tint status;\n\tint ret;\n\tint pid;\n\tchar *default_args[] = {\"/bin/sh\", NULL};\n\tchar buf[1];\n\tint pipe1[2],  // child tells parent it has unshared\n\t    pipe2[2];  // parent tells child it is mapped and may proceed\n\n\tmemset(ttyname0, '\\0', sizeof(ttyname0));\n\tmemset(ttyname1, '\\0', sizeof(ttyname1));\n\tmemset(ttyname2, '\\0', sizeof(ttyname2));\n\tif (isatty(0)) {\n\t\tret = readlink(\"/proc/self/fd/0\", ttyname0, sizeof(ttyname0));\n\t\tif (ret < 0) {\n\t\t\tperror(\"unable to open stdin.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tret = readlink(\"/proc/self/fd/1\", ttyname1, sizeof(ttyname1));\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Warning: unable to open stdout, continuing.\");\n\t\t\tmemset(ttyname1, '\\0', sizeof(ttyname1));\n\t\t}\n\t\tret = readlink(\"/proc/self/fd/2\", ttyname2, sizeof(ttyname2));\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Warning: unable to open stderr, continuing.\");\n\t\t\tmemset(ttyname2, '\\0', sizeof(ttyname2));\n\t\t}\n\t}\n\n\tlxc_list_init(&active_map);\n\n\twhile ((c = getopt(argc, argv, \"m:h\")) != EOF) {\n\t\tswitch (c) {\n\t\t\tcase 'm': if (parse_map(optarg)) usage(argv[0]); break;\n\t\t\tcase 'h':\n\t\t\tdefault:\n\t\t\t\t  usage(argv[0]);\n\t\t}\n\t};\n\n\tif (lxc_list_empty(&active_map)) {\n\t\tif (find_default_map()) {\n\t\t\tfprintf(stderr, \"You have no allocated subuids or subgids\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\targv = &argv[optind];\n\targc = argc - optind;\n\tif (argc < 1) {\n\t\targv = default_args;\n\t\targc = 1;\n\t}\n\n\tif (pipe(pipe1) < 0 || pipe(pipe2) < 0) {\n\t\tperror(\"pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif ((pid = fork()) == 0) {\n\t\t// Child.\n\n\t\tclose(pipe1[0]);\n\t\tclose(pipe2[1]);\n\t\topentty(ttyname0, 0);\n\t\topentty(ttyname1, 1);\n\t\topentty(ttyname2, 2);\n\n\t\tret = unshare(flags);\n\t\tif (ret < 0) {\n\t\t\tperror(\"unshare\");\n\t\t\treturn 1;\n\t\t}\n\t\tbuf[0] = '1';\n\t\tif (write(pipe1[1], buf, 1) < 1) {\n\t\t\tperror(\"write pipe\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (read(pipe2[0], buf, 1) < 1) {\n\t\t\tperror(\"read pipe\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (buf[0] != '1') {\n\t\t\tfprintf(stderr, \"parent had an error, child exiting\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tclose(pipe1[1]);\n\t\tclose(pipe2[0]);\n\t\treturn do_child((void*)argv);\n\t}\n\n\tclose(pipe1[1]);\n\tclose(pipe2[0]);\n\tif (read(pipe1[0], buf, 1) < 1) {\n\t\tperror(\"read pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tbuf[0] = '1';\n\n\tif (lxc_map_ids(&active_map, pid)) {\n\t\tfprintf(stderr, \"error mapping child\\n\");\n\t\tret = 0;\n\t}\n\tif (write(pipe2[1], buf, 1) < 0) {\n\t\tperror(\"write to pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif ((ret = waitpid(pid, &status, __WALL)) < 0) {\n\t\tprintf(\"waitpid() returns %d, errno %d\\n\", ret, errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texit(WEXITSTATUS(status));\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int unshare(int flags);",
      "static struct lxc_list active_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "WEXITSTATUS(status)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"waitpid() returns %d, errno %d\\n\"",
            "ret",
            "errno"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "__WALL"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"write to pipe\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipe2[1]",
            "buf",
            "1"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error mapping child\\n\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_map_ids",
          "args": [
            "&active_map",
            "pid"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_map_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "3230-3305",
          "snippet": "int lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_map_ids(struct lxc_list *idmap, pid_t pid)\n{\n\tstruct lxc_list *iterator;\n\tstruct id_map *map;\n\tint ret = 0, use_shadow = 0;\n\tenum idtype type;\n\tchar *buf = NULL, *pos, *cmdpath = NULL;\n\n\t/*\n\t * If newuidmap exists, that is, if shadow is handing out subuid\n\t * ranges, then insist that root also reserve ranges in subuid.  This\n\t * will protected it by preventing another user from being handed the\n\t * range by shadow.\n\t */\n\tcmdpath = on_path(\"newuidmap\", NULL);\n\tif (cmdpath) {\n\t\tuse_shadow = 1;\n\t\tfree(cmdpath);\n\t}\n\n\tif (!use_shadow && geteuid()) {\n\t\tERROR(\"Missing newuidmap/newgidmap\");\n\t\treturn -1;\n\t}\n\n\tfor(type = ID_TYPE_UID; type <= ID_TYPE_GID; type++) {\n\t\tint left, fill;\n\t\tint had_entry = 0;\n\t\tif (!buf) {\n\t\t\tbuf = pos = malloc(4096);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpos = buf;\n\t\tif (use_shadow)\n\t\t\tpos += sprintf(buf, \"new%cidmap %d\",\n\t\t\t\ttype == ID_TYPE_UID ? 'u' : 'g',\n\t\t\t\tpid);\n\n\t\tlxc_list_for_each(iterator, idmap) {\n\t\t\t/* The kernel only takes <= 4k for writes to /proc/<nr>/[ug]id_map */\n\t\t\tmap = iterator->elem;\n\t\t\tif (map->idtype != type)\n\t\t\t\tcontinue;\n\n\t\t\thad_entry = 1;\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"%s%lu %lu %lu%s\",\n\t\t\t\t\tuse_shadow ? \" \" : \"\",\n\t\t\t\t\tmap->nsid, map->hostid, map->range,\n\t\t\t\t\tuse_shadow ? \"\" : \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t}\n\t\tif (!had_entry)\n\t\t\tcontinue;\n\n\t\tif (!use_shadow) {\n\t\t\tret = write_id_mapping(type, pid, buf, pos-buf);\n\t\t} else {\n\t\t\tleft = 4096 - (pos - buf);\n\t\t\tfill = snprintf(pos, left, \"\\n\");\n\t\t\tif (fill <= 0 || fill >= left)\n\t\t\t\tSYSERROR(\"snprintf failed, too many mappings\");\n\t\t\tpos += fill;\n\t\t\tret = system(buf);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"read pipe\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipe1[0]",
            "buf",
            "1"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "read_default_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "201-251",
          "snippet": "static int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list active_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct lxc_list active_map;\n\nstatic int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipe2[0]"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_child",
          "args": [
            "(void*)argv"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "do_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "104-134",
          "snippet": "static int do_child(void *vargv)\n{\n\tchar **argv = (char **)vargv;\n\n\t// Assume we want to become root\n\tif (setgid(0) < 0) {\n\t\tperror(\"setgid\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tperror(\"setuid\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0) {\n\t\tperror(\"setgroups\");\n\t\treturn -1;\n\t}\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tperror(\"unshare CLONE_NEWNS\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tprintf(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\texecvp(argv[0], argv);\n\tperror(\"execvpe\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MS_SLAVE (1 << 19)",
            "#define MS_REC 16384"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MS_SLAVE (1 << 19)\n#define MS_REC 16384\n\nstatic int do_child(void *vargv)\n{\n\tchar **argv = (char **)vargv;\n\n\t// Assume we want to become root\n\tif (setgid(0) < 0) {\n\t\tperror(\"setgid\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tperror(\"setuid\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0) {\n\t\tperror(\"setgroups\");\n\t\treturn -1;\n\t}\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tperror(\"unshare CLONE_NEWNS\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tprintf(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\texecvp(argv[0], argv);\n\tperror(\"execvpe\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"parent had an error, child exiting\\n\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"read pipe\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"write pipe\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"unshare\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "flags"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "opentty",
          "args": [
            "ttyname2",
            "2"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "opentty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "77-101",
          "snippet": "static void opentty(const char * tty, int which) {\n\tint fd, flags;\n\n\tif (tty[0] == '\\0')\n\t\treturn;\n\n\tfd = open(tty, O_RDWR | O_NONBLOCK);\n\tif (fd == -1) {\n\t\tprintf(\"WARN: could not reopen tty: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tflags &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) < 0) {\n\t\tprintf(\"WARN: could not set fd flags: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tclose(which);\n\tif (fd != which) {\n\t\tdup2(fd, which);\n\t\tclose(fd);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unshare(int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint unshare(int flags);\n\nstatic void opentty(const char * tty, int which) {\n\tint fd, flags;\n\n\tif (tty[0] == '\\0')\n\t\treturn;\n\n\tfd = open(tty, O_RDWR | O_NONBLOCK);\n\tif (fd == -1) {\n\t\tprintf(\"WARN: could not reopen tty: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tflags &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) < 0) {\n\t\tprintf(\"WARN: could not set fd flags: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tclose(which);\n\tif (fd != which) {\n\t\tdup2(fd, which);\n\t\tclose(fd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"pipe\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipe2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipe1"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"You have no allocated subuids or subgids\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_default_map",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "find_default_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "253-263",
          "snippet": "static int find_default_map(void)\n{\n\tstruct passwd *p = getpwuid(getuid());\n\tif (!p)\n\t\treturn -1;\n\tif (read_default_map(subuidfile, ID_TYPE_UID, p->pw_name) < 0)\n\t\treturn -1;\n\tif (read_default_map(subgidfile, ID_TYPE_GID, p->pw_name) < 0)\n\t\treturn -1;\n    return 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int find_default_map(void)\n{\n\tstruct passwd *p = getpwuid(getuid());\n\tif (!p)\n\t\treturn -1;\n\tif (read_default_map(subuidfile, ID_TYPE_UID, p->pw_name) < 0)\n\t\treturn -1;\n\tif (read_default_map(subgidfile, ID_TYPE_GID, p->pw_name) < 0)\n\t\treturn -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_empty",
          "args": [
            "&active_map"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "94-97",
          "snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int lxc_list_empty(struct lxc_list *list)\n{\n\treturn list == list->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "argv[0]"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "58-75",
          "snippet": "static void usage(const char *name)\n{\n\tprintf(\"usage: %s [-h] [-m <uid-maps>] -- [command [arg ..]]\\n\", name);\n\tprintf(\"\\n\");\n\tprintf(\"  -h            this message\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -m <uid-maps> uid maps to use\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  uid-maps: [u|g|b]:ns_id:host_id:range\\n\");\n\tprintf(\"            [u|g|b]: map user id, group id, or both\\n\");\n\tprintf(\"            ns_id: the base id in the new namespace\\n\");\n\tprintf(\"            host_id: the base id in the parent namespace\\n\");\n\tprintf(\"            range: how many ids to map\\n\");\n\tprintf(\"  Note: This program uses newuidmap(2) and newgidmap(2).\\n\");\n\tprintf(\"        As such, /etc/subuid and /etc/subgid must grant the\\n\");\n\tprintf(\"        calling user permission to use the mapped ranges\\n\");\n\texit(EXIT_SUCCESS);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void usage(const char *name)\n{\n\tprintf(\"usage: %s [-h] [-m <uid-maps>] -- [command [arg ..]]\\n\", name);\n\tprintf(\"\\n\");\n\tprintf(\"  -h            this message\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -m <uid-maps> uid maps to use\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  uid-maps: [u|g|b]:ns_id:host_id:range\\n\");\n\tprintf(\"            [u|g|b]: map user id, group id, or both\\n\");\n\tprintf(\"            ns_id: the base id in the new namespace\\n\");\n\tprintf(\"            host_id: the base id in the parent namespace\\n\");\n\tprintf(\"            range: how many ids to map\\n\");\n\tprintf(\"  Note: This program uses newuidmap(2) and newgidmap(2).\\n\");\n\tprintf(\"        As such, /etc/subuid and /etc/subgid must grant the\\n\");\n\tprintf(\"        calling user permission to use the mapped ranges\\n\");\n\texit(EXIT_SUCCESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_map",
          "args": [
            "optarg"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "parse_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "142-190",
          "snippet": "static int parse_map(char *map)\n{\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tint ret;\n\tint i;\n\tchar types[2] = {'u', 'g'};\n\tchar which;\n\tlong host_id, ns_id, range;\n\n\tif (!map)\n\t\treturn -1;\n\n\tret = sscanf(map, \"%c:%ld:%ld:%ld\", &which, &ns_id, &host_id, &range);\n\tif (ret != 4)\n\t\treturn -1;\n\n\tif (which != 'b' && which != 'u' && which != 'g')\n\t\treturn -1;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (which != types[i] && which != 'b')\n\t\t\tcontinue;\n\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)\n\t\t\treturn -1;\n\n\t\tnewmap->hostid = host_id;\n\t\tnewmap->nsid = ns_id;\n\t\tnewmap->range = range;\n\n\t\tif (types[i] == 'u')\n\t\t\tnewmap->idtype = ID_TYPE_UID;\n\t\telse\n\t\t\tnewmap->idtype = ID_TYPE_GID;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list active_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct lxc_list active_map;\n\nstatic int parse_map(char *map)\n{\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tint ret;\n\tint i;\n\tchar types[2] = {'u', 'g'};\n\tchar which;\n\tlong host_id, ns_id, range;\n\n\tif (!map)\n\t\treturn -1;\n\n\tret = sscanf(map, \"%c:%ld:%ld:%ld\", &which, &ns_id, &host_id, &range);\n\tif (ret != 4)\n\t\treturn -1;\n\n\tif (which != 'b' && which != 'u' && which != 'g')\n\t\treturn -1;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (which != types[i] && which != 'b')\n\t\t\tcontinue;\n\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)\n\t\t\treturn -1;\n\n\t\tnewmap->hostid = host_id;\n\t\tnewmap->nsid = ns_id;\n\t\tnewmap->range = range;\n\n\t\tif (types[i] == 'u')\n\t\t\tnewmap->idtype = ID_TYPE_UID;\n\t\telse\n\t\t\tnewmap->idtype = ID_TYPE_GID;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"m:h\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_list_init",
          "args": [
            "&active_map"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "68-72",
          "snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_init(struct lxc_list *list)\n{\n\tlist->elem = NULL;\n\tlist->next = list->prev = list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ttyname2",
            "'\\0'",
            "sizeof(ttyname2)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: unable to open stderr, continuing.\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "\"/proc/self/fd/2\"",
            "ttyname2",
            "sizeof(ttyname2)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ttyname1",
            "'\\0'",
            "sizeof(ttyname1)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: unable to open stdout, continuing.\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "\"/proc/self/fd/1\"",
            "ttyname1",
            "sizeof(ttyname1)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"unable to open stdin.\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "\"/proc/self/fd/0\"",
            "ttyname0",
            "sizeof(ttyname0)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ttyname2",
            "'\\0'",
            "sizeof(ttyname2)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ttyname1",
            "'\\0'",
            "sizeof(ttyname1)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ttyname0",
            "'\\0'",
            "sizeof(ttyname0)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint unshare(int flags);\nstatic struct lxc_list active_map;\n\nint main(int argc, char *argv[])\n{\n\tint c;\n\tunsigned long flags = CLONE_NEWUSER | CLONE_NEWNS;\n\tchar ttyname0[256], ttyname1[256], ttyname2[256];\n\tint status;\n\tint ret;\n\tint pid;\n\tchar *default_args[] = {\"/bin/sh\", NULL};\n\tchar buf[1];\n\tint pipe1[2],  // child tells parent it has unshared\n\t    pipe2[2];  // parent tells child it is mapped and may proceed\n\n\tmemset(ttyname0, '\\0', sizeof(ttyname0));\n\tmemset(ttyname1, '\\0', sizeof(ttyname1));\n\tmemset(ttyname2, '\\0', sizeof(ttyname2));\n\tif (isatty(0)) {\n\t\tret = readlink(\"/proc/self/fd/0\", ttyname0, sizeof(ttyname0));\n\t\tif (ret < 0) {\n\t\t\tperror(\"unable to open stdin.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tret = readlink(\"/proc/self/fd/1\", ttyname1, sizeof(ttyname1));\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Warning: unable to open stdout, continuing.\");\n\t\t\tmemset(ttyname1, '\\0', sizeof(ttyname1));\n\t\t}\n\t\tret = readlink(\"/proc/self/fd/2\", ttyname2, sizeof(ttyname2));\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Warning: unable to open stderr, continuing.\");\n\t\t\tmemset(ttyname2, '\\0', sizeof(ttyname2));\n\t\t}\n\t}\n\n\tlxc_list_init(&active_map);\n\n\twhile ((c = getopt(argc, argv, \"m:h\")) != EOF) {\n\t\tswitch (c) {\n\t\t\tcase 'm': if (parse_map(optarg)) usage(argv[0]); break;\n\t\t\tcase 'h':\n\t\t\tdefault:\n\t\t\t\t  usage(argv[0]);\n\t\t}\n\t};\n\n\tif (lxc_list_empty(&active_map)) {\n\t\tif (find_default_map()) {\n\t\t\tfprintf(stderr, \"You have no allocated subuids or subgids\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\targv = &argv[optind];\n\targc = argc - optind;\n\tif (argc < 1) {\n\t\targv = default_args;\n\t\targc = 1;\n\t}\n\n\tif (pipe(pipe1) < 0 || pipe(pipe2) < 0) {\n\t\tperror(\"pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif ((pid = fork()) == 0) {\n\t\t// Child.\n\n\t\tclose(pipe1[0]);\n\t\tclose(pipe2[1]);\n\t\topentty(ttyname0, 0);\n\t\topentty(ttyname1, 1);\n\t\topentty(ttyname2, 2);\n\n\t\tret = unshare(flags);\n\t\tif (ret < 0) {\n\t\t\tperror(\"unshare\");\n\t\t\treturn 1;\n\t\t}\n\t\tbuf[0] = '1';\n\t\tif (write(pipe1[1], buf, 1) < 1) {\n\t\t\tperror(\"write pipe\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (read(pipe2[0], buf, 1) < 1) {\n\t\t\tperror(\"read pipe\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (buf[0] != '1') {\n\t\t\tfprintf(stderr, \"parent had an error, child exiting\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tclose(pipe1[1]);\n\t\tclose(pipe2[0]);\n\t\treturn do_child((void*)argv);\n\t}\n\n\tclose(pipe1[1]);\n\tclose(pipe2[0]);\n\tif (read(pipe1[0], buf, 1) < 1) {\n\t\tperror(\"read pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tbuf[0] = '1';\n\n\tif (lxc_map_ids(&active_map, pid)) {\n\t\tfprintf(stderr, \"error mapping child\\n\");\n\t\tret = 0;\n\t}\n\tif (write(pipe2[1], buf, 1) < 0) {\n\t\tperror(\"write to pipe\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif ((ret = waitpid(pid, &status, __WALL)) < 0) {\n\t\tprintf(\"waitpid() returns %d, errno %d\\n\", ret, errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texit(WEXITSTATUS(status));\n}"
  },
  {
    "function_name": "find_default_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "253-263",
    "snippet": "static int find_default_map(void)\n{\n\tstruct passwd *p = getpwuid(getuid());\n\tif (!p)\n\t\treturn -1;\n\tif (read_default_map(subuidfile, ID_TYPE_UID, p->pw_name) < 0)\n\t\treturn -1;\n\tif (read_default_map(subgidfile, ID_TYPE_GID, p->pw_name) < 0)\n\t\treturn -1;\n    return 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_default_map",
          "args": [
            "subgidfile",
            "ID_TYPE_GID",
            "p->pw_name"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "read_default_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "201-251",
          "snippet": "static int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"conf.h\"",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <sys/syscall.h>",
            "#include <sched.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lxc_list active_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct lxc_list active_map;\n\nstatic int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic int find_default_map(void)\n{\n\tstruct passwd *p = getpwuid(getuid());\n\tif (!p)\n\t\treturn -1;\n\tif (read_default_map(subuidfile, ID_TYPE_UID, p->pw_name) < 0)\n\t\treturn -1;\n\tif (read_default_map(subgidfile, ID_TYPE_GID, p->pw_name) < 0)\n\t\treturn -1;\n    return 0;\n}"
  },
  {
    "function_name": "read_default_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "201-251",
    "snippet": "static int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list active_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "line"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "&active_map",
            "tmp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmp)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "p2+1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "p1+1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fin"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*newmap)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p1+1",
            "':'"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "username"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "username",
            "strlen(username)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "username"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "username"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "&line",
            "&sz",
            "fin"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getline.c",
          "lines": "39-60",
          "snippet": "ssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nssize_t\ngetline(char **outbuf, size_t *outsize, FILE *fp)\n{\n    size_t len;\n    char *buf;\n    buf = fgetln(fp, &len);\n\n    if (buf == NULL)\n        return (-1);\n\n    /* Assumes realloc() accepts NULL for ptr (C99) */\n    if (*outbuf == NULL || *outsize < len + 1) {\n        void *tmp = realloc(*outbuf, len + 1);\n        if (tmp == NULL)\n            return (-1);\n        *outbuf = tmp;\n        *outsize = len + 1;\n    }\n    memcpy(*outbuf, buf, len);\n    (*outbuf)[len] = '\\0';\n    return (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fnam",
            "\"r\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct lxc_list active_map;\n\nstatic int read_default_map(char *fnam, int which, char *username)\n{\n\tFILE *fin;\n\tchar *line = NULL;\n\tsize_t sz = 0;\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tchar *p1, *p2;\n\n\tfin = fopen(fnam, \"r\");\n\tif (!fin)\n\t\treturn -1;\n\twhile (getline(&line, &sz, fin) != -1) {\n\t\tif (sz <= strlen(username) ||\n\t\t    strncmp(line, username, strlen(username)) != 0 ||\n\t\t    line[strlen(username)] != ':')\n\t\t\tcontinue;\n\t\tp1 = strchr(line, ':');\n\t\tif (!p1)\n\t\t\tcontinue;\n\t\tp2 = strchr(p1+1, ':');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)  {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmap->hostid = atol(p1+1);\n\t\tnewmap->range = atol(p2+1);\n\t\tnewmap->nsid = 0;\n\t\tnewmap->idtype = which;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfclose(fin);\n\t\t\tfree(line);\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fin);\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "142-190",
    "snippet": "static int parse_map(char *map)\n{\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tint ret;\n\tint i;\n\tchar types[2] = {'u', 'g'};\n\tchar which;\n\tlong host_id, ns_id, range;\n\n\tif (!map)\n\t\treturn -1;\n\n\tret = sscanf(map, \"%c:%ld:%ld:%ld\", &which, &ns_id, &host_id, &range);\n\tif (ret != 4)\n\t\treturn -1;\n\n\tif (which != 'b' && which != 'u' && which != 'g')\n\t\treturn -1;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (which != types[i] && which != 'b')\n\t\t\tcontinue;\n\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)\n\t\t\treturn -1;\n\n\t\tnewmap->hostid = host_id;\n\t\tnewmap->nsid = ns_id;\n\t\tnewmap->range = range;\n\n\t\tif (types[i] == 'u')\n\t\t\tnewmap->idtype = ID_TYPE_UID;\n\t\telse\n\t\t\tnewmap->idtype = ID_TYPE_GID;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lxc_list active_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_list_add_tail",
          "args": [
            "&active_map",
            "tmp"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_list_add_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/list.h",
          "lines": "133-137",
          "snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void lxc_list_add_tail(struct lxc_list *head,\n\t\t\t\t     struct lxc_list *list)\n{\n\t__lxc_list_add(list, head->prev, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newmap"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "free_mnts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_copy.c",
          "lines": "539-554",
          "snippet": "static void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}",
          "includes": [
            "#include <../include/getsubopt.h>",
            "#include \"utils.h\"",
            "#include \"state.h\"",
            "#include \"conf.h\"",
            "#include \"lxc.h\"",
            "#include \"arguments.h\"",
            "#include \"confile.h\"",
            "#include \"log.h\"",
            "#include \"bdev.h\"",
            "#include \"attach.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <stdbool.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <stdint.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <getopt.h>",
            "#include <unistd.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int mnt_table_size = 0;",
            "static struct mnts *mnt_table = NULL;",
            "static void free_mnts(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <../include/getsubopt.h>\n#include \"utils.h\"\n#include \"state.h\"\n#include \"conf.h\"\n#include \"lxc.h\"\n#include \"arguments.h\"\n#include \"confile.h\"\n#include \"log.h\"\n#include \"bdev.h\"\n#include \"attach.h\"\n#include <lxc/lxccontainer.h>\n#include <stdbool.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <getopt.h>\n#include <unistd.h>\n#include \"config.h\"\n\nstatic unsigned int mnt_table_size = 0;\nstatic struct mnts *mnt_table = NULL;\nstatic void free_mnts(void);\n\nstatic void free_mnts()\n{\n\tunsigned int i;\n\tstruct mnts *n = NULL;\n\n\tfor (i = 0, n = mnt_table; i < mnt_table_size; i++, n++) {\n\t\tfree(n->src);\n\t\tfree(n->dest);\n\t\tfree(n->options);\n\t\tfree(n->upper);\n\t\tfree(n->workdir);\n\t}\n\tfree(mnt_table);\n\tmnt_table = NULL;\n\tmnt_table_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*tmp)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*newmap)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "map",
            "\"%c:%ld:%ld:%ld\"",
            "&which",
            "&ns_id",
            "&host_id",
            "&range"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic struct lxc_list active_map;\n\nstatic int parse_map(char *map)\n{\n\tstruct id_map *newmap;\n\tstruct lxc_list *tmp = NULL;\n\tint ret;\n\tint i;\n\tchar types[2] = {'u', 'g'};\n\tchar which;\n\tlong host_id, ns_id, range;\n\n\tif (!map)\n\t\treturn -1;\n\n\tret = sscanf(map, \"%c:%ld:%ld:%ld\", &which, &ns_id, &host_id, &range);\n\tif (ret != 4)\n\t\treturn -1;\n\n\tif (which != 'b' && which != 'u' && which != 'g')\n\t\treturn -1;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (which != types[i] && which != 'b')\n\t\t\tcontinue;\n\n\t\tnewmap = malloc(sizeof(*newmap));\n\t\tif (!newmap)\n\t\t\treturn -1;\n\n\t\tnewmap->hostid = host_id;\n\t\tnewmap->nsid = ns_id;\n\t\tnewmap->range = range;\n\n\t\tif (types[i] == 'u')\n\t\t\tnewmap->idtype = ID_TYPE_UID;\n\t\telse\n\t\t\tnewmap->idtype = ID_TYPE_GID;\n\n\t\ttmp = malloc(sizeof(*tmp));\n\t\tif (!tmp) {\n\t\t\tfree(newmap);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp->elem = newmap;\n\t\tlxc_list_add_tail(&active_map, tmp);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "104-134",
    "snippet": "static int do_child(void *vargv)\n{\n\tchar **argv = (char **)vargv;\n\n\t// Assume we want to become root\n\tif (setgid(0) < 0) {\n\t\tperror(\"setgid\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tperror(\"setuid\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0) {\n\t\tperror(\"setgroups\");\n\t\treturn -1;\n\t}\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tperror(\"unshare CLONE_NEWNS\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tprintf(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\texecvp(argv[0], argv);\n\tperror(\"execvpe\");\n\treturn -1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MS_SLAVE (1 << 19)",
      "#define MS_REC 16384"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvpe\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "argv"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to make / rslave\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE|MS_REC",
            "NULL"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "mount_entry_on_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/conf.c",
          "lines": "1838-1869",
          "snippet": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <../include/lxcmntent.h>",
            "#include <sys/personality.h>",
            "#include <sys/capability.h>",
            "#include \"lsm/lsm.h\"",
            "#include \"utils.h\"",
            "#include \"parse.h\"",
            "#include \"network.h\"",
            "#include \"namespace.h\"",
            "#include \"lxcseccomp.h\"",
            "#include \"lxcoverlay.h\"",
            "#include \"lxclock.h\"",
            "#include \"lxcaufs.h\"",
            "#include \"log.h\"",
            "#include \"error.h\"",
            "#include \"conf.h\"",
            "#include \"cgroup.h\"",
            "#include \"caps.h\"       /* for lxc_caps_last_cap() */",
            "#include \"bdev.h\"",
            "#include \"af_unix.h\"",
            "#include <linux/memfd.h>",
            "#include <../include/openpty.h>",
            "#include <pty.h>",
            "#include <sys/statvfs.h>",
            "#    include <sys/sysmacros.h>",
            "#    include <sys/mkdev.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/loop.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <libgen.h>",
            "#include <inttypes.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <../include/lxcmntent.h>\n#include <sys/personality.h>\n#include <sys/capability.h>\n#include \"lsm/lsm.h\"\n#include \"utils.h\"\n#include \"parse.h\"\n#include \"network.h\"\n#include \"namespace.h\"\n#include \"lxcseccomp.h\"\n#include \"lxcoverlay.h\"\n#include \"lxclock.h\"\n#include \"lxcaufs.h\"\n#include \"log.h\"\n#include \"error.h\"\n#include \"conf.h\"\n#include \"cgroup.h\"\n#include \"caps.h\"       /* for lxc_caps_last_cap() */\n#include \"bdev.h\"\n#include \"af_unix.h\"\n#include <linux/memfd.h>\n#include <../include/openpty.h>\n#include <pty.h>\n#include <sys/statvfs.h>\n#    include <sys/sysmacros.h>\n#    include <sys/mkdev.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/loop.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nstatic inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const struct lxc_rootfs *rootfs,\n\t\t const char *lxc_name, const char *lxc_path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tbool dev = hasmntopt(mntent, \"dev\") != NULL;\n\n\tchar *rootfs_path = NULL;\n\tif (rootfs && rootfs->path)\n\t\trootfs_path = rootfs->mount;\n\n\tret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,\n\t\t\t  mntdata, optional, dev, rootfs_path);\n\n\tfree(mntdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_shared_rootfs",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "detect_shared_rootfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "1102-1132",
          "snippet": "int detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint detect_shared_rootfs(void)\n{\n\tchar buf[LXC_LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LXC_LINELEN, f)) {\n\t\tfor (p = buf, i = 0; p && i < 4; i++)\n\t\t\tp = strchr(p + 1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p + 1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p + 1, \"/\") == 0) {\n\t\t\t// this is '/'.  is it shared?\n\t\t\tp = strchr(p2 + 1, ' ');\n\t\t\tif (p && strstr(p, \"shared:\")) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"unshare CLONE_NEWNS\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWNS"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "unshare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.h",
          "lines": "73-81",
          "snippet": "static inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <stdint.h>",
            "#  include <sys/signalfd.h>",
            "#include <../include/getline.h>",
            "#include \"initutils.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <stdbool.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#  include <sys/signalfd.h>\n#include <../include/getline.h>\n#include \"initutils.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic inline int unshare(int flags)\n{\n#ifdef __NR_unshare\n\treturn syscall(__NR_unshare, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setgroups\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgroups",
          "args": [
            "0",
            "NULL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_setgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "2063-2072",
          "snippet": "int lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_setgroups(int size, gid_t list[])\n{\n\tif (setgroups(size, list) < 0) {\n\t\tSYSERROR(\"Failed to setgroups().\");\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Dropped additional groups.\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setuid\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setgid\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define MS_SLAVE (1 << 19)\n#define MS_REC 16384\n\nstatic int do_child(void *vargv)\n{\n\tchar **argv = (char **)vargv;\n\n\t// Assume we want to become root\n\tif (setgid(0) < 0) {\n\t\tperror(\"setgid\");\n\t\treturn -1;\n\t}\n\tif (setuid(0) < 0) {\n\t\tperror(\"setuid\");\n\t\treturn -1;\n\t}\n\tif (setgroups(0, NULL) < 0) {\n\t\tperror(\"setgroups\");\n\t\treturn -1;\n\t}\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tperror(\"unshare CLONE_NEWNS\");\n\t\treturn -1;\n\t}\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tprintf(\"Failed to make / rslave\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\texecvp(argv[0], argv);\n\tperror(\"execvpe\");\n\treturn -1;\n}"
  },
  {
    "function_name": "opentty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "77-101",
    "snippet": "static void opentty(const char * tty, int which) {\n\tint fd, flags;\n\n\tif (tty[0] == '\\0')\n\t\treturn;\n\n\tfd = open(tty, O_RDWR | O_NONBLOCK);\n\tif (fd == -1) {\n\t\tprintf(\"WARN: could not reopen tty: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tflags &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) < 0) {\n\t\tprintf(\"WARN: could not set fd flags: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tclose(which);\n\tif (fd != which) {\n\t\tdup2(fd, which);\n\t\tclose(fd);\n\t}\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int unshare(int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "which"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARN: could not set fd flags: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "flags"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARN: could not reopen tty: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "tty",
            "O_RDWR | O_NONBLOCK"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "opentty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
          "lines": "77-101",
          "snippet": "static void opentty(const char * tty, int which) {\n\tint fd, flags;\n\n\tif (tty[0] == '\\0')\n\t\treturn;\n\n\tfd = open(tty, O_RDWR | O_NONBLOCK);\n\tif (fd == -1) {\n\t\tprintf(\"WARN: could not reopen tty: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tflags &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) < 0) {\n\t\tprintf(\"WARN: could not set fd flags: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tclose(which);\n\tif (fd != which) {\n\t\tdup2(fd, which);\n\t\tclose(fd);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint unshare(int flags);\n\nstatic void opentty(const char * tty, int which) {\n\tint fd, flags;\n\n\tif (tty[0] == '\\0')\n\t\treturn;\n\n\tfd = open(tty, O_RDWR | O_NONBLOCK);\n\tif (fd == -1) {\n\t\tprintf(\"WARN: could not reopen tty: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tflags &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) < 0) {\n\t\tprintf(\"WARN: could not set fd flags: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tclose(which);\n\tif (fd != which) {\n\t\tdup2(fd, which);\n\t\tclose(fd);\n\t}\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/tools/lxc_usernsexec.c",
    "lines": "58-75",
    "snippet": "static void usage(const char *name)\n{\n\tprintf(\"usage: %s [-h] [-m <uid-maps>] -- [command [arg ..]]\\n\", name);\n\tprintf(\"\\n\");\n\tprintf(\"  -h            this message\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -m <uid-maps> uid maps to use\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  uid-maps: [u|g|b]:ns_id:host_id:range\\n\");\n\tprintf(\"            [u|g|b]: map user id, group id, or both\\n\");\n\tprintf(\"            ns_id: the base id in the new namespace\\n\");\n\tprintf(\"            host_id: the base id in the parent namespace\\n\");\n\tprintf(\"            range: how many ids to map\\n\");\n\tprintf(\"  Note: This program uses newuidmap(2) and newgidmap(2).\\n\");\n\tprintf(\"        As such, /etc/subuid and /etc/subgid must grant the\\n\");\n\tprintf(\"        calling user permission to use the mapped ranges\\n\");\n\texit(EXIT_SUCCESS);\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"namespace.h\"",
      "#include \"conf.h\"",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <sched.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <sys/syscall.h>",
      "#include <sched.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"        calling user permission to use the mapped ranges\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"        As such, /etc/subuid and /etc/subgid must grant the\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  Note: This program uses newuidmap(2) and newgidmap(2).\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"            range: how many ids to map\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"            host_id: the base id in the parent namespace\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"            ns_id: the base id in the new namespace\\n\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"            [u|g|b]: map user id, group id, or both\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  uid-maps: [u|g|b]:ns_id:host_id:range\\n\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -m <uid-maps> uid maps to use\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h            this message\\n\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usage: %s [-h] [-m <uid-maps>] -- [command [arg ..]]\\n\"",
            "name"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"namespace.h\"\n#include \"conf.h\"\n#include <grp.h>\n#include <pwd.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatic void usage(const char *name)\n{\n\tprintf(\"usage: %s [-h] [-m <uid-maps>] -- [command [arg ..]]\\n\", name);\n\tprintf(\"\\n\");\n\tprintf(\"  -h            this message\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  -m <uid-maps> uid maps to use\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"  uid-maps: [u|g|b]:ns_id:host_id:range\\n\");\n\tprintf(\"            [u|g|b]: map user id, group id, or both\\n\");\n\tprintf(\"            ns_id: the base id in the new namespace\\n\");\n\tprintf(\"            host_id: the base id in the parent namespace\\n\");\n\tprintf(\"            range: how many ids to map\\n\");\n\tprintf(\"  Note: This program uses newuidmap(2) and newgidmap(2).\\n\");\n\tprintf(\"        As such, /etc/subuid and /etc/subgid must grant the\\n\");\n\tprintf(\"        calling user permission to use the mapped ranges\\n\");\n\texit(EXIT_SUCCESS);\n}"
  }
]