[
  {
    "function_name": "hasmntopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "175-193",
    "snippet": "char *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rest",
            "opt"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opt"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nchar *hasmntopt (const struct mntent *mnt, const char *opt)\n{\n    const size_t optlen = strlen (opt);\n    char *rest = mnt->mnt_opts, *p;\n\n    while ((p = strstr (rest, opt)) != NULL)\n    {\n        if ((p == rest || p[-1] == ',')\n            && (p[optlen] == '\\0' || p[optlen] == '=' || p[optlen] == ','))\n            return p;\n\n        rest = strchr (p, ',');\n        if (rest == NULL)\n            break;\n        ++rest;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "endmntent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "166-171",
    "snippet": "int endmntent (FILE *stream)\n{\n    if (stream) /* SunOS 4.x allows for NULL stream */\n    fclose (stream);\n    return 1; /* SunOS 4.x says to always return 1 */\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stream"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nint endmntent (FILE *stream)\n{\n    if (stream) /* SunOS 4.x allows for NULL stream */\n    fclose (stream);\n    return 1; /* SunOS 4.x says to always return 1 */\n}"
  },
  {
    "function_name": "setmntent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "151-162",
    "snippet": "FILE *setmntent (const char *file, const char *mode)\n{\n    /* Extend the mode parameter with \"c\" to disable cancellation in the\n    I/O functions and \"e\" to set FD_CLOEXEC. */\n    size_t modelen = strlen (mode);\n    char newmode[modelen + 3];\n    memcpy (newmode, mode, modelen);\n    memcpy (newmode + modelen, \"ce\", 3);\n    FILE *result = fopen (file, newmode);\n\n    return result;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "newmode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "fopen_cloexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/initutils.c",
          "lines": "256-298",
          "snippet": "FILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"initutils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"initutils.h\"\n\nFILE *fopen_cloexec(const char *path, const char *mode)\n{\n\tint open_mode = 0;\n\tint step = 0;\n\tint fd;\n\tint saved_errno = 0;\n\tFILE *ret;\n\n\tif (!strncmp(mode, \"r+\", 2)) {\n\t\topen_mode = O_RDWR;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"r\", 1)) {\n\t\topen_mode = O_RDONLY;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"w+\", 2)) {\n\t\topen_mode = O_RDWR | O_TRUNC | O_CREAT;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"w\", 1)) {\n\t\topen_mode = O_WRONLY | O_TRUNC | O_CREAT;\n\t\tstep = 1;\n\t} else if (!strncmp(mode, \"a+\", 2)) {\n\t\topen_mode = O_RDWR | O_CREAT | O_APPEND;\n\t\tstep = 2;\n\t} else if (!strncmp(mode, \"a\", 1)) {\n\t\topen_mode = O_WRONLY | O_CREAT | O_APPEND;\n\t\tstep = 1;\n\t}\n\tfor (; mode[step]; step++)\n\t\tif (mode[step] == 'x')\n\t\t\topen_mode |= O_EXCL;\n\topen_mode |= O_CLOEXEC;\n\n\tfd = open(path, open_mode, 0666);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tret = fdopen(fd, mode);\n\tsaved_errno = errno;\n\tif (!ret)\n\t\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newmode + modelen",
            "\"ce\"",
            "3"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newmode",
            "mode",
            "modelen"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nFILE *setmntent (const char *file, const char *mode)\n{\n    /* Extend the mode parameter with \"c\" to disable cancellation in the\n    I/O functions and \"e\" to set FD_CLOEXEC. */\n    size_t modelen = strlen (mode);\n    char newmode[modelen + 3];\n    memcpy (newmode, mode, modelen);\n    memcpy (newmode + modelen, \"ce\", 3);\n    FILE *result = fopen (file, newmode);\n\n    return result;\n}"
  },
  {
    "function_name": "getmntent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "134-146",
    "snippet": "struct mntent *getmntent (FILE *stream)\n{\n    static struct mntent m;\n    static char *getmntent_buffer;\n\n    #define BUFFER_SIZE 4096\n    if (getmntent_buffer == NULL) {\n        getmntent_buffer = (char *) malloc (BUFFER_SIZE);\n    }\n\n    return getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);\n    #undef BUFFER_SIZE\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define BUFFER_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getmntent_r",
          "args": [
            "stream",
            "&m",
            "getmntent_buffer",
            "BUFFER_SIZE"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "getmntent_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "76-132",
          "snippet": "struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstruct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "BUFFER_SIZE"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\n#define BUFFER_SIZE 4096\n\nstruct mntent *getmntent (FILE *stream)\n{\n    static struct mntent m;\n    static char *getmntent_buffer;\n\n    #define BUFFER_SIZE 4096\n    if (getmntent_buffer == NULL) {\n        getmntent_buffer = (char *) malloc (BUFFER_SIZE);\n    }\n\n    return getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);\n    #undef BUFFER_SIZE\n}"
  },
  {
    "function_name": "getmntent_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "76-132",
    "snippet": "struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "head",
            "\" %d %d \"",
            "&mp->mnt_freq",
            "&mp->mnt_passno"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_name",
          "args": [
            "cp"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "decode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
          "lines": "29-71",
          "snippet": "static char *\ndecode_name (char *buf)\n{\n    char *rp = buf;\n    char *wp = buf;\n\n    do\n    if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')\n    {\n        /* \\040 is a SPACE. */\n        *wp++ = ' ';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')\n    {\n        /* \\011 is a TAB. */\n        *wp++ = '\\t';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')\n    {\n        /* \\012 is a NEWLINE. */\n        *wp++ = '\\n';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '\\\\')\n    {\n        /* We have to escape \\\\ to be able to represent all characters. */\n        *wp++ = '\\\\';\n        rp += 1;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')\n    {\n        /* \\134 is also \\\\. */\n        *wp++ = '\\\\';\n        rp += 3;\n    }\n    else\n        *wp++ = *rp;\n    while (*rp++ != '\\0');\n\n    return buf;\n}",
          "includes": [
            "#include <mntent.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic char *\ndecode_name (char *buf)\n{\n    char *rp = buf;\n    char *wp = buf;\n\n    do\n    if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')\n    {\n        /* \\040 is a SPACE. */\n        *wp++ = ' ';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')\n    {\n        /* \\011 is a TAB. */\n        *wp++ = '\\t';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')\n    {\n        /* \\012 is a NEWLINE. */\n        *wp++ = '\\n';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '\\\\')\n    {\n        /* We have to escape \\\\ to be able to represent all characters. */\n        *wp++ = '\\\\';\n        rp += 1;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')\n    {\n        /* \\134 is also \\\\. */\n        *wp++ = '\\\\';\n        rp += 3;\n    }\n    else\n        *wp++ = *rp;\n    while (*rp++ != '\\0');\n\n    return buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&head",
            "\" \\t\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "head",
            "\" \\t\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&head",
            "\" \\t\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "head",
            "\" \\t\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&head",
            "\" \\t\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "head",
            "\" \\t\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&head",
            "\" \\t\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "buffer",
            "\" \\t\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'\\n'"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "strchrnul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/getsubopt.c",
          "lines": "28-40",
          "snippet": "char *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\nchar *strchrnul(const char *s, int c)\n{\n    char *result;\n\n    result = strchr( s, c );\n\n    if( !result )\n    {\n        result = (char *)s + strlen( s );\n    }\n\n    return( result );\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "sizeof tmp",
            "stream"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buffer",
            "bufsiz",
            "stream"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstruct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)\n{\n    char *cp;\n    char *head;\n\n    do\n    {\n        char *end_ptr;\n\n        if (fgets (buffer, bufsiz, stream) == NULL)\n        {\n            return NULL;\n        }\n\n        end_ptr = strchr (buffer, '\\n');\n        if (end_ptr != NULL) /* chop newline */\n            *end_ptr = '\\0';\n        else\n        {\n            /* Not the whole line was read. Do it now but forget it. */\n            char tmp[1024];\n            while (fgets (tmp, sizeof tmp, stream) != NULL)\n                if (strchr (tmp, '\\n') != NULL)\n                    break;\n        }\n\n        head = buffer + strspn (buffer, \" \\t\");\n        /* skip empty lines and comment lines: */\n    }\n    while (head[0] == '\\0' || head[0] == '#');\n\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) \"\";\n    if (head)\n        head += strspn (head, \" \\t\");\n    cp = strsep (&head, \" \\t\");\n    mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) \"\";\n    switch (head ? sscanf (head, \" %d %d \", &mp->mnt_freq, &mp->mnt_passno) : 0)\n    {\n        case 0:\n            mp->mnt_freq = 0;\n        case 1:\n            mp->mnt_passno = 0;\n        case 2:\n            break;\n    }\n\n    return mp;\n}"
  },
  {
    "function_name": "decode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/include/lxcmntent.c",
    "lines": "29-71",
    "snippet": "static char *\ndecode_name (char *buf)\n{\n    char *rp = buf;\n    char *wp = buf;\n\n    do\n    if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')\n    {\n        /* \\040 is a SPACE. */\n        *wp++ = ' ';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')\n    {\n        /* \\011 is a TAB. */\n        *wp++ = '\\t';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')\n    {\n        /* \\012 is a NEWLINE. */\n        *wp++ = '\\n';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '\\\\')\n    {\n        /* We have to escape \\\\ to be able to represent all characters. */\n        *wp++ = '\\\\';\n        rp += 1;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')\n    {\n        /* \\134 is also \\\\. */\n        *wp++ = '\\\\';\n        rp += 3;\n    }\n    else\n        *wp++ = *rp;\n    while (*rp++ != '\\0');\n\n    return buf;\n}",
    "includes": [
      "#include <mntent.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mntent.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic char *\ndecode_name (char *buf)\n{\n    char *rp = buf;\n    char *wp = buf;\n\n    do\n    if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')\n    {\n        /* \\040 is a SPACE. */\n        *wp++ = ' ';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')\n    {\n        /* \\011 is a TAB. */\n        *wp++ = '\\t';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')\n    {\n        /* \\012 is a NEWLINE. */\n        *wp++ = '\\n';\n        rp += 3;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '\\\\')\n    {\n        /* We have to escape \\\\ to be able to represent all characters. */\n        *wp++ = '\\\\';\n        rp += 1;\n    }\n    else if (rp[0] == '\\\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')\n    {\n        /* \\134 is also \\\\. */\n        *wp++ = '\\\\';\n        rp += 3;\n    }\n    else\n        *wp++ = *rp;\n    while (*rp++ != '\\0');\n\n    return buf;\n}"
  }
]