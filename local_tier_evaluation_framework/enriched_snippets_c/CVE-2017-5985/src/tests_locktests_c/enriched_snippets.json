[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/locktests.c",
    "lines": "96-139",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lxc/lock/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include \"config.h\"",
      "#include \"lxc/lxclock.h\""
    ],
    "macros_used": [
      "#define mycontainername \"lxctest.sem\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"all tests passed\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_two_locks",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "test_two_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/locktests.c",
          "lines": "31-94",
          "snippet": "static void test_two_locks(void)\n{\n\tstruct lxc_lock *l;\n\tpid_t pid;\n\tint ret, status;\n\tint p[2];\n\tchar c;\n\n\tif (pipe(p) < 0)\n\t\texit(1);\n\tif ((pid = fork()) < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\tif (read(p[0], &c, 1) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(1);\n\t\t}\n\t\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\t\tif (!l) {\n\t\t\tfprintf(stderr, \"%d: child: failed to create lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tif (lxclock(l, 0) < 0) {\n\t\t\tfprintf(stderr, \"%d: child: failed to grab lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(stderr, \"%d: child: grabbed lock\\n\", __LINE__);\n\t\texit(0);\n\t}\n\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\tif (!l) {\n\t\tfprintf(stderr, \"%d: failed to create lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (lxclock(l, 0) < 0) {\n\t\tfprintf(stderr, \"%d; failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (write(p[1], \"a\", 1) < 0) {\n\t\tperror(\"write\");\n\t\texit(1);\n\t}\n\tsleep(3);\n\tret = waitpid(pid, &status, WNOHANG);\n\tif (ret == pid) { // task exited\n\t\tif (WIFEXITED(status)) {\n\t\t\tprintf(\"%d exited normally with exit code %d\\n\", pid,\n\t\t\t\tWEXITSTATUS(status));\n\t\t\tif (WEXITSTATUS(status) == 0)\n\t\t\t\texit(1);\n\t\t} else\n\t\t\tprintf(\"%d did not exit normally\\n\", pid);\n\t\treturn;\n\t} else if (ret < 0) {\n\t\tperror(\"waitpid\");\n\t\texit(1);\n\t}\n\tkill(pid, SIGKILL);\n\twait(&status);\n\tclose(p[1]);\n\tclose(p[0]);\n\tlxcunlock(l);\n\tlxc_putlock(l);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include \"config.h\"",
            "#include \"lxc/lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include \"config.h\"\n#include \"lxc/lxclock.h\"\n\nstatic void test_two_locks(void)\n{\n\tstruct lxc_lock *l;\n\tpid_t pid;\n\tint ret, status;\n\tint p[2];\n\tchar c;\n\n\tif (pipe(p) < 0)\n\t\texit(1);\n\tif ((pid = fork()) < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\tif (read(p[0], &c, 1) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(1);\n\t\t}\n\t\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\t\tif (!l) {\n\t\t\tfprintf(stderr, \"%d: child: failed to create lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tif (lxclock(l, 0) < 0) {\n\t\t\tfprintf(stderr, \"%d: child: failed to grab lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(stderr, \"%d: child: grabbed lock\\n\", __LINE__);\n\t\texit(0);\n\t}\n\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\tif (!l) {\n\t\tfprintf(stderr, \"%d: failed to create lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (lxclock(l, 0) < 0) {\n\t\tfprintf(stderr, \"%d; failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (write(p[1], \"a\", 1) < 0) {\n\t\tperror(\"write\");\n\t\texit(1);\n\t}\n\tsleep(3);\n\tret = waitpid(pid, &status, WNOHANG);\n\tif (ret == pid) { // task exited\n\t\tif (WIFEXITED(status)) {\n\t\t\tprintf(\"%d exited normally with exit code %d\\n\", pid,\n\t\t\t\tWEXITSTATUS(status));\n\t\t\tif (WEXITSTATUS(status) == 0)\n\t\t\t\texit(1);\n\t\t} else\n\t\t\tprintf(\"%d did not exit normally\\n\", pid);\n\t\treturn;\n\t} else if (ret < 0) {\n\t\tperror(\"waitpid\");\n\t\texit(1);\n\t}\n\tkill(pid, SIGKILL);\n\twait(&status);\n\tclose(p[1]);\n\tclose(p[0]);\n\tlxcunlock(l);\n\tlxc_putlock(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxc_putlock",
          "args": [
            "lock"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_putlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "291-313",
          "snippet": "void lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: filename %s not created\\n\"",
            "__LINE__",
            "pathname"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "pathname",
            "&sb"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "Container_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "599-603",
          "snippet": "static PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic PyObject *\nContainer_state(Container *self, void *closure)\n{\n    return PyUnicode_FromString(self->container->state(self->container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to get lock\\n\"",
            "__LINE__"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_newlock",
          "args": [
            "\"/var/lib/lxc\"",
            "mycontainername"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_newlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "161-190",
          "snippet": "struct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstruct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to put unnamed lock (%d)\\n\"",
            "__LINE__",
            "ret"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcunlock",
          "args": [
            "lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "lxcunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "250-282",
          "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to take unnamed lock (%d)\\n\"",
            "__LINE__",
            "ret"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxclock",
          "args": [
            "lock",
            "0"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "lxclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "192-248",
          "snippet": "int lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to get unnamed lock\\n\"",
            "__LINE__"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include \"config.h\"\n#include \"lxc/lxclock.h\"\n\n#define mycontainername \"lxctest.sem\"\n\nint main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lxc/lock/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}"
  },
  {
    "function_name": "test_two_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/tests/locktests.c",
    "lines": "31-94",
    "snippet": "static void test_two_locks(void)\n{\n\tstruct lxc_lock *l;\n\tpid_t pid;\n\tint ret, status;\n\tint p[2];\n\tchar c;\n\n\tif (pipe(p) < 0)\n\t\texit(1);\n\tif ((pid = fork()) < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\tif (read(p[0], &c, 1) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(1);\n\t\t}\n\t\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\t\tif (!l) {\n\t\t\tfprintf(stderr, \"%d: child: failed to create lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tif (lxclock(l, 0) < 0) {\n\t\t\tfprintf(stderr, \"%d: child: failed to grab lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(stderr, \"%d: child: grabbed lock\\n\", __LINE__);\n\t\texit(0);\n\t}\n\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\tif (!l) {\n\t\tfprintf(stderr, \"%d: failed to create lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (lxclock(l, 0) < 0) {\n\t\tfprintf(stderr, \"%d; failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (write(p[1], \"a\", 1) < 0) {\n\t\tperror(\"write\");\n\t\texit(1);\n\t}\n\tsleep(3);\n\tret = waitpid(pid, &status, WNOHANG);\n\tif (ret == pid) { // task exited\n\t\tif (WIFEXITED(status)) {\n\t\t\tprintf(\"%d exited normally with exit code %d\\n\", pid,\n\t\t\t\tWEXITSTATUS(status));\n\t\t\tif (WEXITSTATUS(status) == 0)\n\t\t\t\texit(1);\n\t\t} else\n\t\t\tprintf(\"%d did not exit normally\\n\", pid);\n\t\treturn;\n\t} else if (ret < 0) {\n\t\tperror(\"waitpid\");\n\t\texit(1);\n\t}\n\tkill(pid, SIGKILL);\n\twait(&status);\n\tclose(p[1]);\n\tclose(p[0]);\n\tlxcunlock(l);\n\tlxc_putlock(l);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include \"config.h\"",
      "#include \"lxc/lxclock.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxc_putlock",
          "args": [
            "l"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_putlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "291-313",
          "snippet": "void lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nvoid lxc_putlock(struct lxc_lock *l)\n{\n\tif (!l)\n\t\treturn;\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (l->u.sem) {\n\t\t\tsem_destroy(l->u.sem);\n\t\t\tfree(l->u.sem);\n\t\t\tl->u.sem = NULL;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t}\n\t\tfree(l->u.f.fname);\n\t\tl->u.f.fname = NULL;\n\t\tbreak;\n\t}\n\tfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcunlock",
          "args": [
            "l"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "lxcunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "250-282",
          "snippet": "int lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxcunlock(struct lxc_lock *l)\n{\n\tint ret = 0, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!l->u.sem)\n\t\t\tret = -2;\n\t\telse {\n\t\t\tret = sem_post(l->u.sem);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tif (l->u.f.fd != -1) {\n\t\t\tlk.l_type = F_UNLCK;\n\t\t\tlk.l_whence = SEEK_SET;\n\t\t\tlk.l_start = 0;\n\t\t\tlk.l_len = 0;\n\t\t\tret = fcntl(l->u.f.fd, F_SETLK, &lk);\n\t\t\tif (ret < 0)\n\t\t\t\tsaved_errno = errno;\n\t\t\tclose(l->u.f.fd);\n\t\t\tl->u.f.fd = -1;\n\t\t} else\n\t\t\tret = -2;\n\t\tbreak;\n\t}\n\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[0]"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_abstract_unix_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/af_unix.c",
          "lines": "84-96",
          "snippet": "int lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include \"config.h\"\n\nint lxc_abstract_unix_close(int fd)\n{\n\tstruct sockaddr_un addr;\n\tsocklen_t addrlen = sizeof(addr);\n\n\tif (!getsockname(fd, (struct sockaddr *)&addr, &addrlen) &&\n\t\t\taddr.sun_path[0])\n\t\tunlink(addr.sun_path);\n\n\tclose(fd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "&status"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_wait_for_pid_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/python-lxc/lxc.c",
          "lines": "67-81",
          "snippet": "static int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}",
          "includes": [
            "#include <sched.h>",
            "#include <sys/wait.h>",
            "#include <stdio.h>",
            "#include <lxc/lxccontainer.h>",
            "#include \"structmember.h\"",
            "#include <Python.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sched.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <lxc/lxccontainer.h>\n#include \"structmember.h\"\n#include <Python.h>\n\nstatic int lxc_wait_for_pid_status(pid_t pid)\n{\n    int status, ret;\n\nagain:\n    ret = waitpid(pid, &status, 0);\n    if (ret == -1) {\n        if (errno == EINTR)\n            goto again;\n        return -1;\n    }\n    if (ret != pid)\n        goto again;\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGKILL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"waitpid\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d did not exit normally\\n\"",
            "pid"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d exited normally with exit code %d\\n\"",
            "pid",
            "WEXITSTATUS(status)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "3"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_util_usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lua-lxc/core.c",
          "lines": "564-567",
          "snippet": "static int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}",
          "includes": [
            "#include \"lxc/commands.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <lauxlib.h>",
            "#include <lua.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lxc/commands.h\"\n#include <lxc/lxccontainer.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <lauxlib.h>\n#include <lua.h>\n\nstatic int lxc_util_usleep(lua_State *L) {\n    usleep((useconds_t)luaL_checkunsigned(L, 1));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"write\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "p[1]",
            "\"a\"",
            "1"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_write_nointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "327-335",
          "snippet": "ssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nssize_t lxc_write_nointr(int fd, const void* buf, size_t count)\n{\n\tssize_t ret;\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d; failed to get lock\\n\"",
            "__LINE__"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxclock",
          "args": [
            "l",
            "0"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "lxclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "192-248",
          "snippet": "int lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nint lxclock(struct lxc_lock *l, int timeout)\n{\n\tint ret = -1, saved_errno = errno;\n\tstruct flock lk;\n\n\tswitch(l->type) {\n\tcase LXC_LOCK_ANON_SEM:\n\t\tif (!timeout) {\n\t\t\tret = sem_wait(l->u.sem);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tif (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n\t\t\t\tret = -2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tts.tv_sec += timeout;\n\t\t\tret = sem_timedwait(l->u.sem, &ts);\n\t\t\tif (ret == -1)\n\t\t\t\tsaved_errno = errno;\n\t\t}\n\t\tbreak;\n\tcase LXC_LOCK_FLOCK:\n\t\tret = -2;\n\t\tif (timeout) {\n\t\t\tERROR(\"Error: timeout not supported with flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!l->u.f.fname) {\n\t\t\tERROR(\"Error: filename not set for flock\");\n\t\t\tret = -2;\n\t\t\tgoto out;\n\t\t}\n\t\tif (l->u.f.fd == -1) {\n\t\t\tl->u.f.fd = open(l->u.f.fname, O_RDWR|O_CREAT,\n\t\t\t\t\tS_IWUSR | S_IRUSR);\n\t\t\tif (l->u.f.fd == -1) {\n\t\t\t\tERROR(\"Error opening %s\", l->u.f.fname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlk.l_type = F_WRLCK;\n\t\tlk.l_whence = SEEK_SET;\n\t\tlk.l_start = 0;\n\t\tlk.l_len = 0;\n\t\tret = fcntl(l->u.f.fd, F_SETLKW, &lk);\n\t\tif (ret == -1)\n\t\t\tsaved_errno = errno;\n\t\tbreak;\n\t}\n\nout:\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: failed to create lock\\n\"",
            "__LINE__"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxc_newlock",
          "args": [
            "\"/tmp\"",
            "\"lxctest-sem\""
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_newlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "161-190",
          "snippet": "struct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\nstruct lxc_lock *lxc_newlock(const char *lxcpath, const char *name)\n{\n\tstruct lxc_lock *l;\n\n\tl = malloc(sizeof(*l));\n\tif (!l)\n\t\tgoto out;\n\n\tif (!name) {\n\t\tl->type = LXC_LOCK_ANON_SEM;\n\t\tl->u.sem = lxc_new_unnamed_sem();\n\t\tif (!l->u.sem) {\n\t\t\tfree(l);\n\t\t\tl = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tl->type = LXC_LOCK_FLOCK;\n\tl->u.f.fname = lxclock_name(lxcpath, name);\n\tif (!l->u.f.fname) {\n\t\tfree(l);\n\t\tl = NULL;\n\t\tgoto out;\n\t}\n\tl->u.f.fd = -1;\n\nout:\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: child: grabbed lock\\n\"",
            "__LINE__"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: child: failed to grab lock\\n\"",
            "__LINE__"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d: child: failed to create lock\\n\"",
            "__LINE__"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"read\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "p[0]",
            "&c",
            "1"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "lxc_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/utils.c",
          "lines": "962-990",
          "snippet": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}",
          "includes": [
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include \"utils.h\"",
            "#include \"namespace.h\"",
            "#include \"lxclock.h\"",
            "#include \"log.h\"",
            "#include <sys/wait.h>",
            "#include <sys/vfs.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/prctl.h>",
            "#include <sys/param.h>",
            "#include <sys/mount.h>",
            "#include <sys/mman.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <libgen.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include \"utils.h\"\n#include \"namespace.h\"\n#include \"lxclock.h\"\n#include \"log.h\"\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/prctl.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <libgen.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nint lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_setup_atfork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5985/repo/src/lxc/lxclock.c",
          "lines": "335-339",
          "snippet": "__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}",
          "includes": [
            "#include <execinfo.h>",
            "#include \"log.h\"",
            "#include \"utils.h\"",
            "#include <lxc/lxccontainer.h>",
            "#include <pthread.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <malloc.h>",
            "#include \"lxclock.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n#include \"log.h\"\n#include \"utils.h\"\n#include <lxc/lxccontainer.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <malloc.h>\n#include \"lxclock.h\"\n\n__attribute__((constructor))\nstatic void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(process_lock, process_unlock, process_unlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include \"config.h\"\n#include \"lxc/lxclock.h\"\n\nstatic void test_two_locks(void)\n{\n\tstruct lxc_lock *l;\n\tpid_t pid;\n\tint ret, status;\n\tint p[2];\n\tchar c;\n\n\tif (pipe(p) < 0)\n\t\texit(1);\n\tif ((pid = fork()) < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\tif (read(p[0], &c, 1) < 0) {\n\t\t\tperror(\"read\");\n\t\t\texit(1);\n\t\t}\n\t\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\t\tif (!l) {\n\t\t\tfprintf(stderr, \"%d: child: failed to create lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tif (lxclock(l, 0) < 0) {\n\t\t\tfprintf(stderr, \"%d: child: failed to grab lock\\n\", __LINE__);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(stderr, \"%d: child: grabbed lock\\n\", __LINE__);\n\t\texit(0);\n\t}\n\tl = lxc_newlock(\"/tmp\", \"lxctest-sem\");\n\tif (!l) {\n\t\tfprintf(stderr, \"%d: failed to create lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (lxclock(l, 0) < 0) {\n\t\tfprintf(stderr, \"%d; failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tif (write(p[1], \"a\", 1) < 0) {\n\t\tperror(\"write\");\n\t\texit(1);\n\t}\n\tsleep(3);\n\tret = waitpid(pid, &status, WNOHANG);\n\tif (ret == pid) { // task exited\n\t\tif (WIFEXITED(status)) {\n\t\t\tprintf(\"%d exited normally with exit code %d\\n\", pid,\n\t\t\t\tWEXITSTATUS(status));\n\t\t\tif (WEXITSTATUS(status) == 0)\n\t\t\t\texit(1);\n\t\t} else\n\t\t\tprintf(\"%d did not exit normally\\n\", pid);\n\t\treturn;\n\t} else if (ret < 0) {\n\t\tperror(\"waitpid\");\n\t\texit(1);\n\t}\n\tkill(pid, SIGKILL);\n\twait(&status);\n\tclose(p[1]);\n\tclose(p[0]);\n\tlxcunlock(l);\n\tlxc_putlock(l);\n}"
  }
]