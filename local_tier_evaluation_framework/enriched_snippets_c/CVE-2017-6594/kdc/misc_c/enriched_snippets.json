[
  {
    "function_name": "kdc_get_preferred_key(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
    "lines": "175-220",
    "snippet": "rb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "INVAL,",
            "No valid kerberos key found for %s\",",
            "ame)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "h->entry,",
            "ULL,",
            "->entry.keys.val[i].key.keytype,",
            "ey)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_weak_exception(",
          "args": [
            "->entry.principal,",
            "->entry.keys.val[i].key.keytype)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_is_weak_exception(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "90-100",
          "snippet": "rb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "->entry.keys.val[i].key.keytype)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "h->entry,",
            "ULL,",
            "[i],",
            "ey)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "[i])"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kerberos_enctypes(",
          "args": [
            "ontext)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}"
  },
  {
    "function_name": "kdc_free_ent(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
    "lines": "163-168",
    "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree",
          "args": [
            "nt)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_free_entry",
          "args": [
            "ontext,",
            "nt)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
  },
  {
    "function_name": "kdc_db_fetch(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
    "lines": "54-161",
    "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nt)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "nterprise_principal)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "no such entry found in hdb\")"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onfig->db[i]->hdb_close",
          "args": [
            "ontext,",
            "onfig->db[i])"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onfig->db[i]->hdb_fetch_kvno",
          "args": [
            "ontext,",
            "onfig->db[i],",
            "rinc,",
            "lags | HDB_F_DECRYPT,",
            "vno,",
            "nt)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed to open database: %s\",",
            "sg)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onfig->db[i]->hdb_open",
          "args": [
            "ontext,",
            "onfig->db[i],",
            "_RDONLY,",
            ")"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "rincipal->name.name_string.val[0],",
            "enterprise_principal)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malformed request: \"\n                                   \"enterprise name with %d name components\",",
            "rincipal->name.name_string.len)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enomem(",
          "args": [
            "ontext)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof (*ent))"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame_type_ok(",
          "args": [
            "ontext,",
            "onfig,",
            "rincipal)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ame_type_ok(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "36-50",
          "snippet": "tatic int\nname_type_ok(krb5_context context,\n             krb5_kdc_configuration *config,\n             krb5_const_principal principal)\n{\n    int nt = krb5_principal_get_type(context, principal);\n\n    if (!krb5_principal_is_krbtgt(context, principal))\n        return 1;\n    if (nt == KRB5_NT_SRV_INST || nt == KRB5_NT_UNKNOWN)\n        return 1;\n    if (config->strict_nametypes == 0)\n        return 1;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nname_type_ok(krb5_context context,\n             krb5_kdc_configuration *config,\n             krb5_const_principal principal)\n{\n    int nt = krb5_principal_get_type(context, principal);\n\n    if (!krb5_principal_is_krbtgt(context, principal))\n        return 1;\n    if (nt == KRB5_NT_SRV_INST || nt == KRB5_NT_UNKNOWN)\n        return 1;\n    if (config->strict_nametypes == 0)\n        return 1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
  },
  {
    "function_name": "ame_type_ok(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
    "lines": "36-50",
    "snippet": "tatic int\nname_type_ok(krb5_context context,\n             krb5_kdc_configuration *config,\n             krb5_const_principal principal)\n{\n    int nt = krb5_principal_get_type(context, principal);\n\n    if (!krb5_principal_is_krbtgt(context, principal))\n        return 1;\n    if (nt == KRB5_NT_SRV_INST || nt == KRB5_NT_UNKNOWN)\n        return 1;\n    if (config->strict_nametypes == 0)\n        return 1;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_principal_is_krbtgt(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_type(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nname_type_ok(krb5_context context,\n             krb5_kdc_configuration *config,\n             krb5_const_principal principal)\n{\n    int nt = krb5_principal_get_type(context, principal);\n\n    if (!krb5_principal_is_krbtgt(context, principal))\n        return 1;\n    if (nt == KRB5_NT_SRV_INST || nt == KRB5_NT_UNKNOWN)\n        return 1;\n    if (config->strict_nametypes == 0)\n        return 1;\n    return 0;\n}"
  }
]