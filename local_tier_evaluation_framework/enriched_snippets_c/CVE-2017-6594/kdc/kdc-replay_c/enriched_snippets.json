[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
    "lines": "53-212",
    "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int version_flag;",
      "tatic int help_flag;",
      "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
      "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "done\\n\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_context(",
          "args": [
            "ontext)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_address(",
          "args": [
            "ontext,",
            "a)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "d)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "tag not invalid\")"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "clty not invalid\")"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "r)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "tag mismatch\")"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "class|type mismatch: %d != %d\",",
            "int)MAKE_TAG(cl, ty, 0),",
            "int)clty)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AKE_TAG(",
          "args": [
            "l,",
            "y,",
            ")"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AKE_TAG(",
          "args": [
            "l,",
            "y,",
            ")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_get_tag",
          "args": [
            ".data,",
            ".length,",
            "cl,",
            "ty,",
            "tag2,",
            "ULL)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kdc_process_request\")"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_process_request(",
          "args": [
            "ontext,",
            "onfig,",
            ".data,",
            ".length,",
            "r,",
            "ULL,",
            "str,",
            "struct sockaddr *)&sa,",
            ")"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_process_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "187-223",
          "snippet": "nt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};\n\nnt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_real_time(",
          "args": [
            "ontext,",
            "v.tv_sec,",
            ")"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_update_time(",
          "args": [
            "tv)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_update_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "41-48",
          "snippet": "oid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "processing request from %s, %lu bytes\\n\",",
            "str,",
            "unsigned long)d.length)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_print_address\")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_print_address(",
          "args": [
            "a,",
            "str,",
            "izeof(astr),",
            "ULL)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_addr2sockaddr\")"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_addr2sockaddr",
          "args": [
            "ontext,",
            "a,",
            "struct sockaddr *)&sa,",
            "salen,",
            "8)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_uint32(tag)\")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "tag)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_uint32(class|type)\")"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "clty)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_data\")"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_data(",
          "args": [
            "p,",
            "d)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_address\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_address(",
          "args": [
            "p,",
            "a)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_uint32(time)\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "t)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "version not 1\")"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_ret_uint32(version)\")"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "t)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_storage_from_fd\")"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_from_fd(",
          "args": [
            "d)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "open: %s\",",
            "rgv[1])"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen(",
          "args": [
            "rgv[1],",
            "_RDONLY)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "kdc replay\\n\")"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "argc != 2\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_pk_initialize(",
          "args": [
            "ontext,",
            "onfig,",
            "onfig->pkinit_kdc_identity,",
            "onfig->pkinit_kdc_anchors,",
            "onfig->pkinit_kdc_cert_pool,",
            "onfig->pkinit_kdc_revoke)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_pk_initialize(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1909-2016",
          "snippet": "rb5_error_code\nkrb5_kdc_pk_initialize(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       const char *user_id,\n\t\t       const char *anchors,\n\t\t       char **pool,\n\t\t       char **revoke_list)\n{\n    const char *file;\n    char *fn = NULL;\n    krb5_error_code ret;\n\n    file = krb5_config_get_string(context, NULL,\n\t\t\t\t  \"libdefaults\", \"moduli\", NULL);\n\n    ret = _krb5_parse_moduli(context, file, &moduli);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"PKINIT: failed to load modidi file\");\n\n    principal_mappings.len = 0;\n    principal_mappings.val = NULL;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &kdc_identity,\n\t\t\t   user_id,\n\t\t\t   anchors,\n\t\t\t   pool,\n\t\t\t   revoke_list,\n\t\t\t   NULL,\n\t\t\t   NULL,\n\t\t\t   NULL);\n    if (ret) {\n\tkrb5_warn(context, ret, \"PKINIT: \");\n\tconfig->enable_pkinit = 0;\n\treturn ret;\n    }\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret == 0) {\n\t    if (hx509_cert_check_eku(context->hx509ctx, cert,\n\t\t\t\t     &asn1_oid_id_pkkdcekuoid, 0)) {\n\t\thx509_name name;\n\t\tchar *str;\n\t\tret = hx509_cert_get_subject(cert, &name);\n\t\tif (ret == 0) {\n\t\t    hx509_name_to_string(name, &str);\n\t\t    krb5_warnx(context, \"WARNING Found KDC certificate (%s)\"\n\t\t\t       \"is missing the PK-INIT KDC EKU, this is bad for \"\n\t\t\t       \"interoperability.\", str);\n\t\t    hx509_name_free(&name);\n\t\t    free(str);\n\t\t}\n\t    }\n\t    hx509_cert_free(cert);\n\t} else\n\t    krb5_warnx(context, \"PKINIT: failed to find a signing \"\n\t\t       \"certifiate with a public key\");\n    }\n\n    if (krb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_allow_proxy_certificate\",\n\t\t\t\t     NULL))\n\tconfig->pkinit_allow_proxy_certs = 1;\n\n    file = krb5_config_get_string(context,\n\t\t\t\t  NULL,\n\t\t\t\t  \"kdc\",\n\t\t\t\t  \"pkinit_mappings_file\",\n\t\t\t\t  NULL);\n    if (file == NULL) {\n\tint aret;\n\n\taret = asprintf(&fn, \"%s/pki-mapping\", hdb_db_dir(context));\n\tif (aret == -1) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\tfile = fn;\n    }\n\n    load_mappings(context, file);\n    if (fn)\n\tfree(fn);\n\n    return 0;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\nkrb5_kdc_pk_initialize(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       const char *user_id,\n\t\t       const char *anchors,\n\t\t       char **pool,\n\t\t       char **revoke_list)\n{\n    const char *file;\n    char *fn = NULL;\n    krb5_error_code ret;\n\n    file = krb5_config_get_string(context, NULL,\n\t\t\t\t  \"libdefaults\", \"moduli\", NULL);\n\n    ret = _krb5_parse_moduli(context, file, &moduli);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"PKINIT: failed to load modidi file\");\n\n    principal_mappings.len = 0;\n    principal_mappings.val = NULL;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &kdc_identity,\n\t\t\t   user_id,\n\t\t\t   anchors,\n\t\t\t   pool,\n\t\t\t   revoke_list,\n\t\t\t   NULL,\n\t\t\t   NULL,\n\t\t\t   NULL);\n    if (ret) {\n\tkrb5_warn(context, ret, \"PKINIT: \");\n\tconfig->enable_pkinit = 0;\n\treturn ret;\n    }\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret == 0) {\n\t    if (hx509_cert_check_eku(context->hx509ctx, cert,\n\t\t\t\t     &asn1_oid_id_pkkdcekuoid, 0)) {\n\t\thx509_name name;\n\t\tchar *str;\n\t\tret = hx509_cert_get_subject(cert, &name);\n\t\tif (ret == 0) {\n\t\t    hx509_name_to_string(name, &str);\n\t\t    krb5_warnx(context, \"WARNING Found KDC certificate (%s)\"\n\t\t\t       \"is missing the PK-INIT KDC EKU, this is bad for \"\n\t\t\t       \"interoperability.\", str);\n\t\t    hx509_name_free(&name);\n\t\t    free(str);\n\t\t}\n\t    }\n\t    hx509_cert_free(cert);\n\t} else\n\t    krb5_warnx(context, \"PKINIT: failed to find a signing \"\n\t\t       \"certifiate with a public key\");\n    }\n\n    if (krb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_allow_proxy_certificate\",\n\t\t\t\t     NULL))\n\tconfig->pkinit_allow_proxy_certs = 1;\n\n    file = krb5_config_get_string(context,\n\t\t\t\t  NULL,\n\t\t\t\t  \"kdc\",\n\t\t\t\t  \"pkinit_mappings_file\",\n\t\t\t\t  NULL);\n    if (file == NULL) {\n\tint aret;\n\n\taret = asprintf(&fn, \"%s/pki-mapping\", hdb_db_dir(context));\n\tif (aret == -1) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\tfile = fn;\n    }\n\n    load_mappings(context, file);\n    if (fn)\n\tfree(fn);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "pkinit enabled but no X509 anchors\")"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "pkinit enabled but no identity\")"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kdc_set_dbinfo\")"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_set_dbinfo(",
          "args": [
            "ontext,",
            "onfig)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_set_dbinfo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/set_dbinfo.c",
          "lines": "67-111",
          "snippet": "rb5_error_code\nkrb5_kdc_set_dbinfo(krb5_context context, struct krb5_kdc_configuration *c)\n{\n    struct hdb_dbinfo *info, *d;\n    krb5_error_code ret;\n    int i;\n\n    /* fetch the databases */\n    ret = hdb_get_dbinfo(context, &info);\n    if (ret)\n\treturn ret;\n\n    d = NULL;\n    while ((d = hdb_dbinfo_get_next(info, d)) != NULL) {\n\n\tret = add_db(context, c,\n\t\t     hdb_dbinfo_get_dbname(context, d),\n\t\t     hdb_dbinfo_get_mkey_file(context, d));\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, c, 0, \"label: %s\",\n\t\thdb_dbinfo_get_label(context, d));\n\tkdc_log(context, c, 0, \"\\tdbname: %s\",\n\t\thdb_dbinfo_get_dbname(context, d));\n\tkdc_log(context, c, 0, \"\\tmkey_file: %s\",\n\t\thdb_dbinfo_get_mkey_file(context, d));\n\tkdc_log(context, c, 0, \"\\tacl_file: %s\",\n\t\thdb_dbinfo_get_acl_file(context, d));\n    }\n    hdb_free_dbinfo(context, &info);\n\n    return 0;\nout:\n    for (i = 0; i < c->num_db; i++)\n\tif (c->db[i] && c->db[i]->hdb_destroy)\n\t    (*c->db[i]->hdb_destroy)(context, c->db[i]);\n    c->num_db = 0;\n    free(c->db);\n    c->db = NULL;\n\n    hdb_free_dbinfo(context, &info);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkrb5_kdc_set_dbinfo(krb5_context context, struct krb5_kdc_configuration *c)\n{\n    struct hdb_dbinfo *info, *d;\n    krb5_error_code ret;\n    int i;\n\n    /* fetch the databases */\n    ret = hdb_get_dbinfo(context, &info);\n    if (ret)\n\treturn ret;\n\n    d = NULL;\n    while ((d = hdb_dbinfo_get_next(info, d)) != NULL) {\n\n\tret = add_db(context, c,\n\t\t     hdb_dbinfo_get_dbname(context, d),\n\t\t     hdb_dbinfo_get_mkey_file(context, d));\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, c, 0, \"label: %s\",\n\t\thdb_dbinfo_get_label(context, d));\n\tkdc_log(context, c, 0, \"\\tdbname: %s\",\n\t\thdb_dbinfo_get_dbname(context, d));\n\tkdc_log(context, c, 0, \"\\tmkey_file: %s\",\n\t\thdb_dbinfo_get_mkey_file(context, d));\n\tkdc_log(context, c, 0, \"\\tacl_file: %s\",\n\t\thdb_dbinfo_get_acl_file(context, d));\n    }\n    hdb_free_dbinfo(context, &info);\n\n    return 0;\nout:\n    for (i = 0; i < c->num_db; i++)\n\tif (c->db[i] && c->db[i]->hdb_destroy)\n\t    (*c->db[i]->hdb_destroy)(context, c->db[i]);\n    c->num_db = 0;\n    free(c->db);\n    c->db = NULL;\n\n    hdb_free_dbinfo(context, &info);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_openlog(",
          "args": [
            "ontext,",
            "kdc-replay\",",
            "onfig)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "dc_openlog(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "38-61",
          "snippet": "oid\nkdc_openlog(krb5_context context,\n\t    const char *service,\n\t    krb5_kdc_configuration *config)\n{\n    char **s = NULL, **p;\n    krb5_initlog(context, \"kdc\", &config->logf);\n    s = krb5_config_get_strings(context, NULL, service, \"logging\", NULL);\n    if(s == NULL)\n\ts = krb5_config_get_strings(context, NULL, \"logging\", service, NULL);\n    if(s){\n\tfor(p = s; *p; p++)\n\t    krb5_addlog_dest(context, config->logf, *p);\n\tkrb5_config_free_strings(s);\n    }else {\n\tchar *ss;\n\tif (asprintf(&ss, \"0-1/FILE:%s/%s\", hdb_db_dir(context),\n\t    KDC_LOG_FILE) < 0)\n\t    err(1, \"out of memory\");\n\tkrb5_addlog_dest(context, config->logf, ss);\n\tfree(ss);\n    }\n    krb5_set_warn_dest(context, config->logf);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_openlog(krb5_context context,\n\t    const char *service,\n\t    krb5_kdc_configuration *config)\n{\n    char **s = NULL, **p;\n    krb5_initlog(context, \"kdc\", &config->logf);\n    s = krb5_config_get_strings(context, NULL, service, \"logging\", NULL);\n    if(s == NULL)\n\ts = krb5_config_get_strings(context, NULL, \"logging\", service, NULL);\n    if(s){\n\tfor(p = s; *p; p++)\n\t    krb5_addlog_dest(context, config->logf, *p);\n\tkrb5_config_free_strings(s);\n    }else {\n\tchar *ss;\n\tif (asprintf(&ss, \"0-1/FILE:%s/%s\", hdb_db_dir(context),\n\t    KDC_LOG_FILE) < 0)\n\t    err(1, \"out of memory\");\n\tkrb5_addlog_dest(context, config->logf, ss);\n\tfree(ss);\n    }\n    krb5_set_warn_dest(context, config->logf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kdc_default_config\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_get_config(",
          "args": [
            "ontext,",
            "config)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_get_config(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/default_config.c",
          "lines": "40-262",
          "snippet": "rb5_error_code\nkrb5_kdc_get_config(krb5_context context, krb5_kdc_configuration **config)\n{\n    krb5_kdc_configuration *c;\n\n    c = calloc(1, sizeof(*c));\n    if (c == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n\treturn ENOMEM;\n    }\n\n    c->num_kdc_processes = -1;\n    c->require_preauth = TRUE;\n    c->kdc_warn_pwexpire = 0;\n    c->encode_as_rep_as_tgs_rep = FALSE;\n    c->tgt_use_strongest_session_key = FALSE;\n    c->preauth_use_strongest_session_key = FALSE;\n    c->svc_use_strongest_session_key = FALSE;\n    c->use_strongest_server_key = TRUE;\n    c->check_ticket_addresses = TRUE;\n    c->allow_null_ticket_addresses = TRUE;\n    c->allow_anonymous = FALSE;\n    c->strict_nametypes = FALSE;\n    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n    c->enable_pkinit = FALSE;\n    c->pkinit_princ_in_cert = TRUE;\n    c->pkinit_require_binding = TRUE;\n    c->db = NULL;\n    c->num_db = 0;\n    c->logf = NULL;\n\n    c->num_kdc_processes =\n        krb5_config_get_int_default(context, NULL, c->num_kdc_processes,\n\t\t\t\t    \"kdc\", \"num-kdc-processes\", NULL);\n\n    c->require_preauth =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->require_preauth,\n\t\t\t\t     \"kdc\", \"require-preauth\", NULL);\n#ifdef DIGEST\n    c->enable_digest =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-digest\", NULL);\n\n    {\n\tconst char *digests;\n\n\tdigests = krb5_config_get_string(context, NULL,\n\t\t\t\t\t \"kdc\",\n\t\t\t\t\t \"digests_allowed\", NULL);\n\tif (digests == NULL)\n\t    digests = \"ntlm-v2\";\n\tc->digests_allowed = parse_flags(digests,_kdc_digestunits, 0);\n\tif (c->digests_allowed == -1) {\n\t    kdc_log(context, c, 0,\n\t\t    \"unparsable digest units (%s), turning off digest\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t} else if (c->digests_allowed == 0) {\n\t    kdc_log(context, c, 0,\n\t\t    \"no digest enable, turning digest off\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t}\n    }\n#endif\n\n#ifdef KX509\n    c->enable_kx509 =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-kx509\", NULL);\n\n    if (c->enable_kx509) {\n\tc->kx509_template =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_template\", NULL);\n\tc->kx509_ca =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_ca\", NULL);\n\tif (c->kx509_ca == NULL || c->kx509_template == NULL) {\n\t    kdc_log(context, c, 0,\n\t\t    \"missing kx509 configuration, turning off\");\n\t    c->enable_kx509 = FALSE;\n\t}\n    }\n#endif\n\n    c->tgt_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->tgt_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"tgt-use-strongest-session-key\", NULL);\n    c->preauth_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->preauth_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"preauth-use-strongest-session-key\", NULL);\n    c->svc_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->svc_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"svc-use-strongest-session-key\", NULL);\n    c->use_strongest_server_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->use_strongest_server_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"use-strongest-server-key\", NULL);\n\n    c->check_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->check_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"check-ticket-addresses\", NULL);\n    c->allow_null_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_null_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-null-ticket-addresses\", NULL);\n\n    c->allow_anonymous =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_anonymous,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-anonymous\", NULL);\n\n    c->strict_nametypes =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->strict_nametypes,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"strict-nametypes\", NULL);\n\n    c->max_datagram_reply_length =\n\tkrb5_config_get_int_default(context,\n\t\t\t\t    NULL,\n\t\t\t\t    1400,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-kdc-datagram-reply-length\",\n\t\t\t\t    NULL);\n\n    {\n\tconst char *trpolicy_str;\n\n\ttrpolicy_str =\n\t    krb5_config_get_string_default(context, NULL, \"DEFAULT\", \"kdc\",\n\t\t\t\t\t   \"transited-policy\", NULL);\n\tif(strcasecmp(trpolicy_str, \"always-check\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n\t} else if(strcasecmp(trpolicy_str, \"allow-per-principal\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALLOW_PER_PRINCIPAL;\n\t} else if(strcasecmp(trpolicy_str, \"always-honour-request\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_HONOUR_REQUEST;\n\t} else if(strcasecmp(trpolicy_str, \"DEFAULT\") == 0) {\n\t    /* default */\n\t} else {\n\t    kdc_log(context, c, 0,\n\t\t    \"unknown transited-policy: %s, \"\n\t\t    \"reverting to default (always-check)\",\n\t\t    trpolicy_str);\n\t}\n    }\n\n    c->encode_as_rep_as_tgs_rep =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->encode_as_rep_as_tgs_rep,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"encode_as_rep_as_tgs_rep\", NULL);\n\n    c->kdc_warn_pwexpire =\n\tkrb5_config_get_time_default (context, NULL,\n\t\t\t\t      c->kdc_warn_pwexpire,\n\t\t\t\t      \"kdc\", \"kdc_warn_pwexpire\", NULL);\n\n\n    c->enable_pkinit =\n\tkrb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     c->enable_pkinit,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"enable-pkinit\",\n\t\t\t\t     NULL);\n\n\n    c->pkinit_kdc_identity =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_identity\", NULL);\n    c->pkinit_kdc_anchors =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_anchors\", NULL);\n    c->pkinit_kdc_cert_pool =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_pool\", NULL);\n    c->pkinit_kdc_revoke =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_revoke\", NULL);\n    c->pkinit_kdc_ocsp_file =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_ocsp\", NULL);\n    c->pkinit_kdc_friendly_name =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_friendly_name\", NULL);\n    c->pkinit_princ_in_cert =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_princ_in_cert,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_principal_in_certificate\",\n\t\t\t\t     NULL);\n    c->pkinit_require_binding =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_require_binding,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_win2k_require_binding\",\n\t\t\t\t     NULL);\n    c->pkinit_dh_min_bits =\n\tkrb5_config_get_int_default(context, NULL,\n\t\t\t\t    0,\n\t\t\t\t    \"kdc\", \"pkinit_dh_min_bits\", NULL);\n\n    *config = c;\n\n    return 0;\n}",
          "includes": [
            "include <parse_bytes.h>",
            "include <getarg.h>\n#",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <parse_bytes.h>\ninclude <getarg.h>\n#\ninclude \"kdc_locl.h\"\n#\n\nrb5_error_code\nkrb5_kdc_get_config(krb5_context context, krb5_kdc_configuration **config)\n{\n    krb5_kdc_configuration *c;\n\n    c = calloc(1, sizeof(*c));\n    if (c == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n\treturn ENOMEM;\n    }\n\n    c->num_kdc_processes = -1;\n    c->require_preauth = TRUE;\n    c->kdc_warn_pwexpire = 0;\n    c->encode_as_rep_as_tgs_rep = FALSE;\n    c->tgt_use_strongest_session_key = FALSE;\n    c->preauth_use_strongest_session_key = FALSE;\n    c->svc_use_strongest_session_key = FALSE;\n    c->use_strongest_server_key = TRUE;\n    c->check_ticket_addresses = TRUE;\n    c->allow_null_ticket_addresses = TRUE;\n    c->allow_anonymous = FALSE;\n    c->strict_nametypes = FALSE;\n    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n    c->enable_pkinit = FALSE;\n    c->pkinit_princ_in_cert = TRUE;\n    c->pkinit_require_binding = TRUE;\n    c->db = NULL;\n    c->num_db = 0;\n    c->logf = NULL;\n\n    c->num_kdc_processes =\n        krb5_config_get_int_default(context, NULL, c->num_kdc_processes,\n\t\t\t\t    \"kdc\", \"num-kdc-processes\", NULL);\n\n    c->require_preauth =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->require_preauth,\n\t\t\t\t     \"kdc\", \"require-preauth\", NULL);\n#ifdef DIGEST\n    c->enable_digest =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-digest\", NULL);\n\n    {\n\tconst char *digests;\n\n\tdigests = krb5_config_get_string(context, NULL,\n\t\t\t\t\t \"kdc\",\n\t\t\t\t\t \"digests_allowed\", NULL);\n\tif (digests == NULL)\n\t    digests = \"ntlm-v2\";\n\tc->digests_allowed = parse_flags(digests,_kdc_digestunits, 0);\n\tif (c->digests_allowed == -1) {\n\t    kdc_log(context, c, 0,\n\t\t    \"unparsable digest units (%s), turning off digest\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t} else if (c->digests_allowed == 0) {\n\t    kdc_log(context, c, 0,\n\t\t    \"no digest enable, turning digest off\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t}\n    }\n#endif\n\n#ifdef KX509\n    c->enable_kx509 =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-kx509\", NULL);\n\n    if (c->enable_kx509) {\n\tc->kx509_template =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_template\", NULL);\n\tc->kx509_ca =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_ca\", NULL);\n\tif (c->kx509_ca == NULL || c->kx509_template == NULL) {\n\t    kdc_log(context, c, 0,\n\t\t    \"missing kx509 configuration, turning off\");\n\t    c->enable_kx509 = FALSE;\n\t}\n    }\n#endif\n\n    c->tgt_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->tgt_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"tgt-use-strongest-session-key\", NULL);\n    c->preauth_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->preauth_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"preauth-use-strongest-session-key\", NULL);\n    c->svc_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->svc_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"svc-use-strongest-session-key\", NULL);\n    c->use_strongest_server_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->use_strongest_server_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"use-strongest-server-key\", NULL);\n\n    c->check_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->check_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"check-ticket-addresses\", NULL);\n    c->allow_null_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_null_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-null-ticket-addresses\", NULL);\n\n    c->allow_anonymous =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_anonymous,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-anonymous\", NULL);\n\n    c->strict_nametypes =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->strict_nametypes,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"strict-nametypes\", NULL);\n\n    c->max_datagram_reply_length =\n\tkrb5_config_get_int_default(context,\n\t\t\t\t    NULL,\n\t\t\t\t    1400,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-kdc-datagram-reply-length\",\n\t\t\t\t    NULL);\n\n    {\n\tconst char *trpolicy_str;\n\n\ttrpolicy_str =\n\t    krb5_config_get_string_default(context, NULL, \"DEFAULT\", \"kdc\",\n\t\t\t\t\t   \"transited-policy\", NULL);\n\tif(strcasecmp(trpolicy_str, \"always-check\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n\t} else if(strcasecmp(trpolicy_str, \"allow-per-principal\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALLOW_PER_PRINCIPAL;\n\t} else if(strcasecmp(trpolicy_str, \"always-honour-request\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_HONOUR_REQUEST;\n\t} else if(strcasecmp(trpolicy_str, \"DEFAULT\") == 0) {\n\t    /* default */\n\t} else {\n\t    kdc_log(context, c, 0,\n\t\t    \"unknown transited-policy: %s, \"\n\t\t    \"reverting to default (always-check)\",\n\t\t    trpolicy_str);\n\t}\n    }\n\n    c->encode_as_rep_as_tgs_rep =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->encode_as_rep_as_tgs_rep,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"encode_as_rep_as_tgs_rep\", NULL);\n\n    c->kdc_warn_pwexpire =\n\tkrb5_config_get_time_default (context, NULL,\n\t\t\t\t      c->kdc_warn_pwexpire,\n\t\t\t\t      \"kdc\", \"kdc_warn_pwexpire\", NULL);\n\n\n    c->enable_pkinit =\n\tkrb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     c->enable_pkinit,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"enable-pkinit\",\n\t\t\t\t     NULL);\n\n\n    c->pkinit_kdc_identity =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_identity\", NULL);\n    c->pkinit_kdc_anchors =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_anchors\", NULL);\n    c->pkinit_kdc_cert_pool =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_pool\", NULL);\n    c->pkinit_kdc_revoke =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_revoke\", NULL);\n    c->pkinit_kdc_ocsp_file =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_ocsp\", NULL);\n    c->pkinit_kdc_friendly_name =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_friendly_name\", NULL);\n    c->pkinit_princ_in_cert =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_princ_in_cert,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_principal_in_certificate\",\n\t\t\t\t     NULL);\n    c->pkinit_require_binding =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_require_binding,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_win2k_require_binding\",\n\t\t\t\t     NULL);\n    c->pkinit_dh_min_bits =\n\tkrb5_config_get_int_default(context, NULL,\n\t\t\t\t    0,\n\t\t\t\t    \"kdc\", \"pkinit_dh_min_bits\", NULL);\n\n    *config = c;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_init_context failed to parse configuration file\")"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_context(",
          "args": [
            "context)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit(",
          "args": [
            ")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_version(",
          "args": [
            "ULL)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sage(",
          "args": [
            ")"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "sage(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
          "lines": "46-51",
          "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"kdc-request-log-file\");\n    exit (ret);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
            "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"kdc-request-log-file\");\n    exit (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "etarg(",
          "args": [
            "rgs,",
            "um_args,",
            "rgc,",
            "rgv,",
            "optidx)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etprogname(",
          "args": [
            "rgv[0])"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int version_flag;\ntatic int help_flag;\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "sage(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
    "lines": "46-51",
    "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"kdc-request-log-file\");\n    exit (ret);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
      "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xit",
          "args": [
            "et)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg_printusage",
          "args": [
            "rgs,",
            "um_args,",
            "ULL,",
            "kdc-request-log-file\")"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"kdc-request-log-file\");\n    exit (ret);\n}"
  }
]