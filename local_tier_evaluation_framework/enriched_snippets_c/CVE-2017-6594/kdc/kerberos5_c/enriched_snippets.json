[
  {
    "function_name": "_is_anon_request(con",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "2342-2351",
    "snippet": "_boolean\n_kdc_is_anon_request(const KDC_REQ_BODY *b)\n{\n\t/* some versions of heimdal use bit 14 instead of 16 for\n\t   request_anonymous, as indicated in the anonymous draft prior to\n\t   version 11. Bit 14 is assigned to S4U2Proxy, but all S4U2Proxy\n\t   requests will have a second ticket; don't consider those anonymous */\n\treturn (b->kdc_options.request_anonymous ||\n\t\t(b->kdc_options.constrained_delegation && !b->additional_tickets));\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\n_boolean\n_kdc_is_anon_request(const KDC_REQ_BODY *b)\n{\n\t/* some versions of heimdal use bit 14 instead of 16 for\n\t   request_anonymous, as indicated in the anonymous draft prior to\n\t   version 11. Bit 14 is assigned to S4U2Proxy, but all S4U2Proxy\n\t   requests will have a second ticket; don't consider those anonymous */\n\treturn (b->kdc_options.request_anonymous ||\n\t\t(b->kdc_options.constrained_delegation && !b->additional_tickets));\n}"
  },
  {
    "function_name": "_tkt_add_if_relevant_ad(krb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "2286-2340",
    "snippet": "_error_code\n_kdc_tkt_add_if_relevant_ad(krb5_context context,\n\t\t\t    EncTicketPart *tkt,\n\t\t\t    int type,\n\t\t\t    const krb5_data *data)\n{\n    krb5_error_code ret;\n    size_t size = 0;\n\n    if (tkt->authorization_data == NULL) {\n\ttkt->authorization_data = calloc(1, sizeof(*tkt->authorization_data));\n\tif (tkt->authorization_data == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, \"out of memory\");\n\t    return ENOMEM;\n\t}\n    }\n\n    /* add the entry to the last element */\n    {\n\tAuthorizationData ad = { 0, NULL };\n\tAuthorizationDataElement ade;\n\n\tade.ad_type = type;\n\tade.ad_data = *data;\n\n\tret = add_AuthorizationData(&ad, &ade);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"add AuthorizationData failed\");\n\t    return ret;\n\t}\n\n\tade.ad_type = KRB5_AUTHDATA_IF_RELEVANT;\n\n\tASN1_MALLOC_ENCODE(AuthorizationData,\n\t\t\t   ade.ad_data.data, ade.ad_data.length,\n\t\t\t   &ad, &size, ret);\n\tfree_AuthorizationData(&ad);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encode of \"\n\t\t\t\t   \"AuthorizationData failed\");\n\t    return ret;\n\t}\n\tif (ade.ad_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\tret = add_AuthorizationData(tkt->authorization_data, &ade);\n\tder_free_octet_string(&ade.ad_data);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"add AuthorizationData failed\");\n\t    return ret;\n\t}\n    }\n\n    return 0;\n}\n\nkr",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_set_error_message(con",
          "args": [
            "ext, re",
            "\"a",
            "AuthorizationData failed\");"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_octet_string(&ad",
          "args": [
            ".ad_data);"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthorizationData(tkt",
          "args": [
            ">authorization_data, &a",
            ");"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_abortx(con",
          "args": [
            "ext, \"i",
            "ernal asn.1 encoder error\");"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_error_message(con",
          "args": [
            "ext, re",
            "\"A",
            ".1 encode of \"\n\t\t\t\t   \"AuthorizationData failed\");"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_AuthorizationData(&ad",
          "args": [
            ";"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MALLOC_ENCODE(Aut",
          "args": [
            "orizationData,",
            "ad_data.data, ad",
            "ad_data.length,",
            "&s",
            "e, re",
            ";"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_error_message(con",
          "args": [
            "ext, re",
            "\"a",
            "AuthorizationData failed\");"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthorizationData(&ad",
          "args": [
            "&a",
            ");"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_error_message(con",
          "args": [
            "ext, EN",
            "EM, \"o",
            "of memory\");"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oc(1,",
          "args": [
            "i",
            "of(*tkt->authorization_data));"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\n_error_code\n_kdc_tkt_add_if_relevant_ad(krb5_context context,\n\t\t\t    EncTicketPart *tkt,\n\t\t\t    int type,\n\t\t\t    const krb5_data *data)\n{\n    krb5_error_code ret;\n    size_t size = 0;\n\n    if (tkt->authorization_data == NULL) {\n\ttkt->authorization_data = calloc(1, sizeof(*tkt->authorization_data));\n\tif (tkt->authorization_data == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, \"out of memory\");\n\t    return ENOMEM;\n\t}\n    }\n\n    /* add the entry to the last element */\n    {\n\tAuthorizationData ad = { 0, NULL };\n\tAuthorizationDataElement ade;\n\n\tade.ad_type = type;\n\tade.ad_data = *data;\n\n\tret = add_AuthorizationData(&ad, &ade);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"add AuthorizationData failed\");\n\t    return ret;\n\t}\n\n\tade.ad_type = KRB5_AUTHDATA_IF_RELEVANT;\n\n\tASN1_MALLOC_ENCODE(AuthorizationData,\n\t\t\t   ade.ad_data.data, ade.ad_data.length,\n\t\t\t   &ad, &size, ret);\n\tfree_AuthorizationData(&ad);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encode of \"\n\t\t\t\t   \"AuthorizationData failed\");\n\t    return ret;\n\t}\n\tif (ade.ad_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\tret = add_AuthorizationData(tkt->authorization_data, &ade);\n\tder_free_octet_string(&ade.ad_data);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"add AuthorizationData failed\");\n\t    return ret;\n\t}\n    }\n\n    return 0;\n}\n\nkr"
  },
  {
    "function_name": "kdc_as_rep(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1616-2279",
    "snippet": "rb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "->context,",
            "r->session_key)"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "->context,",
            "r->reply_key)"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "->armor_crypto)"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_free_ent(",
          "args": [
            "ontext,",
            "->server)"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "->server_name)"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "->server_princ)"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "->client_name)"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "->client_princ)"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "r->outpadata)"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "error_method)"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KDCFastState(",
          "args": [
            "r->fast)"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncKDCRepPart(",
          "args": [
            "r->ek)"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncTicketPart(",
          "args": [
            "r->et)"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fast_mk_error(",
          "args": [
            "ontext,",
            ",",
            "error_method,",
            "->armor_crypto,",
            "req->req_body,",
            "et,",
            "->e_text,",
            "->server_princ,",
            "r->client_princ->name,",
            "r->client_princ->realm,",
            "ULL,",
            "ULL,",
            "eply)"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fast_mk_error(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "239-344",
          "snippet": "rb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_set_e_text(",
          "args": [
            ",",
            "Reply packet too large\")"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_set_e_text(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "276-281",
          "snippet": "tatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "eply)"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_encode_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "->armor_crypto,",
            "eq->req_body.nonce,",
            "rep,",
            "r->et,",
            "r->ek,",
            "etype,",
            "->server->entry.kvno,",
            "skey->key,",
            "->client->entry.kvno,",
            "r->reply_key,",
            ",",
            "r->e_text,",
            "eply)"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_encode_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "810-987",
          "snippet": "rb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "->context,",
            "sg)"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_r_log(",
          "args": [
            ",",
            ",",
            "add_enc_pa_rep failed: %s: %d\",",
            "sg,",
            "et)"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_r_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "265-274",
          "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "->context,",
            "et)"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_enc_pa_rep(",
          "args": [
            ")"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "dd_enc_pa_rep(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1570-1610",
          "snippet": "tatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \"ASN.1 internal error\");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \"ASN.1 internal error\");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "eq,",
            "i,",
            "RB5_PADATA_REQ_ENC_PA_REP)"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "og_as_req(",
          "args": [
            "ontext,",
            "onfig,",
            "->reply_key.keytype,",
            "etype,",
            ")"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "og_as_req(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1228-1288",
          "snippet": "tatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \"%s\", \"Client supported enctypes: \");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \"%s\", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \"%d\", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"no encryption types\");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \", using %s/%s\", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \", using enctypes %d/%d\",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"%s\", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \"Requested flags: %s\", fixedstr);\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \"%s\", \"Client supported enctypes: \");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \"%s\", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \"%d\", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"no encryption types\");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \", using %s/%s\", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \", using enctypes %d/%d\",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"%s\", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \"Requested flags: %s\", fixedstr);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_add_KRB5SignedPath(",
          "args": [
            "ontext,",
            "onfig,",
            "->server,",
            "etype,",
            "->client->entry.principal,",
            "ULL,",
            "ULL,",
            "r->et)"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_add_KRB5SignedPath(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "102-184",
          "snippet": "rb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_log_timestamp(",
          "args": [
            "ontext,",
            "onfig,",
            "AS-REQ\",",
            "->et.authtime,",
            "->et.starttime,",
            "->et.endtime,",
            "->et.renew_till)"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_log_timestamp(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "283-311",
          "snippet": "oid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enerate_pac(",
          "args": [
            ",",
            "key)"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "enerate_pac(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1505-1539",
          "snippet": "tatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC generation failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC signing failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC generation failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC signing failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_pac_p(",
          "args": [
            "ontext,",
            "eq)"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "end_pac_p(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1476-1499",
          "snippet": "tatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opy_METHOD_DATA(",
          "args": [
            "r->outpadata,",
            "ep.padata)"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "ep.padata)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_EncryptionKey(",
          "args": [
            "r->session_key,",
            "r->ek.key)"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_EncryptionKey(",
          "args": [
            "r->session_key,",
            "r->et.key)"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "->sessionetype,",
            "r->session_key)"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_HostAddresses(",
          "args": [
            "->et.caddr,",
            "->ek.caddr)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->ek.caddr)"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_PrincipalName(",
          "args": [
            "rep.ticket.sname,",
            "r->ek.sname)"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "rep.ticket.realm,",
            "r->ek.srealm)"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->ek.renew_till)"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->ek.starttime)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in(",
          "args": [
            "r->client->entry.valid_end,",
            "r->client->entry.pw_end)"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "ain(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
          "lines": "53-212",
          "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int version_flag;",
            "tatic int help_flag;",
            "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
            "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int version_flag;\ntatic int help_flag;\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->ek.key_expiration)"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "* sizeof(*r->ek.last_req.val))"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "r->et.transited.contents)"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_HostAddresses(",
          "args": [
            "->addresses,",
            "->et.caddr)"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->et.caddr)"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->et.renew_till)"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->rtime)"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fix_time(",
          "args": [
            "b->till)"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fix_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "38-46",
          "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->et.starttime)"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "rep.crealm,",
            "r->et.crealm)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_PrincipalName(",
          "args": [
            "rep.cname,",
            "r->et.cname)"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_check_addresses(",
          "args": [
            "ontext,",
            "onfig,",
            "->addresses,",
            "rom_addr)"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_check_addresses(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1431-1470",
          "snippet": "rb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NT(",
          "args": [
            ",",
            "RV_XHST)"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NT(",
          "args": [
            ",",
            "RV_HST)"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NT(",
          "args": [
            ",",
            "RV_INST)"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NT(",
          "args": [
            ",",
            "RINCIPAL)"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NT(",
          "args": [
            ",",
            "NKNOWN)"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal2principalname(",
          "args": [
            "rep.ticket.sname,",
            "->server->entry.principal)"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "r->server->entry.principal->realm,",
            "rep.ticket.realm)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal2principalname(",
          "args": [
            "rep.cname,",
            "->client->entry.principal)"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "r->client->entry.principal->realm,",
            "rep.crealm)"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "anon_realm,",
            "rep.crealm)"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anonymous(",
          "args": [
            "ontext,",
            "->client_princ)"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_is_anonymous(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1545-1555",
          "snippet": "rb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_get_preferred_key(",
          "args": [
            "ontext,",
            "onfig,",
            "->server,",
            "->server_name,",
            "setype,",
            "skey)"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_get_preferred_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "175-220",
          "snippet": "rb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_check_access(",
          "args": [
            "ontext,",
            "onfig,",
            "->client,",
            "->client_name,",
            "->server,",
            "->server_name,",
            "eq,",
            "error_method)"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_check_access(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
          "lines": "174-204",
          "snippet": "rb5_error_code\n_kdc_check_access(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  hdb_entry_ex *client_ex, const char *client_name,\n\t\t  hdb_entry_ex *server_ex, const char *server_name,\n\t\t  KDC_REQ *req,\n\t\t  METHOD_DATA *method_data)\n{\n    krb5_error_code ret = KRB5_PLUGIN_NO_HANDLE;\n    struct check_uc uc;\n\n    if (have_plugin) {\n        uc.config = config;\n        uc.client_ex = client_ex;\n        uc.client_name = client_name;\n        uc.server_ex = server_ex;\n        uc.server_name = server_name;\n        uc.req = req;\n        uc.method_data = method_data;\n\n        ret = _krb5_plugin_run_f(context, \"krb5\", \"windc\",\n                                 KRB5_WINDC_PLUGIN_MINOR, 0, &uc, check);\n    }\n\n    if (ret == KRB5_PLUGIN_NO_HANDLE)\n\treturn kdc_check_flags(context, config,\n\t\t\t       client_ex, client_name,\n\t\t\t       server_ex, server_name,\n\t\t\t       req->msg_type == krb_as_req);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int have_plugin = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_check_access(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  hdb_entry_ex *client_ex, const char *client_name,\n\t\t  hdb_entry_ex *server_ex, const char *server_name,\n\t\t  KDC_REQ *req,\n\t\t  METHOD_DATA *method_data)\n{\n    krb5_error_code ret = KRB5_PLUGIN_NO_HANDLE;\n    struct check_uc uc;\n\n    if (have_plugin) {\n        uc.config = config;\n        uc.client_ex = client_ex;\n        uc.client_name = client_name;\n        uc.server_ex = server_ex;\n        uc.server_name = server_name;\n        uc.req = req;\n        uc.method_data = method_data;\n\n        ret = _krb5_plugin_run_f(context, \"krb5\", \"windc\",\n                                 KRB5_WINDC_PLUGIN_MINOR, 0, &uc, check);\n    }\n\n    if (ret == KRB5_PLUGIN_NO_HANDLE)\n\treturn kdc_check_flags(context, config,\n\t\t\t       client_ex, client_name,\n\t\t\t       server_ex, server_name,\n\t\t\t       req->msg_type == krb_as_req);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "->clientdb->hdb_auth_status",
          "args": [
            "ontext,",
            "->clientdb,",
            "->client,",
            "DB_AUTH_SUCCESS)"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_copy_keyblock_contents(",
          "args": [
            "->context,",
            "ckey->key,",
            "r->reply_key)"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "->context,",
            "r->reply_key)"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equire_preauth_p(",
          "args": [
            ")"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "equire_preauth_p(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1557-1563",
          "snippet": "tatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "et_pa_etype_info2(",
          "args": [
            "ontext,",
            "onfig,",
            "error_method,",
            "key)"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "et_pa_etype_info2(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1188-1222",
          "snippet": "tatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "et_pa_etype_info(",
          "args": [
            "ontext,",
            "onfig,",
            "error_method,",
            "key)"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "et_pa_etype_info(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1069-1104",
          "snippet": "tatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lder_enctype(",
          "args": [
            "key->key.keytype)"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "lder_enctype(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "994-1015",
          "snippet": "tatic int\nolder_enctype(krb5_enctype enctype)\n{\n    switch (enctype) {\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \"old\" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nolder_enctype(krb5_enctype enctype)\n{\n    switch (enctype) {\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \"old\" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_find_etype(",
          "args": [
            "ontext,",
            "onfig->preauth_use_strongest_session_key,",
            "RUE,",
            "->client,",
            "->etype.val,",
            "->etype.len,",
            "ULL,",
            "ckey)"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_etype(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "125-246",
          "snippet": "rb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "error_method,",
            "at[n].type,",
            "ULL,",
            ")"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "%s pre-authentication succeeded -- %s\",",
            "at[n].name,",
            "->client_name)"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "at[n].validate",
          "args": [
            ",",
            "a)"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og_patypes(",
          "args": [
            "ontext,",
            "onfig,",
            "eq->padata)"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "og_patypes(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "773-804",
          "snippet": "tatic void\nlog_patypes(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    METHOD_DATA *padata)\n{\n    struct rk_strpool *p = NULL;\n    char *str;\n    size_t n, m;\n\t\n    for (n = 0; n < padata->len; n++) {\n\tfor (m = 0; m < sizeof(pat) / sizeof(pat[0]); m++) {\n\t    if (padata->val[n].padata_type == pat[m].type) {\n\t\tp = rk_strpoolprintf(p, \"%s\", pat[m].name);\n\t\tbreak;\n\t    }\n\t}\n\tif (m == sizeof(pat) / sizeof(pat[0]))\n\t    p = rk_strpoolprintf(p, \"%d\", padata->val[n].padata_type);\n\tif (p && n + 1 < padata->len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"none\");\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"Client sent patypes: %s\", str);\n    free(str);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};\n\ntatic void\nlog_patypes(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    METHOD_DATA *padata)\n{\n    struct rk_strpool *p = NULL;\n    char *str;\n    size_t n, m;\n\t\n    for (n = 0; n < padata->len; n++) {\n\tfor (m = 0; m < sizeof(pat) / sizeof(pat[0]); m++) {\n\t    if (padata->val[n].padata_type == pat[m].type) {\n\t\tp = rk_strpoolprintf(p, \"%s\", pat[m].name);\n\t\tbreak;\n\t    }\n\t}\n\tif (m == sizeof(pat) / sizeof(pat[0]))\n\t    p = rk_strpoolprintf(p, \"%d\", padata->val[n].padata_type);\n\tif (p && n + 1 < padata->len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"none\");\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"Client sent patypes: %s\", str);\n    free(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_is_krbtgt(",
          "args": [
            "ontext,",
            "->server_princ)"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "->server_princ,",
            "DB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,",
            "ULL,",
            "ULL,",
            "r->server)"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ixed_client_name)"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "->client->entry.principal,",
            "fixed_client_name)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "->client_princ,",
            "r->client_name)"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal",
          "args": [
            "ontext,",
            "r->client_princ,",
            "(b->cname),",
            "->realm)"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "->server_princ,",
            "r->server_name)"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal",
          "args": [
            "ontext,",
            "r->server_princ,",
            "(b->sname),",
            "->realm)"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fast_unwrap_request(",
          "args": [
            ")"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fast_unwrap_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "346-560",
          "snippet": "rb5_error_code\n_kdc_fast_unwrap_request(kdc_request_t r)\n{\n    krb5_principal armor_server = NULL;\n    hdb_entry_ex *armor_user = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_auth_context ac = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_flags ap_req_options;\n    Key *armor_key = NULL;\n    krb5_keyblock armorkey;\n    krb5_error_code ret;\n    krb5_ap_req ap_req;\n    unsigned char *buf = NULL;\n    KrbFastReq fastreq;\n    size_t len, size;\n    krb5_data data;\n    const PA_DATA *pa;\n    int i = 0;\n\n    /*\n     * First look for FX_COOKIE and and process it\n     */\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_COOKIE);\n    if (pa) {\n\tret = fast_parse_cookie(r, pa);\n\tif (ret)\n\t    goto out;\n    }\n\t\t\t  \n    i = 0;\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_FAST);\n    if (pa == NULL)\n\treturn 0;\n\n    ret = decode_PA_FX_FAST_REQUEST(pa->padata_value.data,\n\t\t\t\t    pa->padata_value.length,\n\t\t\t\t    &fxreq,\n\t\t\t\t    &len);\n    if (ret)\n\tgoto out;\n    if (len != pa->padata_value.length) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.element != choice_PA_FX_FAST_REQUEST_armored_data) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ FAST contain unknown type: %d\", (int)fxreq.element);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* pull out armor key */\n    if (fxreq.u.armored_data.armor == NULL) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.u.armored_data.armor->armor_type != 1) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor type not ap-req\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\t    \n    ret = krb5_decode_ap_req(r->context,\n\t\t\t     &fxreq.u.armored_data.armor->armor_value,\n\t\t\t     &ap_req);\n    if(ret) {\n\tkdc_log(r->context, r->config, 0, \"AP-REQ decode failed\");\n\tgoto out;\n    }\n\n    /* Save that principal that was in the request */\n    ret = _krb5_principalname2krb5_principal(r->context,\n\t\t\t\t\t     &armor_server,\n\t\t\t\t\t     ap_req.ticket.sname,\n\t\t\t\t\t     ap_req.ticket.realm);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(r->context, r->config, armor_server,\n\t\t\tHDB_F_GET_SERVER, NULL, NULL, &armor_user);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(r->context, r->config, 5,\n\t\t\"armor key does not have secrets at this KDC, \"\n\t\t\"need to proxy\");\n\tgoto out;\n    } else if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    ret = hdb_enctype2key(r->context, &armor_user->entry, NULL,\n\t\t\t  ap_req.ticket.enc_part.etype,\n\t\t\t  &armor_key);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = krb5_verify_ap_req2(r->context, &ac, \n\t\t\t      &ap_req,\n\t\t\t      armor_server,\n\t\t\t      &armor_key->key,\n\t\t\t      0,\n\t\t\t      &ap_req_options,\n\t\t\t      &ticket, \n\t\t\t      KRB5_KU_AP_REQ_AUTH);\n    free_AP_REQ(&ap_req);\n    if (ret)\n\tgoto out;\n\n    if (ac->remote_subkey == NULL) {\n\tkrb5_auth_con_free(r->context, ac);\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST AP-REQ remote subkey missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n\n    ret = _krb5_fast_armor_key(r->context,\n\t\t\t       ac->remote_subkey,\n\t\t\t       &ticket->ticket.key,\n\t\t\t       &armorkey,\n\t\t\t       &r->armor_crypto);\n    krb5_auth_con_free(r->context, ac);\n    krb5_free_ticket(r->context, ticket);\n    if (ret)\n\tgoto out;\n\n    krb5_free_keyblock_contents(r->context, &armorkey);\n\n    /* verify req-checksum of the outer body */\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &r->req.req_body, &size, ret);\n    if (ret)\n\tgoto out;\n    if (size != len) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    ret = krb5_verify_checksum(r->context, r->armor_crypto,\n\t\t\t       KRB5_KU_FAST_REQ_CHKSUM,\n\t\t\t       buf, len, \n\t\t\t       &fxreq.u.armored_data.req_checksum);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST request have a bad checksum\");\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(r->context, r->armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_ENC,\n\t\t\t\t     &fxreq.u.armored_data.enc_fast_req,\n\t\t\t\t     &data);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"Failed to decrypt FAST request\");\n\tgoto out;\n    }\n\n    ret = decode_KrbFastReq(data.data, data.length, &fastreq, &size);\n    if (ret) {\n\tkrb5_data_free(&data);\n\tgoto out;\n    }\n    if (data.length != size) {\n\tkrb5_data_free(&data);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n    krb5_data_free(&data);\n\n    free_KDC_REQ_BODY(&r->req.req_body);\n    ret = copy_KDC_REQ_BODY(&fastreq.req_body, &r->req.req_body);\n    if (ret)\n\tgoto out;\n\t    \n    /* check for unsupported mandatory options */\n    if (FastOptions2int(fastreq.fast_options) & 0xfffc) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST unsupported mandatory option set\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* KDC MUST ignore outer pa data preauth-14 - 6.5.5 */\n    if (r->req.padata)\n\tfree_METHOD_DATA(r->req.padata);\n    else\n\tALLOC(r->req.padata);\n\n    ret = copy_METHOD_DATA(&fastreq.padata, r->req.padata);\n    if (ret)\n\tgoto out;\n\n    free_KrbFastReq(&fastreq);\n    free_PA_FX_FAST_REQUEST(&fxreq);\n\n out:\n    if (armor_server)\n\tkrb5_free_principal(r->context, armor_server);\n    if(armor_user)\n\t_kdc_free_ent(r->context, armor_user);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_unwrap_request(kdc_request_t r)\n{\n    krb5_principal armor_server = NULL;\n    hdb_entry_ex *armor_user = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_auth_context ac = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_flags ap_req_options;\n    Key *armor_key = NULL;\n    krb5_keyblock armorkey;\n    krb5_error_code ret;\n    krb5_ap_req ap_req;\n    unsigned char *buf = NULL;\n    KrbFastReq fastreq;\n    size_t len, size;\n    krb5_data data;\n    const PA_DATA *pa;\n    int i = 0;\n\n    /*\n     * First look for FX_COOKIE and and process it\n     */\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_COOKIE);\n    if (pa) {\n\tret = fast_parse_cookie(r, pa);\n\tif (ret)\n\t    goto out;\n    }\n\t\t\t  \n    i = 0;\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_FAST);\n    if (pa == NULL)\n\treturn 0;\n\n    ret = decode_PA_FX_FAST_REQUEST(pa->padata_value.data,\n\t\t\t\t    pa->padata_value.length,\n\t\t\t\t    &fxreq,\n\t\t\t\t    &len);\n    if (ret)\n\tgoto out;\n    if (len != pa->padata_value.length) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.element != choice_PA_FX_FAST_REQUEST_armored_data) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ FAST contain unknown type: %d\", (int)fxreq.element);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* pull out armor key */\n    if (fxreq.u.armored_data.armor == NULL) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.u.armored_data.armor->armor_type != 1) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor type not ap-req\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\t    \n    ret = krb5_decode_ap_req(r->context,\n\t\t\t     &fxreq.u.armored_data.armor->armor_value,\n\t\t\t     &ap_req);\n    if(ret) {\n\tkdc_log(r->context, r->config, 0, \"AP-REQ decode failed\");\n\tgoto out;\n    }\n\n    /* Save that principal that was in the request */\n    ret = _krb5_principalname2krb5_principal(r->context,\n\t\t\t\t\t     &armor_server,\n\t\t\t\t\t     ap_req.ticket.sname,\n\t\t\t\t\t     ap_req.ticket.realm);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(r->context, r->config, armor_server,\n\t\t\tHDB_F_GET_SERVER, NULL, NULL, &armor_user);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(r->context, r->config, 5,\n\t\t\"armor key does not have secrets at this KDC, \"\n\t\t\"need to proxy\");\n\tgoto out;\n    } else if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    ret = hdb_enctype2key(r->context, &armor_user->entry, NULL,\n\t\t\t  ap_req.ticket.enc_part.etype,\n\t\t\t  &armor_key);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = krb5_verify_ap_req2(r->context, &ac, \n\t\t\t      &ap_req,\n\t\t\t      armor_server,\n\t\t\t      &armor_key->key,\n\t\t\t      0,\n\t\t\t      &ap_req_options,\n\t\t\t      &ticket, \n\t\t\t      KRB5_KU_AP_REQ_AUTH);\n    free_AP_REQ(&ap_req);\n    if (ret)\n\tgoto out;\n\n    if (ac->remote_subkey == NULL) {\n\tkrb5_auth_con_free(r->context, ac);\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST AP-REQ remote subkey missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n\n    ret = _krb5_fast_armor_key(r->context,\n\t\t\t       ac->remote_subkey,\n\t\t\t       &ticket->ticket.key,\n\t\t\t       &armorkey,\n\t\t\t       &r->armor_crypto);\n    krb5_auth_con_free(r->context, ac);\n    krb5_free_ticket(r->context, ticket);\n    if (ret)\n\tgoto out;\n\n    krb5_free_keyblock_contents(r->context, &armorkey);\n\n    /* verify req-checksum of the outer body */\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &r->req.req_body, &size, ret);\n    if (ret)\n\tgoto out;\n    if (size != len) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    ret = krb5_verify_checksum(r->context, r->armor_crypto,\n\t\t\t       KRB5_KU_FAST_REQ_CHKSUM,\n\t\t\t       buf, len, \n\t\t\t       &fxreq.u.armored_data.req_checksum);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST request have a bad checksum\");\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(r->context, r->armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_ENC,\n\t\t\t\t     &fxreq.u.armored_data.enc_fast_req,\n\t\t\t\t     &data);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"Failed to decrypt FAST request\");\n\tgoto out;\n    }\n\n    ret = decode_KrbFastReq(data.data, data.length, &fastreq, &size);\n    if (ret) {\n\tkrb5_data_free(&data);\n\tgoto out;\n    }\n    if (data.length != size) {\n\tkrb5_data_free(&data);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n    krb5_data_free(&data);\n\n    free_KDC_REQ_BODY(&r->req.req_body);\n    ret = copy_KDC_REQ_BODY(&fastreq.req_body, &r->req.req_body);\n    if (ret)\n\tgoto out;\n\t    \n    /* check for unsupported mandatory options */\n    if (FastOptions2int(fastreq.fast_options) & 0xfffc) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST unsupported mandatory option set\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* KDC MUST ignore outer pa data preauth-14 - 6.5.5 */\n    if (r->req.padata)\n\tfree_METHOD_DATA(r->req.padata);\n    else\n\tALLOC(r->req.padata);\n\n    ret = copy_METHOD_DATA(&fastreq.padata, r->req.padata);\n    if (ret)\n\tgoto out;\n\n    free_KrbFastReq(&fastreq);\n    free_PA_FX_FAST_REQUEST(&fxreq);\n\n out:\n    if (armor_server)\n\tkrb5_free_principal(r->context, armor_server);\n    if(armor_user)\n\t_kdc_free_ent(r->context, armor_user);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rep,",
            ",",
            "izeof(rep))"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};\n\nrb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}"
  },
  {
    "function_name": "dd_enc_pa_rep(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1570-1610",
    "snippet": "tatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \"ASN.1 internal error\");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "->context,",
            "->ek.encrypted_pa_data,",
            "RB5_PADATA_FX_FAST,",
            "ULL,",
            ")"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "->context,",
            "->ek.encrypted_pa_data,",
            "RB5_PADATA_REQ_ENC_PA_REP,",
            "data.data,",
            "data.length)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->ek.encrypted_pa_data)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "data.length == len,",
            "ASN.1 internal error\")"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "checksum)"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "hecksum,",
            "data.data,",
            "data.length,",
            "checksum,",
            "len,",
            "et)"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "rypto)"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "->context,",
            "rypto,",
            "RB5_KU_AS_REQ,",
            ",",
            "->request.data,",
            "->request.length,",
            "checksum)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "->context,",
            "r->reply_key,",
            ",",
            "crypto)"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \"ASN.1 internal error\");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}"
  },
  {
    "function_name": "equire_preauth_p(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1557-1563",
    "snippet": "tatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}"
  },
  {
    "function_name": "kdc_is_anonymous(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1545-1555",
    "snippet": "rb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rincipal->name.name_string.val[1],",
            "RB5_ANON_NAME)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rincipal->name.name_string.val[0],",
            "RB5_WELLKNOWN_NAME)"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}"
  },
  {
    "function_name": "enerate_pac(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1505-1539",
    "snippet": "tatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC generation failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC signing failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_tkt_add_if_relevant_ad(",
          "args": [
            "->context,",
            "r->et,",
            "RB5_AUTHDATA_WIN2K_PAC,",
            "data)"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_r_log(",
          "args": [
            ",",
            ",",
            "PAC signing failed for -- %s\",",
            "->client_name)"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_r_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "265-274",
          "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_pac_free(",
          "args": [
            "->context,",
            ")"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pac_sign(",
          "args": [
            "->context,",
            ",",
            "->et.authtime,",
            "->client->entry.principal,",
            "skey->key,",
            "* Server key */\nskey->key,",
            "* FIXME: should be krbtgt key */\ndata)"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_pac_generate(",
          "args": [
            "->context,",
            "->client,",
            "p)"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pac_generate(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
          "lines": "74-90",
          "snippet": "rb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int have_plugin = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC generation failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"PAC signing failed for -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}"
  },
  {
    "function_name": "end_pac_p(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1476-1499",
    "snippet": "tatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_PA_PAC_REQUEST(",
          "args": [
            "pacreq)"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_PAC_REQUEST(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "pacreq,",
            "ULL)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "eq,",
            "i,",
            "RB5_PADATA_PA_PAC_REQUEST)"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}"
  },
  {
    "function_name": "kdc_check_addresses(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1431-1470",
    "snippet": "rb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_address",
          "args": [
            "ontext,",
            "addr)"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_address_search(",
          "args": [
            "ontext,",
            "addr,",
            "ddresses)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_sockaddr2address",
          "args": [
            "ontext,",
            "rom,",
            "addr)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}"
  },
  {
    "function_name": "dc_check_flags(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1296-1423",
    "snippet": "rb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Server's key has expired at -- %s\",",
            "wend_str,",
            "erver_name)"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "server->pw_end,",
            "wend_str,",
            "izeof(pwend_str),",
            "RUE)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "server->valid_end,",
            "ndtime_str,",
            "izeof(endtime_str),",
            "RUE)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "server->valid_start,",
            "tarttime_str,",
            "izeof(starttime_str),",
            "RUE)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "client->pw_end,",
            "wend_str,",
            "izeof(pwend_str),",
            "RUE)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "client->valid_end,",
            "ndtime_str,",
            "izeof(endtime_str),",
            "RUE)"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "client->valid_start,",
            "tarttime_str,",
            "izeof(starttime_str),",
            "RUE)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "function_name": "og_as_req(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1228-1288",
    "snippet": "tatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \"%s\", \"Client supported enctypes: \");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \"%s\", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \"%d\", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"no encryption types\");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \", using %s/%s\", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \", using enctypes %d/%d\",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"%s\", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \"Requested flags: %s\", fixedstr);\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Requested flags: %s\",",
            "ixedstr)"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nparse_flags(",
          "args": [
            "DCOptions2int(b->kdc_options),",
            "sn1_KDCOptions_units(),",
            "ixedstr,",
            "izeof(fixedstr))"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sn1_KDCOptions_units(",
          "args": [],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DCOptions2int(",
          "args": [
            "->kdc_options)"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolcollect(",
          "args": [
            ")"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            ", using enctypes %d/%d\",",
            "etype,",
            "etype)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "et)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "et)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            ", using %s/%s\",",
            "et,",
            "et)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "ontext,",
            "etype,",
            "set)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "ontext,",
            "etype,",
            "cet)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "no encryption types\")"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            ", \")"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "%d\",",
            "->etype.val[i])"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "%s\",",
            "tr)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "ontext,",
            "->etype.val[i],",
            "str)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            "ULL,",
            "%s\",",
            "Client supported enctypes: \")"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \"%s\", \"Client supported enctypes: \");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \"%s\", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \"%d\", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"no encryption types\");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \", using %s/%s\", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \", using enctypes %d/%d\",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"%s\", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \"Requested flags: %s\", fixedstr);\n    }\n}"
  },
  {
    "function_name": "et_pa_etype_info2(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1188-1222",
    "snippet": "tatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc_method_data(",
          "args": [
            "d)"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ealloc_method_data(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "48-58",
          "snippet": "tatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_ETYPE_INFO2(",
          "args": [
            "pa)"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "TYPE_INFO2,",
            "uf,",
            "en,",
            "pa,",
            "len,",
            "et)"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ETYPE_INFO2(",
          "args": [
            "pa)"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_etype_info2_entry(",
          "args": [
            "pa.val[0],",
            "key)"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ake_etype_info2_entry(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1132-1180",
          "snippet": "tatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "xtern int _krb5_AES_SHA1_string_to_default_iterator;",
            "xtern int _krb5_AES_SHA2_string_to_default_iterator;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nxtern int _krb5_AES_SHA1_string_to_default_iterator;\nxtern int _krb5_AES_SHA2_string_to_default_iterator;\n\ntatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(pa.val[0]))"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}"
  },
  {
    "function_name": "ake_etype_info2_entry(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1132-1180",
    "snippet": "tatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "xtern int _krb5_AES_SHA1_string_to_default_iterator;",
      "xtern int _krb5_AES_SHA2_string_to_default_iterator;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ake_s2kparams(",
          "args": [
            ",",
            ",",
            "ent->s2kparams)"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "ake_s2kparams(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1113-1130",
          "snippet": "tatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "ent->salt,",
            "ey->salt->salt.data,",
            "ey->salt->salt.length)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nt->salt)"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "ey->salt->salt.length + 1)"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "nt->salt)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nxtern int _krb5_AES_SHA1_string_to_default_iterator;\nxtern int _krb5_AES_SHA2_string_to_default_iterator;\n\ntatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "ake_s2kparams(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1113-1130",
    "snippet": "tatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_put_int(",
          "args": [
            "2kparams->data,",
            "alue,",
            "en)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "2kparams)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_alloc(",
          "args": [
            "2kparams,",
            "en)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "2kparams)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}"
  },
  {
    "function_name": "et_pa_etype_info(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1069-1104",
    "snippet": "tatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc_method_data(",
          "args": [
            "d)"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ealloc_method_data(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "48-58",
          "snippet": "tatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_ETYPE_INFO(",
          "args": [
            "pa)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "TYPE_INFO,",
            "uf,",
            "en,",
            "pa,",
            "len,",
            "et)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ETYPE_INFO(",
          "args": [
            "pa)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_etype_info_entry(",
          "args": [
            "ontext,",
            "pa.val[0],",
            "key)"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ake_etype_info_entry(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1021-1067",
          "snippet": "tatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \"unknown salt-type: %d\",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \"unknown salt-type: %d\",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(pa.val[0]))"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}"
  },
  {
    "function_name": "ake_etype_info_entry(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "1021-1067",
    "snippet": "tatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \"unknown salt-type: %d\",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_copy_data(",
          "args": [
            "ontext,",
            "key->salt->salt,",
            "ent->salt)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "nt->salttype)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "unknown salt-type: %d\",",
            "ey->salt->type)"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "nt->salttype)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \"unknown salt-type: %d\",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "lder_enctype(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "994-1015",
    "snippet": "tatic int\nolder_enctype(krb5_enctype enctype)\n{\n    switch (enctype) {\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \"old\" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nolder_enctype(krb5_enctype enctype)\n{\n    switch (enctype) {\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \"old\" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}"
  },
  {
    "function_name": "kdc_encode_reply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "810-987",
    "snippet": "rb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Internal error in ASN.1 encoder\")"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "GS_REP,",
            "uf,",
            "uf_size,",
            "ep,",
            "len,",
            "et)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "k_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,",
            "uf,",
            "en,",
            "kvno,",
            "rep->enc_part)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "S_REP,",
            "uf,",
            "uf_size,",
            "ep,",
            "len,",
            "et)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_AS_REP_ENC_PART,",
            "uf,",
            "en,",
            "kvno,",
            "rep->enc_part)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "eply_key,",
            ",",
            "crypto)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncTGSRepPart,",
            "uf,",
            "uf_size,",
            "k,",
            "len,",
            "et)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncASRepPart,",
            "uf,",
            "uf_size,",
            "k,",
            "len,",
            "et)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PrincipalName(",
          "args": [
            "rep->cname)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "ep->padata,",
            "RB5_PADATA_FX_FAST,",
            "ata.data,",
            "ata.length)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*(rep->padata)))"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "ep->padata)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "finished.ticket_checksum)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fast_mk_response(",
          "args": [
            "ontext,",
            "rmor_crypto,",
            "ep->padata,",
            "trengthen_key,",
            "finished,",
            "once,",
            "data)"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fast_mk_response(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "180-236",
          "snippet": "rb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "ontext,",
            "rmor_crypto,",
            "RB5_KU_FAST_FINISHED,",
            ",",
            "ata.data,",
            "ata.length,",
            "finished.ticket_checksum)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 error\")"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "icket,",
            "ata.data,",
            "ata.length,",
            "rep->ticket,",
            "len,",
            "et)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "data)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "finished,",
            ",",
            "izeof(finished))"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_TICKET,",
            "uf,",
            "en,",
            "kvno,",
            "rep->ticket.enc_part)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "key,",
            "type,",
            "crypto)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal error in ASN.1 encoder\")"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncTicketPart,",
            "uf,",
            "uf_size,",
            "t,",
            "len,",
            "et)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}"
  },
  {
    "function_name": "og_patypes(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "773-804",
    "snippet": "tatic void\nlog_patypes(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    METHOD_DATA *padata)\n{\n    struct rk_strpool *p = NULL;\n    char *str;\n    size_t n, m;\n\t\n    for (n = 0; n < padata->len; n++) {\n\tfor (m = 0; m < sizeof(pat) / sizeof(pat[0]); m++) {\n\t    if (padata->val[n].padata_type == pat[m].type) {\n\t\tp = rk_strpoolprintf(p, \"%s\", pat[m].name);\n\t\tbreak;\n\t    }\n\t}\n\tif (m == sizeof(pat) / sizeof(pat[0]))\n\t    p = rk_strpoolprintf(p, \"%d\", padata->val[n].padata_type);\n\tif (p && n + 1 < padata->len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"none\");\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"Client sent patypes: %s\", str);\n    free(str);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Client sent patypes: %s\",",
            "tr)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_strpoolcollect(",
          "args": [
            ")"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "none\")"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            ", \")"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "%d\",",
            "adata->val[n].padata_type)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_strpoolprintf(",
          "args": [
            ",",
            "%s\",",
            "at[m].name)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};\n\ntatic void\nlog_patypes(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    METHOD_DATA *padata)\n{\n    struct rk_strpool *p = NULL;\n    char *str;\n    size_t n, m;\n\t\n    for (n = 0; n < padata->len; n++) {\n\tfor (m = 0; m < sizeof(pat) / sizeof(pat[0]); m++) {\n\t    if (padata->val[n].padata_type == pat[m].type) {\n\t\tp = rk_strpoolprintf(p, \"%s\", pat[m].name);\n\t\tbreak;\n\t    }\n\t}\n\tif (m == sizeof(pat) / sizeof(pat[0]))\n\t    p = rk_strpoolprintf(p, \"%d\", padata->val[n].padata_type);\n\tif (p && n + 1 < padata->len)\n\t    p = rk_strpoolprintf(p, \", \");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \"out of memory\");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \"none\");\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \"Client sent patypes: %s\", str);\n    free(str);\n}"
  },
  {
    "function_name": "a_enc_ts_validate(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "573-726",
    "snippet": "tatic krb5_error_code\npa_enc_ts_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    EncryptedData enc_data;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    krb5_data ts_data;\n    PA_ENC_TS_ENC p;\n    size_t len;\n    Key *pa_key;\n    char *str;\n\t\n    if (_kdc_is_anon_request(&r->req.req_body)) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_set_e_text(r, \"ENC-TS doesn't support anon\");\n\tgoto out;\n    }\n\n    ret = decode_EncryptedData(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &enc_data,\n\t\t\t       &len);\n    if (ret) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-DATA -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n\t\n    ret = hdb_enctype2key(r->context, &r->client->entry, NULL,\n\t\t\t  enc_data.etype, &pa_key);\n    if(ret){\n\tchar *estr;\n\t_kdc_set_e_text(r, \"No key matching entype\");\n\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\tif(krb5_enctype_to_string(r->context, enc_data.etype, &estr))\n\t    estr = NULL;\n\tif(estr == NULL)\n\t    _kdc_r_log(r, 5,\n\t\t       \"No client key matching pa-data (%d) -- %s\",\n\t\t       enc_data.etype, r->client_name);\n\telse\n\t    _kdc_r_log(r, 5,\n\t\t       \"No client key matching pa-data (%s) -- %s\",\n\t\t       estr, r->client_name);\n\tfree(estr);\n\tfree_EncryptedData(&enc_data);\n\tgoto out;\n    }\n\n try_next_key:\n    ret = krb5_crypto_init(r->context, &pa_key->key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(r->context, ret);\n\t_kdc_r_log(r, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(r->context, msg);\n\tfree_EncryptedData(&enc_data);\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData (r->context,\n\t\t\t\t      crypto,\n\t\t\t\t      KRB5_KU_PA_ENC_TIMESTAMP,\n\t\t\t\t      &enc_data,\n\t\t\t\t      &ts_data);\n    krb5_crypto_destroy(r->context, crypto);\n    /*\n     * Since the user might have several keys with the same\n     * enctype but with diffrent salting, we need to try all\n     * the keys with the same enctype.\n     */\n    if(ret){\n\tkrb5_error_code ret2;\n\tconst char *msg = krb5_get_error_message(r->context, ret);\n\n\tret2 = krb5_enctype_to_string(r->context,\n\t\t\t\t      pa_key->key.keytype, &str);\n\tif (ret2)\n\t    str = NULL;\n\t_kdc_r_log(r, 5, \"Failed to decrypt PA-DATA -- %s \"\n\t\t   \"(enctype %s) error %s\",\n\t\t   r->client_name, str ? str : \"unknown enctype\", msg);\n\tkrb5_free_error_message(r->context, msg);\n\tfree(str);\n\n\tif(hdb_next_enctype2key(r->context, &r->client->entry, NULL,\n\t\t\t\tenc_data.etype, &pa_key) == 0)\n\t    goto try_next_key;\n\n\tfree_EncryptedData(&enc_data);\n\n\tif (r->clientdb->hdb_auth_status)\n\t    r->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t\t HDB_AUTH_WRONG_PASSWORD);\n\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n    free_EncryptedData(&enc_data);\n    ret = decode_PA_ENC_TS_ENC(ts_data.data,\n\t\t\t       ts_data.length,\n\t\t\t       &p,\n\t\t\t       &len);\n    krb5_data_free(&ts_data);\n    if(ret){\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-ENC-TS_ENC -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n    if (labs(kdc_time - p.patimestamp) > r->context->max_skew) {\n\tchar client_time[100];\n\t\t\n\tkrb5_format_time(r->context, p.patimestamp,\n\t\t\t client_time, sizeof(client_time), TRUE);\n\n\tret = KRB5KRB_AP_ERR_SKEW;\n\t_kdc_r_log(r, 0, \"Too large time skew, \"\n\t\t   \"client time %s is out by %u > %u seconds -- %s\",\n\t\t   client_time,\n\t\t   (unsigned)labs(kdc_time - p.patimestamp),\n\t\t   r->context->max_skew,\n\t\t   r->client_name);\n\n\t/*\n\t * The following is needed to make windows clients to\n\t * retry using the timestamp in the error message, if\n\t * there is a e_text, they become unhappy.\n\t */\n\tr->e_text = NULL;\n\tfree_PA_ENC_TS_ENC(&p);\n\tgoto out;\n    }\n    free_PA_ENC_TS_ENC(&p);\n\n    set_salt_padata(&r->outpadata, pa_key->salt);\n\n    ret = krb5_copy_keyblock_contents(r->context, &pa_key->key, &r->reply_key);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_enctype_to_string(r->context, pa_key->key.keytype, &str);\n    if (ret)\n\tstr = NULL;\n    _kdc_r_log(r, 2, \"ENC-TS Pre-authentication succeeded -- %s using %s\",\n\t       r->client_name, str ? str : \"unknown enctype\");\n    free(str);\n\n    ret = 0;\n\n out:\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_r_log(",
          "args": [
            ",",
            ",",
            "ENC-TS Pre-authentication succeeded -- %s using %s\",",
            "->client_name,",
            "tr ? str : \"unknown enctype\")"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_r_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "265-274",
          "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "->context,",
            "a_key->key.keytype,",
            "str)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_copy_keyblock_contents(",
          "args": [
            "->context,",
            "pa_key->key,",
            "r->reply_key)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_salt_padata(",
          "args": [
            "r->outpadata,",
            "a_key->salt)"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "et_salt_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "60-69",
          "snippet": "tatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_PA_ENC_TS_ENC(",
          "args": [
            "p)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_ENC_TS_ENC(",
          "args": [
            "p)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "dc_time - p.patimestamp)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "->context,",
            ".patimestamp,",
            "lient_time,",
            "izeof(client_time),",
            "RUE)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "dc_time - p.patimestamp)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "ts_data)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_ENC_TS_ENC(",
          "args": [
            "s_data.data,",
            "s_data.length,",
            "p,",
            "len)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "enc_data)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->clientdb->hdb_auth_status",
          "args": [
            "->context,",
            "->clientdb,",
            "->client,",
            "DB_AUTH_WRONG_PASSWORD)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "enc_data)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_next_enctype2key(",
          "args": [
            "->context,",
            "r->client->entry,",
            "ULL,",
            "nc_data.etype,",
            "pa_key)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "->context,",
            "sg)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "->context,",
            "a_key->key.keytype,",
            "str)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "->context,",
            "et)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "rypto)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData",
          "args": [
            "->context,",
            "rypto,",
            "RB5_KU_PA_ENC_TIMESTAMP,",
            "enc_data,",
            "ts_data)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "enc_data)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "->context,",
            "sg)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "->context,",
            "et)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "->context,",
            "pa_key->key,",
            ",",
            "crypto)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "enc_data)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "str)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "->context,",
            "nc_data.etype,",
            "estr)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_set_e_text(",
          "args": [
            ",",
            "No key matching entype\")"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_set_e_text(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "276-281",
          "snippet": "tatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "->context,",
            "r->client->entry,",
            "ULL,",
            "nc_data.etype,",
            "pa_key)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_EncryptedData(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "enc_data,",
            "len)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            "r->req.req_body)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\npa_enc_ts_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    EncryptedData enc_data;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    krb5_data ts_data;\n    PA_ENC_TS_ENC p;\n    size_t len;\n    Key *pa_key;\n    char *str;\n\t\n    if (_kdc_is_anon_request(&r->req.req_body)) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_set_e_text(r, \"ENC-TS doesn't support anon\");\n\tgoto out;\n    }\n\n    ret = decode_EncryptedData(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &enc_data,\n\t\t\t       &len);\n    if (ret) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-DATA -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n\t\n    ret = hdb_enctype2key(r->context, &r->client->entry, NULL,\n\t\t\t  enc_data.etype, &pa_key);\n    if(ret){\n\tchar *estr;\n\t_kdc_set_e_text(r, \"No key matching entype\");\n\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\tif(krb5_enctype_to_string(r->context, enc_data.etype, &estr))\n\t    estr = NULL;\n\tif(estr == NULL)\n\t    _kdc_r_log(r, 5,\n\t\t       \"No client key matching pa-data (%d) -- %s\",\n\t\t       enc_data.etype, r->client_name);\n\telse\n\t    _kdc_r_log(r, 5,\n\t\t       \"No client key matching pa-data (%s) -- %s\",\n\t\t       estr, r->client_name);\n\tfree(estr);\n\tfree_EncryptedData(&enc_data);\n\tgoto out;\n    }\n\n try_next_key:\n    ret = krb5_crypto_init(r->context, &pa_key->key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(r->context, ret);\n\t_kdc_r_log(r, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(r->context, msg);\n\tfree_EncryptedData(&enc_data);\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData (r->context,\n\t\t\t\t      crypto,\n\t\t\t\t      KRB5_KU_PA_ENC_TIMESTAMP,\n\t\t\t\t      &enc_data,\n\t\t\t\t      &ts_data);\n    krb5_crypto_destroy(r->context, crypto);\n    /*\n     * Since the user might have several keys with the same\n     * enctype but with diffrent salting, we need to try all\n     * the keys with the same enctype.\n     */\n    if(ret){\n\tkrb5_error_code ret2;\n\tconst char *msg = krb5_get_error_message(r->context, ret);\n\n\tret2 = krb5_enctype_to_string(r->context,\n\t\t\t\t      pa_key->key.keytype, &str);\n\tif (ret2)\n\t    str = NULL;\n\t_kdc_r_log(r, 5, \"Failed to decrypt PA-DATA -- %s \"\n\t\t   \"(enctype %s) error %s\",\n\t\t   r->client_name, str ? str : \"unknown enctype\", msg);\n\tkrb5_free_error_message(r->context, msg);\n\tfree(str);\n\n\tif(hdb_next_enctype2key(r->context, &r->client->entry, NULL,\n\t\t\t\tenc_data.etype, &pa_key) == 0)\n\t    goto try_next_key;\n\n\tfree_EncryptedData(&enc_data);\n\n\tif (r->clientdb->hdb_auth_status)\n\t    r->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t\t HDB_AUTH_WRONG_PASSWORD);\n\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n    free_EncryptedData(&enc_data);\n    ret = decode_PA_ENC_TS_ENC(ts_data.data,\n\t\t\t       ts_data.length,\n\t\t\t       &p,\n\t\t\t       &len);\n    krb5_data_free(&ts_data);\n    if(ret){\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-ENC-TS_ENC -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n    if (labs(kdc_time - p.patimestamp) > r->context->max_skew) {\n\tchar client_time[100];\n\t\t\n\tkrb5_format_time(r->context, p.patimestamp,\n\t\t\t client_time, sizeof(client_time), TRUE);\n\n\tret = KRB5KRB_AP_ERR_SKEW;\n\t_kdc_r_log(r, 0, \"Too large time skew, \"\n\t\t   \"client time %s is out by %u > %u seconds -- %s\",\n\t\t   client_time,\n\t\t   (unsigned)labs(kdc_time - p.patimestamp),\n\t\t   r->context->max_skew,\n\t\t   r->client_name);\n\n\t/*\n\t * The following is needed to make windows clients to\n\t * retry using the timestamp in the error message, if\n\t * there is a e_text, they become unhappy.\n\t */\n\tr->e_text = NULL;\n\tfree_PA_ENC_TS_ENC(&p);\n\tgoto out;\n    }\n    free_PA_ENC_TS_ENC(&p);\n\n    set_salt_padata(&r->outpadata, pa_key->salt);\n\n    ret = krb5_copy_keyblock_contents(r->context, &pa_key->key, &r->reply_key);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_enctype_to_string(r->context, pa_key->key.keytype, &str);\n    if (ret)\n\tstr = NULL;\n    _kdc_r_log(r, 2, \"ENC-TS Pre-authentication succeeded -- %s using %s\",\n\t       r->client_name, str ? str : \"unknown enctype\");\n    free(str);\n\n    ret = 0;\n\n out:\n\n    return ret;\n}"
  },
  {
    "function_name": "a_enc_chal_validate(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "421-571",
    "snippet": "tatic krb5_error_code\npa_enc_chal_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_data pepper1, pepper2, ts_data;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    int invalidPassword = 0;\n    EncryptedData enc_data;\n    krb5_enctype aenctype;\n    krb5_error_code ret;\n    struct Key *k;\n    size_t size;\n    int i;\n\n    heim_assert(r->armor_crypto != NULL, \"ENC-CHAL called for non FAST\");\n    \n    if (_kdc_is_anon_request(b)) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\tkdc_log(r->context, r->config, 0, \"ENC-CHALL doesn't support anon\");\n\treturn ret;\n    }\n\n    ret = decode_EncryptedData(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &enc_data,\n\t\t\t       &size);\n    if (ret) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-DATA -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n\n    pepper1.data = \"clientchallengearmor\";\n    pepper1.length = strlen(pepper1.data);\n    pepper2.data = \"challengelongterm\";\n    pepper2.length = strlen(pepper2.data);\n\n    krb5_crypto_getenctype(r->context, r->armor_crypto, &aenctype);\n\n    for (i = 0; i < r->client->entry.keys.len; i++) {\n\tkrb5_crypto challangecrypto, longtermcrypto;\n\tkrb5_keyblock challangekey;\n\tPA_ENC_TS_ENC p;\n\n\tk = &r->client->entry.keys.val[i];\n\t\n\tret = krb5_crypto_init(r->context, &k->key, 0, &longtermcrypto);\n\tif (ret)\n\t    continue;\t\t\t\n\t\n\tret = krb5_crypto_fx_cf2(r->context, r->armor_crypto, longtermcrypto,\n\t\t\t\t &pepper1, &pepper2, aenctype,\n\t\t\t\t &challangekey);\n\tkrb5_crypto_destroy(r->context, longtermcrypto);\n\tif (ret)\n\t    continue;\n\t\n\tret = krb5_crypto_init(r->context, &challangekey, 0,\n\t\t\t       &challangecrypto);\n\tif (ret)\n\t    continue;\n\t\n\tret = krb5_decrypt_EncryptedData(r->context, challangecrypto,\n\t\t\t\t\t KRB5_KU_ENC_CHALLENGE_CLIENT,\n\t\t\t\t\t &enc_data,\n\t\t\t\t\t &ts_data);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    krb5_error_code ret2;\n\t    char *str = NULL;\n\n\t    invalidPassword = 1;\n\n\t    ret2 = krb5_enctype_to_string(r->context, k->key.keytype, &str);\n\t    if (ret2)\n\t\tstr = NULL;\n\t    _kdc_r_log(r, 5, \"Failed to decrypt ENC-CHAL -- %s \"\n\t\t       \"(enctype %s) error %s\",\n\t\t       r->client_name, str ? str : \"unknown enctype\", msg);\n\t    krb5_free_error_message(r->context, msg);\n\t    free(str);\n\n\t    continue;\n\t}\n\t\n\tret = decode_PA_ENC_TS_ENC(ts_data.data,\n\t\t\t\t   ts_data.length,\n\t\t\t\t   &p,\n\t\t\t\t   &size);\n\tkrb5_data_free(&ts_data);\n\tif(ret){\n\t    krb5_crypto_destroy(r->context, challangecrypto);\n\t    ret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t    _kdc_r_log(r, 5, \"Failed to decode PA-ENC-TS_ENC -- %s\",\n\t\t       r->client_name);\n\t    continue;\n\t}\n\n\tif (labs(kdc_time - p.patimestamp) > r->context->max_skew) {\n\t    char client_time[100];\n\n\t    krb5_crypto_destroy(r->context, challangecrypto);\n\n\t    krb5_format_time(r->context, p.patimestamp,\n\t\t\t     client_time, sizeof(client_time), TRUE);\n\n\t    ret = KRB5KRB_AP_ERR_SKEW;\n\t    _kdc_r_log(r, 0, \"Too large time skew, \"\n\t\t       \"client time %s is out by %u > %u seconds -- %s\",\n\t\t       client_time,\n\t\t       (unsigned)labs(kdc_time - p.patimestamp),\n\t\t       r->context->max_skew,\n\t\t       r->client_name);\n\n\t    free_PA_ENC_TS_ENC(&p);\n\t    goto out;\n\t}\n\n\tfree_PA_ENC_TS_ENC(&p);\n\n\tret = make_pa_enc_challange(r->context, &r->outpadata,\n\t\t\t\t    challangecrypto);\n\tkrb5_crypto_destroy(r->context, challangecrypto);\n\tif (ret)\n\t    goto out;\n\t\t\t\t\t    \n\tset_salt_padata(&r->outpadata, k->salt);\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &k->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n\n\t/*\n\t * Success\n\t */\n\tif (r->clientdb->hdb_auth_status)\n\t    r->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t\t HDB_AUTH_SUCCESS);\n\tgoto out;\n    }\n\n    if (invalidPassword && r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t     HDB_AUTH_WRONG_PASSWORD);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n out:\n    free_EncryptedData(&enc_data);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "enc_data)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->clientdb->hdb_auth_status",
          "args": [
            "->context,",
            "->clientdb,",
            "->client,",
            "DB_AUTH_WRONG_PASSWORD)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->clientdb->hdb_auth_status",
          "args": [
            "->context,",
            "->clientdb,",
            "->client,",
            "DB_AUTH_SUCCESS)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_copy_keyblock_contents(",
          "args": [
            "->context,",
            "k->key,",
            "r->reply_key)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "->context,",
            "r->reply_key)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_salt_padata(",
          "args": [
            "r->outpadata,",
            "->salt)"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "et_salt_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "60-69",
          "snippet": "tatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "hallangecrypto)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_pa_enc_challange(",
          "args": [
            "->context,",
            "r->outpadata,",
            "hallangecrypto)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ake_pa_enc_challange(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "374-419",
          "snippet": "tatic krb5_error_code\nmake_pa_enc_challange(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_crypto crypto)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_ENC_CHALLENGE_KDC,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENCRYPTED_CHALLENGE, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_pa_enc_challange(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_crypto crypto)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_ENC_CHALLENGE_KDC,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENCRYPTED_CHALLENGE, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_PA_ENC_TS_ENC(",
          "args": [
            "p)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_ENC_TS_ENC(",
          "args": [
            "p)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_r_log(",
          "args": [
            ",",
            ",",
            "Too large time skew, \"\n\t\t       \"client time %s is out by %u > %u seconds -- %s\",",
            "lient_time,",
            "unsigned)labs(kdc_time - p.patimestamp),",
            "->context->max_skew,",
            "->client_name)"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_r_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "265-274",
          "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "dc_time - p.patimestamp)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "->context,",
            ".patimestamp,",
            "lient_time,",
            "izeof(client_time),",
            "RUE)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "hallangecrypto)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "dc_time - p.patimestamp)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "hallangecrypto)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "ts_data)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_ENC_TS_ENC(",
          "args": [
            "s_data.data,",
            "s_data.length,",
            "p,",
            "size)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "->context,",
            "sg)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "->context,",
            "->key.keytype,",
            "str)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "->context,",
            "et)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData(",
          "args": [
            "->context,",
            "hallangecrypto,",
            "RB5_KU_ENC_CHALLENGE_CLIENT,",
            "enc_data,",
            "ts_data)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "->context,",
            "challangekey,",
            ",",
            "challangecrypto)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "ongtermcrypto)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_fx_cf2(",
          "args": [
            "->context,",
            "->armor_crypto,",
            "ongtermcrypto,",
            "pepper1,",
            "pepper2,",
            "enctype,",
            "challangekey)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "->context,",
            "k->key,",
            ",",
            "longtermcrypto)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_getenctype(",
          "args": [
            "->context,",
            "->armor_crypto,",
            "aenctype)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "epper2.data)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "epper1.data)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_EncryptedData(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "enc_data,",
            "size)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "->context,",
            "->config,",
            ",",
            "ENC-CHALL doesn't support anon\")"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            ")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "->armor_crypto != NULL,",
            "ENC-CHAL called for non FAST\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\npa_enc_chal_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_data pepper1, pepper2, ts_data;\n    KDC_REQ_BODY *b = &r->req.req_body;\n    int invalidPassword = 0;\n    EncryptedData enc_data;\n    krb5_enctype aenctype;\n    krb5_error_code ret;\n    struct Key *k;\n    size_t size;\n    int i;\n\n    heim_assert(r->armor_crypto != NULL, \"ENC-CHAL called for non FAST\");\n    \n    if (_kdc_is_anon_request(b)) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\tkdc_log(r->context, r->config, 0, \"ENC-CHALL doesn't support anon\");\n\treturn ret;\n    }\n\n    ret = decode_EncryptedData(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &enc_data,\n\t\t\t       &size);\n    if (ret) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PA-DATA -- %s\",\n\t\t   r->client_name);\n\treturn ret;\n    }\n\n    pepper1.data = \"clientchallengearmor\";\n    pepper1.length = strlen(pepper1.data);\n    pepper2.data = \"challengelongterm\";\n    pepper2.length = strlen(pepper2.data);\n\n    krb5_crypto_getenctype(r->context, r->armor_crypto, &aenctype);\n\n    for (i = 0; i < r->client->entry.keys.len; i++) {\n\tkrb5_crypto challangecrypto, longtermcrypto;\n\tkrb5_keyblock challangekey;\n\tPA_ENC_TS_ENC p;\n\n\tk = &r->client->entry.keys.val[i];\n\t\n\tret = krb5_crypto_init(r->context, &k->key, 0, &longtermcrypto);\n\tif (ret)\n\t    continue;\t\t\t\n\t\n\tret = krb5_crypto_fx_cf2(r->context, r->armor_crypto, longtermcrypto,\n\t\t\t\t &pepper1, &pepper2, aenctype,\n\t\t\t\t &challangekey);\n\tkrb5_crypto_destroy(r->context, longtermcrypto);\n\tif (ret)\n\t    continue;\n\t\n\tret = krb5_crypto_init(r->context, &challangekey, 0,\n\t\t\t       &challangecrypto);\n\tif (ret)\n\t    continue;\n\t\n\tret = krb5_decrypt_EncryptedData(r->context, challangecrypto,\n\t\t\t\t\t KRB5_KU_ENC_CHALLENGE_CLIENT,\n\t\t\t\t\t &enc_data,\n\t\t\t\t\t &ts_data);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    krb5_error_code ret2;\n\t    char *str = NULL;\n\n\t    invalidPassword = 1;\n\n\t    ret2 = krb5_enctype_to_string(r->context, k->key.keytype, &str);\n\t    if (ret2)\n\t\tstr = NULL;\n\t    _kdc_r_log(r, 5, \"Failed to decrypt ENC-CHAL -- %s \"\n\t\t       \"(enctype %s) error %s\",\n\t\t       r->client_name, str ? str : \"unknown enctype\", msg);\n\t    krb5_free_error_message(r->context, msg);\n\t    free(str);\n\n\t    continue;\n\t}\n\t\n\tret = decode_PA_ENC_TS_ENC(ts_data.data,\n\t\t\t\t   ts_data.length,\n\t\t\t\t   &p,\n\t\t\t\t   &size);\n\tkrb5_data_free(&ts_data);\n\tif(ret){\n\t    krb5_crypto_destroy(r->context, challangecrypto);\n\t    ret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t    _kdc_r_log(r, 5, \"Failed to decode PA-ENC-TS_ENC -- %s\",\n\t\t       r->client_name);\n\t    continue;\n\t}\n\n\tif (labs(kdc_time - p.patimestamp) > r->context->max_skew) {\n\t    char client_time[100];\n\n\t    krb5_crypto_destroy(r->context, challangecrypto);\n\n\t    krb5_format_time(r->context, p.patimestamp,\n\t\t\t     client_time, sizeof(client_time), TRUE);\n\n\t    ret = KRB5KRB_AP_ERR_SKEW;\n\t    _kdc_r_log(r, 0, \"Too large time skew, \"\n\t\t       \"client time %s is out by %u > %u seconds -- %s\",\n\t\t       client_time,\n\t\t       (unsigned)labs(kdc_time - p.patimestamp),\n\t\t       r->context->max_skew,\n\t\t       r->client_name);\n\n\t    free_PA_ENC_TS_ENC(&p);\n\t    goto out;\n\t}\n\n\tfree_PA_ENC_TS_ENC(&p);\n\n\tret = make_pa_enc_challange(r->context, &r->outpadata,\n\t\t\t\t    challangecrypto);\n\tkrb5_crypto_destroy(r->context, challangecrypto);\n\tif (ret)\n\t    goto out;\n\t\t\t\t\t    \n\tset_salt_padata(&r->outpadata, k->salt);\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &k->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n\n\t/*\n\t * Success\n\t */\n\tif (r->clientdb->hdb_auth_status)\n\t    r->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t\t HDB_AUTH_SUCCESS);\n\tgoto out;\n    }\n\n    if (invalidPassword && r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(r->context, r->clientdb, r->client,\n\t\t\t\t     HDB_AUTH_WRONG_PASSWORD);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n out:\n    free_EncryptedData(&enc_data);\n\n    return ret;\n}"
  },
  {
    "function_name": "ake_pa_enc_challange(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "374-419",
    "snippet": "tatic krb5_error_code\nmake_pa_enc_challange(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_crypto crypto)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_ENC_CHALLENGE_KDC,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENCRYPTED_CHALLENGE, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "d,",
            "RB5_PADATA_ENCRYPTED_CHALLENGE,",
            "uf,",
            "en)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal error in ASN.1 encoder\")"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "encdata)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncryptedData,",
            "uf,",
            "uf_size,",
            "encdata,",
            "len,",
            "et)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_ENC_CHALLENGE_KDC,",
            "uf,",
            "en,",
            ",",
            "encdata)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal error in ASN.1 encoder\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_ENC_TS_ENC,",
            "uf,",
            "uf_size,",
            "p,",
            "len,",
            "et)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_us_timeofday",
          "args": [
            "ontext,",
            "p.patimestamp,",
            "usec)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nmake_pa_enc_challange(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_crypto crypto)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_ENC_CHALLENGE_KDC,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENCRYPTED_CHALLENGE, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}"
  },
  {
    "function_name": "a_pkinit_validate(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "319-366",
    "snippet": "tatic krb5_error_code\npa_pkinit_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    pk_client_params *pkp = NULL;\n    char *client_cert = NULL;\n    krb5_error_code ret;\n\n    ret = _kdc_pk_rd_padata(r->context, r->config, &r->req, pa, r->client, &pkp);\n    if (ret || pkp == NULL) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PKINIT PA-DATA -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n    \n    ret = _kdc_pk_check_client(r->context,\n\t\t\t       r->config,\n\t\t\t       r->clientdb, \n\t\t\t       r->client,\n\t\t\t       pkp,\n\t\t\t       &client_cert);\n    if (ret) {\n\t_kdc_set_e_text(r, \"PKINIT certificate not allowed to \"\n\t\t\t\"impersonate principal\");\n\tgoto out;\n    }\n\n    _kdc_r_log(r, 0, \"PKINIT pre-authentication succeeded -- %s using %s\",\n\t       r->client_name, client_cert);\n    free(client_cert);\n\n    ret = _kdc_pk_mk_pa_reply(r->context, r->config, pkp, r->client,\n\t\t\t      r->sessionetype, &r->req, &r->request,\n\t\t\t      &r->reply_key, &r->session_key, &r->outpadata);\n    if (ret) {\n\t_kdc_set_e_text(r, \"Failed to build PK-INIT reply\");\n\tgoto out;\n    }\n#if 0\n    ret = _kdc_add_inital_verified_cas(r->context, r->config,\n\t\t\t\t       pkp, &r->et);\n#endif\n out:\n    if (pkp)\n\t_kdc_pk_free_client_param(r->context, pkp);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_pk_free_client_param(",
          "args": [
            "->context,",
            "kp)"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_free_client_param(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "167-194",
          "snippet": "oid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\noid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_add_inital_verified_cas(",
          "args": [
            "->context,",
            "->config,",
            "kp,",
            "r->et)"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_add_inital_verified_cas(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1829-1856",
          "snippet": "rb5_error_code\n_kdc_add_inital_verified_cas(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     pk_client_params *cp,\n\t\t\t     EncTicketPart *tkt)\n{\n    AD_INITIAL_VERIFIED_CAS cas;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&cas, 0, sizeof(cas));\n\n    /* XXX add CAs to cas here */\n\n    ASN1_MALLOC_ENCODE(AD_INITIAL_VERIFIED_CAS, data.data, data.length,\n\t\t       &cas, &size, ret);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_add_inital_verified_cas(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     pk_client_params *cp,\n\t\t\t     EncTicketPart *tkt)\n{\n    AD_INITIAL_VERIFIED_CAS cas;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&cas, 0, sizeof(cas));\n\n    /* XXX add CAs to cas here */\n\n    ASN1_MALLOC_ENCODE(AD_INITIAL_VERIFIED_CAS, data.data, data.length,\n\t\t       &cas, &size, ret);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_set_e_text(",
          "args": [
            ",",
            "Failed to build PK-INIT reply\")"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_set_e_text(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "276-281",
          "snippet": "tatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_pk_mk_pa_reply(",
          "args": [
            "->context,",
            "->config,",
            "kp,",
            "->client,",
            "->sessionetype,",
            "r->req,",
            "r->request,",
            "r->reply_key,",
            "r->session_key,",
            "r->outpadata)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_mk_pa_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1125-1529",
          "snippet": "rb5_error_code\n_kdc_pk_mk_pa_reply(krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    pk_client_params *cp,\n\t\t    const hdb_entry_ex *client,\n\t\t    krb5_enctype sessionetype,\n\t\t    const KDC_REQ *req,\n\t\t    const krb5_data *req_buffer,\n\t\t    krb5_keyblock *reply_key,\n\t\t    krb5_keyblock *sessionkey,\n\t\t    METHOD_DATA *md)\n{\n    krb5_error_code ret;\n    void *buf = NULL;\n    size_t len = 0, size = 0;\n    krb5_enctype enctype;\n    int pa_type;\n    hx509_cert kdc_cert = NULL;\n    size_t i;\n\n    if (!config->enable_pkinit) {\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    if (req->req_body.etype.len > 0) {\n\tfor (i = 0; i < req->req_body.etype.len; i++)\n\t    if (krb5_enctype_valid(context, req->req_body.etype.val[i]) == 0)\n\t\tbreak;\n\tif (req->req_body.etype.len <= i) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"No valid enctype available from client\");\n\t    goto out;\n\t}\n\tenctype = req->req_body.etype.val[i];\n    } else\n\tenctype = ETYPE_DES3_CBC_SHA1;\n\n    if (cp->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\tconst char *type, *other = \"\";\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP;\n\n\tif (cp->keyex == USE_RSA) {\n\t    ContentInfo info;\n\n\t    type = \"enckey\";\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\n\t    ret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t\t&cp->reply_key);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t\tconfig,\n\t\t\t\t\tcp,\n\t\t\t\t\treq,\n\t\t\t\t\treq_buffer,\n\t\t\t\t\t&cp->reply_key,\n\t\t\t\t\t&info,\n\t\t\t\t\t&kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t       rep.u.encKeyPack.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    ret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\tsessionkey);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\n\t} else {\n\t    ContentInfo info;\n\n\t    switch (cp->keyex) {\n\t    case USE_DH: type = \"dh\"; break;\n\t    case USE_ECDH: type = \"ecdh\"; break;\n\t    default: krb5_abortx(context, \"unknown keyex\"); break;\n\t    }\n\n\t    if (cp->dh_group_name)\n\t\tother = cp->dh_group_name;\n\n\t    rep.element = choice_PA_PK_AS_REP_dhInfo;\n\n\t    ret = generate_dh_keyblock(context, cp, enctype);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ret = pk_mk_pa_reply_dh(context, config,\n\t\t\t\t    cp,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"create pa-reply-dh \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tgoto out;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.dhInfo.dhSignedData.data,\n\t\t\t       rep.u.dhInfo.dhSignedData.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    /* generate the session key using the method from RFC6112 */\n\t    {\n\t\tkrb5_keyblock kdc_contribution_key;\n\t\tkrb5_crypto reply_crypto;\n\t\tkrb5_crypto kdccont_crypto;\n\t\tkrb5_data p1 = { strlen(\"PKINIT\"), \"PKINIT\"};\n\t\tkrb5_data p2 = { strlen(\"KEYEXCHANGE\"), \"KEYEXCHANGE\"};\n\t\tvoid *kckdata;\n\t\tsize_t kcklen;\n\t\tEncryptedData kx;\n\t\tvoid *kxdata;\n\t\tsize_t kxlen;\n\n\t\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\t&kdc_contribution_key);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &cp->reply_key, enctype, &reply_crypto);\n\t\tif (ret) {\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &kdc_contribution_key, sessionetype, &kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\t/* KRB-FX-CF2 */\n\t\tret = krb5_crypto_fx_cf2(context, kdccont_crypto, reply_crypto,\n\t\t\t\t\t &p1, &p2, sessionetype, sessionkey);\n\t\tkrb5_crypto_destroy(context, kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptionKey, kckdata, kcklen,\n\t\t\t\t   &kdc_contribution_key, &size, ret);\n\t\tkrb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX Key failed %d\", ret);\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kcklen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\tret = krb5_encrypt_EncryptedData(context, reply_crypto, KRB5_KU_PA_PKINIT_KX,\n\t\t\t\t\tkckdata, kcklen, 0, &kx);\n\t\tkrb5_crypto_destroy(context, reply_crypto);\n\t\tfree(kckdata);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptedData, kxdata, kxlen,\n\t\t\t\t   &kx, &size, ret);\n\t\tfree_EncryptedData(&kx);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX failed %d\", ret);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kxlen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\t/* Add PA-PKINIT-KX */\n\t\tret = krb5_padata_add(context, md, KRB5_PADATA_PKINIT_KX, kxdata, kxlen);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed adding PKINIT-KX %d\", ret);\n\t\t    free(buf);\n\t\t    goto out;\n\t\t}\n\t    }\n\t}\n\n#define use_btmm_with_enckey 0\n\tif (use_btmm_with_enckey && rep.element == choice_PA_PK_AS_REP_encKeyPack) {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    heim_any any;\n\n\t    any.data = rep.u.encKeyPack.data;\n\t    any.length = rep.u.encKeyPack.length;\n\n\t    btmm.dhSignedData = NULL;\n\t    btmm.encKeyPack = &any;\n\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP_BTMM, buf, len, &btmm, &size, ret);\n\t} else {\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP, buf, len, &rep, &size, ret);\n\t}\n\n\tfree_PA_PK_AS_REP(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"encode PA-PK-AS-REP failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tkdc_log(context, config, 0, \"PK-INIT using %s %s\", type, other);\n\n    } else if (cp->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k rep;\n\tContentInfo info;\n\n\tif (cp->keyex != USE_RSA) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Windows PK-INIT doesn't support DH\");\n\t    goto out;\n\t}\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP_19;\n\trep.element = choice_PA_PK_AS_REP_Win2k_encKeyPack;\n\n\tret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t    &cp->reply_key);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t    config,\n\t\t\t\t    cp,\n\t\t\t\t    req,\n\t\t\t\t    req_buffer,\n\t\t\t\t    &cp->reply_key,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t   rep.u.encKeyPack.length, &info, &size,\n\t\t\t   ret);\n\tfree_ContentInfo(&info);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t  \"failed %d\", ret);\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tif (rep.u.encKeyPack.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REP_Win2k, buf, len, &rep, &size, ret);\n\tfree_PA_PK_AS_REP_Win2k(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t  \"encode PA-PK-AS-REP-Win2k failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t    sessionkey);\n\tif (ret) {\n\t    free(buf);\n\t    goto out;\n\t}\n\n    } else\n\tkrb5_abortx(context, \"PK-INIT internal error\");\n\n\n    ret = krb5_padata_add(context, md, pa_type, buf, len);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Failed adding PA-PK-AS-REP %d\", ret);\n\tfree(buf);\n\tgoto out;\n    }\n\n    if (config->pkinit_kdc_ocsp_file) {\n\n\tif (ocsp.expire == 0 && ocsp.next_update > kdc_time) {\n\t    struct stat sb;\n\t    int fd;\n\n\t    krb5_data_free(&ocsp.data);\n\n\t    ocsp.expire = 0;\n\t    ocsp.next_update = kdc_time + 60 * 5;\n\n\t    fd = open(config->pkinit_kdc_ocsp_file, O_RDONLY);\n\t    if (fd < 0) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to open ocsp data file %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\t    ret = fstat(fd, &sb);\n\t    if (ret) {\n\t\tret = errno;\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = krb5_data_alloc(&ocsp.data, sb.st_size);\n\t    if (ret) {\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\t    ocsp.data.length = sb.st_size;\n\t    ret = read(fd, ocsp.data.data, sb.st_size);\n\t    close(fd);\n\t    if (ret != sb.st_size) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to read ocsp data %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = hx509_ocsp_verify(context->hx509ctx,\n\t\t\t\t    kdc_time,\n\t\t\t\t    kdc_cert,\n\t\t\t\t    0,\n\t\t\t\t    ocsp.data.data, ocsp.data.length,\n\t\t\t\t    &ocsp.expire);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to verify ocsp data %d\", ret);\n\t\tkrb5_data_free(&ocsp.data);\n\t\tocsp.expire = 0;\n\t    } else if (ocsp.expire > 180) {\n\t\tocsp.expire -= 180; /* refetch the ocsp before it expire */\n\t\tocsp.next_update = ocsp.expire;\n\t    } else {\n\t\tocsp.next_update = kdc_time;\n\t    }\n\tout_ocsp:\n\t    ret = 0;\n\t}\n\n\tif (ocsp.expire != 0 && ocsp.expire > kdc_time) {\n\n\t    ret = krb5_padata_add(context, md,\n\t\t\t\t  KRB5_PADATA_PA_PK_OCSP_RESPONSE,\n\t\t\t\t  ocsp.data.data, ocsp.data.length);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed adding OCSP response %d\", ret);\n\t\tgoto out;\n\t    }\n\t}\n    }\n\nout:\n    if (kdc_cert)\n\thx509_cert_free(kdc_cert);\n\n    if (ret == 0)\n\tret = krb5_copy_keyblock_contents(context, &cp->reply_key, reply_key);\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_mk_pa_reply(krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    pk_client_params *cp,\n\t\t    const hdb_entry_ex *client,\n\t\t    krb5_enctype sessionetype,\n\t\t    const KDC_REQ *req,\n\t\t    const krb5_data *req_buffer,\n\t\t    krb5_keyblock *reply_key,\n\t\t    krb5_keyblock *sessionkey,\n\t\t    METHOD_DATA *md)\n{\n    krb5_error_code ret;\n    void *buf = NULL;\n    size_t len = 0, size = 0;\n    krb5_enctype enctype;\n    int pa_type;\n    hx509_cert kdc_cert = NULL;\n    size_t i;\n\n    if (!config->enable_pkinit) {\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    if (req->req_body.etype.len > 0) {\n\tfor (i = 0; i < req->req_body.etype.len; i++)\n\t    if (krb5_enctype_valid(context, req->req_body.etype.val[i]) == 0)\n\t\tbreak;\n\tif (req->req_body.etype.len <= i) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"No valid enctype available from client\");\n\t    goto out;\n\t}\n\tenctype = req->req_body.etype.val[i];\n    } else\n\tenctype = ETYPE_DES3_CBC_SHA1;\n\n    if (cp->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\tconst char *type, *other = \"\";\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP;\n\n\tif (cp->keyex == USE_RSA) {\n\t    ContentInfo info;\n\n\t    type = \"enckey\";\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\n\t    ret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t\t&cp->reply_key);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t\tconfig,\n\t\t\t\t\tcp,\n\t\t\t\t\treq,\n\t\t\t\t\treq_buffer,\n\t\t\t\t\t&cp->reply_key,\n\t\t\t\t\t&info,\n\t\t\t\t\t&kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t       rep.u.encKeyPack.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    ret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\tsessionkey);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\n\t} else {\n\t    ContentInfo info;\n\n\t    switch (cp->keyex) {\n\t    case USE_DH: type = \"dh\"; break;\n\t    case USE_ECDH: type = \"ecdh\"; break;\n\t    default: krb5_abortx(context, \"unknown keyex\"); break;\n\t    }\n\n\t    if (cp->dh_group_name)\n\t\tother = cp->dh_group_name;\n\n\t    rep.element = choice_PA_PK_AS_REP_dhInfo;\n\n\t    ret = generate_dh_keyblock(context, cp, enctype);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ret = pk_mk_pa_reply_dh(context, config,\n\t\t\t\t    cp,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"create pa-reply-dh \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tgoto out;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.dhInfo.dhSignedData.data,\n\t\t\t       rep.u.dhInfo.dhSignedData.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    /* generate the session key using the method from RFC6112 */\n\t    {\n\t\tkrb5_keyblock kdc_contribution_key;\n\t\tkrb5_crypto reply_crypto;\n\t\tkrb5_crypto kdccont_crypto;\n\t\tkrb5_data p1 = { strlen(\"PKINIT\"), \"PKINIT\"};\n\t\tkrb5_data p2 = { strlen(\"KEYEXCHANGE\"), \"KEYEXCHANGE\"};\n\t\tvoid *kckdata;\n\t\tsize_t kcklen;\n\t\tEncryptedData kx;\n\t\tvoid *kxdata;\n\t\tsize_t kxlen;\n\n\t\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\t&kdc_contribution_key);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &cp->reply_key, enctype, &reply_crypto);\n\t\tif (ret) {\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &kdc_contribution_key, sessionetype, &kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\t/* KRB-FX-CF2 */\n\t\tret = krb5_crypto_fx_cf2(context, kdccont_crypto, reply_crypto,\n\t\t\t\t\t &p1, &p2, sessionetype, sessionkey);\n\t\tkrb5_crypto_destroy(context, kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptionKey, kckdata, kcklen,\n\t\t\t\t   &kdc_contribution_key, &size, ret);\n\t\tkrb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX Key failed %d\", ret);\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kcklen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\tret = krb5_encrypt_EncryptedData(context, reply_crypto, KRB5_KU_PA_PKINIT_KX,\n\t\t\t\t\tkckdata, kcklen, 0, &kx);\n\t\tkrb5_crypto_destroy(context, reply_crypto);\n\t\tfree(kckdata);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptedData, kxdata, kxlen,\n\t\t\t\t   &kx, &size, ret);\n\t\tfree_EncryptedData(&kx);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX failed %d\", ret);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kxlen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\t/* Add PA-PKINIT-KX */\n\t\tret = krb5_padata_add(context, md, KRB5_PADATA_PKINIT_KX, kxdata, kxlen);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed adding PKINIT-KX %d\", ret);\n\t\t    free(buf);\n\t\t    goto out;\n\t\t}\n\t    }\n\t}\n\n#define use_btmm_with_enckey 0\n\tif (use_btmm_with_enckey && rep.element == choice_PA_PK_AS_REP_encKeyPack) {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    heim_any any;\n\n\t    any.data = rep.u.encKeyPack.data;\n\t    any.length = rep.u.encKeyPack.length;\n\n\t    btmm.dhSignedData = NULL;\n\t    btmm.encKeyPack = &any;\n\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP_BTMM, buf, len, &btmm, &size, ret);\n\t} else {\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP, buf, len, &rep, &size, ret);\n\t}\n\n\tfree_PA_PK_AS_REP(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"encode PA-PK-AS-REP failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tkdc_log(context, config, 0, \"PK-INIT using %s %s\", type, other);\n\n    } else if (cp->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k rep;\n\tContentInfo info;\n\n\tif (cp->keyex != USE_RSA) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Windows PK-INIT doesn't support DH\");\n\t    goto out;\n\t}\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP_19;\n\trep.element = choice_PA_PK_AS_REP_Win2k_encKeyPack;\n\n\tret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t    &cp->reply_key);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t    config,\n\t\t\t\t    cp,\n\t\t\t\t    req,\n\t\t\t\t    req_buffer,\n\t\t\t\t    &cp->reply_key,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t   rep.u.encKeyPack.length, &info, &size,\n\t\t\t   ret);\n\tfree_ContentInfo(&info);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t  \"failed %d\", ret);\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tif (rep.u.encKeyPack.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REP_Win2k, buf, len, &rep, &size, ret);\n\tfree_PA_PK_AS_REP_Win2k(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t  \"encode PA-PK-AS-REP-Win2k failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t    sessionkey);\n\tif (ret) {\n\t    free(buf);\n\t    goto out;\n\t}\n\n    } else\n\tkrb5_abortx(context, \"PK-INIT internal error\");\n\n\n    ret = krb5_padata_add(context, md, pa_type, buf, len);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Failed adding PA-PK-AS-REP %d\", ret);\n\tfree(buf);\n\tgoto out;\n    }\n\n    if (config->pkinit_kdc_ocsp_file) {\n\n\tif (ocsp.expire == 0 && ocsp.next_update > kdc_time) {\n\t    struct stat sb;\n\t    int fd;\n\n\t    krb5_data_free(&ocsp.data);\n\n\t    ocsp.expire = 0;\n\t    ocsp.next_update = kdc_time + 60 * 5;\n\n\t    fd = open(config->pkinit_kdc_ocsp_file, O_RDONLY);\n\t    if (fd < 0) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to open ocsp data file %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\t    ret = fstat(fd, &sb);\n\t    if (ret) {\n\t\tret = errno;\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = krb5_data_alloc(&ocsp.data, sb.st_size);\n\t    if (ret) {\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\t    ocsp.data.length = sb.st_size;\n\t    ret = read(fd, ocsp.data.data, sb.st_size);\n\t    close(fd);\n\t    if (ret != sb.st_size) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to read ocsp data %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = hx509_ocsp_verify(context->hx509ctx,\n\t\t\t\t    kdc_time,\n\t\t\t\t    kdc_cert,\n\t\t\t\t    0,\n\t\t\t\t    ocsp.data.data, ocsp.data.length,\n\t\t\t\t    &ocsp.expire);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to verify ocsp data %d\", ret);\n\t\tkrb5_data_free(&ocsp.data);\n\t\tocsp.expire = 0;\n\t    } else if (ocsp.expire > 180) {\n\t\tocsp.expire -= 180; /* refetch the ocsp before it expire */\n\t\tocsp.next_update = ocsp.expire;\n\t    } else {\n\t\tocsp.next_update = kdc_time;\n\t    }\n\tout_ocsp:\n\t    ret = 0;\n\t}\n\n\tif (ocsp.expire != 0 && ocsp.expire > kdc_time) {\n\n\t    ret = krb5_padata_add(context, md,\n\t\t\t\t  KRB5_PADATA_PA_PK_OCSP_RESPONSE,\n\t\t\t\t  ocsp.data.data, ocsp.data.length);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed adding OCSP response %d\", ret);\n\t\tgoto out;\n\t    }\n\t}\n    }\n\nout:\n    if (kdc_cert)\n\thx509_cert_free(kdc_cert);\n\n    if (ret == 0)\n\tret = krb5_copy_keyblock_contents(context, &cp->reply_key, reply_key);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "lient_cert)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_r_log(",
          "args": [
            ",",
            ",",
            "PKINIT pre-authentication succeeded -- %s using %s\",",
            "->client_name,",
            "lient_cert)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_r_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "265-274",
          "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_pk_check_client(",
          "args": [
            "->context,",
            "->config,",
            "->clientdb,",
            "->client,",
            "kp,",
            "client_cert)"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_check_client(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1664-1796",
          "snippet": "rb5_error_code\n_kdc_pk_check_client(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HDB *clientdb,\n\t\t     hdb_entry_ex *client,\n\t\t     pk_client_params *cp,\n\t\t     char **subject_name)\n{\n    const HDB_Ext_PKINIT_acl *acl;\n    const HDB_Ext_PKINIT_cert *pc;\n    krb5_error_code ret;\n    hx509_name name;\n    size_t i;\n\n    if (cp->cert == NULL) {\n\n\t*subject_name = strdup(\"anonymous client client\");\n\tif (*subject_name == NULL)\n\t    return ENOMEM;\n\treturn 0;\n    }\n\n    ret = hx509_cert_get_base_subject(context->hx509ctx,\n\t\t\t\t      cp->cert,\n\t\t\t\t      &name);\n    if (ret)\n\treturn ret;\n\n    ret = hx509_name_to_string(name, subject_name);\n    hx509_name_free(&name);\n    if (ret)\n\treturn ret;\n\n    kdc_log(context, config, 0,\n\t    \"Trying to authorize PK-INIT subject DN %s\",\n\t    *subject_name);\n\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc) {\n\thx509_cert cert;\n\tsize_t j;\n\n\tfor (j = 0; j < pc->len; j++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[j].cert.data,\n\t\t\t\t\tpc->val[j].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    ret = hx509_cert_cmp(cert, cp->cert);\n\t    hx509_cert_free(cert);\n\t    if (ret == 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Found matching PK-INIT cert in hdb\");\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n\n    if (config->pkinit_princ_in_cert) {\n\tret = match_rfc_san(context, config,\n\t\t\t    context->hx509ctx,\n\t\t\t    cp->cert,\n\t\t\t    client->entry.principal);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT SAN in certificate\");\n\t    return 0;\n\t}\n\tret = match_ms_upn_san(context, config,\n\t\t\t       context->hx509ctx,\n\t\t\t       cp->cert,\n\t\t\t       clientdb,\n\t\t\t       client);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching MS UPN SAN in certificate\");\n\t    return 0;\n\t}\n    }\n\n    ret = hdb_entry_get_pkinit_acl(&client->entry, &acl);\n    if (ret == 0 && acl != NULL) {\n\t/*\n\t * Cheat here and compare the generated name with the string\n\t * and not the reverse.\n\t */\n\tfor (i = 0; i < acl->len; i++) {\n\t    if (strcmp(*subject_name, acl->val[0].subject) != 0)\n\t\tcontinue;\n\n\t    /* Don't support isser and anchor checking right now */\n\t    if (acl->val[0].issuer)\n\t\tcontinue;\n\t    if (acl->val[0].anchor)\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT database ACL\");\n\t    return 0;\n\t}\n    }\n\n    for (i = 0; i < principal_mappings.len; i++) {\n\tkrb5_boolean b;\n\n\tb = krb5_principal_compare(context,\n\t\t\t\t   client->entry.principal,\n\t\t\t\t   principal_mappings.val[i].principal);\n\tif (b == FALSE)\n\t    continue;\n\tif (strcmp(principal_mappings.val[i].subject, *subject_name) != 0)\n\t    continue;\n\tkdc_log(context, config, 5,\n\t\t\"Found matching PK-INIT FILE ACL\");\n\treturn 0;\n    }\n\n    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    krb5_set_error_message(context, ret,\n\t\t\t  \"PKINIT no matching principals for %s\",\n\t\t\t  *subject_name);\n\n    kdc_log(context, config, 5,\n\t    \"PKINIT no matching principals for %s\",\n\t    *subject_name);\n\n    free(*subject_name);\n    *subject_name = NULL;\n\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_check_client(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HDB *clientdb,\n\t\t     hdb_entry_ex *client,\n\t\t     pk_client_params *cp,\n\t\t     char **subject_name)\n{\n    const HDB_Ext_PKINIT_acl *acl;\n    const HDB_Ext_PKINIT_cert *pc;\n    krb5_error_code ret;\n    hx509_name name;\n    size_t i;\n\n    if (cp->cert == NULL) {\n\n\t*subject_name = strdup(\"anonymous client client\");\n\tif (*subject_name == NULL)\n\t    return ENOMEM;\n\treturn 0;\n    }\n\n    ret = hx509_cert_get_base_subject(context->hx509ctx,\n\t\t\t\t      cp->cert,\n\t\t\t\t      &name);\n    if (ret)\n\treturn ret;\n\n    ret = hx509_name_to_string(name, subject_name);\n    hx509_name_free(&name);\n    if (ret)\n\treturn ret;\n\n    kdc_log(context, config, 0,\n\t    \"Trying to authorize PK-INIT subject DN %s\",\n\t    *subject_name);\n\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc) {\n\thx509_cert cert;\n\tsize_t j;\n\n\tfor (j = 0; j < pc->len; j++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[j].cert.data,\n\t\t\t\t\tpc->val[j].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    ret = hx509_cert_cmp(cert, cp->cert);\n\t    hx509_cert_free(cert);\n\t    if (ret == 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Found matching PK-INIT cert in hdb\");\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n\n    if (config->pkinit_princ_in_cert) {\n\tret = match_rfc_san(context, config,\n\t\t\t    context->hx509ctx,\n\t\t\t    cp->cert,\n\t\t\t    client->entry.principal);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT SAN in certificate\");\n\t    return 0;\n\t}\n\tret = match_ms_upn_san(context, config,\n\t\t\t       context->hx509ctx,\n\t\t\t       cp->cert,\n\t\t\t       clientdb,\n\t\t\t       client);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching MS UPN SAN in certificate\");\n\t    return 0;\n\t}\n    }\n\n    ret = hdb_entry_get_pkinit_acl(&client->entry, &acl);\n    if (ret == 0 && acl != NULL) {\n\t/*\n\t * Cheat here and compare the generated name with the string\n\t * and not the reverse.\n\t */\n\tfor (i = 0; i < acl->len; i++) {\n\t    if (strcmp(*subject_name, acl->val[0].subject) != 0)\n\t\tcontinue;\n\n\t    /* Don't support isser and anchor checking right now */\n\t    if (acl->val[0].issuer)\n\t\tcontinue;\n\t    if (acl->val[0].anchor)\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT database ACL\");\n\t    return 0;\n\t}\n    }\n\n    for (i = 0; i < principal_mappings.len; i++) {\n\tkrb5_boolean b;\n\n\tb = krb5_principal_compare(context,\n\t\t\t\t   client->entry.principal,\n\t\t\t\t   principal_mappings.val[i].principal);\n\tif (b == FALSE)\n\t    continue;\n\tif (strcmp(principal_mappings.val[i].subject, *subject_name) != 0)\n\t    continue;\n\tkdc_log(context, config, 5,\n\t\t\"Found matching PK-INIT FILE ACL\");\n\treturn 0;\n    }\n\n    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    krb5_set_error_message(context, ret,\n\t\t\t  \"PKINIT no matching principals for %s\",\n\t\t\t  *subject_name);\n\n    kdc_log(context, config, 5,\n\t    \"PKINIT no matching principals for %s\",\n\t    *subject_name);\n\n    free(*subject_name);\n    *subject_name = NULL;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_pk_rd_padata(",
          "args": [
            "->context,",
            "->config,",
            "r->req,",
            "a,",
            "->client,",
            "pkp)"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_rd_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "394-797",
          "snippet": "rb5_error_code\n_kdc_pk_rd_padata(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  const KDC_REQ *req,\n\t\t  const PA_DATA *pa,\n\t\t  hdb_entry_ex *client,\n\t\t  pk_client_params **ret_params)\n{\n    pk_client_params *cp;\n    krb5_error_code ret;\n    heim_oid eContentType = { 0, NULL }, contentInfoOid = { 0, NULL };\n    krb5_data eContent = { 0, NULL };\n    krb5_data signed_content = { 0, NULL };\n    const char *type = \"unknown type\";\n    hx509_certs trust_anchors;\n    int have_data = 0;\n    const HDB_Ext_PKINIT_cert *pc;\n\n    *ret_params = NULL;\n\n    if (!config->enable_pkinit) {\n\tkdc_log(context, config, 0, \"PK-INIT request but PK-INIT not enabled\");\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    cp = calloc(1, sizeof(*cp));\n    if (cp == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t   \"MEMORY:trust-anchors\",\n\t\t\t   0, NULL, &trust_anchors);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"failed to create trust anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_merge(context->hx509ctx, trust_anchors,\n\t\t\t    kdc_identity->anchors);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    /* Add any registered certificates for this client as trust anchors */\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc != NULL) {\n\thx509_cert cert;\n\tunsigned int i;\n\n\tfor (i = 0; i < pc->len; i++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[i].cert.data,\n\t\t\t\t\tpc->val[i].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    hx509_certs_add(context->hx509ctx, trust_anchors, cert);\n\t    hx509_cert_free(cert);\n\t}\n    }\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &cp->verify_ctx);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_set_time(cp->verify_ctx, kdc_time);\n    hx509_verify_attach_anchors(cp->verify_ctx, trust_anchors);\n    hx509_certs_free(&trust_anchors);\n\n    if (config->pkinit_allow_proxy_certs)\n\thx509_verify_set_proxy_certificate(cp->verify_ctx, 1);\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tPA_PK_AS_REQ_Win2k r;\n\n\ttype = \"PK-INIT-Win2k\";\n\n\tif (_kdc_is_anon_request(&req->req_body)) {\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = decode_PA_PK_AS_REQ_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&r,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Can't decode \"\n\t\t\t\t   \"PK-AS-REQ-Win2k: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signed_auth_pack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ_Win2k(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo(win): %d\", ret);\n\t    goto out;\n\t}\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tPA_PK_AS_REQ r;\n\n\ttype = \"PK-INIT-IETF\";\n\n\tret = decode_PA_PK_AS_REQ(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &r,\n\t\t\t\t  NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode PK-AS-REQ: %d\", ret);\n\t    goto out;\n\t}\n\n\t/* XXX look at r.kdcPkId */\n\tif (r.trustedCertifiers) {\n\t    ExternalPrincipalIdentifiers *edi = r.trustedCertifiers;\n\t    unsigned int i, maxedi;\n\n\t    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t\t   \"MEMORY:client-anchors\",\n\t\t\t\t   0, NULL,\n\t\t\t\t   &cp->client_anchors);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Can't allocate client anchors: %d\",\n\t\t\t\t       ret);\n\t\tgoto out;\n\n\t    }\n\t    /*\n\t     * If the client sent more then 10 EDI, don't bother\n\t     * looking more then 10 of performance reasons.\n\t     */\n\t    maxedi = edi->len;\n\t    if (maxedi > 10)\n\t\tmaxedi = 10;\n\t    for (i = 0; i < maxedi; i++) {\n\t\tIssuerAndSerialNumber iasn;\n\t\thx509_query *q;\n\t\thx509_cert cert;\n\t\tsize_t size;\n\n\t\tif (edi->val[i].issuerAndSerialNumber == NULL)\n\t\t    continue;\n\n\t\tret = hx509_query_alloc(context->hx509ctx, &q);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t  \"Failed to allocate hx509_query\");\n\t\t    goto out;\n\t\t}\n\n\t\tret = decode_IssuerAndSerialNumber(edi->val[i].issuerAndSerialNumber->data,\n\t\t\t\t\t\t   edi->val[i].issuerAndSerialNumber->length,\n\t\t\t\t\t\t   &iasn,\n\t\t\t\t\t\t   &size);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\t\tret = hx509_query_match_issuer_serial(q, &iasn.issuer, &iasn.serialNumber);\n\t\tfree_IssuerAndSerialNumber(&iasn);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\n\t\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t\t       kdc_identity->certs,\n\t\t\t\t       q,\n\t\t\t\t       &cert);\n\t\thx509_query_free(context->hx509ctx, q);\n\t\tif (ret)\n\t\t    continue;\n\t\thx509_certs_add(context->hx509ctx,\n\t\t\t\tcp->client_anchors, cert);\n\t\thx509_cert_free(cert);\n\t    }\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signedAuthPack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo: %d\", ret);\n\t    goto out;\n\t}\n\n    } else {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\tgoto out;\n    }\n\n    ret = der_heim_oid_cmp(&contentInfoOid, &asn1_oid_id_pkcs7_signedData);\n    if (ret != 0) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PK-AS-REQ-Win2k invalid content type oid\");\n\tgoto out;\n    }\n\n    if (!have_data) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t      \"PK-AS-REQ-Win2k no signed auth pack\");\n\tgoto out;\n    }\n\n    {\n\thx509_certs signer_certs;\n\tint flags = HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH; /* BTMM */\n\n\tif (_kdc_is_anon_request(&req->req_body))\n\t    flags |= HX509_CMS_VS_ALLOW_ZERO_SIGNER;\n\n\tret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t      cp->verify_ctx,\n\t\t\t\t      flags,\n\t\t\t\t      signed_content.data,\n\t\t\t\t      signed_content.length,\n\t\t\t\t      NULL,\n\t\t\t\t      kdc_identity->certpool,\n\t\t\t\t      &eContentType,\n\t\t\t\t      &eContent,\n\t\t\t\t      &signer_certs);\n\tif (ret) {\n\t    char *s = hx509_get_error_string(context->hx509ctx, ret);\n\t    krb5_warnx(context, \"PKINIT: failed to verify signature: %s: %d\",\n\t\t       s, ret);\n\t    free(s);\n\t    goto out;\n\t}\n\n\tif (signer_certs) {\n\t    ret = hx509_get_one_cert(context->hx509ctx, signer_certs,\n\t\t\t\t     &cp->cert);\n\t    hx509_certs_free(&signer_certs);\n\t}\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Signature is correct, now verify the signed message */\n    if (der_heim_oid_cmp(&eContentType, &asn1_oid_id_pkcs7_data) != 0 &&\n\tder_heim_oid_cmp(&eContentType, &asn1_oid_id_pkauthdata) != 0)\n    {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret, \"got wrong oid for pkauthdata\");\n\tgoto out;\n    }\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tAuthPack_Win2k ap;\n\n\tret = decode_AuthPack_Win2k(eContent.data,\n\t\t\t\t    eContent.length,\n\t\t\t\t    &ap,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator_win2k(context,\n\t\t\t\t\t     &ap.pkAuthenticator,\n\t\t\t\t\t     req);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_WIN2K;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"DH not supported for windows\");\n\t    goto out;\n\t}\n\tfree_AuthPack_Win2k(&ap);\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tAuthPack ap;\n\n\tret = decode_AuthPack(eContent.data,\n\t\t\t      eContent.length,\n\t\t\t      &ap,\n\t\t\t      NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (_kdc_is_anon_request(&req->req_body) &&\n\t    ap.clientPublicValue == NULL) {\n\t    free_AuthPack(&ap);\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator(context,\n\t\t\t\t       &ap.pkAuthenticator,\n\t\t\t\t       req);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_27;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_dhpublicnumber) == 0) {\n\t\tcp->keyex = USE_DH;\n\t\tret = get_dh_param(context, config,\n\t\t\t\t   ap.clientPublicValue, cp);\n\t    } else if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_ecPublicKey) == 0) {\n\t\tcp->keyex = USE_ECDH;\n                ret = _kdc_get_ecdh_param(context, config,\n                                          ap.clientPublicValue,\n                                          &cp->u.ecdh.public_key);\n\t    } else {\n\t\tret = KRB5_BADMSGTYPE;\n\t\tkrb5_set_error_message(context, ret, \"PKINIT unknown DH mechanism\");\n\t    }\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else\n\t    cp->keyex = USE_RSA;\n\n\tret = hx509_peer_info_alloc(context->hx509ctx,\n\t\t\t\t\t&cp->peer);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (ap.supportedCMSTypes) {\n\t    ret = hx509_peer_info_set_cms_algs(context->hx509ctx,\n\t\t\t\t\t       cp->peer,\n\t\t\t\t\t       ap.supportedCMSTypes->val,\n\t\t\t\t\t       ap.supportedCMSTypes->len);\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else {\n\t    /* assume old client */\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_crypto_des_rsdi_ede3_cbc());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_rsa_with_sha1());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_sha1());\n\t}\n\tfree_AuthPack(&ap);\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    kdc_log(context, config, 0, \"PK-INIT request of type %s\", type);\n\nout:\n    if (ret)\n\tkrb5_warn(context, ret, \"PKINIT\");\n\n    if (signed_content.data)\n\tfree(signed_content.data);\n    krb5_data_free(&eContent);\n    der_free_oid(&eContentType);\n    der_free_oid(&contentInfoOid);\n    if (ret) {\n        _kdc_pk_free_client_param(context, cp);\n    } else\n\t*ret_params = cp;\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_rd_padata(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  const KDC_REQ *req,\n\t\t  const PA_DATA *pa,\n\t\t  hdb_entry_ex *client,\n\t\t  pk_client_params **ret_params)\n{\n    pk_client_params *cp;\n    krb5_error_code ret;\n    heim_oid eContentType = { 0, NULL }, contentInfoOid = { 0, NULL };\n    krb5_data eContent = { 0, NULL };\n    krb5_data signed_content = { 0, NULL };\n    const char *type = \"unknown type\";\n    hx509_certs trust_anchors;\n    int have_data = 0;\n    const HDB_Ext_PKINIT_cert *pc;\n\n    *ret_params = NULL;\n\n    if (!config->enable_pkinit) {\n\tkdc_log(context, config, 0, \"PK-INIT request but PK-INIT not enabled\");\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    cp = calloc(1, sizeof(*cp));\n    if (cp == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t   \"MEMORY:trust-anchors\",\n\t\t\t   0, NULL, &trust_anchors);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"failed to create trust anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_merge(context->hx509ctx, trust_anchors,\n\t\t\t    kdc_identity->anchors);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    /* Add any registered certificates for this client as trust anchors */\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc != NULL) {\n\thx509_cert cert;\n\tunsigned int i;\n\n\tfor (i = 0; i < pc->len; i++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[i].cert.data,\n\t\t\t\t\tpc->val[i].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    hx509_certs_add(context->hx509ctx, trust_anchors, cert);\n\t    hx509_cert_free(cert);\n\t}\n    }\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &cp->verify_ctx);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_set_time(cp->verify_ctx, kdc_time);\n    hx509_verify_attach_anchors(cp->verify_ctx, trust_anchors);\n    hx509_certs_free(&trust_anchors);\n\n    if (config->pkinit_allow_proxy_certs)\n\thx509_verify_set_proxy_certificate(cp->verify_ctx, 1);\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tPA_PK_AS_REQ_Win2k r;\n\n\ttype = \"PK-INIT-Win2k\";\n\n\tif (_kdc_is_anon_request(&req->req_body)) {\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = decode_PA_PK_AS_REQ_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&r,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Can't decode \"\n\t\t\t\t   \"PK-AS-REQ-Win2k: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signed_auth_pack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ_Win2k(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo(win): %d\", ret);\n\t    goto out;\n\t}\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tPA_PK_AS_REQ r;\n\n\ttype = \"PK-INIT-IETF\";\n\n\tret = decode_PA_PK_AS_REQ(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &r,\n\t\t\t\t  NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode PK-AS-REQ: %d\", ret);\n\t    goto out;\n\t}\n\n\t/* XXX look at r.kdcPkId */\n\tif (r.trustedCertifiers) {\n\t    ExternalPrincipalIdentifiers *edi = r.trustedCertifiers;\n\t    unsigned int i, maxedi;\n\n\t    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t\t   \"MEMORY:client-anchors\",\n\t\t\t\t   0, NULL,\n\t\t\t\t   &cp->client_anchors);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Can't allocate client anchors: %d\",\n\t\t\t\t       ret);\n\t\tgoto out;\n\n\t    }\n\t    /*\n\t     * If the client sent more then 10 EDI, don't bother\n\t     * looking more then 10 of performance reasons.\n\t     */\n\t    maxedi = edi->len;\n\t    if (maxedi > 10)\n\t\tmaxedi = 10;\n\t    for (i = 0; i < maxedi; i++) {\n\t\tIssuerAndSerialNumber iasn;\n\t\thx509_query *q;\n\t\thx509_cert cert;\n\t\tsize_t size;\n\n\t\tif (edi->val[i].issuerAndSerialNumber == NULL)\n\t\t    continue;\n\n\t\tret = hx509_query_alloc(context->hx509ctx, &q);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t  \"Failed to allocate hx509_query\");\n\t\t    goto out;\n\t\t}\n\n\t\tret = decode_IssuerAndSerialNumber(edi->val[i].issuerAndSerialNumber->data,\n\t\t\t\t\t\t   edi->val[i].issuerAndSerialNumber->length,\n\t\t\t\t\t\t   &iasn,\n\t\t\t\t\t\t   &size);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\t\tret = hx509_query_match_issuer_serial(q, &iasn.issuer, &iasn.serialNumber);\n\t\tfree_IssuerAndSerialNumber(&iasn);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\n\t\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t\t       kdc_identity->certs,\n\t\t\t\t       q,\n\t\t\t\t       &cert);\n\t\thx509_query_free(context->hx509ctx, q);\n\t\tif (ret)\n\t\t    continue;\n\t\thx509_certs_add(context->hx509ctx,\n\t\t\t\tcp->client_anchors, cert);\n\t\thx509_cert_free(cert);\n\t    }\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signedAuthPack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo: %d\", ret);\n\t    goto out;\n\t}\n\n    } else {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\tgoto out;\n    }\n\n    ret = der_heim_oid_cmp(&contentInfoOid, &asn1_oid_id_pkcs7_signedData);\n    if (ret != 0) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PK-AS-REQ-Win2k invalid content type oid\");\n\tgoto out;\n    }\n\n    if (!have_data) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t      \"PK-AS-REQ-Win2k no signed auth pack\");\n\tgoto out;\n    }\n\n    {\n\thx509_certs signer_certs;\n\tint flags = HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH; /* BTMM */\n\n\tif (_kdc_is_anon_request(&req->req_body))\n\t    flags |= HX509_CMS_VS_ALLOW_ZERO_SIGNER;\n\n\tret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t      cp->verify_ctx,\n\t\t\t\t      flags,\n\t\t\t\t      signed_content.data,\n\t\t\t\t      signed_content.length,\n\t\t\t\t      NULL,\n\t\t\t\t      kdc_identity->certpool,\n\t\t\t\t      &eContentType,\n\t\t\t\t      &eContent,\n\t\t\t\t      &signer_certs);\n\tif (ret) {\n\t    char *s = hx509_get_error_string(context->hx509ctx, ret);\n\t    krb5_warnx(context, \"PKINIT: failed to verify signature: %s: %d\",\n\t\t       s, ret);\n\t    free(s);\n\t    goto out;\n\t}\n\n\tif (signer_certs) {\n\t    ret = hx509_get_one_cert(context->hx509ctx, signer_certs,\n\t\t\t\t     &cp->cert);\n\t    hx509_certs_free(&signer_certs);\n\t}\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Signature is correct, now verify the signed message */\n    if (der_heim_oid_cmp(&eContentType, &asn1_oid_id_pkcs7_data) != 0 &&\n\tder_heim_oid_cmp(&eContentType, &asn1_oid_id_pkauthdata) != 0)\n    {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret, \"got wrong oid for pkauthdata\");\n\tgoto out;\n    }\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tAuthPack_Win2k ap;\n\n\tret = decode_AuthPack_Win2k(eContent.data,\n\t\t\t\t    eContent.length,\n\t\t\t\t    &ap,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator_win2k(context,\n\t\t\t\t\t     &ap.pkAuthenticator,\n\t\t\t\t\t     req);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_WIN2K;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"DH not supported for windows\");\n\t    goto out;\n\t}\n\tfree_AuthPack_Win2k(&ap);\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tAuthPack ap;\n\n\tret = decode_AuthPack(eContent.data,\n\t\t\t      eContent.length,\n\t\t\t      &ap,\n\t\t\t      NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (_kdc_is_anon_request(&req->req_body) &&\n\t    ap.clientPublicValue == NULL) {\n\t    free_AuthPack(&ap);\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator(context,\n\t\t\t\t       &ap.pkAuthenticator,\n\t\t\t\t       req);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_27;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_dhpublicnumber) == 0) {\n\t\tcp->keyex = USE_DH;\n\t\tret = get_dh_param(context, config,\n\t\t\t\t   ap.clientPublicValue, cp);\n\t    } else if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_ecPublicKey) == 0) {\n\t\tcp->keyex = USE_ECDH;\n                ret = _kdc_get_ecdh_param(context, config,\n                                          ap.clientPublicValue,\n                                          &cp->u.ecdh.public_key);\n\t    } else {\n\t\tret = KRB5_BADMSGTYPE;\n\t\tkrb5_set_error_message(context, ret, \"PKINIT unknown DH mechanism\");\n\t    }\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else\n\t    cp->keyex = USE_RSA;\n\n\tret = hx509_peer_info_alloc(context->hx509ctx,\n\t\t\t\t\t&cp->peer);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (ap.supportedCMSTypes) {\n\t    ret = hx509_peer_info_set_cms_algs(context->hx509ctx,\n\t\t\t\t\t       cp->peer,\n\t\t\t\t\t       ap.supportedCMSTypes->val,\n\t\t\t\t\t       ap.supportedCMSTypes->len);\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else {\n\t    /* assume old client */\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_crypto_des_rsdi_ede3_cbc());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_rsa_with_sha1());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_sha1());\n\t}\n\tfree_AuthPack(&ap);\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    kdc_log(context, config, 0, \"PK-INIT request of type %s\", type);\n\nout:\n    if (ret)\n\tkrb5_warn(context, ret, \"PKINIT\");\n\n    if (signed_content.data)\n\tfree(signed_content.data);\n    krb5_data_free(&eContent);\n    der_free_oid(&eContentType);\n    der_free_oid(&contentInfoOid);\n    if (ret) {\n        _kdc_pk_free_client_param(context, cp);\n    } else\n\t*ret_params = cp;\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\npa_pkinit_validate(kdc_request_t r, const PA_DATA *pa)\n{\n    pk_client_params *pkp = NULL;\n    char *client_cert = NULL;\n    krb5_error_code ret;\n\n    ret = _kdc_pk_rd_padata(r->context, r->config, &r->req, pa, r->client, &pkp);\n    if (ret || pkp == NULL) {\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\t_kdc_r_log(r, 5, \"Failed to decode PKINIT PA-DATA -- %s\",\n\t\t   r->client_name);\n\tgoto out;\n    }\n    \n    ret = _kdc_pk_check_client(r->context,\n\t\t\t       r->config,\n\t\t\t       r->clientdb, \n\t\t\t       r->client,\n\t\t\t       pkp,\n\t\t\t       &client_cert);\n    if (ret) {\n\t_kdc_set_e_text(r, \"PKINIT certificate not allowed to \"\n\t\t\t\"impersonate principal\");\n\tgoto out;\n    }\n\n    _kdc_r_log(r, 0, \"PKINIT pre-authentication succeeded -- %s using %s\",\n\t       r->client_name, client_cert);\n    free(client_cert);\n\n    ret = _kdc_pk_mk_pa_reply(r->context, r->config, pkp, r->client,\n\t\t\t      r->sessionetype, &r->req, &r->request,\n\t\t\t      &r->reply_key, &r->session_key, &r->outpadata);\n    if (ret) {\n\t_kdc_set_e_text(r, \"Failed to build PK-INIT reply\");\n\tgoto out;\n    }\n#if 0\n    ret = _kdc_add_inital_verified_cas(r->context, r->config,\n\t\t\t\t       pkp, &r->et);\n#endif\n out:\n    if (pkp)\n\t_kdc_pk_free_client_param(r->context, pkp);\n\n    return ret;\n}"
  },
  {
    "function_name": "kdc_log_timestamp(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "283-311",
    "snippet": "oid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "%s authtime: %s starttime: %s endtime: %s renew till: %s\",",
            "ype,",
            "uthtime_str,",
            "tarttime_str,",
            "ndtime_str,",
            "enewtime_str)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "enewtime_str,",
            "unset\",",
            "izeof(renewtime_str))"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "renew_till,",
            "enewtime_str,",
            "izeof(renewtime_str),",
            "RUE)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "ndtime,",
            "ndtime_str,",
            "izeof(endtime_str),",
            "RUE)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "tarttime_str,",
            "unset\",",
            "izeof(starttime_str))"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "starttime,",
            "tarttime_str,",
            "izeof(starttime_str),",
            "RUE)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_format_time(",
          "args": [
            "ontext,",
            "uthtime,",
            "uthtime_str,",
            "izeof(authtime_str),",
            "RUE)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}"
  },
  {
    "function_name": "kdc_set_e_text(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "276-281",
    "snippet": "tatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "->context,",
            "->config,",
            ",",
            "%s\",",
            "_text)"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_set_e_text(kdc_request_t r, const char *e_text)\n{\n    r->e_text = e_text;\n    kdc_log(r->context, r->config, 0, \"%s\", e_text);\n}"
  },
  {
    "function_name": "kdc_r_log(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "265-274",
    "snippet": "tatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a_end(",
          "args": [
            "p)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log_msg_va(",
          "args": [
            "->context,",
            "->config,",
            "evel,",
            "mt,",
            "p)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log_msg_va(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "63-71",
          "snippet": "har*\nkdc_log_msg_va(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       int level, const char *fmt, va_list ap)\n{\n    char *msg;\n    krb5_vlog_msg(context, config->logf, &msg, level, fmt, ap);\n    return msg;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nhar*\nkdc_log_msg_va(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       int level, const char *fmt, va_list ap)\n{\n    char *msg;\n    krb5_vlog_msg(context, config->logf, &msg, level, fmt, ap);\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "a_start(",
          "args": [
            "p,",
            "mt)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\n_kdc_r_log(kdc_request_t r, int level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(r->context, r->config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
  },
  {
    "function_name": "kdc_make_anonymous_principalname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "248-263",
    "snippet": "rb5_error_code\n_kdc_make_anonymous_principalname (PrincipalName *pn)\n{\n    pn->name_type = KRB5_NT_PRINCIPAL;\n    pn->name_string.len = 1;\n    pn->name_string.val = malloc(sizeof(*pn->name_string.val));\n    if (pn->name_string.val == NULL)\n\treturn ENOMEM;\n    pn->name_string.val[0] = strdup(\"anonymous\");\n    if (pn->name_string.val[0] == NULL) {\n\tfree(pn->name_string.val);\n\tpn->name_string.val = NULL;\n\treturn ENOMEM;\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "n->name_string.val)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "anonymous\")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(*pn->name_string.val))"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_make_anonymous_principalname (PrincipalName *pn)\n{\n    pn->name_type = KRB5_NT_PRINCIPAL;\n    pn->name_string.len = 1;\n    pn->name_string.val = malloc(sizeof(*pn->name_string.val));\n    if (pn->name_string.val == NULL)\n\treturn ENOMEM;\n    pn->name_string.val[0] = strdup(\"anonymous\");\n    if (pn->name_string.val[0] == NULL) {\n\tfree(pn->name_string.val);\n\tpn->name_string.val = NULL;\n\treturn ENOMEM;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "kdc_find_etype(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "125-246",
    "snippet": "rb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_salt",
          "args": [
            "ontext,",
            "ef_salt)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_weak_exception(",
          "args": [
            "rinc->entry.principal,",
            "TYPE_DES_CBC_CRC)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_is_weak_exception(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "90-100",
          "snippet": "rb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s_default_salt_p(",
          "args": [
            "def_salt,",
            "ey)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "s_default_salt_p(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "107-117",
          "snippet": "tatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_next_enctype2key(",
          "args": [
            "ontext,",
            "princ->entry,",
            "ULL,",
            "types[i],",
            "key)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "types[i])"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_next_enctype2key(",
          "args": [
            "ontext,",
            "princ->entry,",
            "ULL,",
            "[i],",
            "key)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "[i])"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kerberos_enctypes(",
          "args": [
            "ontext)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_pw_salt(",
          "args": [
            "ontext,",
            "rinc->entry.principal,",
            "def_salt)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}"
  },
  {
    "function_name": "s_default_salt_p(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "107-117",
    "snippet": "tatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_cmp(",
          "args": [
            "default_salt->saltvalue,",
            "key->salt->salt)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}"
  },
  {
    "function_name": "kdc_is_weak_exception(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "90-100",
    "snippet": "rb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rincipal->name.name_string.val[0],",
            "afs\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}"
  },
  {
    "function_name": "kdc_find_padata(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "71-83",
    "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "et_salt_padata(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "60-69",
    "snippet": "tatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "er_copy_octet_string(",
          "args": [
            "salt->salt,",
            "md->val[md->len - 1].padata_value)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc_method_data(",
          "args": [
            "d)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ealloc_method_data(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "48-58",
          "snippet": "tatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nset_salt_padata(METHOD_DATA *md, Salt *salt)\n{\n    if (salt) {\n       realloc_method_data(md);\n       md->val[md->len - 1].padata_type = salt->type;\n       der_copy_octet_string(&salt->salt,\n                             &md->val[md->len - 1].padata_value);\n    }\n}"
  },
  {
    "function_name": "ealloc_method_data(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "48-58",
    "snippet": "tatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "d->val,",
            "md->len + 1) * sizeof(*md->val))"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nrealloc_method_data(METHOD_DATA *md)\n{\n    PA_DATA *pa;\n    pa = realloc(md->val, (md->len + 1) * sizeof(*md->val));\n    if(pa == NULL)\n\treturn ENOMEM;\n    md->val = pa;\n    md->len++;\n    return 0;\n}"
  },
  {
    "function_name": "kdc_fix_time(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
    "lines": "38-46",
    "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "t)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
  }
]