[
  {
    "function_name": "tart_kdc(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "1094-1273",
    "snippet": "oid\nstart_kdc(krb5_context context,\n\t  krb5_kdc_configuration *config, const char *argv0)\n{\n    struct timeval tv1;\n    struct timeval tv2;\n    struct descr *d;\n    unsigned int ndescr;\n    pid_t pid = -1;\n#ifdef HAVE_FORK\n    pid_t *pids;\n    int max_kdcs = config->num_kdc_processes;\n    int num_kdcs = 0;\n    int i;\n    int islive[2];\n#endif\n\n#ifdef __APPLE__\n    if (do_bonjour > 0)\n        bonjour_kid(context, config, argv0, NULL);\n#endif\n\n#ifdef HAVE_FORK\n#ifdef _SC_NPROCESSORS_ONLN\n    if (max_kdcs < 1)\n\tmax_kdcs = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n    if (max_kdcs < 1)\n\tmax_kdcs = 1;\n\n    pids = calloc(max_kdcs, sizeof(*pids));\n    if (!pids)\n\tkrb5_err(context, 1, errno, \"malloc\");\n\n    /*\n     * We open a socketpair of which we hand one end to each of our kids.\n     * When we exit, for whatever reason, the children will notice an EOF\n     * on their end and be able to cleanly exit.\n     */\n\n    if (socketpair(PF_LOCAL, SOCK_STREAM, 0, islive) == -1)\n\tkrb5_errx(context, 1, \"socketpair\");\n    socket_set_nonblocking(islive[1], 1);\n#endif\n\n    ndescr = init_sockets(context, config, &d);\n    if(ndescr <= 0)\n\tkrb5_errx(context, 1, \"No sockets!\");\n\n#ifdef HAVE_FORK\n\n# ifdef __APPLE__\n    if (do_bonjour < 0)\n        bonjour_kid(context, config, argv0, islive);\n# endif\n\n    kdc_log(context, config, 0, \"KDC started master process pid=%d\", getpid());\n#else\n    kdc_log(context, config, 0, \"KDC started pid=%d\", getpid());\n#endif\n\n    roken_detach_finish(NULL, daemon_child);\n\n    tv1.tv_sec  = 0;\n    tv1.tv_usec = 0;\n\n#ifdef HAVE_FORK\n    if (!testing_flag) {\n        /* Note that we might never execute the body of this loop */\n        while (exit_flag == 0) {\n\n            /* Slow down the creation of KDCs... */\n\n            gettimeofday(&tv2, NULL);\n            if (tv1.tv_sec == tv2.tv_sec && tv2.tv_usec - tv1.tv_usec < 25000) {\n#if 0\t/* XXXrcd: should print a message... */\n                kdc_log(context, config, 0, \"Spawning KDCs too quickly, \"\n                    \"pausing for 50ms\");\n#endif\n                select_sleep(12500);\n                continue;\n            }\n\n            if (num_kdcs >= max_kdcs) {\n                num_kdcs -= reap_kid(context, config, pids, max_kdcs, 0);\n                continue;\n            }\n\n            if (num_kdcs > 0)\n                num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n\n            pid = fork();\n            switch (pid) {\n            case 0:\n                close(islive[0]);\n                loop(context, config, d, ndescr, islive[1]);\n                exit(0);\n            case -1:\n                /* XXXrcd: hmmm, do something useful?? */\n                kdc_log(context, config, 0,\n                        \"KDC master process could not fork worker process\");\n                sleep(10);\n                break;\n            default:\n                for (i=0; i < max_kdcs; i++) {\n                    if (pids[i] == 0) {\n                        pids[i] = pid;\n                        break;\n                    }\n                }\n                kdc_log(context, config, 0, \"KDC worker process started: %d\",\n                        pid);\n                num_kdcs++;\n                gettimeofday(&tv1, NULL);\n                break;\n            }\n        }\n\n        /* Closing these sockets should cause the kids to die... */\n\n        close(islive[0]);\n        close(islive[1]);\n\n        /* Close our listener sockets before terminating workers */\n        for (i = 0; i < ndescr; ++i)\n            clear_descr(&d[i]);\n\n        gettimeofday(&tv1, NULL);\n        tv2 = tv1;\n\n        /* Reap every 10ms, terminate stragglers once a second, give up after 10 */\n        for (;;) {\n            struct timeval tv3;\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                goto end;\n            /*\n             * Using select to sleep will fail with EINTR if we receive a\n             * SIGCHLD.  This is desirable.\n             */\n            select_sleep(10000);\n            gettimeofday(&tv3, NULL);\n            if (tv3.tv_sec - tv1.tv_sec > 10 ||\n                (tv3.tv_sec - tv1.tv_sec == 10 && tv3.tv_usec >= tv1.tv_usec))\n                break;\n            if (tv3.tv_sec - tv2.tv_sec > 1 ||\n                (tv3.tv_sec - tv2.tv_sec == 1 && tv3.tv_usec >= tv2.tv_usec)) {\n                kill_kids(pids, max_kdcs, SIGTERM);\n                tv2 = tv3;\n            }\n        }\n\n        /* Kill stragglers and reap every 200ms, give up after 15s */\n        for (;;) {\n            kill_kids(pids, max_kdcs, SIGKILL);\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                break;\n            select_sleep(200000);\n            gettimeofday(&tv2, NULL);\n            if (tv2.tv_sec - tv1.tv_sec > 15 ||\n                (tv2.tv_sec - tv1.tv_sec == 15 && tv2.tv_usec >= tv1.tv_usec))\n                break;\n        }\n\n     end:\n        kdc_log(context, config, 0, \"KDC master process exiting\", pid);\n        free(pids);\n    } else {\n        loop(context, config, d, ndescr, -1);\n        kdc_log(context, config, 0, \"KDC exiting\", pid);\n    }\n#else\n    loop(context, config, d, ndescr, -1);\n    kdc_log(context, config, 0, \"KDC exiting\", pid);\n#endif\n\n    free(d);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic pid_t bonjour_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "KDC exiting\",",
            "id)"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "oop(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "descr,",
            "1)"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "oop(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "895-978",
          "snippet": "tatic void\nloop(krb5_context context, krb5_kdc_configuration *config,\n     struct descr *d, unsigned int ndescr, int islive)\n{\n\n    while (exit_flag == 0) {\n\tstruct timeval tmout;\n\tfd_set fds;\n\tint min_free = -1;\n\tint max_fd = 0;\n\tsize_t i;\n\n\tFD_ZERO(&fds);\n        if (islive > -1) {\n            FD_SET(islive, &fds);\n            max_fd = islive;\n        }\n\tfor (i = 0; i < ndescr; i++) {\n\t    if (!rk_IS_BAD_SOCKET(d[i].s)) {\n\t\tif (d[i].type == SOCK_STREAM &&\n\t\t   d[i].timeout && d[i].timeout < time(NULL)) {\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"TCP-connection from %s expired after %lu bytes\",\n\t\t\t    d[i].addr_string, (unsigned long)d[i].len);\n\t\t    clear_descr(&d[i]);\n\t\t    continue;\n\t\t}\n#ifndef NO_LIMIT_FD_SETSIZE\n\t\tif (max_fd < d[i].s)\n\t\t    max_fd = d[i].s;\n#ifdef FD_SETSIZE\n\t\tif (max_fd >= FD_SETSIZE)\n\t\t    krb5_errx(context, 1, \"fd too large\");\n#endif\n#endif\n\t\tFD_SET(d[i].s, &fds);\n\t    }\n\t}\n\n\ttmout.tv_sec = TCP_TIMEOUT;\n\ttmout.tv_usec = 0;\n\tswitch(select(max_fd + 1, &fds, 0, 0, &tmout)){\n\tcase 0:\n\t    break;\n\tcase -1:\n\t    if (errno != EINTR)\n\t\tkrb5_warn(context, rk_SOCK_ERRNO, \"select\");\n\t    break;\n\tdefault:\n#ifdef HAVE_FORK\n\t    if (islive > -1 && FD_ISSET(islive, &fds))\n\t\thandle_islive(islive);\n#endif\n\t    for (i = 0; i < ndescr; i++)\n\t\tif (!rk_IS_BAD_SOCKET(d[i].s) && FD_ISSET(d[i].s, &fds)) {\n\t\t    min_free = next_min_free(context, &d, &ndescr);\n\n\t\t    if (d[i].type == SOCK_DGRAM)\n\t\t\thandle_udp(context, config, &d[i]);\n\t\t    else if (d[i].type == SOCK_STREAM)\n\t\t\thandle_tcp(context, config, d, i, min_free);\n\t\t}\n\t}\n    }\n\n    switch (exit_flag) {\n    case -1:\n\tkdc_log(context, config, 0,\n                \"KDC worker process exiting because KDC master exited.\");\n\tbreak;\n#ifdef SIGXCPU\n    case SIGXCPU:\n\tkdc_log(context, config, 0, \"CPU time limit exceeded\");\n\tbreak;\n#endif\n    case SIGINT:\n    case SIGTERM:\n\tkdc_log(context, config, 0, \"Terminated\");\n\tbreak;\n    default:\n\tkdc_log(context, config, 0, \"Unexpected exit reason: %d\", exit_flag);\n\tbreak;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nloop(krb5_context context, krb5_kdc_configuration *config,\n     struct descr *d, unsigned int ndescr, int islive)\n{\n\n    while (exit_flag == 0) {\n\tstruct timeval tmout;\n\tfd_set fds;\n\tint min_free = -1;\n\tint max_fd = 0;\n\tsize_t i;\n\n\tFD_ZERO(&fds);\n        if (islive > -1) {\n            FD_SET(islive, &fds);\n            max_fd = islive;\n        }\n\tfor (i = 0; i < ndescr; i++) {\n\t    if (!rk_IS_BAD_SOCKET(d[i].s)) {\n\t\tif (d[i].type == SOCK_STREAM &&\n\t\t   d[i].timeout && d[i].timeout < time(NULL)) {\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"TCP-connection from %s expired after %lu bytes\",\n\t\t\t    d[i].addr_string, (unsigned long)d[i].len);\n\t\t    clear_descr(&d[i]);\n\t\t    continue;\n\t\t}\n#ifndef NO_LIMIT_FD_SETSIZE\n\t\tif (max_fd < d[i].s)\n\t\t    max_fd = d[i].s;\n#ifdef FD_SETSIZE\n\t\tif (max_fd >= FD_SETSIZE)\n\t\t    krb5_errx(context, 1, \"fd too large\");\n#endif\n#endif\n\t\tFD_SET(d[i].s, &fds);\n\t    }\n\t}\n\n\ttmout.tv_sec = TCP_TIMEOUT;\n\ttmout.tv_usec = 0;\n\tswitch(select(max_fd + 1, &fds, 0, 0, &tmout)){\n\tcase 0:\n\t    break;\n\tcase -1:\n\t    if (errno != EINTR)\n\t\tkrb5_warn(context, rk_SOCK_ERRNO, \"select\");\n\t    break;\n\tdefault:\n#ifdef HAVE_FORK\n\t    if (islive > -1 && FD_ISSET(islive, &fds))\n\t\thandle_islive(islive);\n#endif\n\t    for (i = 0; i < ndescr; i++)\n\t\tif (!rk_IS_BAD_SOCKET(d[i].s) && FD_ISSET(d[i].s, &fds)) {\n\t\t    min_free = next_min_free(context, &d, &ndescr);\n\n\t\t    if (d[i].type == SOCK_DGRAM)\n\t\t\thandle_udp(context, config, &d[i]);\n\t\t    else if (d[i].type == SOCK_STREAM)\n\t\t\thandle_tcp(context, config, d, i, min_free);\n\t\t}\n\t}\n    }\n\n    switch (exit_flag) {\n    case -1:\n\tkdc_log(context, config, 0,\n                \"KDC worker process exiting because KDC master exited.\");\n\tbreak;\n#ifdef SIGXCPU\n    case SIGXCPU:\n\tkdc_log(context, config, 0, \"CPU time limit exceeded\");\n\tbreak;\n#endif\n    case SIGINT:\n    case SIGTERM:\n\tkdc_log(context, config, 0, \"Terminated\");\n\tbreak;\n    default:\n\tkdc_log(context, config, 0, \"Unexpected exit reason: %d\", exit_flag);\n\tbreak;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ids)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "tv2,",
            "ULL)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elect_sleep(",
          "args": [
            "00000)"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "elect_sleep(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1083-1091",
          "snippet": "tatic void\nselect_sleep(int microseconds)\n{\n    struct timeval tv;\n\n    tv.tv_sec = microseconds / 1000000;\n    tv.tv_usec = microseconds % 1000000;\n    select(0, NULL, NULL, NULL, &tv);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nselect_sleep(int microseconds)\n{\n    struct timeval tv;\n\n    tv.tv_sec = microseconds / 1000000;\n    tv.tv_usec = microseconds % 1000000;\n    select(0, NULL, NULL, NULL, &tv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap_kids(",
          "args": [
            "ontext,",
            "onfig,",
            "ids,",
            "ax_kdcs)"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "eap_kids(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1068-1081",
          "snippet": "tatic int\nreap_kids(krb5_context context, krb5_kdc_configuration *config,\n\t  pid_t *pids, int max_kids)\n{\n    int reaped = 0;\n\n    for (;;) {\n\tif (reap_kid(context, config, pids, max_kids, WNOHANG) == 0)\n\t    break;\n\treaped++;\n    }\n\n    return reaped;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nreap_kids(krb5_context context, krb5_kdc_configuration *config,\n\t  pid_t *pids, int max_kids)\n{\n    int reaped = 0;\n\n    for (;;) {\n\tif (reap_kid(context, config, pids, max_kids, WNOHANG) == 0)\n\t    break;\n\treaped++;\n    }\n\n    return reaped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ill_kids(",
          "args": [
            "ids,",
            "ax_kdcs,",
            "IGKILL)"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ill_kids(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1008-1018",
          "snippet": "tatic void\nkill_kids(pid_t *pids, int max_kids, int sig)\n{\n    int i;\n\n    for (i=0; i < max_kids; i++)\n\tif (pids[i] > 0)\n\t    kill(sig, pids[i]);\n    if (bonjour_pid > 0)\n        kill(sig, bonjour_pid);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic pid_t bonjour_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic void\nkill_kids(pid_t *pids, int max_kids, int sig)\n{\n    int i;\n\n    for (i=0; i < max_kids; i++)\n\tif (pids[i] > 0)\n\t    kill(sig, pids[i]);\n    if (bonjour_pid > 0)\n        kill(sig, bonjour_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "tv3,",
            "ULL)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "tv1,",
            "ULL)"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lear_descr(",
          "args": [
            "d[i])"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "lear_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "501-510",
          "snippet": "tatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "slive[1])"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "slive[0])"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "tv1,",
            "ULL)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit(",
          "args": [
            ")"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "slive[0])"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ork(",
          "args": [],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_kid(",
          "args": [
            "ontext,",
            "onfig,",
            "ids,",
            "ax_kdcs,",
            ")"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "eap_kid(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1020-1066",
          "snippet": "tatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic pid_t bonjour_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "tv2,",
            "ULL)"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oken_detach_finish(",
          "args": [
            "ULL,",
            "aemon_child)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etpid(",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etpid(",
          "args": [],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onjour_kid(",
          "args": [
            "ontext,",
            "onfig,",
            "rgv0,",
            "slive)"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "onjour_kid(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "981-1004",
          "snippet": "tatic void\nbonjour_kid(krb5_context context, krb5_kdc_configuration *config, const char *argv0, int *islive)\n{\n    char buf;\n\n    if (do_bonjour > 0) {\n\tbonjour_announce(context, config);\n\n\twhile (read(0, &buf, 1) == 1)\n\t    continue;\n\t_exit(0);\n    }\n\n    if ((bonjour_pid = fork()) != 0)\n\treturn;\n\n    close(islive[0]);\n    if (dup2(islive[1], 0) == -1)\n\terr(1, \"failed to announce with bonjour (dup)\");\n    if (islive[1] != 0)\n        close(islive[1]);\n    execlp(argv0, \"kdc\", \"--bonjour\", NULL);\n    err(1, \"failed to announce with bonjour (exec)\");\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic pid_t bonjour_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic void\nbonjour_kid(krb5_context context, krb5_kdc_configuration *config, const char *argv0, int *islive)\n{\n    char buf;\n\n    if (do_bonjour > 0) {\n\tbonjour_announce(context, config);\n\n\twhile (read(0, &buf, 1) == 1)\n\t    continue;\n\t_exit(0);\n    }\n\n    if ((bonjour_pid = fork()) != 0)\n\treturn;\n\n    close(islive[0]);\n    if (dup2(islive[1], 0) == -1)\n\terr(1, \"failed to announce with bonjour (dup)\");\n    if (islive[1] != 0)\n        close(islive[1]);\n    execlp(argv0, \"kdc\", \"--bonjour\", NULL);\n    err(1, \"failed to announce with bonjour (exec)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "No sockets!\")"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_sockets(",
          "args": [
            "ontext,",
            "onfig,",
            "d)"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "nit_sockets(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "301-353",
          "snippet": "tatic int\ninit_sockets(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr **desc)\n{\n    krb5_error_code ret;\n    size_t i, j;\n    struct descr *d;\n    int num = 0;\n    krb5_addresses addresses;\n\n    if (explicit_addresses.len) {\n\taddresses = explicit_addresses;\n    } else {\n\tret = krb5_get_all_server_addrs (context, &addresses);\n\tif (ret)\n\t    krb5_err (context, 1, ret, \"krb5_get_all_server_addrs\");\n    }\n    parse_ports(context, config, port_str);\n    d = malloc(addresses.len * num_ports * sizeof(*d));\n    if (d == NULL)\n\tkrb5_errx(context, 1, \"malloc(%lu) failed\",\n\t\t  (unsigned long)num_ports * sizeof(*d));\n\n    for (i = 0; i < num_ports; i++){\n\tfor (j = 0; j < addresses.len; ++j) {\n\t    init_socket(context, config, &d[num], &addresses.val[j],\n\t\t\tports[i].family, ports[i].type, ports[i].port);\n\t    if(d[num].s != rk_INVALID_SOCKET){\n\t\tchar a_str[80];\n\t\tsize_t len;\n\n\t\tkrb5_print_address (&addresses.val[j], a_str,\n\t\t\t\t    sizeof(a_str), &len);\n\n\t\tkdc_log(context, config, 5, \"listening on %s port %u/%s\",\n\t\t\ta_str,\n\t\t\tntohs(ports[i].port),\n\t\t\t(ports[i].type == SOCK_STREAM) ? \"tcp\" : \"udp\");\n\t\t/* XXX */\n\t\tnum++;\n\t    }\n\t}\n    }\n    krb5_free_addresses (context, &addresses);\n    d = realloc(d, num * sizeof(*d));\n    if (d == NULL && num != 0)\n\tkrb5_errx(context, 1, \"realloc(%lu) failed\",\n\t\t  (unsigned long)num * sizeof(*d));\n    reinit_descrs (d, num);\n    *desc = d;\n    return num;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct port_desc *ports;",
            "tatic size_t num_ports;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct port_desc *ports;\ntatic size_t num_ports;\n\ntatic int\ninit_sockets(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr **desc)\n{\n    krb5_error_code ret;\n    size_t i, j;\n    struct descr *d;\n    int num = 0;\n    krb5_addresses addresses;\n\n    if (explicit_addresses.len) {\n\taddresses = explicit_addresses;\n    } else {\n\tret = krb5_get_all_server_addrs (context, &addresses);\n\tif (ret)\n\t    krb5_err (context, 1, ret, \"krb5_get_all_server_addrs\");\n    }\n    parse_ports(context, config, port_str);\n    d = malloc(addresses.len * num_ports * sizeof(*d));\n    if (d == NULL)\n\tkrb5_errx(context, 1, \"malloc(%lu) failed\",\n\t\t  (unsigned long)num_ports * sizeof(*d));\n\n    for (i = 0; i < num_ports; i++){\n\tfor (j = 0; j < addresses.len; ++j) {\n\t    init_socket(context, config, &d[num], &addresses.val[j],\n\t\t\tports[i].family, ports[i].type, ports[i].port);\n\t    if(d[num].s != rk_INVALID_SOCKET){\n\t\tchar a_str[80];\n\t\tsize_t len;\n\n\t\tkrb5_print_address (&addresses.val[j], a_str,\n\t\t\t\t    sizeof(a_str), &len);\n\n\t\tkdc_log(context, config, 5, \"listening on %s port %u/%s\",\n\t\t\ta_str,\n\t\t\tntohs(ports[i].port),\n\t\t\t(ports[i].type == SOCK_STREAM) ? \"tcp\" : \"udp\");\n\t\t/* XXX */\n\t\tnum++;\n\t    }\n\t}\n    }\n    krb5_free_addresses (context, &addresses);\n    d = realloc(d, num * sizeof(*d));\n    if (d == NULL && num != 0)\n\tkrb5_errx(context, 1, \"realloc(%lu) failed\",\n\t\t  (unsigned long)num * sizeof(*d));\n    reinit_descrs (d, num);\n    *desc = d;\n    return num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket_set_nonblocking(",
          "args": [
            "slive[1],",
            ")"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "socketpair\")"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocketpair(",
          "args": [
            "F_LOCAL,",
            "OCK_STREAM,",
            ",",
            "slive)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "rrno,",
            "malloc\")"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "ax_kdcs,",
            "izeof(*pids))"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ysconf(",
          "args": [
            "SC_NPROCESSORS_ONLN)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\noid\nstart_kdc(krb5_context context,\n\t  krb5_kdc_configuration *config, const char *argv0)\n{\n    struct timeval tv1;\n    struct timeval tv2;\n    struct descr *d;\n    unsigned int ndescr;\n    pid_t pid = -1;\n#ifdef HAVE_FORK\n    pid_t *pids;\n    int max_kdcs = config->num_kdc_processes;\n    int num_kdcs = 0;\n    int i;\n    int islive[2];\n#endif\n\n#ifdef __APPLE__\n    if (do_bonjour > 0)\n        bonjour_kid(context, config, argv0, NULL);\n#endif\n\n#ifdef HAVE_FORK\n#ifdef _SC_NPROCESSORS_ONLN\n    if (max_kdcs < 1)\n\tmax_kdcs = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n    if (max_kdcs < 1)\n\tmax_kdcs = 1;\n\n    pids = calloc(max_kdcs, sizeof(*pids));\n    if (!pids)\n\tkrb5_err(context, 1, errno, \"malloc\");\n\n    /*\n     * We open a socketpair of which we hand one end to each of our kids.\n     * When we exit, for whatever reason, the children will notice an EOF\n     * on their end and be able to cleanly exit.\n     */\n\n    if (socketpair(PF_LOCAL, SOCK_STREAM, 0, islive) == -1)\n\tkrb5_errx(context, 1, \"socketpair\");\n    socket_set_nonblocking(islive[1], 1);\n#endif\n\n    ndescr = init_sockets(context, config, &d);\n    if(ndescr <= 0)\n\tkrb5_errx(context, 1, \"No sockets!\");\n\n#ifdef HAVE_FORK\n\n# ifdef __APPLE__\n    if (do_bonjour < 0)\n        bonjour_kid(context, config, argv0, islive);\n# endif\n\n    kdc_log(context, config, 0, \"KDC started master process pid=%d\", getpid());\n#else\n    kdc_log(context, config, 0, \"KDC started pid=%d\", getpid());\n#endif\n\n    roken_detach_finish(NULL, daemon_child);\n\n    tv1.tv_sec  = 0;\n    tv1.tv_usec = 0;\n\n#ifdef HAVE_FORK\n    if (!testing_flag) {\n        /* Note that we might never execute the body of this loop */\n        while (exit_flag == 0) {\n\n            /* Slow down the creation of KDCs... */\n\n            gettimeofday(&tv2, NULL);\n            if (tv1.tv_sec == tv2.tv_sec && tv2.tv_usec - tv1.tv_usec < 25000) {\n#if 0\t/* XXXrcd: should print a message... */\n                kdc_log(context, config, 0, \"Spawning KDCs too quickly, \"\n                    \"pausing for 50ms\");\n#endif\n                select_sleep(12500);\n                continue;\n            }\n\n            if (num_kdcs >= max_kdcs) {\n                num_kdcs -= reap_kid(context, config, pids, max_kdcs, 0);\n                continue;\n            }\n\n            if (num_kdcs > 0)\n                num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n\n            pid = fork();\n            switch (pid) {\n            case 0:\n                close(islive[0]);\n                loop(context, config, d, ndescr, islive[1]);\n                exit(0);\n            case -1:\n                /* XXXrcd: hmmm, do something useful?? */\n                kdc_log(context, config, 0,\n                        \"KDC master process could not fork worker process\");\n                sleep(10);\n                break;\n            default:\n                for (i=0; i < max_kdcs; i++) {\n                    if (pids[i] == 0) {\n                        pids[i] = pid;\n                        break;\n                    }\n                }\n                kdc_log(context, config, 0, \"KDC worker process started: %d\",\n                        pid);\n                num_kdcs++;\n                gettimeofday(&tv1, NULL);\n                break;\n            }\n        }\n\n        /* Closing these sockets should cause the kids to die... */\n\n        close(islive[0]);\n        close(islive[1]);\n\n        /* Close our listener sockets before terminating workers */\n        for (i = 0; i < ndescr; ++i)\n            clear_descr(&d[i]);\n\n        gettimeofday(&tv1, NULL);\n        tv2 = tv1;\n\n        /* Reap every 10ms, terminate stragglers once a second, give up after 10 */\n        for (;;) {\n            struct timeval tv3;\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                goto end;\n            /*\n             * Using select to sleep will fail with EINTR if we receive a\n             * SIGCHLD.  This is desirable.\n             */\n            select_sleep(10000);\n            gettimeofday(&tv3, NULL);\n            if (tv3.tv_sec - tv1.tv_sec > 10 ||\n                (tv3.tv_sec - tv1.tv_sec == 10 && tv3.tv_usec >= tv1.tv_usec))\n                break;\n            if (tv3.tv_sec - tv2.tv_sec > 1 ||\n                (tv3.tv_sec - tv2.tv_sec == 1 && tv3.tv_usec >= tv2.tv_usec)) {\n                kill_kids(pids, max_kdcs, SIGTERM);\n                tv2 = tv3;\n            }\n        }\n\n        /* Kill stragglers and reap every 200ms, give up after 15s */\n        for (;;) {\n            kill_kids(pids, max_kdcs, SIGKILL);\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                break;\n            select_sleep(200000);\n            gettimeofday(&tv2, NULL);\n            if (tv2.tv_sec - tv1.tv_sec > 15 ||\n                (tv2.tv_sec - tv1.tv_sec == 15 && tv2.tv_usec >= tv1.tv_usec))\n                break;\n        }\n\n     end:\n        kdc_log(context, config, 0, \"KDC master process exiting\", pid);\n        free(pids);\n    } else {\n        loop(context, config, d, ndescr, -1);\n        kdc_log(context, config, 0, \"KDC exiting\", pid);\n    }\n#else\n    loop(context, config, d, ndescr, -1);\n    kdc_log(context, config, 0, \"KDC exiting\", pid);\n#endif\n\n    free(d);\n}"
  },
  {
    "function_name": "elect_sleep(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "1083-1091",
    "snippet": "tatic void\nselect_sleep(int microseconds)\n{\n    struct timeval tv;\n\n    tv.tv_sec = microseconds / 1000000;\n    tv.tv_usec = microseconds % 1000000;\n    select(0, NULL, NULL, NULL, &tv);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elect(",
          "args": [
            ",",
            "ULL,",
            "ULL,",
            "ULL,",
            "tv)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nselect_sleep(int microseconds)\n{\n    struct timeval tv;\n\n    tv.tv_sec = microseconds / 1000000;\n    tv.tv_usec = microseconds % 1000000;\n    select(0, NULL, NULL, NULL, &tv);\n}"
  },
  {
    "function_name": "eap_kids(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "1068-1081",
    "snippet": "tatic int\nreap_kids(krb5_context context, krb5_kdc_configuration *config,\n\t  pid_t *pids, int max_kids)\n{\n    int reaped = 0;\n\n    for (;;) {\n\tif (reap_kid(context, config, pids, max_kids, WNOHANG) == 0)\n\t    break;\n\treaped++;\n    }\n\n    return reaped;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eap_kid(",
          "args": [
            "ontext,",
            "onfig,",
            "ids,",
            "ax_kids,",
            "NOHANG)"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "eap_kid(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1020-1066",
          "snippet": "tatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic pid_t bonjour_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nreap_kids(krb5_context context, krb5_kdc_configuration *config,\n\t  pid_t *pids, int max_kids)\n{\n    int reaped = 0;\n\n    for (;;) {\n\tif (reap_kid(context, config, pids, max_kids, WNOHANG) == 0)\n\t    break;\n\treaped++;\n    }\n\n    return reaped;\n}"
  },
  {
    "function_name": "eap_kid(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "1020-1066",
    "snippet": "tatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic pid_t bonjour_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "KDC reaped %s process: %d\",",
            "hat,",
            "int)pid)"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COREDUMP(",
          "args": [
            "tatus)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TERMSIG(",
          "args": [
            "tatus)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFSIGNALED(",
          "args": [
            "tatus)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXITSTATUS(",
          "args": [
            "tatus)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFEXITED(",
          "args": [
            "tatus)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aitpid(",
          "args": [
            "1,",
            "status,",
            "ptions)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic int\nreap_kid(krb5_context context, krb5_kdc_configuration *config,\n\t pid_t *pids, int max_kids, int options)\n{\n    pid_t pid;\n    char *what;\n    int status;\n    int i = 0; /* quiet warnings */\n\n    pid = waitpid(-1, &status, options);\n    if (pid < 1)\n\treturn 0;\n\n    if (pid != bonjour_pid) {\n        for (i=0; i < max_kids; i++) {\n            if (pids[i] == pid)\n                break;\n        }\n\n        if (i == max_kids) {\n            /* XXXrcd: this should not happen, have to do something, though */\n            return 0;\n        }\n    }\n\n    if (pid == bonjour_pid)\n        what = \"bonjour\";\n    else\n        what = \"worker\";\n    if (WIFEXITED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, exit status: %d\",\n                what, (int)pid, WEXITSTATUS(status));\n    else if (WIFSIGNALED(status))\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d, term signal %d%s\",\n                what, (int)pid, WTERMSIG(status),\n                WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n    else\n        kdc_log(context, config, 0, \"KDC reaped %s process: %d\",\n                what, (int)pid);\n    if (pid == bonjour_pid) {\n        bonjour_pid = (pid_t)-1;\n        return 0;\n    } else {\n        pids[i] = (pid_t)-1;\n        return 1;\n    }\n}"
  },
  {
    "function_name": "ill_kids(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "1008-1018",
    "snippet": "tatic void\nkill_kids(pid_t *pids, int max_kids, int sig)\n{\n    int i;\n\n    for (i=0; i < max_kids; i++)\n\tif (pids[i] > 0)\n\t    kill(sig, pids[i]);\n    if (bonjour_pid > 0)\n        kill(sig, bonjour_pid);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic pid_t bonjour_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ill(",
          "args": [
            "ig,",
            "onjour_pid)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ill(",
          "args": [
            "ig,",
            "ids[i])"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic void\nkill_kids(pid_t *pids, int max_kids, int sig)\n{\n    int i;\n\n    for (i=0; i < max_kids; i++)\n\tif (pids[i] > 0)\n\t    kill(sig, pids[i]);\n    if (bonjour_pid > 0)\n        kill(sig, bonjour_pid);\n}"
  },
  {
    "function_name": "onjour_kid(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "981-1004",
    "snippet": "tatic void\nbonjour_kid(krb5_context context, krb5_kdc_configuration *config, const char *argv0, int *islive)\n{\n    char buf;\n\n    if (do_bonjour > 0) {\n\tbonjour_announce(context, config);\n\n\twhile (read(0, &buf, 1) == 1)\n\t    continue;\n\t_exit(0);\n    }\n\n    if ((bonjour_pid = fork()) != 0)\n\treturn;\n\n    close(islive[0]);\n    if (dup2(islive[1], 0) == -1)\n\terr(1, \"failed to announce with bonjour (dup)\");\n    if (islive[1] != 0)\n        close(islive[1]);\n    execlp(argv0, \"kdc\", \"--bonjour\", NULL);\n    err(1, \"failed to announce with bonjour (exec)\");\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic pid_t bonjour_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "failed to announce with bonjour (exec)\")"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xeclp(",
          "args": [
            "rgv0,",
            "kdc\",",
            "--bonjour\",",
            "ULL)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "slive[1])"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "failed to announce with bonjour (dup)\")"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up2(",
          "args": [
            "slive[1],",
            ")"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "slive[0])"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ork(",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit(",
          "args": [
            ")"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(",
          "args": [
            ",",
            "buf,",
            ")"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onjour_announce(",
          "args": [
            "ontext,",
            "onfig)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\ntatic void\nbonjour_kid(krb5_context context, krb5_kdc_configuration *config, const char *argv0, int *islive)\n{\n    char buf;\n\n    if (do_bonjour > 0) {\n\tbonjour_announce(context, config);\n\n\twhile (read(0, &buf, 1) == 1)\n\t    continue;\n\t_exit(0);\n    }\n\n    if ((bonjour_pid = fork()) != 0)\n\treturn;\n\n    close(islive[0]);\n    if (dup2(islive[1], 0) == -1)\n\terr(1, \"failed to announce with bonjour (dup)\");\n    if (islive[1] != 0)\n        close(islive[1]);\n    execlp(argv0, \"kdc\", \"--bonjour\", NULL);\n    err(1, \"failed to announce with bonjour (exec)\");\n}"
  },
  {
    "function_name": "oop(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "895-978",
    "snippet": "tatic void\nloop(krb5_context context, krb5_kdc_configuration *config,\n     struct descr *d, unsigned int ndescr, int islive)\n{\n\n    while (exit_flag == 0) {\n\tstruct timeval tmout;\n\tfd_set fds;\n\tint min_free = -1;\n\tint max_fd = 0;\n\tsize_t i;\n\n\tFD_ZERO(&fds);\n        if (islive > -1) {\n            FD_SET(islive, &fds);\n            max_fd = islive;\n        }\n\tfor (i = 0; i < ndescr; i++) {\n\t    if (!rk_IS_BAD_SOCKET(d[i].s)) {\n\t\tif (d[i].type == SOCK_STREAM &&\n\t\t   d[i].timeout && d[i].timeout < time(NULL)) {\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"TCP-connection from %s expired after %lu bytes\",\n\t\t\t    d[i].addr_string, (unsigned long)d[i].len);\n\t\t    clear_descr(&d[i]);\n\t\t    continue;\n\t\t}\n#ifndef NO_LIMIT_FD_SETSIZE\n\t\tif (max_fd < d[i].s)\n\t\t    max_fd = d[i].s;\n#ifdef FD_SETSIZE\n\t\tif (max_fd >= FD_SETSIZE)\n\t\t    krb5_errx(context, 1, \"fd too large\");\n#endif\n#endif\n\t\tFD_SET(d[i].s, &fds);\n\t    }\n\t}\n\n\ttmout.tv_sec = TCP_TIMEOUT;\n\ttmout.tv_usec = 0;\n\tswitch(select(max_fd + 1, &fds, 0, 0, &tmout)){\n\tcase 0:\n\t    break;\n\tcase -1:\n\t    if (errno != EINTR)\n\t\tkrb5_warn(context, rk_SOCK_ERRNO, \"select\");\n\t    break;\n\tdefault:\n#ifdef HAVE_FORK\n\t    if (islive > -1 && FD_ISSET(islive, &fds))\n\t\thandle_islive(islive);\n#endif\n\t    for (i = 0; i < ndescr; i++)\n\t\tif (!rk_IS_BAD_SOCKET(d[i].s) && FD_ISSET(d[i].s, &fds)) {\n\t\t    min_free = next_min_free(context, &d, &ndescr);\n\n\t\t    if (d[i].type == SOCK_DGRAM)\n\t\t\thandle_udp(context, config, &d[i]);\n\t\t    else if (d[i].type == SOCK_STREAM)\n\t\t\thandle_tcp(context, config, d, i, min_free);\n\t\t}\n\t}\n    }\n\n    switch (exit_flag) {\n    case -1:\n\tkdc_log(context, config, 0,\n                \"KDC worker process exiting because KDC master exited.\");\n\tbreak;\n#ifdef SIGXCPU\n    case SIGXCPU:\n\tkdc_log(context, config, 0, \"CPU time limit exceeded\");\n\tbreak;\n#endif\n    case SIGINT:\n    case SIGTERM:\n\tkdc_log(context, config, 0, \"Terminated\");\n\tbreak;\n    default:\n\tkdc_log(context, config, 0, \"Unexpected exit reason: %d\", exit_flag);\n\tbreak;\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Unexpected exit reason: %d\",",
            "xit_flag)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "andle_tcp(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            ",",
            "in_free)"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "andle_tcp(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "758-838",
          "snippet": "tatic void\nhandle_tcp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d, int idx, int min_free)\n{\n    unsigned char buf[1024];\n    int n;\n    int ret = 0;\n\n    if (d[idx].timeout == 0) {\n\tadd_new_tcp (context, config, d, idx, min_free);\n\treturn;\n    }\n\n    n = recvfrom(d[idx].s, buf, sizeof(buf), 0, NULL, NULL);\n    if(rk_IS_SOCKET_ERROR(n)){\n\tkrb5_warn(context, rk_SOCK_ERRNO, \"recvfrom failed from %s to %s/%d\",\n\t\t  d[idx].addr_string, descr_type(d + idx),\n\t\t  ntohs(d[idx].port));\n\treturn;\n    } else if (n == 0) {\n\tkrb5_warnx(context, \"connection closed before end of data after %lu \"\n\t\t   \"bytes from %s to %s/%d\", (unsigned long)d[idx].len,\n\t\t   d[idx].addr_string, descr_type(d + idx),\n\t\t   ntohs(d[idx].port));\n\tclear_descr (d + idx);\n\treturn;\n    }\n    if (grow_descr (context, config, &d[idx], n))\n\treturn;\n    memcpy(d[idx].buf + d[idx].len, buf, n);\n    d[idx].len += n;\n    if(d[idx].len > 4 && d[idx].buf[0] == 0) {\n\tret = handle_vanilla_tcp (context, config, &d[idx]);\n    } else if(enable_http &&\n\t      d[idx].len >= 4 &&\n\t      strncmp((char *)d[idx].buf, \"GET \", 4) == 0 &&\n\t      strncmp((char *)d[idx].buf + d[idx].len - 4,\n\t\t      \"\\r\\n\\r\\n\", 4) == 0) {\n\n        /* remove the trailing \\r\\n\\r\\n so the string is NUL terminated */\n        d[idx].buf[d[idx].len - 4] = '\\0';\n\n\tret = handle_http_tcp (context, config, &d[idx]);\n\tif (ret < 0)\n\t    clear_descr (d + idx);\n    } else if (d[idx].len > 4) {\n\tkdc_log (context, config,\n\t\t 0, \"TCP data of strange type from %s to %s/%d\",\n\t\t d[idx].addr_string, descr_type(d + idx),\n\t\t ntohs(d[idx].port));\n\tif (d[idx].buf[0] & 0x80) {\n\t    krb5_data reply;\n\n\t    kdc_log (context, config, 0, \"TCP extension not supported\");\n\n\t    ret = krb5_mk_error(context,\n\t\t\t\tKRB5KRB_ERR_FIELD_TOOLONG,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&reply);\n\t    if (ret == 0) {\n\t\tsend_reply(context, config, TRUE, d + idx, &reply);\n\t\tkrb5_data_free(&reply);\n\t    }\n\t}\n\tclear_descr(d + idx);\n\treturn;\n    }\n    if (ret < 0)\n\treturn;\n    else if (ret == 1) {\n\tdo_request(context, config,\n\t\t   d[idx].buf, d[idx].len, TRUE, &d[idx]);\n\tclear_descr(d + idx);\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_tcp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d, int idx, int min_free)\n{\n    unsigned char buf[1024];\n    int n;\n    int ret = 0;\n\n    if (d[idx].timeout == 0) {\n\tadd_new_tcp (context, config, d, idx, min_free);\n\treturn;\n    }\n\n    n = recvfrom(d[idx].s, buf, sizeof(buf), 0, NULL, NULL);\n    if(rk_IS_SOCKET_ERROR(n)){\n\tkrb5_warn(context, rk_SOCK_ERRNO, \"recvfrom failed from %s to %s/%d\",\n\t\t  d[idx].addr_string, descr_type(d + idx),\n\t\t  ntohs(d[idx].port));\n\treturn;\n    } else if (n == 0) {\n\tkrb5_warnx(context, \"connection closed before end of data after %lu \"\n\t\t   \"bytes from %s to %s/%d\", (unsigned long)d[idx].len,\n\t\t   d[idx].addr_string, descr_type(d + idx),\n\t\t   ntohs(d[idx].port));\n\tclear_descr (d + idx);\n\treturn;\n    }\n    if (grow_descr (context, config, &d[idx], n))\n\treturn;\n    memcpy(d[idx].buf + d[idx].len, buf, n);\n    d[idx].len += n;\n    if(d[idx].len > 4 && d[idx].buf[0] == 0) {\n\tret = handle_vanilla_tcp (context, config, &d[idx]);\n    } else if(enable_http &&\n\t      d[idx].len >= 4 &&\n\t      strncmp((char *)d[idx].buf, \"GET \", 4) == 0 &&\n\t      strncmp((char *)d[idx].buf + d[idx].len - 4,\n\t\t      \"\\r\\n\\r\\n\", 4) == 0) {\n\n        /* remove the trailing \\r\\n\\r\\n so the string is NUL terminated */\n        d[idx].buf[d[idx].len - 4] = '\\0';\n\n\tret = handle_http_tcp (context, config, &d[idx]);\n\tif (ret < 0)\n\t    clear_descr (d + idx);\n    } else if (d[idx].len > 4) {\n\tkdc_log (context, config,\n\t\t 0, \"TCP data of strange type from %s to %s/%d\",\n\t\t d[idx].addr_string, descr_type(d + idx),\n\t\t ntohs(d[idx].port));\n\tif (d[idx].buf[0] & 0x80) {\n\t    krb5_data reply;\n\n\t    kdc_log (context, config, 0, \"TCP extension not supported\");\n\n\t    ret = krb5_mk_error(context,\n\t\t\t\tKRB5KRB_ERR_FIELD_TOOLONG,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&reply);\n\t    if (ret == 0) {\n\t\tsend_reply(context, config, TRUE, d + idx, &reply);\n\t\tkrb5_data_free(&reply);\n\t    }\n\t}\n\tclear_descr(d + idx);\n\treturn;\n    }\n    if (ret < 0)\n\treturn;\n    else if (ret == 1) {\n\tdo_request(context, config,\n\t\t   d[idx].buf, d[idx].len, TRUE, &d[idx]);\n\tclear_descr(d + idx);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "andle_udp(",
          "args": [
            "ontext,",
            "onfig,",
            "d[i])"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "andle_udp(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "455-499",
          "snippet": "tatic void\nhandle_udp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d)\n{\n    unsigned char *buf;\n    ssize_t n;\n\n    buf = malloc(max_request_udp);\n    if (buf == NULL){\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t        (unsigned long)max_request_udp);\n\treturn;\n    }\n\n    d->sock_len = sizeof(d->__ss);\n    n = recvfrom(d->s, buf, max_request_udp, 0, d->sa, &d->sock_len);\n    if (rk_IS_SOCKET_ERROR(n)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"recvfrom\");\n    } else {\n\taddr_to_string (context, d->sa, d->sock_len,\n\t\t\td->addr_string, sizeof(d->addr_string));\n\tif ((size_t)n == max_request_udp) {\n\t    krb5_data data;\n\t    krb5_warn(context, errno,\n\t\t      \"recvfrom: truncated packet from %s, asking for TCP\",\n\t\t      d->addr_string);\n\t    krb5_mk_error(context,\n\t\t\t  KRB5KRB_ERR_RESPONSE_TOO_BIG,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  &data);\n\t    send_reply(context, config, FALSE, d, &data);\n\t    krb5_data_free(&data);\n\t} else {\n\t    do_request(context, config, buf, n, FALSE, d);\n\t}\n    }\n    free (buf);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_udp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d)\n{\n    unsigned char *buf;\n    ssize_t n;\n\n    buf = malloc(max_request_udp);\n    if (buf == NULL){\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t        (unsigned long)max_request_udp);\n\treturn;\n    }\n\n    d->sock_len = sizeof(d->__ss);\n    n = recvfrom(d->s, buf, max_request_udp, 0, d->sa, &d->sock_len);\n    if (rk_IS_SOCKET_ERROR(n)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"recvfrom\");\n    } else {\n\taddr_to_string (context, d->sa, d->sock_len,\n\t\t\td->addr_string, sizeof(d->addr_string));\n\tif ((size_t)n == max_request_udp) {\n\t    krb5_data data;\n\t    krb5_warn(context, errno,\n\t\t      \"recvfrom: truncated packet from %s, asking for TCP\",\n\t\t      d->addr_string);\n\t    krb5_mk_error(context,\n\t\t\t  KRB5KRB_ERR_RESPONSE_TOO_BIG,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  &data);\n\t    send_reply(context, config, FALSE, d, &data);\n\t    krb5_data_free(&data);\n\t} else {\n\t    do_request(context, config, buf, n, FALSE, d);\n\t}\n    }\n    free (buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_min_free(",
          "args": [
            "ontext,",
            "d,",
            "ndescr)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ext_min_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "874-893",
          "snippet": "nt\nnext_min_free(krb5_context context, struct descr **d, unsigned int *ndescr)\n{\n    size_t i;\n    int min_free;\n\n    for(i = 0; i < *ndescr; i++) {\n        int s = (*d + i)->s;\n        if(rk_IS_BAD_SOCKET(s))\n            return i;\n    }\n\n    min_free = *ndescr;\n    if(!realloc_descrs(d, ndescr)) {\n        min_free = -1;\n        krb5_warnx(context, \"No memory\");\n    }\n\n    return min_free;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nnt\nnext_min_free(krb5_context context, struct descr **d, unsigned int *ndescr)\n{\n    size_t i;\n    int min_free;\n\n    for(i = 0; i < *ndescr; i++) {\n        int s = (*d + i)->s;\n        if(rk_IS_BAD_SOCKET(s))\n            return i;\n    }\n\n    min_free = *ndescr;\n    if(!realloc_descrs(d, ndescr)) {\n        min_free = -1;\n        krb5_warnx(context, \"No memory\");\n    }\n\n    return min_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D_ISSET(",
          "args": [
            "[i].s,",
            "fds)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_BAD_SOCKET(",
          "args": [
            "[i].s)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andle_islive(",
          "args": [
            "slive)"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "andle_islive(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "841-850",
          "snippet": "tatic void\nhandle_islive(int fd)\n{\n    char buf;\n    int ret;\n\n    ret = read(fd, &buf, 1);\n    if (ret != 1)\n\texit_flag = -1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_islive(int fd)\n{\n    char buf;\n    int ret;\n\n    ret = read(fd, &buf, 1);\n    if (ret != 1)\n\texit_flag = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "D_ISSET(",
          "args": [
            "slive,",
            "fds)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "k_SOCK_ERRNO,",
            "select\")"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elect(",
          "args": [
            "ax_fd + 1,",
            "fds,",
            ",",
            ",",
            "tmout)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_SET(",
          "args": [
            "[i].s,",
            "fds)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "fd too large\")"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lear_descr(",
          "args": [
            "d[i])"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "lear_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "501-510",
          "snippet": "tatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ime(",
          "args": [
            "ULL)"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fix_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "38-46",
          "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_IS_BAD_SOCKET(",
          "args": [
            "[i].s)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_SET(",
          "args": [
            "slive,",
            "fds)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_ZERO(",
          "args": [
            "fds)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nloop(krb5_context context, krb5_kdc_configuration *config,\n     struct descr *d, unsigned int ndescr, int islive)\n{\n\n    while (exit_flag == 0) {\n\tstruct timeval tmout;\n\tfd_set fds;\n\tint min_free = -1;\n\tint max_fd = 0;\n\tsize_t i;\n\n\tFD_ZERO(&fds);\n        if (islive > -1) {\n            FD_SET(islive, &fds);\n            max_fd = islive;\n        }\n\tfor (i = 0; i < ndescr; i++) {\n\t    if (!rk_IS_BAD_SOCKET(d[i].s)) {\n\t\tif (d[i].type == SOCK_STREAM &&\n\t\t   d[i].timeout && d[i].timeout < time(NULL)) {\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"TCP-connection from %s expired after %lu bytes\",\n\t\t\t    d[i].addr_string, (unsigned long)d[i].len);\n\t\t    clear_descr(&d[i]);\n\t\t    continue;\n\t\t}\n#ifndef NO_LIMIT_FD_SETSIZE\n\t\tif (max_fd < d[i].s)\n\t\t    max_fd = d[i].s;\n#ifdef FD_SETSIZE\n\t\tif (max_fd >= FD_SETSIZE)\n\t\t    krb5_errx(context, 1, \"fd too large\");\n#endif\n#endif\n\t\tFD_SET(d[i].s, &fds);\n\t    }\n\t}\n\n\ttmout.tv_sec = TCP_TIMEOUT;\n\ttmout.tv_usec = 0;\n\tswitch(select(max_fd + 1, &fds, 0, 0, &tmout)){\n\tcase 0:\n\t    break;\n\tcase -1:\n\t    if (errno != EINTR)\n\t\tkrb5_warn(context, rk_SOCK_ERRNO, \"select\");\n\t    break;\n\tdefault:\n#ifdef HAVE_FORK\n\t    if (islive > -1 && FD_ISSET(islive, &fds))\n\t\thandle_islive(islive);\n#endif\n\t    for (i = 0; i < ndescr; i++)\n\t\tif (!rk_IS_BAD_SOCKET(d[i].s) && FD_ISSET(d[i].s, &fds)) {\n\t\t    min_free = next_min_free(context, &d, &ndescr);\n\n\t\t    if (d[i].type == SOCK_DGRAM)\n\t\t\thandle_udp(context, config, &d[i]);\n\t\t    else if (d[i].type == SOCK_STREAM)\n\t\t\thandle_tcp(context, config, d, i, min_free);\n\t\t}\n\t}\n    }\n\n    switch (exit_flag) {\n    case -1:\n\tkdc_log(context, config, 0,\n                \"KDC worker process exiting because KDC master exited.\");\n\tbreak;\n#ifdef SIGXCPU\n    case SIGXCPU:\n\tkdc_log(context, config, 0, \"CPU time limit exceeded\");\n\tbreak;\n#endif\n    case SIGINT:\n    case SIGTERM:\n\tkdc_log(context, config, 0, \"Terminated\");\n\tbreak;\n    default:\n\tkdc_log(context, config, 0, \"Unexpected exit reason: %d\", exit_flag);\n\tbreak;\n    }\n}"
  },
  {
    "function_name": "ext_min_free(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "874-893",
    "snippet": "nt\nnext_min_free(krb5_context context, struct descr **d, unsigned int *ndescr)\n{\n    size_t i;\n    int min_free;\n\n    for(i = 0; i < *ndescr; i++) {\n        int s = (*d + i)->s;\n        if(rk_IS_BAD_SOCKET(s))\n            return i;\n    }\n\n    min_free = *ndescr;\n    if(!realloc_descrs(d, ndescr)) {\n        min_free = -1;\n        krb5_warnx(context, \"No memory\");\n    }\n\n    return min_free;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "No memory\")"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc_descrs(",
          "args": [
            ",",
            "descr)"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "ealloc_descrs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "853-872",
          "snippet": "rb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_IS_BAD_SOCKET(",
          "args": [
            ")"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nnt\nnext_min_free(krb5_context context, struct descr **d, unsigned int *ndescr)\n{\n    size_t i;\n    int min_free;\n\n    for(i = 0; i < *ndescr; i++) {\n        int s = (*d + i)->s;\n        if(rk_IS_BAD_SOCKET(s))\n            return i;\n    }\n\n    min_free = *ndescr;\n    if(!realloc_descrs(d, ndescr)) {\n        min_free = -1;\n        krb5_warnx(context, \"No memory\");\n    }\n\n    return min_free;\n}"
  },
  {
    "function_name": "ealloc_descrs(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "853-872",
    "snippet": "rb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nit_descr",
          "args": [
            "d + i)"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "nit_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "208-214",
          "snippet": "tatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "d + *ndescr,",
            ",",
            "* sizeof(**d))"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "einit_descrs",
          "args": [
            "d,",
            "ndescr)"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "einit_descrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "220-227",
          "snippet": "tatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "d,",
            "*ndescr + 4) * sizeof(**d))"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}"
  },
  {
    "function_name": "andle_islive(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "841-850",
    "snippet": "tatic void\nhandle_islive(int fd)\n{\n    char buf;\n    int ret;\n\n    ret = read(fd, &buf, 1);\n    if (ret != 1)\n\texit_flag = -1;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ead(",
          "args": [
            "d,",
            "buf,",
            ")"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_islive(int fd)\n{\n    char buf;\n    int ret;\n\n    ret = read(fd, &buf, 1);\n    if (ret != 1)\n\texit_flag = -1;\n}"
  },
  {
    "function_name": "andle_tcp(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "758-838",
    "snippet": "tatic void\nhandle_tcp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d, int idx, int min_free)\n{\n    unsigned char buf[1024];\n    int n;\n    int ret = 0;\n\n    if (d[idx].timeout == 0) {\n\tadd_new_tcp (context, config, d, idx, min_free);\n\treturn;\n    }\n\n    n = recvfrom(d[idx].s, buf, sizeof(buf), 0, NULL, NULL);\n    if(rk_IS_SOCKET_ERROR(n)){\n\tkrb5_warn(context, rk_SOCK_ERRNO, \"recvfrom failed from %s to %s/%d\",\n\t\t  d[idx].addr_string, descr_type(d + idx),\n\t\t  ntohs(d[idx].port));\n\treturn;\n    } else if (n == 0) {\n\tkrb5_warnx(context, \"connection closed before end of data after %lu \"\n\t\t   \"bytes from %s to %s/%d\", (unsigned long)d[idx].len,\n\t\t   d[idx].addr_string, descr_type(d + idx),\n\t\t   ntohs(d[idx].port));\n\tclear_descr (d + idx);\n\treturn;\n    }\n    if (grow_descr (context, config, &d[idx], n))\n\treturn;\n    memcpy(d[idx].buf + d[idx].len, buf, n);\n    d[idx].len += n;\n    if(d[idx].len > 4 && d[idx].buf[0] == 0) {\n\tret = handle_vanilla_tcp (context, config, &d[idx]);\n    } else if(enable_http &&\n\t      d[idx].len >= 4 &&\n\t      strncmp((char *)d[idx].buf, \"GET \", 4) == 0 &&\n\t      strncmp((char *)d[idx].buf + d[idx].len - 4,\n\t\t      \"\\r\\n\\r\\n\", 4) == 0) {\n\n        /* remove the trailing \\r\\n\\r\\n so the string is NUL terminated */\n        d[idx].buf[d[idx].len - 4] = '\\0';\n\n\tret = handle_http_tcp (context, config, &d[idx]);\n\tif (ret < 0)\n\t    clear_descr (d + idx);\n    } else if (d[idx].len > 4) {\n\tkdc_log (context, config,\n\t\t 0, \"TCP data of strange type from %s to %s/%d\",\n\t\t d[idx].addr_string, descr_type(d + idx),\n\t\t ntohs(d[idx].port));\n\tif (d[idx].buf[0] & 0x80) {\n\t    krb5_data reply;\n\n\t    kdc_log (context, config, 0, \"TCP extension not supported\");\n\n\t    ret = krb5_mk_error(context,\n\t\t\t\tKRB5KRB_ERR_FIELD_TOOLONG,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&reply);\n\t    if (ret == 0) {\n\t\tsend_reply(context, config, TRUE, d + idx, &reply);\n\t\tkrb5_data_free(&reply);\n\t    }\n\t}\n\tclear_descr(d + idx);\n\treturn;\n    }\n    if (ret < 0)\n\treturn;\n    else if (ret == 1) {\n\tdo_request(context, config,\n\t\t   d[idx].buf, d[idx].len, TRUE, &d[idx]);\n\tclear_descr(d + idx);\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lear_descr(",
          "args": [
            "+ idx)"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "lear_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "501-510",
          "snippet": "tatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o_request(",
          "args": [
            "ontext,",
            "onfig,",
            "[idx].buf,",
            "[idx].len,",
            "RUE,",
            "d[idx])"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "o_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "422-449",
          "snippet": "tatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "reply)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "RUE,",
            "+ idx,",
            "reply)"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "end_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "388-416",
          "snippet": "tatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_mk_error(",
          "args": [
            "ontext,",
            "RB5KRB_ERR_FIELD_TOOLONG,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "reply)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "TCP extension not supported\")"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_log",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "TCP data of strange type from %s to %s/%d\",",
            "[idx].addr_string,",
            "escr_type(d + idx),",
            "tohs(d[idx].port))"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_log_timestamp(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "283-311",
          "snippet": "oid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "[idx].port)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escr_type(",
          "args": [
            "+ idx)"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "escr_type(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "359-367",
          "snippet": "tatic const char *\ndescr_type(struct descr *d)\n{\n    if (d->type == SOCK_DGRAM)\n\treturn \"udp\";\n    else if (d->type == SOCK_STREAM)\n\treturn \"tcp\";\n    return \"unknown\";\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const char *\ndescr_type(struct descr *d)\n{\n    if (d->type == SOCK_DGRAM)\n\treturn \"udp\";\n    else if (d->type == SOCK_STREAM)\n\treturn \"tcp\";\n    return \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "andle_http_tcp",
          "args": [
            "ontext,",
            "onfig,",
            "d[idx])"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "andle_http_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "645-752",
          "snippet": "tatic int\nhandle_http_tcp (krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t struct descr *d)\n{\n    char *s, *p, *t;\n    void *data;\n    char *proto;\n    int len;\n\n    s = (char *)d->buf;\n\n    /* If its a multi line query, truncate off the first line */\n    p = strstr(s, \"\\r\\n\");\n    if (p)\n\t*p = 0;\n\n    p = NULL;\n    t = strtok_r(s, \" \\t\", &p);\n    if (t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP operand (GET) request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    t = strtok_r(NULL, \" \\t\", &p);\n    if(t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP GET data in request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    data = malloc(strlen(t));\n    if (data == NULL) {\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t\t(unsigned long)strlen(t));\n\treturn -1;\n    }\n    if(*t == '/')\n\tt++;\n    if(de_http(t) != 0) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\treturn -1;\n    }\n    proto = strtok_r(NULL, \" \\t\", &p);\n    if (proto == NULL) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tfree(data);\n\treturn -1;\n    }\n    len = rk_base64_decode(t, data);\n    if(len <= 0){\n\tconst char *msg =\n\t    \" 404 Not found\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: text/html\\r\\n\"\n\t    \"Content-transfer-encoding: 8bit\\r\\n\\r\\n\"\n\t    \"<TITLE>404 Not found</TITLE>\\r\\n\"\n\t    \"<H1>404 Not found</H1>\\r\\n\"\n\t    \"That page doesn't exist, maybe you are looking for \"\n\t    \"<A HREF=\\\"http://www.h5l.org/\\\">Heimdal</A>?\\r\\n\";\n\tkdc_log(context, config, 0, \"HTTP request from %s is non KDC request\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\treturn -1;\n    }\n    {\n\tconst char *msg =\n\t    \" 200 OK\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: application/octet-stream\\r\\n\"\n\t    \"Content-transfer-encoding: binary\\r\\n\\r\\n\";\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n    }\n    if ((size_t)len > d->len)\n        len = d->len;\n    memcpy(d->buf, data, len);\n    d->len = len;\n    free(data);\n    return 1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nhandle_http_tcp (krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t struct descr *d)\n{\n    char *s, *p, *t;\n    void *data;\n    char *proto;\n    int len;\n\n    s = (char *)d->buf;\n\n    /* If its a multi line query, truncate off the first line */\n    p = strstr(s, \"\\r\\n\");\n    if (p)\n\t*p = 0;\n\n    p = NULL;\n    t = strtok_r(s, \" \\t\", &p);\n    if (t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP operand (GET) request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    t = strtok_r(NULL, \" \\t\", &p);\n    if(t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP GET data in request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    data = malloc(strlen(t));\n    if (data == NULL) {\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t\t(unsigned long)strlen(t));\n\treturn -1;\n    }\n    if(*t == '/')\n\tt++;\n    if(de_http(t) != 0) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\treturn -1;\n    }\n    proto = strtok_r(NULL, \" \\t\", &p);\n    if (proto == NULL) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tfree(data);\n\treturn -1;\n    }\n    len = rk_base64_decode(t, data);\n    if(len <= 0){\n\tconst char *msg =\n\t    \" 404 Not found\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: text/html\\r\\n\"\n\t    \"Content-transfer-encoding: 8bit\\r\\n\\r\\n\"\n\t    \"<TITLE>404 Not found</TITLE>\\r\\n\"\n\t    \"<H1>404 Not found</H1>\\r\\n\"\n\t    \"That page doesn't exist, maybe you are looking for \"\n\t    \"<A HREF=\\\"http://www.h5l.org/\\\">Heimdal</A>?\\r\\n\";\n\tkdc_log(context, config, 0, \"HTTP request from %s is non KDC request\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\treturn -1;\n    }\n    {\n\tconst char *msg =\n\t    \" 200 OK\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: application/octet-stream\\r\\n\"\n\t    \"Content-transfer-encoding: binary\\r\\n\\r\\n\";\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n    }\n    if ((size_t)len > d->len)\n        len = d->len;\n    memcpy(d->buf, data, len);\n    d->len = len;\n    free(data);\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            "char *)d[idx].buf + d[idx].len - 4,",
            "\\r\\n\\r\\n\",",
            ")"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            "char *)d[idx].buf,",
            "GET \",",
            ")"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andle_vanilla_tcp",
          "args": [
            "ontext,",
            "onfig,",
            "d[idx])"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "andle_vanilla_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "617-638",
          "snippet": "tatic int\nhandle_vanilla_tcp (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    struct descr *d)\n{\n    krb5_storage *sp;\n    uint32_t len;\n\n    sp = krb5_storage_from_mem(d->buf, d->len);\n    if (sp == NULL) {\n\tkdc_log (context, config, 0, \"krb5_storage_from_mem failed\");\n\treturn -1;\n    }\n    krb5_ret_uint32(sp, &len);\n    krb5_storage_free(sp);\n    if(d->len - 4 >= len) {\n\tmemmove(d->buf, d->buf + 4, d->len - 4);\n\td->len -= 4;\n\treturn 1;\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nhandle_vanilla_tcp (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    struct descr *d)\n{\n    krb5_storage *sp;\n    uint32_t len;\n\n    sp = krb5_storage_from_mem(d->buf, d->len);\n    if (sp == NULL) {\n\tkdc_log (context, config, 0, \"krb5_storage_from_mem failed\");\n\treturn -1;\n    }\n    krb5_ret_uint32(sp, &len);\n    krb5_storage_free(sp);\n    if(d->len - 4 >= len) {\n\tmemmove(d->buf, d->buf + 4, d->len - 4);\n\td->len -= 4;\n\treturn 1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "[idx].buf + d[idx].len,",
            "uf,",
            ")"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "row_descr",
          "args": [
            "ontext,",
            "onfig,",
            "d[idx],",
            ")"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "row_descr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "583-610",
          "snippet": "tatic int\ngrow_descr (krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, size_t n)\n{\n    if (d->size - d->len < n) {\n\tunsigned char *tmp;\n\tsize_t grow;\n\n\tgrow = max(1024, d->len + n);\n\tif (d->size + grow > max_request_tcp) {\n\t    kdc_log(context, config, 0, \"Request exceeds max request size (%lu bytes).\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\ttmp = realloc (d->buf, d->size + grow);\n\tif (tmp == NULL) {\n\t    kdc_log(context, config, 0, \"Failed to re-allocate %lu bytes.\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\td->size += grow;\n\td->buf = tmp;\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\ngrow_descr (krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, size_t n)\n{\n    if (d->size - d->len < n) {\n\tunsigned char *tmp;\n\tsize_t grow;\n\n\tgrow = max(1024, d->len + n);\n\tif (d->size + grow > max_request_tcp) {\n\t    kdc_log(context, config, 0, \"Request exceeds max request size (%lu bytes).\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\ttmp = realloc (d->buf, d->size + grow);\n\tif (tmp == NULL) {\n\t    kdc_log(context, config, 0, \"Failed to re-allocate %lu bytes.\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\td->size += grow;\n\td->buf = tmp;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "connection closed before end of data after %lu \"\n\t\t   \"bytes from %s to %s/%d\",",
            "unsigned long)d[idx].len,",
            "[idx].addr_string,",
            "escr_type(d + idx),",
            "tohs(d[idx].port))"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "[idx].port)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "k_SOCK_ERRNO,",
            "recvfrom failed from %s to %s/%d\",",
            "[idx].addr_string,",
            "escr_type(d + idx),",
            "tohs(d[idx].port))"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "[idx].port)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            ")"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecvfrom(",
          "args": [
            "[idx].s,",
            "uf,",
            "izeof(buf),",
            ",",
            "ULL,",
            "ULL)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_new_tcp",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "dx,",
            "in_free)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "dd_new_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "544-576",
          "snippet": "tatic void\nadd_new_tcp (krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr *d, int parent, int child)\n{\n    krb5_socket_t s;\n\n    if (child == -1)\n\treturn;\n\n    d[child].sock_len = sizeof(d[child].__ss);\n    s = accept(d[parent].s, d[child].sa, &d[child].sock_len);\n    if(rk_IS_BAD_SOCKET(s)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"accept\");\n\treturn;\n    }\n\n#ifdef FD_SETSIZE\n    if (s >= FD_SETSIZE) {\n\tkrb5_warnx(context, \"socket FD too large\");\n\trk_closesocket (s);\n\treturn;\n    }\n#endif\n\n    d[child].s = s;\n    d[child].timeout = time(NULL) + TCP_TIMEOUT;\n    d[child].type = SOCK_STREAM;\n    addr_to_string (context,\n\t\t    d[child].sa, d[child].sock_len,\n\t\t    d[child].addr_string, sizeof(d[child].addr_string));\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_new_tcp (krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr *d, int parent, int child)\n{\n    krb5_socket_t s;\n\n    if (child == -1)\n\treturn;\n\n    d[child].sock_len = sizeof(d[child].__ss);\n    s = accept(d[parent].s, d[child].sa, &d[child].sock_len);\n    if(rk_IS_BAD_SOCKET(s)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"accept\");\n\treturn;\n    }\n\n#ifdef FD_SETSIZE\n    if (s >= FD_SETSIZE) {\n\tkrb5_warnx(context, \"socket FD too large\");\n\trk_closesocket (s);\n\treturn;\n    }\n#endif\n\n    d[child].s = s;\n    d[child].timeout = time(NULL) + TCP_TIMEOUT;\n    d[child].type = SOCK_STREAM;\n    addr_to_string (context,\n\t\t    d[child].sa, d[child].sock_len,\n\t\t    d[child].addr_string, sizeof(d[child].addr_string));\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_tcp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d, int idx, int min_free)\n{\n    unsigned char buf[1024];\n    int n;\n    int ret = 0;\n\n    if (d[idx].timeout == 0) {\n\tadd_new_tcp (context, config, d, idx, min_free);\n\treturn;\n    }\n\n    n = recvfrom(d[idx].s, buf, sizeof(buf), 0, NULL, NULL);\n    if(rk_IS_SOCKET_ERROR(n)){\n\tkrb5_warn(context, rk_SOCK_ERRNO, \"recvfrom failed from %s to %s/%d\",\n\t\t  d[idx].addr_string, descr_type(d + idx),\n\t\t  ntohs(d[idx].port));\n\treturn;\n    } else if (n == 0) {\n\tkrb5_warnx(context, \"connection closed before end of data after %lu \"\n\t\t   \"bytes from %s to %s/%d\", (unsigned long)d[idx].len,\n\t\t   d[idx].addr_string, descr_type(d + idx),\n\t\t   ntohs(d[idx].port));\n\tclear_descr (d + idx);\n\treturn;\n    }\n    if (grow_descr (context, config, &d[idx], n))\n\treturn;\n    memcpy(d[idx].buf + d[idx].len, buf, n);\n    d[idx].len += n;\n    if(d[idx].len > 4 && d[idx].buf[0] == 0) {\n\tret = handle_vanilla_tcp (context, config, &d[idx]);\n    } else if(enable_http &&\n\t      d[idx].len >= 4 &&\n\t      strncmp((char *)d[idx].buf, \"GET \", 4) == 0 &&\n\t      strncmp((char *)d[idx].buf + d[idx].len - 4,\n\t\t      \"\\r\\n\\r\\n\", 4) == 0) {\n\n        /* remove the trailing \\r\\n\\r\\n so the string is NUL terminated */\n        d[idx].buf[d[idx].len - 4] = '\\0';\n\n\tret = handle_http_tcp (context, config, &d[idx]);\n\tif (ret < 0)\n\t    clear_descr (d + idx);\n    } else if (d[idx].len > 4) {\n\tkdc_log (context, config,\n\t\t 0, \"TCP data of strange type from %s to %s/%d\",\n\t\t d[idx].addr_string, descr_type(d + idx),\n\t\t ntohs(d[idx].port));\n\tif (d[idx].buf[0] & 0x80) {\n\t    krb5_data reply;\n\n\t    kdc_log (context, config, 0, \"TCP extension not supported\");\n\n\t    ret = krb5_mk_error(context,\n\t\t\t\tKRB5KRB_ERR_FIELD_TOOLONG,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&reply);\n\t    if (ret == 0) {\n\t\tsend_reply(context, config, TRUE, d + idx, &reply);\n\t\tkrb5_data_free(&reply);\n\t    }\n\t}\n\tclear_descr(d + idx);\n\treturn;\n    }\n    if (ret < 0)\n\treturn;\n    else if (ret == 1) {\n\tdo_request(context, config,\n\t\t   d[idx].buf, d[idx].len, TRUE, &d[idx]);\n\tclear_descr(d + idx);\n    }\n}"
  },
  {
    "function_name": "andle_http_tcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "645-752",
    "snippet": "tatic int\nhandle_http_tcp (krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t struct descr *d)\n{\n    char *s, *p, *t;\n    void *data;\n    char *proto;\n    int len;\n\n    s = (char *)d->buf;\n\n    /* If its a multi line query, truncate off the first line */\n    p = strstr(s, \"\\r\\n\");\n    if (p)\n\t*p = 0;\n\n    p = NULL;\n    t = strtok_r(s, \" \\t\", &p);\n    if (t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP operand (GET) request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    t = strtok_r(NULL, \" \\t\", &p);\n    if(t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP GET data in request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    data = malloc(strlen(t));\n    if (data == NULL) {\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t\t(unsigned long)strlen(t));\n\treturn -1;\n    }\n    if(*t == '/')\n\tt++;\n    if(de_http(t) != 0) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\treturn -1;\n    }\n    proto = strtok_r(NULL, \" \\t\", &p);\n    if (proto == NULL) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tfree(data);\n\treturn -1;\n    }\n    len = rk_base64_decode(t, data);\n    if(len <= 0){\n\tconst char *msg =\n\t    \" 404 Not found\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: text/html\\r\\n\"\n\t    \"Content-transfer-encoding: 8bit\\r\\n\\r\\n\"\n\t    \"<TITLE>404 Not found</TITLE>\\r\\n\"\n\t    \"<H1>404 Not found</H1>\\r\\n\"\n\t    \"That page doesn't exist, maybe you are looking for \"\n\t    \"<A HREF=\\\"http://www.h5l.org/\\\">Heimdal</A>?\\r\\n\";\n\tkdc_log(context, config, 0, \"HTTP request from %s is non KDC request\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\treturn -1;\n    }\n    {\n\tconst char *msg =\n\t    \" 200 OK\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: application/octet-stream\\r\\n\"\n\t    \"Content-transfer-encoding: binary\\r\\n\\r\\n\";\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n    }\n    if ((size_t)len > d->len)\n        len = d->len;\n    memcpy(d->buf, data, len);\n    d->len = len;\n    free(data);\n    return 1;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "->buf,",
            "ata,",
            "en)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "HTTP write failed: %s: %s\",",
            "->addr_string,",
            "trerror(rk_SOCK_ERRNO))"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "end(d->s, msg, strlen(msg), 0))"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end(",
          "args": [
            "->s,",
            "sg,",
            "trlen(msg),",
            ")"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "sg)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "end(d->s, proto, strlen(proto), 0))"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end(",
          "args": [
            "->s,",
            "roto,",
            "trlen(proto),",
            ")"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "roto)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "end(d->s, msg, strlen(msg), 0))"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end(",
          "args": [
            "->s,",
            "sg,",
            "trlen(msg),",
            ")"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "sg)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "end(d->s, proto, strlen(proto), 0))"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end(",
          "args": [
            "->s,",
            "roto,",
            "trlen(proto),",
            ")"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "roto)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_base64_decode(",
          "args": [
            ",",
            "ata)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtok_r(",
          "args": [
            "ULL,",
            "\\t\",",
            "p)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_http(",
          "args": [
            ")"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "e_http(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "514-536",
          "snippet": "tatic int\nde_http(char *buf)\n{\n    unsigned char *p, *q;\n    unsigned int x;\n\n    for (p = q = (unsigned char *)buf; *p; p++, q++) {\n\tif (*p == '%') {\n\t    if (!(isxdigit(p[1]) && isxdigit(p[2])))\n\t\treturn -1;\n\n\t    if (sscanf((char *)p + 1, \"%2x\", &x) != 1)\n\t\treturn -1;\n\n\t    *q = x;\n\t    p += 2;\n\t} else {\n\t    *q = *p;\n\t}\n    }\n    *q = '\\0';\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nde_http(char *buf)\n{\n    unsigned char *p, *q;\n    unsigned int x;\n\n    for (p = q = (unsigned char *)buf; *p; p++, q++) {\n\tif (*p == '%') {\n\t    if (!(isxdigit(p[1]) && isxdigit(p[2])))\n\t\treturn -1;\n\n\t    if (sscanf((char *)p + 1, \"%2x\", &x) != 1)\n\t\treturn -1;\n\n\t    *q = x;\n\t    p += 2;\n\t} else {\n\t    *q = *p;\n\t}\n    }\n    *q = '\\0';\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            ")"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "trlen(t))"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            ")"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtok_r(",
          "args": [
            "ULL,",
            "\\t\",",
            "p)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtok_r(",
          "args": [
            ",",
            "\\t\",",
            "p)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trstr(",
          "args": [
            ",",
            "\\r\\n\")"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nhandle_http_tcp (krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t struct descr *d)\n{\n    char *s, *p, *t;\n    void *data;\n    char *proto;\n    int len;\n\n    s = (char *)d->buf;\n\n    /* If its a multi line query, truncate off the first line */\n    p = strstr(s, \"\\r\\n\");\n    if (p)\n\t*p = 0;\n\n    p = NULL;\n    t = strtok_r(s, \" \\t\", &p);\n    if (t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP operand (GET) request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    t = strtok_r(NULL, \" \\t\", &p);\n    if(t == NULL) {\n\tkdc_log(context, config, 0,\n\t\t\"Missing HTTP GET data in request from %s\", d->addr_string);\n\treturn -1;\n    }\n\n    data = malloc(strlen(t));\n    if (data == NULL) {\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t\t(unsigned long)strlen(t));\n\treturn -1;\n    }\n    if(*t == '/')\n\tt++;\n    if(de_http(t) != 0) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\treturn -1;\n    }\n    proto = strtok_r(NULL, \" \\t\", &p);\n    if (proto == NULL) {\n\tkdc_log(context, config, 0, \"Malformed HTTP request from %s\", d->addr_string);\n\tfree(data);\n\treturn -1;\n    }\n    len = rk_base64_decode(t, data);\n    if(len <= 0){\n\tconst char *msg =\n\t    \" 404 Not found\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: text/html\\r\\n\"\n\t    \"Content-transfer-encoding: 8bit\\r\\n\\r\\n\"\n\t    \"<TITLE>404 Not found</TITLE>\\r\\n\"\n\t    \"<H1>404 Not found</H1>\\r\\n\"\n\t    \"That page doesn't exist, maybe you are looking for \"\n\t    \"<A HREF=\\\"http://www.h5l.org/\\\">Heimdal</A>?\\r\\n\";\n\tkdc_log(context, config, 0, \"HTTP request from %s is non KDC request\", d->addr_string);\n\tkdc_log(context, config, 5, \"HTTP request: %s\", t);\n\tfree(data);\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\treturn -1;\n    }\n    {\n\tconst char *msg =\n\t    \" 200 OK\\r\\n\"\n\t    \"Server: Heimdal/\" VERSION \"\\r\\n\"\n\t    \"Cache-Control: no-cache\\r\\n\"\n\t    \"Pragma: no-cache\\r\\n\"\n\t    \"Content-type: application/octet-stream\\r\\n\"\n\t    \"Content-transfer-encoding: binary\\r\\n\\r\\n\";\n\tif (rk_IS_SOCKET_ERROR(send(d->s, proto, strlen(proto), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n\tif (rk_IS_SOCKET_ERROR(send(d->s, msg, strlen(msg), 0))) {\n\t    free(data);\n\t    kdc_log(context, config, 0, \"HTTP write failed: %s: %s\",\n\t\t    d->addr_string, strerror(rk_SOCK_ERRNO));\n\t    return -1;\n\t}\n    }\n    if ((size_t)len > d->len)\n        len = d->len;\n    memcpy(d->buf, data, len);\n    d->len = len;\n    free(data);\n    return 1;\n}"
  },
  {
    "function_name": "andle_vanilla_tcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "617-638",
    "snippet": "tatic int\nhandle_vanilla_tcp (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    struct descr *d)\n{\n    krb5_storage *sp;\n    uint32_t len;\n\n    sp = krb5_storage_from_mem(d->buf, d->len);\n    if (sp == NULL) {\n\tkdc_log (context, config, 0, \"krb5_storage_from_mem failed\");\n\treturn -1;\n    }\n    krb5_ret_uint32(sp, &len);\n    krb5_storage_free(sp);\n    if(d->len - 4 >= len) {\n\tmemmove(d->buf, d->buf + 4, d->len - 4);\n\td->len -= 4;\n\treturn 1;\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emmove(",
          "args": [
            "->buf,",
            "->buf + 4,",
            "->len - 4)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "len)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "krb5_storage_from_mem failed\")"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_storage_from_mem(",
          "args": [
            "->buf,",
            "->len)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nhandle_vanilla_tcp (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    struct descr *d)\n{\n    krb5_storage *sp;\n    uint32_t len;\n\n    sp = krb5_storage_from_mem(d->buf, d->len);\n    if (sp == NULL) {\n\tkdc_log (context, config, 0, \"krb5_storage_from_mem failed\");\n\treturn -1;\n    }\n    krb5_ret_uint32(sp, &len);\n    krb5_storage_free(sp);\n    if(d->len - 4 >= len) {\n\tmemmove(d->buf, d->buf + 4, d->len - 4);\n\td->len -= 4;\n\treturn 1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "row_descr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "583-610",
    "snippet": "tatic int\ngrow_descr (krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, size_t n)\n{\n    if (d->size - d->len < n) {\n\tunsigned char *tmp;\n\tsize_t grow;\n\n\tgrow = max(1024, d->len + n);\n\tif (d->size + grow > max_request_tcp) {\n\t    kdc_log(context, config, 0, \"Request exceeds max request size (%lu bytes).\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\ttmp = realloc (d->buf, d->size + grow);\n\tif (tmp == NULL) {\n\t    kdc_log(context, config, 0, \"Failed to re-allocate %lu bytes.\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\td->size += grow;\n\td->buf = tmp;\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lear_descr(",
          "args": [
            ")"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "lear_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "501-510",
          "snippet": "tatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed to re-allocate %lu bytes.\",",
            "unsigned long)d->size + grow)"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ealloc",
          "args": [
            "->buf,",
            "->size + grow)"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ealloc_descrs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "853-872",
          "snippet": "rb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\nrealloc_descrs(struct descr **d, unsigned int *ndescr)\n{\n    struct descr *tmp;\n    size_t i;\n\n    tmp = realloc(*d, (*ndescr + 4) * sizeof(**d));\n    if(tmp == NULL)\n        return FALSE;\n\n    *d = tmp;\n    reinit_descrs (*d, *ndescr);\n    memset(*d + *ndescr, 0, 4 * sizeof(**d));\n    for(i = *ndescr; i < *ndescr + 4; i++)\n        init_descr (*d + i);\n\n    *ndescr += 4;\n\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ax(",
          "args": [
            "024,",
            "->len + n)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\ngrow_descr (krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, size_t n)\n{\n    if (d->size - d->len < n) {\n\tunsigned char *tmp;\n\tsize_t grow;\n\n\tgrow = max(1024, d->len + n);\n\tif (d->size + grow > max_request_tcp) {\n\t    kdc_log(context, config, 0, \"Request exceeds max request size (%lu bytes).\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\ttmp = realloc (d->buf, d->size + grow);\n\tif (tmp == NULL) {\n\t    kdc_log(context, config, 0, \"Failed to re-allocate %lu bytes.\",\n\t\t    (unsigned long)d->size + grow);\n\t    clear_descr(d);\n\t    return -1;\n\t}\n\td->size += grow;\n\td->buf = tmp;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "dd_new_tcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "544-576",
    "snippet": "tatic void\nadd_new_tcp (krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr *d, int parent, int child)\n{\n    krb5_socket_t s;\n\n    if (child == -1)\n\treturn;\n\n    d[child].sock_len = sizeof(d[child].__ss);\n    s = accept(d[parent].s, d[child].sa, &d[child].sock_len);\n    if(rk_IS_BAD_SOCKET(s)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"accept\");\n\treturn;\n    }\n\n#ifdef FD_SETSIZE\n    if (s >= FD_SETSIZE) {\n\tkrb5_warnx(context, \"socket FD too large\");\n\trk_closesocket (s);\n\treturn;\n    }\n#endif\n\n    d[child].s = s;\n    d[child].timeout = time(NULL) + TCP_TIMEOUT;\n    d[child].type = SOCK_STREAM;\n    addr_to_string (context,\n\t\t    d[child].sa, d[child].sock_len,\n\t\t    d[child].addr_string, sizeof(d[child].addr_string));\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ddr_to_string",
          "args": [
            "ontext,",
            "[child].sa,",
            "[child].sock_len,",
            "[child].addr_string,",
            "izeof(d[child].addr_string))"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ddr_to_string(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "369-382",
          "snippet": "tatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ime(",
          "args": [
            "ULL)"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fix_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "38-46",
          "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_closesocket",
          "args": [
            ")"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "socket FD too large\")"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "k_SOCK_ERRNO,",
            "accept\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_BAD_SOCKET(",
          "args": [
            ")"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccept(",
          "args": [
            "[parent].s,",
            "[child].sa,",
            "d[child].sock_len)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_new_tcp (krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr *d, int parent, int child)\n{\n    krb5_socket_t s;\n\n    if (child == -1)\n\treturn;\n\n    d[child].sock_len = sizeof(d[child].__ss);\n    s = accept(d[parent].s, d[child].sa, &d[child].sock_len);\n    if(rk_IS_BAD_SOCKET(s)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"accept\");\n\treturn;\n    }\n\n#ifdef FD_SETSIZE\n    if (s >= FD_SETSIZE) {\n\tkrb5_warnx(context, \"socket FD too large\");\n\trk_closesocket (s);\n\treturn;\n    }\n#endif\n\n    d[child].s = s;\n    d[child].timeout = time(NULL) + TCP_TIMEOUT;\n    d[child].type = SOCK_STREAM;\n    addr_to_string (context,\n\t\t    d[child].sa, d[child].sock_len,\n\t\t    d[child].addr_string, sizeof(d[child].addr_string));\n}"
  },
  {
    "function_name": "e_http(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "514-536",
    "snippet": "tatic int\nde_http(char *buf)\n{\n    unsigned char *p, *q;\n    unsigned int x;\n\n    for (p = q = (unsigned char *)buf; *p; p++, q++) {\n\tif (*p == '%') {\n\t    if (!(isxdigit(p[1]) && isxdigit(p[2])))\n\t\treturn -1;\n\n\t    if (sscanf((char *)p + 1, \"%2x\", &x) != 1)\n\t\treturn -1;\n\n\t    *q = x;\n\t    p += 2;\n\t} else {\n\t    *q = *p;\n\t}\n    }\n    *q = '\\0';\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scanf(",
          "args": [
            "char *)p + 1,",
            "%2x\",",
            "x)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sxdigit(",
          "args": [
            "[2])"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sxdigit(",
          "args": [
            "[1])"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int\nde_http(char *buf)\n{\n    unsigned char *p, *q;\n    unsigned int x;\n\n    for (p = q = (unsigned char *)buf; *p; p++, q++) {\n\tif (*p == '%') {\n\t    if (!(isxdigit(p[1]) && isxdigit(p[2])))\n\t\treturn -1;\n\n\t    if (sscanf((char *)p + 1, \"%2x\", &x) != 1)\n\t\treturn -1;\n\n\t    *q = x;\n\t    p += 2;\n\t} else {\n\t    *q = *p;\n\t}\n    }\n    *q = '\\0';\n    return 0;\n}"
  },
  {
    "function_name": "lear_descr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "501-510",
    "snippet": "tatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "k_closesocket(",
          "args": [
            "->s)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "->buf,",
            ",",
            "->size)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nclear_descr(struct descr *d)\n{\n    if(d->buf)\n\tmemset(d->buf, 0, d->size);\n    d->len = 0;\n    if(d->s != rk_INVALID_SOCKET)\n\trk_closesocket(d->s);\n    d->s = rk_INVALID_SOCKET;\n}"
  },
  {
    "function_name": "andle_udp(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "455-499",
    "snippet": "tatic void\nhandle_udp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d)\n{\n    unsigned char *buf;\n    ssize_t n;\n\n    buf = malloc(max_request_udp);\n    if (buf == NULL){\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t        (unsigned long)max_request_udp);\n\treturn;\n    }\n\n    d->sock_len = sizeof(d->__ss);\n    n = recvfrom(d->s, buf, max_request_udp, 0, d->sa, &d->sock_len);\n    if (rk_IS_SOCKET_ERROR(n)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"recvfrom\");\n    } else {\n\taddr_to_string (context, d->sa, d->sock_len,\n\t\t\td->addr_string, sizeof(d->addr_string));\n\tif ((size_t)n == max_request_udp) {\n\t    krb5_data data;\n\t    krb5_warn(context, errno,\n\t\t      \"recvfrom: truncated packet from %s, asking for TCP\",\n\t\t      d->addr_string);\n\t    krb5_mk_error(context,\n\t\t\t  KRB5KRB_ERR_RESPONSE_TOO_BIG,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  &data);\n\t    send_reply(context, config, FALSE, d, &data);\n\t    krb5_data_free(&data);\n\t} else {\n\t    do_request(context, config, buf, n, FALSE, d);\n\t}\n    }\n    free (buf);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree",
          "args": [
            "uf)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_request(",
          "args": [
            "ontext,",
            "onfig,",
            "uf,",
            ",",
            "ALSE,",
            ")"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "o_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "422-449",
          "snippet": "tatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "ALSE,",
            ",",
            "data)"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "end_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "388-416",
          "snippet": "tatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_mk_error(",
          "args": [
            "ontext,",
            "RB5KRB_ERR_RESPONSE_TOO_BIG,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "data)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "rrno,",
            "recvfrom: truncated packet from %s, asking for TCP\",",
            "->addr_string)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddr_to_string",
          "args": [
            "ontext,",
            "->sa,",
            "->sock_len,",
            "->addr_string,",
            "izeof(d->addr_string))"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ddr_to_string(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "369-382",
          "snippet": "tatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "k_SOCK_ERRNO,",
            "recvfrom\")"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            ")"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecvfrom(",
          "args": [
            "->s,",
            "uf,",
            "ax_request_udp,",
            ",",
            "->sa,",
            "d->sock_len)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed to allocate %lu bytes\",",
            "unsigned long)max_request_udp)"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "ax_request_udp)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nhandle_udp(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   struct descr *d)\n{\n    unsigned char *buf;\n    ssize_t n;\n\n    buf = malloc(max_request_udp);\n    if (buf == NULL){\n\tkdc_log(context, config, 0, \"Failed to allocate %lu bytes\",\n\t        (unsigned long)max_request_udp);\n\treturn;\n    }\n\n    d->sock_len = sizeof(d->__ss);\n    n = recvfrom(d->s, buf, max_request_udp, 0, d->sa, &d->sock_len);\n    if (rk_IS_SOCKET_ERROR(n)) {\n\tif (rk_SOCK_ERRNO != EAGAIN && rk_SOCK_ERRNO != EINTR)\n\t    krb5_warn(context, rk_SOCK_ERRNO, \"recvfrom\");\n    } else {\n\taddr_to_string (context, d->sa, d->sock_len,\n\t\t\td->addr_string, sizeof(d->addr_string));\n\tif ((size_t)n == max_request_udp) {\n\t    krb5_data data;\n\t    krb5_warn(context, errno,\n\t\t      \"recvfrom: truncated packet from %s, asking for TCP\",\n\t\t      d->addr_string);\n\t    krb5_mk_error(context,\n\t\t\t  KRB5KRB_ERR_RESPONSE_TOO_BIG,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  NULL,\n\t\t\t  &data);\n\t    send_reply(context, config, FALSE, d, &data);\n\t    krb5_data_free(&data);\n\t} else {\n\t    do_request(context, config, buf, n, FALSE, d);\n\t}\n    }\n    free (buf);\n}"
  },
  {
    "function_name": "o_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "422-449",
    "snippet": "tatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed processing %lu byte request from %s\",",
            "unsigned long)len,",
            "->addr_string)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "reply)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "rependlength,",
            ",",
            "reply)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "end_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "388-416",
          "snippet": "tatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_kdc_save_request(",
          "args": [
            "ontext,",
            "equest_log,",
            "uf,",
            "en,",
            "reply,",
            "->sa)"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_save_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "267-329",
          "snippet": "nt\nkrb5_kdc_save_request(krb5_context context,\n\t\t      const char *fn,\n\t\t      const unsigned char *buf,\n\t\t      size_t len,\n\t\t      const krb5_data *reply,\n\t\t      const struct sockaddr *sa)\n{\n    krb5_storage *sp;\n    krb5_address a;\n    int fd, ret;\n    uint32_t t;\n    krb5_data d;\n\n    memset(&a, 0, sizeof(a));\n\n    d.data = rk_UNCONST(buf);\n    d.length = len;\n    t = _kdc_now.tv_sec;\n\n    fd = open(fn, O_WRONLY|O_CREAT|O_APPEND, 0600);\n    if (fd < 0) {\n\tint saved_errno = errno;\n\tkrb5_set_error_message(context, saved_errno, \"Failed to open: %s\", fn);\n\treturn saved_errno;\n    }\n\n    sp = krb5_storage_from_fd(fd);\n    close(fd);\n    if (sp == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"Storage failed to open fd\");\n\treturn ENOMEM;\n    }\n\n    ret = krb5_sockaddr2address(context, sa, &a);\n    if (ret)\n\tgoto out;\n\n    krb5_store_uint32(sp, 1);\n    krb5_store_uint32(sp, t);\n    krb5_store_address(sp, a);\n    krb5_store_data(sp, d);\n    {\n\tDer_class cl;\n\tDer_type ty;\n\tunsigned int tag;\n\tret = der_get_tag (reply->data, reply->length,\n\t\t\t   &cl, &ty, &tag, NULL);\n\tif (ret) {\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t} else {\n\t    krb5_store_uint32(sp, MAKE_TAG(cl, ty, 0));\n\t    krb5_store_uint32(sp, tag);\n\t}\n    }\n\n    krb5_free_address(context, &a);\nout:\n    krb5_storage_free(sp);\n\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nnt\nkrb5_kdc_save_request(krb5_context context,\n\t\t      const char *fn,\n\t\t      const unsigned char *buf,\n\t\t      size_t len,\n\t\t      const krb5_data *reply,\n\t\t      const struct sockaddr *sa)\n{\n    krb5_storage *sp;\n    krb5_address a;\n    int fd, ret;\n    uint32_t t;\n    krb5_data d;\n\n    memset(&a, 0, sizeof(a));\n\n    d.data = rk_UNCONST(buf);\n    d.length = len;\n    t = _kdc_now.tv_sec;\n\n    fd = open(fn, O_WRONLY|O_CREAT|O_APPEND, 0600);\n    if (fd < 0) {\n\tint saved_errno = errno;\n\tkrb5_set_error_message(context, saved_errno, \"Failed to open: %s\", fn);\n\treturn saved_errno;\n    }\n\n    sp = krb5_storage_from_fd(fd);\n    close(fd);\n    if (sp == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"Storage failed to open fd\");\n\treturn ENOMEM;\n    }\n\n    ret = krb5_sockaddr2address(context, sa, &a);\n    if (ret)\n\tgoto out;\n\n    krb5_store_uint32(sp, 1);\n    krb5_store_uint32(sp, t);\n    krb5_store_address(sp, a);\n    krb5_store_data(sp, d);\n    {\n\tDer_class cl;\n\tDer_type ty;\n\tunsigned int tag;\n\tret = der_get_tag (reply->data, reply->length,\n\t\t\t   &cl, &ty, &tag, NULL);\n\tif (ret) {\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t} else {\n\t    krb5_store_uint32(sp, MAKE_TAG(cl, ty, 0));\n\t    krb5_store_uint32(sp, tag);\n\t}\n    }\n\n    krb5_free_address(context, &a);\nout:\n    krb5_storage_free(sp);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_kdc_process_request(",
          "args": [
            "ontext,",
            "onfig,",
            "uf,",
            "en,",
            "reply,",
            "prependlength,",
            "->addr_string,",
            "->sa,",
            "atagram_reply)"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_process_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "187-223",
          "snippet": "nt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};\n\nnt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "reply)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_update_time(",
          "args": [
            "ULL)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_update_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "41-48",
          "snippet": "oid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ndo_request(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   void *buf, size_t len, krb5_boolean prependlength,\n\t   struct descr *d)\n{\n    krb5_error_code ret;\n    krb5_data reply;\n    int datagram_reply = (d->type == SOCK_DGRAM);\n\n    krb5_kdc_update_time(NULL);\n\n    krb5_data_zero(&reply);\n    ret = krb5_kdc_process_request(context, config,\n\t\t\t\t   buf, len, &reply, &prependlength,\n\t\t\t\t   d->addr_string, d->sa,\n\t\t\t\t   datagram_reply);\n    if(request_log)\n\tkrb5_kdc_save_request(context, request_log, buf, len, &reply, d->sa);\n    if(reply.length){\n\tsend_reply(context, config, prependlength, d, &reply);\n\tkrb5_data_free(&reply);\n    }\n    if(ret)\n\tkdc_log(context, config, 0,\n\t\t\"Failed processing %lu byte request from %s\",\n\t\t(unsigned long)len, d->addr_string);\n}"
  },
  {
    "function_name": "end_reply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "388-416",
    "snippet": "tatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "sendto(%s): %s\",",
            "->addr_string,",
            "trerror(rk_SOCK_ERRNO))"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "endto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endto(",
          "args": [
            "->s,",
            "eply->data,",
            "eply->length,",
            ",",
            "->sa,",
            "->sock_len)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trerror(",
          "args": [
            "k_SOCK_ERRNO)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "endto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endto(",
          "args": [
            "->s,",
            ",",
            "izeof(l),",
            ",",
            "->sa,",
            "->sock_len)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nsend_reply(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_boolean prependlength,\n\t   struct descr *d,\n\t   krb5_data *reply)\n{\n    kdc_log(context, config, 5,\n\t    \"sending %lu bytes to %s\", (unsigned long)reply->length,\n\t    d->addr_string);\n    if(prependlength){\n\tunsigned char l[4];\n\tl[0] = (reply->length >> 24) & 0xff;\n\tl[1] = (reply->length >> 16) & 0xff;\n\tl[2] = (reply->length >> 8) & 0xff;\n\tl[3] = reply->length & 0xff;\n\tif(rk_IS_SOCKET_ERROR(sendto(d->s, l, sizeof(l), 0, d->sa, d->sock_len))) {\n\t    kdc_log (context, config,\n\t\t     0, \"sendto(%s): %s\", d->addr_string,\n\t\t     strerror(rk_SOCK_ERRNO));\n\t    return;\n\t}\n    }\n    if(rk_IS_SOCKET_ERROR(sendto(d->s, reply->data, reply->length, 0, d->sa, d->sock_len))) {\n\tkdc_log (context, config, 0, \"sendto(%s): %s\", d->addr_string,\n\t\t strerror(rk_SOCK_ERRNO));\n\treturn;\n    }\n}"
  },
  {
    "function_name": "ddr_to_string(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "369-382",
    "snippet": "tatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nprintf(",
          "args": [
            "tr,",
            "en,",
            "<family=%d>\",",
            "ddr->sa_family)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_address(",
          "args": [
            "ontext,",
            "a)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_address(",
          "args": [
            "ontext,",
            "a)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_print_address(",
          "args": [
            "a,",
            "tr,",
            "en,",
            "len)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_sockaddr2address(",
          "args": [
            "ontext,",
            "ddr,",
            "a)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\naddr_to_string(krb5_context context,\n\t       struct sockaddr *addr, size_t addr_len, char *str, size_t len)\n{\n    krb5_address a;\n    if(krb5_sockaddr2address(context, addr, &a) == 0) {\n\tif(krb5_print_address(&a, str, len, &len) == 0) {\n\t    krb5_free_address(context, &a);\n\t    return;\n\t}\n\tkrb5_free_address(context, &a);\n    }\n    snprintf(str, len, \"<family=%d>\", addr->sa_family);\n}"
  },
  {
    "function_name": "escr_type(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "359-367",
    "snippet": "tatic const char *\ndescr_type(struct descr *d)\n{\n    if (d->type == SOCK_DGRAM)\n\treturn \"udp\";\n    else if (d->type == SOCK_STREAM)\n\treturn \"tcp\";\n    return \"unknown\";\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const char *\ndescr_type(struct descr *d)\n{\n    if (d->type == SOCK_DGRAM)\n\treturn \"udp\";\n    else if (d->type == SOCK_STREAM)\n\treturn \"tcp\";\n    return \"unknown\";\n}"
  },
  {
    "function_name": "nit_sockets(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "301-353",
    "snippet": "tatic int\ninit_sockets(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr **desc)\n{\n    krb5_error_code ret;\n    size_t i, j;\n    struct descr *d;\n    int num = 0;\n    krb5_addresses addresses;\n\n    if (explicit_addresses.len) {\n\taddresses = explicit_addresses;\n    } else {\n\tret = krb5_get_all_server_addrs (context, &addresses);\n\tif (ret)\n\t    krb5_err (context, 1, ret, \"krb5_get_all_server_addrs\");\n    }\n    parse_ports(context, config, port_str);\n    d = malloc(addresses.len * num_ports * sizeof(*d));\n    if (d == NULL)\n\tkrb5_errx(context, 1, \"malloc(%lu) failed\",\n\t\t  (unsigned long)num_ports * sizeof(*d));\n\n    for (i = 0; i < num_ports; i++){\n\tfor (j = 0; j < addresses.len; ++j) {\n\t    init_socket(context, config, &d[num], &addresses.val[j],\n\t\t\tports[i].family, ports[i].type, ports[i].port);\n\t    if(d[num].s != rk_INVALID_SOCKET){\n\t\tchar a_str[80];\n\t\tsize_t len;\n\n\t\tkrb5_print_address (&addresses.val[j], a_str,\n\t\t\t\t    sizeof(a_str), &len);\n\n\t\tkdc_log(context, config, 5, \"listening on %s port %u/%s\",\n\t\t\ta_str,\n\t\t\tntohs(ports[i].port),\n\t\t\t(ports[i].type == SOCK_STREAM) ? \"tcp\" : \"udp\");\n\t\t/* XXX */\n\t\tnum++;\n\t    }\n\t}\n    }\n    krb5_free_addresses (context, &addresses);\n    d = realloc(d, num * sizeof(*d));\n    if (d == NULL && num != 0)\n\tkrb5_errx(context, 1, \"realloc(%lu) failed\",\n\t\t  (unsigned long)num * sizeof(*d));\n    reinit_descrs (d, num);\n    *desc = d;\n    return num;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct port_desc *ports;",
      "tatic size_t num_ports;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "einit_descrs",
          "args": [
            ",",
            "um)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "einit_descrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "220-227",
          "snippet": "tatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "realloc(%lu) failed\",",
            "unsigned long)num * sizeof(*d))"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            ",",
            "um * sizeof(*d))"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_addresses",
          "args": [
            "ontext,",
            "addresses)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "listening on %s port %u/%s\",",
            "_str,",
            "tohs(ports[i].port),",
            "ports[i].type == SOCK_STREAM) ? \"tcp\" : \"udp\")"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "orts[i].port)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_print_address",
          "args": [
            "addresses.val[j],",
            "_str,",
            "izeof(a_str),",
            "len)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_socket(",
          "args": [
            "ontext,",
            "onfig,",
            "d[num],",
            "addresses.val[j],",
            "orts[i].family,",
            "orts[i].type,",
            "orts[i].port)"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "nit_socket(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "233-294",
          "snippet": "tatic void\ninit_socket(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, krb5_address *a, int family, int type, int port)\n{\n    krb5_error_code ret;\n    struct sockaddr_storage __ss;\n    struct sockaddr *sa = (struct sockaddr *)&__ss;\n    krb5_socklen_t sa_size = sizeof(__ss);\n\n    init_descr (d);\n\n    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);\n    if (ret) {\n\tkrb5_warn(context, ret, \"krb5_addr2sockaddr\");\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n\n    if (sa->sa_family != family)\n\treturn;\n\n    d->s = socket(family, type, 0);\n    if(rk_IS_BAD_SOCKET(d->s)){\n\tkrb5_warn(context, errno, \"socket(%d, %d, 0)\", family, type);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    rk_cloexec(d->s);\n#if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_REUSEADDR)\n    {\n\tint one = 1;\n\tsetsockopt(d->s, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));\n    }\n#endif\n    d->type = type;\n    d->port = port;\n\n    socket_set_nonblocking(d->s, 1);\n\n    if(rk_IS_SOCKET_ERROR(bind(d->s, sa, sa_size))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"bind %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    if(type == SOCK_STREAM && rk_IS_SOCKET_ERROR(listen(d->s, SOMAXCONN))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"listen %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ninit_socket(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, krb5_address *a, int family, int type, int port)\n{\n    krb5_error_code ret;\n    struct sockaddr_storage __ss;\n    struct sockaddr *sa = (struct sockaddr *)&__ss;\n    krb5_socklen_t sa_size = sizeof(__ss);\n\n    init_descr (d);\n\n    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);\n    if (ret) {\n\tkrb5_warn(context, ret, \"krb5_addr2sockaddr\");\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n\n    if (sa->sa_family != family)\n\treturn;\n\n    d->s = socket(family, type, 0);\n    if(rk_IS_BAD_SOCKET(d->s)){\n\tkrb5_warn(context, errno, \"socket(%d, %d, 0)\", family, type);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    rk_cloexec(d->s);\n#if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_REUSEADDR)\n    {\n\tint one = 1;\n\tsetsockopt(d->s, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));\n    }\n#endif\n    d->type = type;\n    d->port = port;\n\n    socket_set_nonblocking(d->s, 1);\n\n    if(rk_IS_SOCKET_ERROR(bind(d->s, sa, sa_size))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"bind %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    if(type == SOCK_STREAM && rk_IS_SOCKET_ERROR(listen(d->s, SOMAXCONN))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"listen %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "malloc(%lu) failed\",",
            "unsigned long)num_ports * sizeof(*d))"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "ddresses.len * num_ports * sizeof(*d))"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arse_ports(",
          "args": [
            "ontext,",
            "onfig,",
            "ort_str)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "arse_ports(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "151-188",
          "snippet": "tatic void\nparse_ports(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    const char *str)\n{\n    char *pos = NULL;\n    char *p;\n    char *str_copy = strdup (str);\n\n    p = strtok_r(str_copy, \" \\t\", &pos);\n    while(p != NULL) {\n\tif(strcmp(p, \"+\") == 0) {\n#ifdef HAVE_IPV6\n\t    add_standard_ports(context, config, AF_INET6);\n#endif\n\t    add_standard_ports(context, config, AF_INET);\n\t} else {\n\t    char *q = strchr(p, '/');\n\t    if(q){\n\t\t*q++ = 0;\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, q);\n#endif\n\t\tadd_port_string(context, AF_INET, p, q);\n\t    }else {\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, \"udp\");\n\t\tadd_port_string(context, AF_INET6, p, \"tcp\");\n#endif\n\t\tadd_port_string(context, AF_INET, p, \"udp\");\n\t\tadd_port_string(context, AF_INET, p, \"tcp\");\n\t    }\n\t}\n\n\tp = strtok_r(NULL, \" \\t\", &pos);\n    }\n    free (str_copy);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nparse_ports(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    const char *str)\n{\n    char *pos = NULL;\n    char *p;\n    char *str_copy = strdup (str);\n\n    p = strtok_r(str_copy, \" \\t\", &pos);\n    while(p != NULL) {\n\tif(strcmp(p, \"+\") == 0) {\n#ifdef HAVE_IPV6\n\t    add_standard_ports(context, config, AF_INET6);\n#endif\n\t    add_standard_ports(context, config, AF_INET);\n\t} else {\n\t    char *q = strchr(p, '/');\n\t    if(q){\n\t\t*q++ = 0;\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, q);\n#endif\n\t\tadd_port_string(context, AF_INET, p, q);\n\t    }else {\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, \"udp\");\n\t\tadd_port_string(context, AF_INET6, p, \"tcp\");\n#endif\n\t\tadd_port_string(context, AF_INET, p, \"udp\");\n\t\tadd_port_string(context, AF_INET, p, \"tcp\");\n\t    }\n\t}\n\n\tp = strtok_r(NULL, \" \\t\", &pos);\n    }\n    free (str_copy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_err",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_get_all_server_addrs\")"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_all_server_addrs",
          "args": [
            "ontext,",
            "addresses)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct port_desc *ports;\ntatic size_t num_ports;\n\ntatic int\ninit_sockets(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     struct descr **desc)\n{\n    krb5_error_code ret;\n    size_t i, j;\n    struct descr *d;\n    int num = 0;\n    krb5_addresses addresses;\n\n    if (explicit_addresses.len) {\n\taddresses = explicit_addresses;\n    } else {\n\tret = krb5_get_all_server_addrs (context, &addresses);\n\tif (ret)\n\t    krb5_err (context, 1, ret, \"krb5_get_all_server_addrs\");\n    }\n    parse_ports(context, config, port_str);\n    d = malloc(addresses.len * num_ports * sizeof(*d));\n    if (d == NULL)\n\tkrb5_errx(context, 1, \"malloc(%lu) failed\",\n\t\t  (unsigned long)num_ports * sizeof(*d));\n\n    for (i = 0; i < num_ports; i++){\n\tfor (j = 0; j < addresses.len; ++j) {\n\t    init_socket(context, config, &d[num], &addresses.val[j],\n\t\t\tports[i].family, ports[i].type, ports[i].port);\n\t    if(d[num].s != rk_INVALID_SOCKET){\n\t\tchar a_str[80];\n\t\tsize_t len;\n\n\t\tkrb5_print_address (&addresses.val[j], a_str,\n\t\t\t\t    sizeof(a_str), &len);\n\n\t\tkdc_log(context, config, 5, \"listening on %s port %u/%s\",\n\t\t\ta_str,\n\t\t\tntohs(ports[i].port),\n\t\t\t(ports[i].type == SOCK_STREAM) ? \"tcp\" : \"udp\");\n\t\t/* XXX */\n\t\tnum++;\n\t    }\n\t}\n    }\n    krb5_free_addresses (context, &addresses);\n    d = realloc(d, num * sizeof(*d));\n    if (d == NULL && num != 0)\n\tkrb5_errx(context, 1, \"realloc(%lu) failed\",\n\t\t  (unsigned long)num * sizeof(*d));\n    reinit_descrs (d, num);\n    *desc = d;\n    return num;\n}"
  },
  {
    "function_name": "nit_socket(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "233-294",
    "snippet": "tatic void\ninit_socket(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, krb5_address *a, int family, int type, int port)\n{\n    krb5_error_code ret;\n    struct sockaddr_storage __ss;\n    struct sockaddr *sa = (struct sockaddr *)&__ss;\n    krb5_socklen_t sa_size = sizeof(__ss);\n\n    init_descr (d);\n\n    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);\n    if (ret) {\n\tkrb5_warn(context, ret, \"krb5_addr2sockaddr\");\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n\n    if (sa->sa_family != family)\n\treturn;\n\n    d->s = socket(family, type, 0);\n    if(rk_IS_BAD_SOCKET(d->s)){\n\tkrb5_warn(context, errno, \"socket(%d, %d, 0)\", family, type);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    rk_cloexec(d->s);\n#if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_REUSEADDR)\n    {\n\tint one = 1;\n\tsetsockopt(d->s, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));\n    }\n#endif\n    d->type = type;\n    d->port = port;\n\n    socket_set_nonblocking(d->s, 1);\n\n    if(rk_IS_SOCKET_ERROR(bind(d->s, sa, sa_size))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"bind %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    if(type == SOCK_STREAM && rk_IS_SOCKET_ERROR(listen(d->s, SOMAXCONN))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"listen %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "k_closesocket(",
          "args": [
            "->s)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "rrno,",
            "listen %s/%d\",",
            "_str,",
            "tohs(port))"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "ort)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_print_address",
          "args": [
            ",",
            "_str,",
            "izeof(a_str),",
            "len)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "isten(d->s, SOMAXCONN))"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isten(",
          "args": [
            "->s,",
            "OMAXCONN)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_closesocket(",
          "args": [
            "->s)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "rrno,",
            "bind %s/%d\",",
            "_str,",
            "tohs(port))"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "ort)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_print_address",
          "args": [
            ",",
            "_str,",
            "izeof(a_str),",
            "len)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_SOCKET_ERROR(",
          "args": [
            "ind(d->s, sa, sa_size))"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ind(",
          "args": [
            "->s,",
            "a,",
            "a_size)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket_set_nonblocking(",
          "args": [
            "->s,",
            ")"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etsockopt(",
          "args": [
            "->s,",
            "OL_SOCKET,",
            "O_REUSEADDR,",
            "void *)&one,",
            "izeof(one))"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_cloexec(",
          "args": [
            "->s)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "rrno,",
            "socket(%d, %d, 0)\",",
            "amily,",
            "ype)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_IS_BAD_SOCKET(",
          "args": [
            "->s)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket(",
          "args": [
            "amily,",
            "ype,",
            ")"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "pen_socket(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "53-87",
          "snippet": "tatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_closesocket(",
          "args": [
            "->s)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "krb5_addr2sockaddr\")"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_addr2sockaddr",
          "args": [
            "ontext,",
            ",",
            "a,",
            "sa_size,",
            "ort)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_descr",
          "args": [
            ")"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "nit_descr(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "208-214",
          "snippet": "tatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ninit_socket(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    struct descr *d, krb5_address *a, int family, int type, int port)\n{\n    krb5_error_code ret;\n    struct sockaddr_storage __ss;\n    struct sockaddr *sa = (struct sockaddr *)&__ss;\n    krb5_socklen_t sa_size = sizeof(__ss);\n\n    init_descr (d);\n\n    ret = krb5_addr2sockaddr (context, a, sa, &sa_size, port);\n    if (ret) {\n\tkrb5_warn(context, ret, \"krb5_addr2sockaddr\");\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n\n    if (sa->sa_family != family)\n\treturn;\n\n    d->s = socket(family, type, 0);\n    if(rk_IS_BAD_SOCKET(d->s)){\n\tkrb5_warn(context, errno, \"socket(%d, %d, 0)\", family, type);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    rk_cloexec(d->s);\n#if defined(HAVE_SETSOCKOPT) && defined(SOL_SOCKET) && defined(SO_REUSEADDR)\n    {\n\tint one = 1;\n\tsetsockopt(d->s, SOL_SOCKET, SO_REUSEADDR, (void *)&one, sizeof(one));\n    }\n#endif\n    d->type = type;\n    d->port = port;\n\n    socket_set_nonblocking(d->s, 1);\n\n    if(rk_IS_SOCKET_ERROR(bind(d->s, sa, sa_size))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"bind %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n    if(type == SOCK_STREAM && rk_IS_SOCKET_ERROR(listen(d->s, SOMAXCONN))){\n\tchar a_str[256];\n\tsize_t len;\n\n\tkrb5_print_address (a, a_str, sizeof(a_str), &len);\n\tkrb5_warn(context, errno, \"listen %s/%d\", a_str, ntohs(port));\n\trk_closesocket(d->s);\n\td->s = rk_INVALID_SOCKET;\n\treturn;\n    }\n}"
  },
  {
    "function_name": "einit_descrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "220-227",
    "snippet": "tatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nreinit_descrs (struct descr *d, int n)\n{\n    int i;\n\n    for (i = 0; i < n; ++i)\n\td[i].sa = (struct sockaddr *)&d[i].__ss;\n}"
  },
  {
    "function_name": "nit_descr(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "208-214",
    "snippet": "tatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            ",",
            ",",
            "izeof(*d))"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\ninit_descr(struct descr *d)\n{\n    memset(d, 0, sizeof(*d));\n    d->sa = (struct sockaddr *)&d->__ss;\n    d->s = rk_INVALID_SOCKET;\n}"
  },
  {
    "function_name": "arse_ports(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "151-188",
    "snippet": "tatic void\nparse_ports(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    const char *str)\n{\n    char *pos = NULL;\n    char *p;\n    char *str_copy = strdup (str);\n\n    p = strtok_r(str_copy, \" \\t\", &pos);\n    while(p != NULL) {\n\tif(strcmp(p, \"+\") == 0) {\n#ifdef HAVE_IPV6\n\t    add_standard_ports(context, config, AF_INET6);\n#endif\n\t    add_standard_ports(context, config, AF_INET);\n\t} else {\n\t    char *q = strchr(p, '/');\n\t    if(q){\n\t\t*q++ = 0;\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, q);\n#endif\n\t\tadd_port_string(context, AF_INET, p, q);\n\t    }else {\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, \"udp\");\n\t\tadd_port_string(context, AF_INET6, p, \"tcp\");\n#endif\n\t\tadd_port_string(context, AF_INET, p, \"udp\");\n\t\tadd_port_string(context, AF_INET, p, \"tcp\");\n\t    }\n\t}\n\n\tp = strtok_r(NULL, \" \\t\", &pos);\n    }\n    free (str_copy);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree",
          "args": [
            "tr_copy)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtok_r(",
          "args": [
            "ULL,",
            "\\t\",",
            "pos)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET,",
            ",",
            "tcp\")"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET,",
            ",",
            "udp\")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET6,",
            ",",
            "tcp\")"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET6,",
            ",",
            "udp\")"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET,",
            ",",
            ")"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_port_string(",
          "args": [
            "ontext,",
            "F_INET6,",
            ",",
            ")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "/')"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_standard_ports(",
          "args": [
            "ontext,",
            "onfig,",
            "F_INET)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_standard_ports(",
          "args": [
            "ontext,",
            "onfig,",
            "F_INET6)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "+\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtok_r(",
          "args": [
            "tr_copy,",
            "\\t\",",
            "pos)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup",
          "args": [
            "tr)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nparse_ports(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    const char *str)\n{\n    char *pos = NULL;\n    char *p;\n    char *str_copy = strdup (str);\n\n    p = strtok_r(str_copy, \" \\t\", &pos);\n    while(p != NULL) {\n\tif(strcmp(p, \"+\") == 0) {\n#ifdef HAVE_IPV6\n\t    add_standard_ports(context, config, AF_INET6);\n#endif\n\t    add_standard_ports(context, config, AF_INET);\n\t} else {\n\t    char *q = strchr(p, '/');\n\t    if(q){\n\t\t*q++ = 0;\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, q);\n#endif\n\t\tadd_port_string(context, AF_INET, p, q);\n\t    }else {\n#ifdef HAVE_IPV6\n\t\tadd_port_string(context, AF_INET6, p, \"udp\");\n\t\tadd_port_string(context, AF_INET6, p, \"tcp\");\n#endif\n\t\tadd_port_string(context, AF_INET, p, \"udp\");\n\t\tadd_port_string(context, AF_INET, p, \"tcp\");\n\t    }\n\t}\n\n\tp = strtok_r(NULL, \" \\t\", &pos);\n    }\n    free (str_copy);\n}"
  },
  {
    "function_name": "dd_standard_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "127-143",
    "snippet": "tatic void\nadd_standard_ports (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    int family)\n{\n    add_port_service(context, family, \"kerberos\", 88, \"udp\");\n    add_port_service(context, family, \"kerberos\", 88, \"tcp\");\n    add_port_service(context, family, \"kerberos-sec\", 88, \"udp\");\n    add_port_service(context, family, \"kerberos-sec\", 88, \"tcp\");\n    if(enable_http)\n\tadd_port_service(context, family, \"http\", 80, \"tcp\");\n    if(config->enable_kx509) {\n\tadd_port_service(context, family, \"kca_service\", 9878, \"udp\");\n\tadd_port_service(context, family, \"kca_service\", 9878, \"tcp\");\n    }\n\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dd_port_service(",
          "args": [
            "ontext,",
            "amily,",
            "kca_service\",",
            "878,",
            "tcp\")"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "dd_port_service(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "89-96",
          "snippet": "tatic void\nadd_port_service(krb5_context context,\n\t\t int family, const char *service, int port,\n\t\t const char *protocol)\n{\n    port = krb5_getportbyname (context, service, protocol, port);\n    add_port (context, family, port, protocol);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_port_service(krb5_context context,\n\t\t int family, const char *service, int port,\n\t\t const char *protocol)\n{\n    port = krb5_getportbyname (context, service, protocol, port);\n    add_port (context, family, port, protocol);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_standard_ports (krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    int family)\n{\n    add_port_service(context, family, \"kerberos\", 88, \"udp\");\n    add_port_service(context, family, \"kerberos\", 88, \"tcp\");\n    add_port_service(context, family, \"kerberos-sec\", 88, \"udp\");\n    add_port_service(context, family, \"kerberos-sec\", 88, \"tcp\");\n    if(enable_http)\n\tadd_port_service(context, family, \"http\", 80, \"tcp\");\n    if(config->enable_kx509) {\n\tadd_port_service(context, family, \"kca_service\", 9878, \"udp\");\n\tadd_port_service(context, family, \"kca_service\", 9878, \"tcp\");\n    }\n\n}"
  },
  {
    "function_name": "dd_port_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "103-121",
    "snippet": "tatic void\nadd_port_string (krb5_context context,\n\t\t int family, const char *str, const char *protocol)\n{\n    struct servent *sp;\n    int port;\n\n    sp = roken_getservbyname (str, protocol);\n    if (sp != NULL) {\n\tport = sp->s_port;\n    } else {\n\tchar *end;\n\n\tport = htons(strtol(str, &end, 0));\n\tif (end == str)\n\t    return;\n    }\n    add_port (context, family, port, protocol);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dd_port",
          "args": [
            "ontext,",
            "amily,",
            "ort,",
            "rotocol)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dd_port_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "103-121",
          "snippet": "tatic void\nadd_port_string (krb5_context context,\n\t\t int family, const char *str, const char *protocol)\n{\n    struct servent *sp;\n    int port;\n\n    sp = roken_getservbyname (str, protocol);\n    if (sp != NULL) {\n\tport = sp->s_port;\n    } else {\n\tchar *end;\n\n\tport = htons(strtol(str, &end, 0));\n\tif (end == str)\n\t    return;\n    }\n    add_port (context, family, port, protocol);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tons(",
          "args": [
            "trtol(str, &end, 0))"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trtol(",
          "args": [
            "tr,",
            "end,",
            ")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oken_getservbyname",
          "args": [
            "tr,",
            "rotocol)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_port_string (krb5_context context,\n\t\t int family, const char *str, const char *protocol)\n{\n    struct servent *sp;\n    int port;\n\n    sp = roken_getservbyname (str, protocol);\n    if (sp != NULL) {\n\tport = sp->s_port;\n    } else {\n\tchar *end;\n\n\tport = htons(strtol(str, &end, 0));\n\tif (end == str)\n\t    return;\n    }\n    add_port (context, family, port, protocol);\n}"
  },
  {
    "function_name": "dd_port_service(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "89-96",
    "snippet": "tatic void\nadd_port_service(krb5_context context,\n\t\t int family, const char *service, int port,\n\t\t const char *protocol)\n{\n    port = krb5_getportbyname (context, service, protocol, port);\n    add_port (context, family, port, protocol);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dd_port",
          "args": [
            "ontext,",
            "amily,",
            "ort,",
            "rotocol)"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "dd_port_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "103-121",
          "snippet": "tatic void\nadd_port_string (krb5_context context,\n\t\t int family, const char *str, const char *protocol)\n{\n    struct servent *sp;\n    int port;\n\n    sp = roken_getservbyname (str, protocol);\n    if (sp != NULL) {\n\tport = sp->s_port;\n    } else {\n\tchar *end;\n\n\tport = htons(strtol(str, &end, 0));\n\tif (end == str)\n\t    return;\n    }\n    add_port (context, family, port, protocol);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_port_string (krb5_context context,\n\t\t int family, const char *str, const char *protocol)\n{\n    struct servent *sp;\n    int port;\n\n    sp = roken_getservbyname (str, protocol);\n    if (sp != NULL) {\n\tport = sp->s_port;\n    } else {\n\tchar *end;\n\n\tport = htons(strtol(str, &end, 0));\n\tif (end == str)\n\t    return;\n    }\n    add_port (context, family, port, protocol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_getportbyname",
          "args": [
            "ontext,",
            "ervice,",
            "rotocol,",
            "ort)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic void\nadd_port_service(krb5_context context,\n\t\t int family, const char *service, int port,\n\t\t const char *protocol)\n{\n    port = krb5_getportbyname (context, service, protocol, port);\n    add_port (context, family, port, protocol);\n}"
  },
  {
    "function_name": "dd_port(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
    "lines": "56-82",
    "snippet": "tatic void\nadd_port(krb5_context context,\n\t int family, int port, const char *protocol)\n{\n    int type;\n    size_t i;\n\n    if(strcmp(protocol, \"udp\") == 0)\n\ttype = SOCK_DGRAM;\n    else if(strcmp(protocol, \"tcp\") == 0)\n\ttype = SOCK_STREAM;\n    else\n\treturn;\n    for(i = 0; i < num_ports; i++){\n\tif(ports[i].type == type\n\t   && ports[i].port == port\n\t   && ports[i].family == family)\n\t    return;\n    }\n    ports = realloc(ports, (num_ports + 1) * sizeof(*ports));\n    if (ports == NULL)\n\tkrb5_err (context, 1, errno, \"realloc\");\n    ports[num_ports].family = family;\n    ports[num_ports].type   = type;\n    ports[num_ports].port   = port;\n    num_ports++;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct port_desc *ports;",
      "tatic size_t num_ports;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_err",
          "args": [
            "ontext,",
            ",",
            "rrno,",
            "realloc\")"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "orts,",
            "num_ports + 1) * sizeof(*ports))"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rotocol,",
            "tcp\")"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rotocol,",
            "udp\")"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct port_desc *ports;\ntatic size_t num_ports;\n\ntatic void\nadd_port(krb5_context context,\n\t int family, int port, const char *protocol)\n{\n    int type;\n    size_t i;\n\n    if(strcmp(protocol, \"udp\") == 0)\n\ttype = SOCK_DGRAM;\n    else if(strcmp(protocol, \"tcp\") == 0)\n\ttype = SOCK_STREAM;\n    else\n\treturn;\n    for(i = 0; i < num_ports; i++){\n\tif(ports[i].type == type\n\t   && ports[i].port == port\n\t   && ports[i].family == family)\n\t    return;\n    }\n    ports = realloc(ports, (num_ports + 1) * sizeof(*ports));\n    if (ports == NULL)\n\tkrb5_err (context, 1, errno, \"realloc\");\n    ports[num_ports].family = family;\n    ports[num_ports].type   = type;\n    ports[num_ports].port   = port;\n    num_ports++;\n}"
  }
]