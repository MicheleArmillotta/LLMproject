[
  {
    "function_name": "rb5_kdc_pk_initialize(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1909-2016",
    "snippet": "rb5_error_code\nkrb5_kdc_pk_initialize(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       const char *user_id,\n\t\t       const char *anchors,\n\t\t       char **pool,\n\t\t       char **revoke_list)\n{\n    const char *file;\n    char *fn = NULL;\n    krb5_error_code ret;\n\n    file = krb5_config_get_string(context, NULL,\n\t\t\t\t  \"libdefaults\", \"moduli\", NULL);\n\n    ret = _krb5_parse_moduli(context, file, &moduli);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"PKINIT: failed to load modidi file\");\n\n    principal_mappings.len = 0;\n    principal_mappings.val = NULL;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &kdc_identity,\n\t\t\t   user_id,\n\t\t\t   anchors,\n\t\t\t   pool,\n\t\t\t   revoke_list,\n\t\t\t   NULL,\n\t\t\t   NULL,\n\t\t\t   NULL);\n    if (ret) {\n\tkrb5_warn(context, ret, \"PKINIT: \");\n\tconfig->enable_pkinit = 0;\n\treturn ret;\n    }\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret == 0) {\n\t    if (hx509_cert_check_eku(context->hx509ctx, cert,\n\t\t\t\t     &asn1_oid_id_pkkdcekuoid, 0)) {\n\t\thx509_name name;\n\t\tchar *str;\n\t\tret = hx509_cert_get_subject(cert, &name);\n\t\tif (ret == 0) {\n\t\t    hx509_name_to_string(name, &str);\n\t\t    krb5_warnx(context, \"WARNING Found KDC certificate (%s)\"\n\t\t\t       \"is missing the PK-INIT KDC EKU, this is bad for \"\n\t\t\t       \"interoperability.\", str);\n\t\t    hx509_name_free(&name);\n\t\t    free(str);\n\t\t}\n\t    }\n\t    hx509_cert_free(cert);\n\t} else\n\t    krb5_warnx(context, \"PKINIT: failed to find a signing \"\n\t\t       \"certifiate with a public key\");\n    }\n\n    if (krb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_allow_proxy_certificate\",\n\t\t\t\t     NULL))\n\tconfig->pkinit_allow_proxy_certs = 1;\n\n    file = krb5_config_get_string(context,\n\t\t\t\t  NULL,\n\t\t\t\t  \"kdc\",\n\t\t\t\t  \"pkinit_mappings_file\",\n\t\t\t\t  NULL);\n    if (file == NULL) {\n\tint aret;\n\n\taret = asprintf(&fn, \"%s/pki-mapping\", hdb_db_dir(context));\n\tif (aret == -1) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\tfile = fn;\n    }\n\n    load_mappings(context, file);\n    if (fn)\n\tfree(fn);\n\n    return 0;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "n)"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_mappings(",
          "args": [
            "ontext,",
            "ile)"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "oad_mappings(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1862-1903",
          "snippet": "tatic void\nload_mappings(krb5_context context, const char *fn)\n{\n    krb5_error_code ret;\n    char buf[1024];\n    unsigned long lineno = 0;\n    FILE *f;\n\n    f = fopen(fn, \"r\");\n    if (f == NULL)\n\treturn;\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n\tchar *subject_name, *p;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tp = buf + strspn(buf, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\n\n\tsubject_name = strchr(p, ':');\n\tif (subject_name == NULL) {\n\t    krb5_warnx(context, \"pkinit mapping file line %lu \"\n\t\t       \"missing \\\":\\\" :%s\",\n\t\t       lineno, buf);\n\t    continue;\n\t}\n\t*subject_name++ = '\\0';\n\n\tret = add_principal_mapping(context, p, subject_name);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"failed to add line %lu \\\":\\\" :%s\\n\",\n\t\t      lineno, buf);\n\t    continue;\n\t}\n    }\n\n    fclose(f);\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic void\nload_mappings(krb5_context context, const char *fn)\n{\n    krb5_error_code ret;\n    char buf[1024];\n    unsigned long lineno = 0;\n    FILE *f;\n\n    f = fopen(fn, \"r\");\n    if (f == NULL)\n\treturn;\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n\tchar *subject_name, *p;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tp = buf + strspn(buf, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\n\n\tsubject_name = strchr(p, ':');\n\tif (subject_name == NULL) {\n\t    krb5_warnx(context, \"pkinit mapping file line %lu \"\n\t\t       \"missing \\\":\\\" :%s\",\n\t\t       lineno, buf);\n\t    continue;\n\t}\n\t*subject_name++ = '\\0';\n\n\tret = add_principal_mapping(context, p, subject_name);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"failed to add line %lu \\\":\\\" :%s\\n\",\n\t\t      lineno, buf);\n\t    continue;\n\t}\n    }\n\n    fclose(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "PKINIT: out of memory\")"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf(",
          "args": [
            "fn,",
            "%s/pki-mapping\",",
            "db_db_dir(context))"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_db_dir(",
          "args": [
            "ontext)"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_config_get_string(",
          "args": [
            "ontext,",
            "ULL,",
            "kdc\",",
            "pkinit_mappings_file\",",
            "ULL)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_config_get_bool_default(",
          "args": [
            "ontext,",
            "ULL,",
            "ALSE,",
            "kdc\",",
            "pkinit_allow_proxy_certificate\",",
            "ULL)"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "PKINIT: failed to find a signing \"\n\t\t       \"certifiate with a public key\")"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "ert)"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_name_free(",
          "args": [
            "name)"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "WARNING Found KDC certificate (%s)\"\n\t\t\t       \"is missing the PK-INIT KDC EKU, this is bad for \"\n\t\t\t       \"interoperability.\",",
            "tr)"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_name_to_string(",
          "args": [
            "ame,",
            "str)"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_get_subject(",
          "args": [
            "ert,",
            "name)"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_check_eku(",
          "args": [
            "ontext->hx509ctx,",
            "ert,",
            "asn1_oid_id_pkkdcekuoid,",
            ")"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_find(",
          "args": [
            "ontext->hx509ctx,",
            "dc_identity->certs,",
            ",",
            "cert)"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_friendly_name(",
          "args": [
            ",",
            "onfig->pkinit_kdc_friendly_name)"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_option(",
          "args": [
            ",",
            "X509_QUERY_OPTION_PRIVATE_KEY)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "PKINIT: out of memory\")"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_alloc(",
          "args": [
            "ontext->hx509ctx,",
            "q)"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "PKINIT: \")"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pk_load_id(",
          "args": [
            "ontext,",
            "kdc_identity,",
            "ser_id,",
            "nchors,",
            "ool,",
            "evoke_list,",
            "ULL,",
            "ULL,",
            "ULL)"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "PKINIT: failed to load modidi file\")"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_moduli(",
          "args": [
            "ontext,",
            "ile,",
            "moduli)"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_config_get_string(",
          "args": [
            "ontext,",
            "ULL,",
            "libdefaults\",",
            "moduli\",",
            "ULL)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\nkrb5_kdc_pk_initialize(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       const char *user_id,\n\t\t       const char *anchors,\n\t\t       char **pool,\n\t\t       char **revoke_list)\n{\n    const char *file;\n    char *fn = NULL;\n    krb5_error_code ret;\n\n    file = krb5_config_get_string(context, NULL,\n\t\t\t\t  \"libdefaults\", \"moduli\", NULL);\n\n    ret = _krb5_parse_moduli(context, file, &moduli);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"PKINIT: failed to load modidi file\");\n\n    principal_mappings.len = 0;\n    principal_mappings.val = NULL;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &kdc_identity,\n\t\t\t   user_id,\n\t\t\t   anchors,\n\t\t\t   pool,\n\t\t\t   revoke_list,\n\t\t\t   NULL,\n\t\t\t   NULL,\n\t\t\t   NULL);\n    if (ret) {\n\tkrb5_warn(context, ret, \"PKINIT: \");\n\tconfig->enable_pkinit = 0;\n\treturn ret;\n    }\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret == 0) {\n\t    if (hx509_cert_check_eku(context->hx509ctx, cert,\n\t\t\t\t     &asn1_oid_id_pkkdcekuoid, 0)) {\n\t\thx509_name name;\n\t\tchar *str;\n\t\tret = hx509_cert_get_subject(cert, &name);\n\t\tif (ret == 0) {\n\t\t    hx509_name_to_string(name, &str);\n\t\t    krb5_warnx(context, \"WARNING Found KDC certificate (%s)\"\n\t\t\t       \"is missing the PK-INIT KDC EKU, this is bad for \"\n\t\t\t       \"interoperability.\", str);\n\t\t    hx509_name_free(&name);\n\t\t    free(str);\n\t\t}\n\t    }\n\t    hx509_cert_free(cert);\n\t} else\n\t    krb5_warnx(context, \"PKINIT: failed to find a signing \"\n\t\t       \"certifiate with a public key\");\n    }\n\n    if (krb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_allow_proxy_certificate\",\n\t\t\t\t     NULL))\n\tconfig->pkinit_allow_proxy_certs = 1;\n\n    file = krb5_config_get_string(context,\n\t\t\t\t  NULL,\n\t\t\t\t  \"kdc\",\n\t\t\t\t  \"pkinit_mappings_file\",\n\t\t\t\t  NULL);\n    if (file == NULL) {\n\tint aret;\n\n\taret = asprintf(&fn, \"%s/pki-mapping\", hdb_db_dir(context));\n\tif (aret == -1) {\n\t    krb5_warnx(context, \"PKINIT: out of memory\");\n\t    return ENOMEM;\n\t}\n\n\tfile = fn;\n    }\n\n    load_mappings(context, file);\n    if (fn)\n\tfree(fn);\n\n    return 0;\n}"
  },
  {
    "function_name": "oad_mappings(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1862-1903",
    "snippet": "tatic void\nload_mappings(krb5_context context, const char *fn)\n{\n    krb5_error_code ret;\n    char buf[1024];\n    unsigned long lineno = 0;\n    FILE *f;\n\n    f = fopen(fn, \"r\");\n    if (f == NULL)\n\treturn;\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n\tchar *subject_name, *p;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tp = buf + strspn(buf, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\n\n\tsubject_name = strchr(p, ':');\n\tif (subject_name == NULL) {\n\t    krb5_warnx(context, \"pkinit mapping file line %lu \"\n\t\t       \"missing \\\":\\\" :%s\",\n\t\t       lineno, buf);\n\t    continue;\n\t}\n\t*subject_name++ = '\\0';\n\n\tret = add_principal_mapping(context, p, subject_name);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"failed to add line %lu \\\":\\\" :%s\\n\",\n\t\t      lineno, buf);\n\t    continue;\n\t}\n    }\n\n    fclose(f);\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close(",
          "args": [
            ")"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "failed to add line %lu \\\":\\\" :%s\\n\",",
            "ineno,",
            "uf)"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_principal_mapping(",
          "args": [
            "ontext,",
            ",",
            "ubject_name)"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "dd_principal_mapping(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1798-1827",
          "snippet": "tatic krb5_error_code\nadd_principal_mapping(krb5_context context,\n\t\t      const char *principal_name,\n\t\t      const char * subject)\n{\n   struct pk_allowed_princ *tmp;\n   krb5_principal principal;\n   krb5_error_code ret;\n\n   tmp = realloc(principal_mappings.val,\n\t         (principal_mappings.len + 1) * sizeof(*tmp));\n   if (tmp == NULL)\n       return ENOMEM;\n   principal_mappings.val = tmp;\n\n   ret = krb5_parse_name(context, principal_name, &principal);\n   if (ret)\n       return ret;\n\n   principal_mappings.val[principal_mappings.len].principal = principal;\n\n   principal_mappings.val[principal_mappings.len].subject = strdup(subject);\n   if (principal_mappings.val[principal_mappings.len].subject == NULL) {\n       krb5_free_principal(context, principal);\n       return ENOMEM;\n   }\n   principal_mappings.len++;\n\n   return 0;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nadd_principal_mapping(krb5_context context,\n\t\t      const char *principal_name,\n\t\t      const char * subject)\n{\n   struct pk_allowed_princ *tmp;\n   krb5_principal principal;\n   krb5_error_code ret;\n\n   tmp = realloc(principal_mappings.val,\n\t         (principal_mappings.len + 1) * sizeof(*tmp));\n   if (tmp == NULL)\n       return ENOMEM;\n   principal_mappings.val = tmp;\n\n   ret = krb5_parse_name(context, principal_name, &principal);\n   if (ret)\n       return ret;\n\n   principal_mappings.val[principal_mappings.len].principal = principal;\n\n   principal_mappings.val[principal_mappings.len].subject = strdup(subject);\n   if (principal_mappings.val[principal_mappings.len].subject == NULL) {\n       krb5_free_principal(context, principal);\n       return ENOMEM;\n   }\n   principal_mappings.len++;\n\n   return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "pkinit mapping file line %lu \"\n\t\t       \"missing \\\":\\\" :%s\",",
            "ineno,",
            "uf)"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            ":')"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trspn(",
          "args": [
            "uf,",
            "\\t\")"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcspn(",
          "args": [
            "uf,",
            "\\n\")"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gets(",
          "args": [
            "uf,",
            "izeof(buf),",
            ")"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open(",
          "args": [
            "n,",
            "r\")"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic void\nload_mappings(krb5_context context, const char *fn)\n{\n    krb5_error_code ret;\n    char buf[1024];\n    unsigned long lineno = 0;\n    FILE *f;\n\n    f = fopen(fn, \"r\");\n    if (f == NULL)\n\treturn;\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n\tchar *subject_name, *p;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tp = buf + strspn(buf, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t    continue;\n\n\tsubject_name = strchr(p, ':');\n\tif (subject_name == NULL) {\n\t    krb5_warnx(context, \"pkinit mapping file line %lu \"\n\t\t       \"missing \\\":\\\" :%s\",\n\t\t       lineno, buf);\n\t    continue;\n\t}\n\t*subject_name++ = '\\0';\n\n\tret = add_principal_mapping(context, p, subject_name);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"failed to add line %lu \\\":\\\" :%s\\n\",\n\t\t      lineno, buf);\n\t    continue;\n\t}\n    }\n\n    fclose(f);\n}"
  },
  {
    "function_name": "kdc_add_inital_verified_cas(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1829-1856",
    "snippet": "rb5_error_code\n_kdc_add_inital_verified_cas(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     pk_client_params *cp,\n\t\t\t     EncTicketPart *tkt)\n{\n    AD_INITIAL_VERIFIED_CAS cas;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&cas, 0, sizeof(cas));\n\n    /* XXX add CAs to cas here */\n\n    ASN1_MALLOC_ENCODE(AD_INITIAL_VERIFIED_CAS, data.data, data.length,\n\t\t       &cas, &size, ret);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_tkt_add_if_relevant_ad(",
          "args": [
            "ontext,",
            "kt,",
            "RB5_AUTHDATA_INITIAL_VERIFIED_CAS,",
            "data)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "D_INITIAL_VERIFIED_CAS,",
            "ata.data,",
            "ata.length,",
            "cas,",
            "size,",
            "et)"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "cas,",
            ",",
            "izeof(cas))"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_add_inital_verified_cas(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     pk_client_params *cp,\n\t\t\t     EncTicketPart *tkt)\n{\n    AD_INITIAL_VERIFIED_CAS cas;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&cas, 0, sizeof(cas));\n\n    /* XXX add CAs to cas here */\n\n    ASN1_MALLOC_ENCODE(AD_INITIAL_VERIFIED_CAS, data.data, data.length,\n\t\t       &cas, &size, ret);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n    return ret;\n}"
  },
  {
    "function_name": "dd_principal_mapping(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1798-1827",
    "snippet": "tatic krb5_error_code\nadd_principal_mapping(krb5_context context,\n\t\t      const char *principal_name,\n\t\t      const char * subject)\n{\n   struct pk_allowed_princ *tmp;\n   krb5_principal principal;\n   krb5_error_code ret;\n\n   tmp = realloc(principal_mappings.val,\n\t         (principal_mappings.len + 1) * sizeof(*tmp));\n   if (tmp == NULL)\n       return ENOMEM;\n   principal_mappings.val = tmp;\n\n   ret = krb5_parse_name(context, principal_name, &principal);\n   if (ret)\n       return ret;\n\n   principal_mappings.val[principal_mappings.len].principal = principal;\n\n   principal_mappings.val[principal_mappings.len].subject = strdup(subject);\n   if (principal_mappings.val[principal_mappings.len].subject == NULL) {\n       krb5_free_principal(context, principal);\n       return ENOMEM;\n   }\n   principal_mappings.len++;\n\n   return 0;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "ubject)"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "rincipal_name,",
            "principal)"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "rincipal_mappings.val,",
            "principal_mappings.len + 1) * sizeof(*tmp))"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nadd_principal_mapping(krb5_context context,\n\t\t      const char *principal_name,\n\t\t      const char * subject)\n{\n   struct pk_allowed_princ *tmp;\n   krb5_principal principal;\n   krb5_error_code ret;\n\n   tmp = realloc(principal_mappings.val,\n\t         (principal_mappings.len + 1) * sizeof(*tmp));\n   if (tmp == NULL)\n       return ENOMEM;\n   principal_mappings.val = tmp;\n\n   ret = krb5_parse_name(context, principal_name, &principal);\n   if (ret)\n       return ret;\n\n   principal_mappings.val[principal_mappings.len].principal = principal;\n\n   principal_mappings.val[principal_mappings.len].subject = strdup(subject);\n   if (principal_mappings.val[principal_mappings.len].subject == NULL) {\n       krb5_free_principal(context, principal);\n       return ENOMEM;\n   }\n   principal_mappings.len++;\n\n   return 0;\n}"
  },
  {
    "function_name": "kdc_pk_check_client(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1664-1796",
    "snippet": "rb5_error_code\n_kdc_pk_check_client(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HDB *clientdb,\n\t\t     hdb_entry_ex *client,\n\t\t     pk_client_params *cp,\n\t\t     char **subject_name)\n{\n    const HDB_Ext_PKINIT_acl *acl;\n    const HDB_Ext_PKINIT_cert *pc;\n    krb5_error_code ret;\n    hx509_name name;\n    size_t i;\n\n    if (cp->cert == NULL) {\n\n\t*subject_name = strdup(\"anonymous client client\");\n\tif (*subject_name == NULL)\n\t    return ENOMEM;\n\treturn 0;\n    }\n\n    ret = hx509_cert_get_base_subject(context->hx509ctx,\n\t\t\t\t      cp->cert,\n\t\t\t\t      &name);\n    if (ret)\n\treturn ret;\n\n    ret = hx509_name_to_string(name, subject_name);\n    hx509_name_free(&name);\n    if (ret)\n\treturn ret;\n\n    kdc_log(context, config, 0,\n\t    \"Trying to authorize PK-INIT subject DN %s\",\n\t    *subject_name);\n\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc) {\n\thx509_cert cert;\n\tsize_t j;\n\n\tfor (j = 0; j < pc->len; j++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[j].cert.data,\n\t\t\t\t\tpc->val[j].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    ret = hx509_cert_cmp(cert, cp->cert);\n\t    hx509_cert_free(cert);\n\t    if (ret == 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Found matching PK-INIT cert in hdb\");\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n\n    if (config->pkinit_princ_in_cert) {\n\tret = match_rfc_san(context, config,\n\t\t\t    context->hx509ctx,\n\t\t\t    cp->cert,\n\t\t\t    client->entry.principal);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT SAN in certificate\");\n\t    return 0;\n\t}\n\tret = match_ms_upn_san(context, config,\n\t\t\t       context->hx509ctx,\n\t\t\t       cp->cert,\n\t\t\t       clientdb,\n\t\t\t       client);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching MS UPN SAN in certificate\");\n\t    return 0;\n\t}\n    }\n\n    ret = hdb_entry_get_pkinit_acl(&client->entry, &acl);\n    if (ret == 0 && acl != NULL) {\n\t/*\n\t * Cheat here and compare the generated name with the string\n\t * and not the reverse.\n\t */\n\tfor (i = 0; i < acl->len; i++) {\n\t    if (strcmp(*subject_name, acl->val[0].subject) != 0)\n\t\tcontinue;\n\n\t    /* Don't support isser and anchor checking right now */\n\t    if (acl->val[0].issuer)\n\t\tcontinue;\n\t    if (acl->val[0].anchor)\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT database ACL\");\n\t    return 0;\n\t}\n    }\n\n    for (i = 0; i < principal_mappings.len; i++) {\n\tkrb5_boolean b;\n\n\tb = krb5_principal_compare(context,\n\t\t\t\t   client->entry.principal,\n\t\t\t\t   principal_mappings.val[i].principal);\n\tif (b == FALSE)\n\t    continue;\n\tif (strcmp(principal_mappings.val[i].subject, *subject_name) != 0)\n\t    continue;\n\tkdc_log(context, config, 5,\n\t\t\"Found matching PK-INIT FILE ACL\");\n\treturn 0;\n    }\n\n    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    krb5_set_error_message(context, ret,\n\t\t\t  \"PKINIT no matching principals for %s\",\n\t\t\t  *subject_name);\n\n    kdc_log(context, config, 5,\n\t    \"PKINIT no matching principals for %s\",\n\t    *subject_name);\n\n    free(*subject_name);\n    *subject_name = NULL;\n\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "subject_name)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "PKINIT no matching principals for %s\",",
            "subject_name)"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "PKINIT no matching principals for %s\",",
            "subject_name)"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rincipal_mappings.val[i].subject,",
            "subject_name)"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "lient->entry.principal,",
            "rincipal_mappings.val[i].principal)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "subject_name,",
            "cl->val[0].subject)"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry_get_pkinit_acl(",
          "args": [
            "client->entry,",
            "acl)"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_ms_upn_san(",
          "args": [
            "ontext,",
            "onfig,",
            "ontext->hx509ctx,",
            "p->cert,",
            "lientdb,",
            "lient)"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "atch_ms_upn_san(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1592-1662",
          "snippet": "tatic int\nmatch_ms_upn_san(krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t hx509_context hx509ctx,\n\t\t hx509_cert client_cert,\n\t\t HDB *clientdb,\n\t\t hdb_entry_ex *client)\n{\n    hx509_octet_string_list list;\n    krb5_principal principal = NULL;\n    int ret;\n    MS_UPN_SAN upn;\n    size_t size;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    if (list.len != 1) {\n\tkdc_log(context, config, 0,\n\t\t\"More then one PK-INIT MS UPN SAN\");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    ret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length, &upn, &size);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Decode of MS-UPN-SAN failed\");\n\tgoto out;\n    }\n    if (size != list.val[0].length) {\n\tfree_MS_UPN_SAN(&upn);\n\tkdc_log(context, config, 0, \"Trailing data in \");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"found MS UPN SAN: %s\", upn);\n\n    ret = krb5_parse_name(context, upn, &principal);\n    free_MS_UPN_SAN(&upn);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed to parse principal in MS UPN SAN\");\n\tgoto out;\n    }\n\n    if (clientdb->hdb_check_pkinit_ms_upn_match) {\n\tret = clientdb->hdb_check_pkinit_ms_upn_match(context, clientdb, client, principal);\n    } else {\n\n\t/*\n\t * This is very wrong, but will do for a fallback\n\t */\n\tstrupr(principal->realm);\n\n\tif (krb5_principal_compare(context, principal, client->entry.principal) == FALSE)\n\t    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n\nout:\n    if (principal)\n\tkrb5_free_principal(context, principal);\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic int\nmatch_ms_upn_san(krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t hx509_context hx509ctx,\n\t\t hx509_cert client_cert,\n\t\t HDB *clientdb,\n\t\t hdb_entry_ex *client)\n{\n    hx509_octet_string_list list;\n    krb5_principal principal = NULL;\n    int ret;\n    MS_UPN_SAN upn;\n    size_t size;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    if (list.len != 1) {\n\tkdc_log(context, config, 0,\n\t\t\"More then one PK-INIT MS UPN SAN\");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    ret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length, &upn, &size);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Decode of MS-UPN-SAN failed\");\n\tgoto out;\n    }\n    if (size != list.val[0].length) {\n\tfree_MS_UPN_SAN(&upn);\n\tkdc_log(context, config, 0, \"Trailing data in \");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"found MS UPN SAN: %s\", upn);\n\n    ret = krb5_parse_name(context, upn, &principal);\n    free_MS_UPN_SAN(&upn);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed to parse principal in MS UPN SAN\");\n\tgoto out;\n    }\n\n    if (clientdb->hdb_check_pkinit_ms_upn_match) {\n\tret = clientdb->hdb_check_pkinit_ms_upn_match(context, clientdb, client, principal);\n    } else {\n\n\t/*\n\t * This is very wrong, but will do for a fallback\n\t */\n\tstrupr(principal->realm);\n\n\tif (krb5_principal_compare(context, principal, client->entry.principal) == FALSE)\n\t    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n\nout:\n    if (principal)\n\tkrb5_free_principal(context, principal);\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atch_rfc_san(",
          "args": [
            "ontext,",
            "onfig,",
            "ontext->hx509ctx,",
            "p->cert,",
            "lient->entry.principal)"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "atch_rfc_san(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "1531-1590",
          "snippet": "tatic int\nmatch_rfc_san(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      hx509_context hx509ctx,\n\t      hx509_cert client_cert,\n\t      krb5_const_principal match)\n{\n    hx509_octet_string_list list;\n    int ret, found = 0;\n    size_t i;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    for (i = 0; !found && i < list.len; i++) {\n\tkrb5_principal_data principal;\n\tKRB5PrincipalName kn;\n\tsize_t size;\n\n\tret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t       list.val[i].length,\n\t\t\t\t       &kn, &size);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name in certificate failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    break;\n\t}\n\tif (size != list.val[i].length) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name have extra bits on the end\");\n\t    return KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\t}\n\n\tmemset(&principal, 0, sizeof (principal));\n\tprincipal.name = kn.principalName;\n\tprincipal.realm = kn.realm;\n\n\tif (krb5_principal_compare(context, &principal, match) == TRUE)\n\t    found = 1;\n\tfree_KRB5PrincipalName(&kn);\n    }\n\nout:\n    hx509_free_octet_string_list(&list);\n    if (ret)\n\treturn ret;\n\n    if (!found)\n\treturn KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\n    return 0;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic int\nmatch_rfc_san(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      hx509_context hx509ctx,\n\t      hx509_cert client_cert,\n\t      krb5_const_principal match)\n{\n    hx509_octet_string_list list;\n    int ret, found = 0;\n    size_t i;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    for (i = 0; !found && i < list.len; i++) {\n\tkrb5_principal_data principal;\n\tKRB5PrincipalName kn;\n\tsize_t size;\n\n\tret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t       list.val[i].length,\n\t\t\t\t       &kn, &size);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name in certificate failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    break;\n\t}\n\tif (size != list.val[i].length) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name have extra bits on the end\");\n\t    return KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\t}\n\n\tmemset(&principal, 0, sizeof (principal));\n\tprincipal.name = kn.principalName;\n\tprincipal.realm = kn.realm;\n\n\tif (krb5_principal_compare(context, &principal, match) == TRUE)\n\t    found = 1;\n\tfree_KRB5PrincipalName(&kn);\n    }\n\nout:\n    hx509_free_octet_string_list(&list);\n    if (ret)\n\treturn ret;\n\n    if (!found)\n\treturn KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "ert)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_cmp(",
          "args": [
            "ert,",
            "p->cert)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_init_data(",
          "args": [
            "ontext->hx509ctx,",
            "c->val[j].cert.data,",
            "c->val[j].cert.length,",
            "ULL)"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry_get_pkinit_cert(",
          "args": [
            "client->entry,",
            "pc)"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_name_free(",
          "args": [
            "name)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_name_to_string(",
          "args": [
            "ame,",
            "ubject_name)"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_get_base_subject(",
          "args": [
            "ontext->hx509ctx,",
            "p->cert,",
            "name)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "anonymous client client\")"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_check_client(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HDB *clientdb,\n\t\t     hdb_entry_ex *client,\n\t\t     pk_client_params *cp,\n\t\t     char **subject_name)\n{\n    const HDB_Ext_PKINIT_acl *acl;\n    const HDB_Ext_PKINIT_cert *pc;\n    krb5_error_code ret;\n    hx509_name name;\n    size_t i;\n\n    if (cp->cert == NULL) {\n\n\t*subject_name = strdup(\"anonymous client client\");\n\tif (*subject_name == NULL)\n\t    return ENOMEM;\n\treturn 0;\n    }\n\n    ret = hx509_cert_get_base_subject(context->hx509ctx,\n\t\t\t\t      cp->cert,\n\t\t\t\t      &name);\n    if (ret)\n\treturn ret;\n\n    ret = hx509_name_to_string(name, subject_name);\n    hx509_name_free(&name);\n    if (ret)\n\treturn ret;\n\n    kdc_log(context, config, 0,\n\t    \"Trying to authorize PK-INIT subject DN %s\",\n\t    *subject_name);\n\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc) {\n\thx509_cert cert;\n\tsize_t j;\n\n\tfor (j = 0; j < pc->len; j++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[j].cert.data,\n\t\t\t\t\tpc->val[j].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    ret = hx509_cert_cmp(cert, cp->cert);\n\t    hx509_cert_free(cert);\n\t    if (ret == 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Found matching PK-INIT cert in hdb\");\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n\n    if (config->pkinit_princ_in_cert) {\n\tret = match_rfc_san(context, config,\n\t\t\t    context->hx509ctx,\n\t\t\t    cp->cert,\n\t\t\t    client->entry.principal);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT SAN in certificate\");\n\t    return 0;\n\t}\n\tret = match_ms_upn_san(context, config,\n\t\t\t       context->hx509ctx,\n\t\t\t       cp->cert,\n\t\t\t       clientdb,\n\t\t\t       client);\n\tif (ret == 0) {\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching MS UPN SAN in certificate\");\n\t    return 0;\n\t}\n    }\n\n    ret = hdb_entry_get_pkinit_acl(&client->entry, &acl);\n    if (ret == 0 && acl != NULL) {\n\t/*\n\t * Cheat here and compare the generated name with the string\n\t * and not the reverse.\n\t */\n\tfor (i = 0; i < acl->len; i++) {\n\t    if (strcmp(*subject_name, acl->val[0].subject) != 0)\n\t\tcontinue;\n\n\t    /* Don't support isser and anchor checking right now */\n\t    if (acl->val[0].issuer)\n\t\tcontinue;\n\t    if (acl->val[0].anchor)\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Found matching PK-INIT database ACL\");\n\t    return 0;\n\t}\n    }\n\n    for (i = 0; i < principal_mappings.len; i++) {\n\tkrb5_boolean b;\n\n\tb = krb5_principal_compare(context,\n\t\t\t\t   client->entry.principal,\n\t\t\t\t   principal_mappings.val[i].principal);\n\tif (b == FALSE)\n\t    continue;\n\tif (strcmp(principal_mappings.val[i].subject, *subject_name) != 0)\n\t    continue;\n\tkdc_log(context, config, 5,\n\t\t\"Found matching PK-INIT FILE ACL\");\n\treturn 0;\n    }\n\n    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    krb5_set_error_message(context, ret,\n\t\t\t  \"PKINIT no matching principals for %s\",\n\t\t\t  *subject_name);\n\n    kdc_log(context, config, 5,\n\t    \"PKINIT no matching principals for %s\",\n\t    *subject_name);\n\n    free(*subject_name);\n    *subject_name = NULL;\n\n    return ret;\n}"
  },
  {
    "function_name": "atch_ms_upn_san(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1592-1662",
    "snippet": "tatic int\nmatch_ms_upn_san(krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t hx509_context hx509ctx,\n\t\t hx509_cert client_cert,\n\t\t HDB *clientdb,\n\t\t hdb_entry_ex *client)\n{\n    hx509_octet_string_list list;\n    krb5_principal principal = NULL;\n    int ret;\n    MS_UPN_SAN upn;\n    size_t size;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    if (list.len != 1) {\n\tkdc_log(context, config, 0,\n\t\t\"More then one PK-INIT MS UPN SAN\");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    ret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length, &upn, &size);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Decode of MS-UPN-SAN failed\");\n\tgoto out;\n    }\n    if (size != list.val[0].length) {\n\tfree_MS_UPN_SAN(&upn);\n\tkdc_log(context, config, 0, \"Trailing data in \");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"found MS UPN SAN: %s\", upn);\n\n    ret = krb5_parse_name(context, upn, &principal);\n    free_MS_UPN_SAN(&upn);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed to parse principal in MS UPN SAN\");\n\tgoto out;\n    }\n\n    if (clientdb->hdb_check_pkinit_ms_upn_match) {\n\tret = clientdb->hdb_check_pkinit_ms_upn_match(context, clientdb, client, principal);\n    } else {\n\n\t/*\n\t * This is very wrong, but will do for a fallback\n\t */\n\tstrupr(principal->realm);\n\n\tif (krb5_principal_compare(context, principal, client->entry.principal) == FALSE)\n\t    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n\nout:\n    if (principal)\n\tkrb5_free_principal(context, principal);\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x509_free_octet_string_list(",
          "args": [
            "list)"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "rincipal,",
            "lient->entry.principal)"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trupr(",
          "args": [
            "rincipal->realm)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lientdb->hdb_check_pkinit_ms_upn_match",
          "args": [
            "ontext,",
            "lientdb,",
            "lient,",
            "rincipal)"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed to parse principal in MS UPN SAN\")"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_MS_UPN_SAN(",
          "args": [
            "upn)"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "pn,",
            "principal)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_MS_UPN_SAN(",
          "args": [
            "upn)"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_MS_UPN_SAN(",
          "args": [
            "ist.val[0].data,",
            "ist.val[0].length,",
            "upn,",
            "size)"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_find_subjectAltName_otherName(",
          "args": [
            "x509ctx,",
            "lient_cert,",
            "asn1_oid_id_pkinit_ms_san,",
            "list)"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "list,",
            "izeof(list))"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic int\nmatch_ms_upn_san(krb5_context context,\n\t\t krb5_kdc_configuration *config,\n\t\t hx509_context hx509ctx,\n\t\t hx509_cert client_cert,\n\t\t HDB *clientdb,\n\t\t hdb_entry_ex *client)\n{\n    hx509_octet_string_list list;\n    krb5_principal principal = NULL;\n    int ret;\n    MS_UPN_SAN upn;\n    size_t size;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    if (list.len != 1) {\n\tkdc_log(context, config, 0,\n\t\t\"More then one PK-INIT MS UPN SAN\");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    ret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length, &upn, &size);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Decode of MS-UPN-SAN failed\");\n\tgoto out;\n    }\n    if (size != list.val[0].length) {\n\tfree_MS_UPN_SAN(&upn);\n\tkdc_log(context, config, 0, \"Trailing data in \");\n\tret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"found MS UPN SAN: %s\", upn);\n\n    ret = krb5_parse_name(context, upn, &principal);\n    free_MS_UPN_SAN(&upn);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed to parse principal in MS UPN SAN\");\n\tgoto out;\n    }\n\n    if (clientdb->hdb_check_pkinit_ms_upn_match) {\n\tret = clientdb->hdb_check_pkinit_ms_upn_match(context, clientdb, client, principal);\n    } else {\n\n\t/*\n\t * This is very wrong, but will do for a fallback\n\t */\n\tstrupr(principal->realm);\n\n\tif (krb5_principal_compare(context, principal, client->entry.principal) == FALSE)\n\t    ret = KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n\nout:\n    if (principal)\n\tkrb5_free_principal(context, principal);\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}"
  },
  {
    "function_name": "atch_rfc_san(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1531-1590",
    "snippet": "tatic int\nmatch_rfc_san(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      hx509_context hx509ctx,\n\t      hx509_cert client_cert,\n\t      krb5_const_principal match)\n{\n    hx509_octet_string_list list;\n    int ret, found = 0;\n    size_t i;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    for (i = 0; !found && i < list.len; i++) {\n\tkrb5_principal_data principal;\n\tKRB5PrincipalName kn;\n\tsize_t size;\n\n\tret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t       list.val[i].length,\n\t\t\t\t       &kn, &size);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name in certificate failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    break;\n\t}\n\tif (size != list.val[i].length) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name have extra bits on the end\");\n\t    return KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\t}\n\n\tmemset(&principal, 0, sizeof (principal));\n\tprincipal.name = kn.principalName;\n\tprincipal.realm = kn.realm;\n\n\tif (krb5_principal_compare(context, &principal, match) == TRUE)\n\t    found = 1;\n\tfree_KRB5PrincipalName(&kn);\n    }\n\nout:\n    hx509_free_octet_string_list(&list);\n    if (ret)\n\treturn ret;\n\n    if (!found)\n\treturn KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\n    return 0;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x509_free_octet_string_list(",
          "args": [
            "list)"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KRB5PrincipalName(",
          "args": [
            "kn)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "principal,",
            "atch)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "principal,",
            ",",
            "izeof (principal))"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Decoding kerberos name have extra bits on the end\")"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_KRB5PrincipalName(",
          "args": [
            "ist.val[i].data,",
            "ist.val[i].length,",
            "kn,",
            "size)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_find_subjectAltName_otherName(",
          "args": [
            "x509ctx,",
            "lient_cert,",
            "asn1_oid_id_pkinit_san,",
            "list)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "list,",
            "izeof(list))"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic int\nmatch_rfc_san(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      hx509_context hx509ctx,\n\t      hx509_cert client_cert,\n\t      krb5_const_principal match)\n{\n    hx509_octet_string_list list;\n    int ret, found = 0;\n    size_t i;\n\n    memset(&list, 0 , sizeof(list));\n\n    ret = hx509_cert_find_subjectAltName_otherName(hx509ctx,\n\t\t\t\t\t\t   client_cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\tgoto out;\n\n    for (i = 0; !found && i < list.len; i++) {\n\tkrb5_principal_data principal;\n\tKRB5PrincipalName kn;\n\tsize_t size;\n\n\tret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t       list.val[i].length,\n\t\t\t\t       &kn, &size);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name in certificate failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    break;\n\t}\n\tif (size != list.val[i].length) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Decoding kerberos name have extra bits on the end\");\n\t    return KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\t}\n\n\tmemset(&principal, 0, sizeof (principal));\n\tprincipal.name = kn.principalName;\n\tprincipal.realm = kn.realm;\n\n\tif (krb5_principal_compare(context, &principal, match) == TRUE)\n\t    found = 1;\n\tfree_KRB5PrincipalName(&kn);\n    }\n\nout:\n    hx509_free_octet_string_list(&list);\n    if (ret)\n\treturn ret;\n\n    if (!found)\n\treturn KRB5_KDC_ERR_CLIENT_NAME_MISMATCH;\n\n    return 0;\n}"
  },
  {
    "function_name": "kdc_pk_mk_pa_reply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "1125-1529",
    "snippet": "rb5_error_code\n_kdc_pk_mk_pa_reply(krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    pk_client_params *cp,\n\t\t    const hdb_entry_ex *client,\n\t\t    krb5_enctype sessionetype,\n\t\t    const KDC_REQ *req,\n\t\t    const krb5_data *req_buffer,\n\t\t    krb5_keyblock *reply_key,\n\t\t    krb5_keyblock *sessionkey,\n\t\t    METHOD_DATA *md)\n{\n    krb5_error_code ret;\n    void *buf = NULL;\n    size_t len = 0, size = 0;\n    krb5_enctype enctype;\n    int pa_type;\n    hx509_cert kdc_cert = NULL;\n    size_t i;\n\n    if (!config->enable_pkinit) {\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    if (req->req_body.etype.len > 0) {\n\tfor (i = 0; i < req->req_body.etype.len; i++)\n\t    if (krb5_enctype_valid(context, req->req_body.etype.val[i]) == 0)\n\t\tbreak;\n\tif (req->req_body.etype.len <= i) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"No valid enctype available from client\");\n\t    goto out;\n\t}\n\tenctype = req->req_body.etype.val[i];\n    } else\n\tenctype = ETYPE_DES3_CBC_SHA1;\n\n    if (cp->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\tconst char *type, *other = \"\";\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP;\n\n\tif (cp->keyex == USE_RSA) {\n\t    ContentInfo info;\n\n\t    type = \"enckey\";\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\n\t    ret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t\t&cp->reply_key);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t\tconfig,\n\t\t\t\t\tcp,\n\t\t\t\t\treq,\n\t\t\t\t\treq_buffer,\n\t\t\t\t\t&cp->reply_key,\n\t\t\t\t\t&info,\n\t\t\t\t\t&kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t       rep.u.encKeyPack.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    ret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\tsessionkey);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\n\t} else {\n\t    ContentInfo info;\n\n\t    switch (cp->keyex) {\n\t    case USE_DH: type = \"dh\"; break;\n\t    case USE_ECDH: type = \"ecdh\"; break;\n\t    default: krb5_abortx(context, \"unknown keyex\"); break;\n\t    }\n\n\t    if (cp->dh_group_name)\n\t\tother = cp->dh_group_name;\n\n\t    rep.element = choice_PA_PK_AS_REP_dhInfo;\n\n\t    ret = generate_dh_keyblock(context, cp, enctype);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ret = pk_mk_pa_reply_dh(context, config,\n\t\t\t\t    cp,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"create pa-reply-dh \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tgoto out;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.dhInfo.dhSignedData.data,\n\t\t\t       rep.u.dhInfo.dhSignedData.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    /* generate the session key using the method from RFC6112 */\n\t    {\n\t\tkrb5_keyblock kdc_contribution_key;\n\t\tkrb5_crypto reply_crypto;\n\t\tkrb5_crypto kdccont_crypto;\n\t\tkrb5_data p1 = { strlen(\"PKINIT\"), \"PKINIT\"};\n\t\tkrb5_data p2 = { strlen(\"KEYEXCHANGE\"), \"KEYEXCHANGE\"};\n\t\tvoid *kckdata;\n\t\tsize_t kcklen;\n\t\tEncryptedData kx;\n\t\tvoid *kxdata;\n\t\tsize_t kxlen;\n\n\t\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\t&kdc_contribution_key);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &cp->reply_key, enctype, &reply_crypto);\n\t\tif (ret) {\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &kdc_contribution_key, sessionetype, &kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\t/* KRB-FX-CF2 */\n\t\tret = krb5_crypto_fx_cf2(context, kdccont_crypto, reply_crypto,\n\t\t\t\t\t &p1, &p2, sessionetype, sessionkey);\n\t\tkrb5_crypto_destroy(context, kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptionKey, kckdata, kcklen,\n\t\t\t\t   &kdc_contribution_key, &size, ret);\n\t\tkrb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX Key failed %d\", ret);\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kcklen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\tret = krb5_encrypt_EncryptedData(context, reply_crypto, KRB5_KU_PA_PKINIT_KX,\n\t\t\t\t\tkckdata, kcklen, 0, &kx);\n\t\tkrb5_crypto_destroy(context, reply_crypto);\n\t\tfree(kckdata);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptedData, kxdata, kxlen,\n\t\t\t\t   &kx, &size, ret);\n\t\tfree_EncryptedData(&kx);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX failed %d\", ret);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kxlen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\t/* Add PA-PKINIT-KX */\n\t\tret = krb5_padata_add(context, md, KRB5_PADATA_PKINIT_KX, kxdata, kxlen);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed adding PKINIT-KX %d\", ret);\n\t\t    free(buf);\n\t\t    goto out;\n\t\t}\n\t    }\n\t}\n\n#define use_btmm_with_enckey 0\n\tif (use_btmm_with_enckey && rep.element == choice_PA_PK_AS_REP_encKeyPack) {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    heim_any any;\n\n\t    any.data = rep.u.encKeyPack.data;\n\t    any.length = rep.u.encKeyPack.length;\n\n\t    btmm.dhSignedData = NULL;\n\t    btmm.encKeyPack = &any;\n\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP_BTMM, buf, len, &btmm, &size, ret);\n\t} else {\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP, buf, len, &rep, &size, ret);\n\t}\n\n\tfree_PA_PK_AS_REP(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"encode PA-PK-AS-REP failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tkdc_log(context, config, 0, \"PK-INIT using %s %s\", type, other);\n\n    } else if (cp->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k rep;\n\tContentInfo info;\n\n\tif (cp->keyex != USE_RSA) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Windows PK-INIT doesn't support DH\");\n\t    goto out;\n\t}\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP_19;\n\trep.element = choice_PA_PK_AS_REP_Win2k_encKeyPack;\n\n\tret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t    &cp->reply_key);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t    config,\n\t\t\t\t    cp,\n\t\t\t\t    req,\n\t\t\t\t    req_buffer,\n\t\t\t\t    &cp->reply_key,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t   rep.u.encKeyPack.length, &info, &size,\n\t\t\t   ret);\n\tfree_ContentInfo(&info);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t  \"failed %d\", ret);\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tif (rep.u.encKeyPack.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REP_Win2k, buf, len, &rep, &size, ret);\n\tfree_PA_PK_AS_REP_Win2k(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t  \"encode PA-PK-AS-REP-Win2k failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t    sessionkey);\n\tif (ret) {\n\t    free(buf);\n\t    goto out;\n\t}\n\n    } else\n\tkrb5_abortx(context, \"PK-INIT internal error\");\n\n\n    ret = krb5_padata_add(context, md, pa_type, buf, len);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Failed adding PA-PK-AS-REP %d\", ret);\n\tfree(buf);\n\tgoto out;\n    }\n\n    if (config->pkinit_kdc_ocsp_file) {\n\n\tif (ocsp.expire == 0 && ocsp.next_update > kdc_time) {\n\t    struct stat sb;\n\t    int fd;\n\n\t    krb5_data_free(&ocsp.data);\n\n\t    ocsp.expire = 0;\n\t    ocsp.next_update = kdc_time + 60 * 5;\n\n\t    fd = open(config->pkinit_kdc_ocsp_file, O_RDONLY);\n\t    if (fd < 0) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to open ocsp data file %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\t    ret = fstat(fd, &sb);\n\t    if (ret) {\n\t\tret = errno;\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = krb5_data_alloc(&ocsp.data, sb.st_size);\n\t    if (ret) {\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\t    ocsp.data.length = sb.st_size;\n\t    ret = read(fd, ocsp.data.data, sb.st_size);\n\t    close(fd);\n\t    if (ret != sb.st_size) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to read ocsp data %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = hx509_ocsp_verify(context->hx509ctx,\n\t\t\t\t    kdc_time,\n\t\t\t\t    kdc_cert,\n\t\t\t\t    0,\n\t\t\t\t    ocsp.data.data, ocsp.data.length,\n\t\t\t\t    &ocsp.expire);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to verify ocsp data %d\", ret);\n\t\tkrb5_data_free(&ocsp.data);\n\t\tocsp.expire = 0;\n\t    } else if (ocsp.expire > 180) {\n\t\tocsp.expire -= 180; /* refetch the ocsp before it expire */\n\t\tocsp.next_update = ocsp.expire;\n\t    } else {\n\t\tocsp.next_update = kdc_time;\n\t    }\n\tout_ocsp:\n\t    ret = 0;\n\t}\n\n\tif (ocsp.expire != 0 && ocsp.expire > kdc_time) {\n\n\t    ret = krb5_padata_add(context, md,\n\t\t\t\t  KRB5_PADATA_PA_PK_OCSP_RESPONSE,\n\t\t\t\t  ocsp.data.data, ocsp.data.length);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed adding OCSP response %d\", ret);\n\t\tgoto out;\n\t    }\n\t}\n    }\n\nout:\n    if (kdc_cert)\n\thx509_cert_free(kdc_cert);\n\n    if (ret == 0)\n\tret = krb5_copy_keyblock_contents(context, &cp->reply_key, reply_key);\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_copy_keyblock_contents(",
          "args": [
            "ontext,",
            "cp->reply_key,",
            "eply_key)"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "dc_cert)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed adding OCSP response %d\",",
            "et)"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "d,",
            "RB5_PADATA_PA_PK_OCSP_RESPONSE,",
            "csp.data.data,",
            "csp.data.length)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "ocsp.data)"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "PK-INIT failed to verify ocsp data %d\",",
            "et)"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x509_ocsp_verify(",
          "args": [
            "ontext->hx509ctx,",
            "dc_time,",
            "dc_cert,",
            ",",
            "csp.data.data,",
            "csp.data.length,",
            "ocsp.expire)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(",
          "args": [
            "d,",
            "csp.data.data,",
            "b.st_size)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_alloc(",
          "args": [
            "ocsp.data,",
            "b.st_size)"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat(",
          "args": [
            "d,",
            "sb)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen(",
          "args": [
            "onfig->pkinit_kdc_ocsp_file,",
            "_RDONLY)"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "ocsp.data)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed adding PA-PK-AS-REP %d\",",
            "et)"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "d,",
            "a_type,",
            "uf,",
            "en)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "PK-INIT internal error\")"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "essionetype,",
            "essionkey)"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encode PA-PK-AS-REP-Win2k failed %d\",",
            "et)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP_Win2k(",
          "args": [
            "rep)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_PK_AS_REP_Win2k,",
            "uf,",
            "en,",
            "rep,",
            "size,",
            "et)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP_Win2k(",
          "args": [
            "rep)"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encoding of Key ContentInfo \"\n\t\t\t\t  \"failed %d\",",
            "et)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ContentInfo(",
          "args": [
            "info)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ontentInfo,",
            "ep.u.encKeyPack.data,",
            "ep.u.encKeyPack.length,",
            "info,",
            "size,",
            "et)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP_Win2k(",
          "args": [
            "rep)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_mk_pa_reply_enckey(",
          "args": [
            "ontext,",
            "onfig,",
            "p,",
            "eq,",
            "eq_buffer,",
            "cp->reply_key,",
            "info,",
            "kdc_cert)"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "k_mk_pa_reply_enckey(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "817-991",
          "snippet": "tatic krb5_error_code\npk_mk_pa_reply_enckey(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      pk_client_params *cp,\n\t\t      const KDC_REQ *req,\n\t\t      const krb5_data *req_buffer,\n\t\t      krb5_keyblock *reply_key,\n\t\t      ContentInfo *content_info,\n\t\t      hx509_cert *kdc_cert)\n{\n    const heim_oid *envelopedAlg = NULL, *sdAlg = NULL, *evAlg = NULL;\n    krb5_error_code ret;\n    krb5_data buf, signed_data;\n    size_t size = 0;\n    int do_win2k = 0;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&signed_data);\n\n    *kdc_cert = NULL;\n\n    /*\n     * If the message client is a win2k-type but it send pa data\n     * 09-binding it expects a IETF (checksum) reply so there can be\n     * no replay attacks.\n     */\n\n    switch (cp->type) {\n    case PKINIT_WIN2K: {\n\tint i = 0;\n\tif (_kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_09_BINDING) == NULL\n\t    && config->pkinit_require_binding == 0)\n\t{\n\t    do_win2k = 1;\n\t}\n\tsdAlg = &asn1_oid_id_pkcs7_data;\n\tevAlg = &asn1_oid_id_pkcs7_data;\n\tenvelopedAlg = &asn1_oid_id_rsadsi_des_ede3_cbc;\n\tbreak;\n    }\n    case PKINIT_27:\n\tsdAlg = &asn1_oid_id_pkrkeydata;\n\tevAlg = &asn1_oid_id_pkcs7_signedData;\n\tbreak;\n    default:\n\tkrb5_abortx(context, \"internal pkinit error\");\n    }\n\n    if (do_win2k) {\n\tReplyKeyPack_Win2k kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tkp.nonce = cp->nonce;\n\n\tASN1_MALLOC_ENCODE(ReplyKeyPack_Win2k,\n\t\t\t   buf.data, buf.length,\n\t\t\t   &kp, &size,ret);\n\tfree_ReplyKeyPack_Win2k(&kp);\n    } else {\n\tkrb5_crypto ascrypto;\n\tReplyKeyPack kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, reply_key, 0, &ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_create_checksum(context, ascrypto, 6, 0,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &kp.asChecksum);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_destroy(context, ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ReplyKeyPack, buf.data, buf.length, &kp, &size,ret);\n\tfree_ReplyKeyPack(&kp);\n    }\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of ReplyKeyPack \"\n\t\t\t       \"failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret)\n\t    goto out;\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t\t0,\n\t\t\t\t\tsdAlg,\n\t\t\t\t\tbuf.data,\n\t\t\t\t\tbuf.length,\n\t\t\t\t\tNULL,\n\t\t\t\t\tcert,\n\t\t\t\t\tcp->peer,\n\t\t\t\t\tcp->client_anchors,\n\t\t\t\t\tkdc_identity->certpool,\n\t\t\t\t\t&signed_data);\n\t*kdc_cert = cert;\n    }\n\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    if (cp->type == PKINIT_WIN2K) {\n\tret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData,\n\t\t\t\t\t &signed_data,\n\t\t\t\t\t &buf);\n\tif (ret)\n\t    goto out;\n\tkrb5_data_free(&signed_data);\n\tsigned_data = buf;\n    }\n\n    ret = hx509_cms_envelope_1(context->hx509ctx,\n\t\t\t       HX509_CMS_EV_NO_KU_CHECK,\n\t\t\t       cp->cert,\n\t\t\t       signed_data.data, signed_data.length,\n\t\t\t       envelopedAlg,\n\t\t\t       evAlg, &buf);\n    if (ret)\n\tgoto out;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &buf,\n\t\t\t\t  &asn1_oid_id_pkcs7_envelopedData,\n\t\t\t\t  content_info);\nout:\n    if (ret && *kdc_cert) {\n        hx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_mk_pa_reply_enckey(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      pk_client_params *cp,\n\t\t      const KDC_REQ *req,\n\t\t      const krb5_data *req_buffer,\n\t\t      krb5_keyblock *reply_key,\n\t\t      ContentInfo *content_info,\n\t\t      hx509_cert *kdc_cert)\n{\n    const heim_oid *envelopedAlg = NULL, *sdAlg = NULL, *evAlg = NULL;\n    krb5_error_code ret;\n    krb5_data buf, signed_data;\n    size_t size = 0;\n    int do_win2k = 0;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&signed_data);\n\n    *kdc_cert = NULL;\n\n    /*\n     * If the message client is a win2k-type but it send pa data\n     * 09-binding it expects a IETF (checksum) reply so there can be\n     * no replay attacks.\n     */\n\n    switch (cp->type) {\n    case PKINIT_WIN2K: {\n\tint i = 0;\n\tif (_kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_09_BINDING) == NULL\n\t    && config->pkinit_require_binding == 0)\n\t{\n\t    do_win2k = 1;\n\t}\n\tsdAlg = &asn1_oid_id_pkcs7_data;\n\tevAlg = &asn1_oid_id_pkcs7_data;\n\tenvelopedAlg = &asn1_oid_id_rsadsi_des_ede3_cbc;\n\tbreak;\n    }\n    case PKINIT_27:\n\tsdAlg = &asn1_oid_id_pkrkeydata;\n\tevAlg = &asn1_oid_id_pkcs7_signedData;\n\tbreak;\n    default:\n\tkrb5_abortx(context, \"internal pkinit error\");\n    }\n\n    if (do_win2k) {\n\tReplyKeyPack_Win2k kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tkp.nonce = cp->nonce;\n\n\tASN1_MALLOC_ENCODE(ReplyKeyPack_Win2k,\n\t\t\t   buf.data, buf.length,\n\t\t\t   &kp, &size,ret);\n\tfree_ReplyKeyPack_Win2k(&kp);\n    } else {\n\tkrb5_crypto ascrypto;\n\tReplyKeyPack kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, reply_key, 0, &ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_create_checksum(context, ascrypto, 6, 0,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &kp.asChecksum);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_destroy(context, ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ReplyKeyPack, buf.data, buf.length, &kp, &size,ret);\n\tfree_ReplyKeyPack(&kp);\n    }\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of ReplyKeyPack \"\n\t\t\t       \"failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret)\n\t    goto out;\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t\t0,\n\t\t\t\t\tsdAlg,\n\t\t\t\t\tbuf.data,\n\t\t\t\t\tbuf.length,\n\t\t\t\t\tNULL,\n\t\t\t\t\tcert,\n\t\t\t\t\tcp->peer,\n\t\t\t\t\tcp->client_anchors,\n\t\t\t\t\tkdc_identity->certpool,\n\t\t\t\t\t&signed_data);\n\t*kdc_cert = cert;\n    }\n\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    if (cp->type == PKINIT_WIN2K) {\n\tret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData,\n\t\t\t\t\t &signed_data,\n\t\t\t\t\t &buf);\n\tif (ret)\n\t    goto out;\n\tkrb5_data_free(&signed_data);\n\tsigned_data = buf;\n    }\n\n    ret = hx509_cms_envelope_1(context->hx509ctx,\n\t\t\t       HX509_CMS_EV_NO_KU_CHECK,\n\t\t\t       cp->cert,\n\t\t\t       signed_data.data, signed_data.length,\n\t\t\t       envelopedAlg,\n\t\t\t       evAlg, &buf);\n    if (ret)\n\tgoto out;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &buf,\n\t\t\t\t  &asn1_oid_id_pkcs7_envelopedData,\n\t\t\t\t  content_info);\nout:\n    if (ret && *kdc_cert) {\n        hx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP_Win2k(",
          "args": [
            "rep)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "nctype,",
            "cp->reply_key)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rep,",
            ",",
            "izeof(rep))"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Windows PK-INIT doesn't support DH\")"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encode PA-PK-AS-REP failed %d\",",
            "et)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_PK_AS_REP,",
            "uf,",
            "en,",
            "rep,",
            "size,",
            "et)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_PK_AS_REP_BTMM,",
            "uf,",
            "en,",
            "btmm,",
            "size,",
            "et)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed adding PKINIT-KX %d\",",
            "et)"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "d,",
            "RB5_PADATA_PKINIT_KX,",
            "xdata,",
            "xlen)"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encoding of PKINIT-KX failed %d\",",
            "et)"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "kx)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncryptedData,",
            "xdata,",
            "xlen,",
            "kx,",
            "size,",
            "et)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ckdata)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "eply_crypto)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "eply_crypto,",
            "RB5_KU_PA_PKINIT_KX,",
            "ckdata,",
            "cklen,",
            ",",
            "kx)"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "eply_crypto)"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encoding of PKINIT-KX Key failed %d\",",
            "et)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "kdc_contribution_key)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncryptionKey,",
            "ckdata,",
            "cklen,",
            "kdc_contribution_key,",
            "size,",
            "et)"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "kdc_contribution_key)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "eply_crypto)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "dccont_crypto)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_fx_cf2(",
          "args": [
            "ontext,",
            "dccont_crypto,",
            "eply_crypto,",
            "p1,",
            "p2,",
            "essionetype,",
            "essionkey)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "kdc_contribution_key)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "eply_crypto)"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "kdc_contribution_key,",
            "essionetype,",
            "kdccont_crypto)"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "kdc_contribution_key)"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "cp->reply_key,",
            "nctype,",
            "reply_crypto)"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "essionetype,",
            "kdc_contribution_key)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "KEYEXCHANGE\")"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "PKINIT\")"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\",",
            "et)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ContentInfo(",
          "args": [
            "info)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ontentInfo,",
            "ep.u.dhInfo.dhSignedData.data,",
            "ep.u.dhInfo.dhSignedData.length,",
            "info,",
            "size,",
            "et)"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "create pa-reply-dh \"\n\t\t\t\t       \"failed %d\",",
            "et)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_mk_pa_reply_dh(",
          "args": [
            "ontext,",
            "onfig,",
            "p,",
            "info,",
            "kdc_cert)"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "k_mk_pa_reply_dh(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "997-1119",
          "snippet": "tatic krb5_error_code\npk_mk_pa_reply_dh(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n      \t\t  pk_client_params *cp,\n\t\t  ContentInfo *content_info,\n\t\t  hx509_cert *kdc_cert)\n{\n    KDCDHKeyInfo dh_info;\n    krb5_data signed_data, buf;\n    ContentInfo contentinfo;\n    krb5_error_code ret;\n    hx509_cert cert;\n    hx509_query *q;\n    size_t size = 0;\n\n    memset(&contentinfo, 0, sizeof(contentinfo));\n    memset(&dh_info, 0, sizeof(dh_info));\n    krb5_data_zero(&signed_data);\n    krb5_data_zero(&buf);\n\n    *kdc_cert = NULL;\n\n    if (cp->keyex == USE_DH) {\n\tDH *kdc_dh = cp->u.dh.key;\n\theim_integer i;\n\n\tret = BN_to_integer(context, kdc_dh->pub_key, &i);\n\tif (ret)\n\t    return ret;\n\n\tASN1_MALLOC_ENCODE(DHPublicKey, buf.data, buf.length, &i, &size, ret);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t\t   \"DHPublicKey failed (%d)\", ret);\n\t    return ret;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tdh_info.subjectPublicKey.length = buf.length * 8;\n\tdh_info.subjectPublicKey.data = buf.data;\n\tkrb5_data_zero(&buf);\n    } else if (cp->keyex == USE_ECDH) {\n        unsigned char *p;\n        ret = _kdc_serialize_ecdh_key(context, cp->u.ecdh.key, &p,\n                                      &dh_info.subjectPublicKey.length);\n        dh_info.subjectPublicKey.data = p;\n        if (ret)\n            goto out;\n    } else\n\tkrb5_abortx(context, \"no keyex selected ?\");\n\n\n    dh_info.nonce = cp->nonce;\n\n    ASN1_MALLOC_ENCODE(KDCDHKeyInfo, buf.data, buf.length, &dh_info, &size,\n\t\t       ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t       \"KdcDHKeyInfo failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    /*\n     * Create the SignedData structure and sign the KdcDHKeyInfo\n     * filled in above\n     */\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret)\n\tgoto out;\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    if (config->pkinit_kdc_friendly_name)\n\thx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n    ret = hx509_certs_find(context->hx509ctx,\n\t\t\t   kdc_identity->certs,\n\t\t\t   q,\n\t\t\t   &cert);\n    hx509_query_free(context->hx509ctx, q);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    0,\n\t\t\t\t    &asn1_oid_id_pkdhkeydata,\n\t\t\t\t    buf.data,\n\t\t\t\t    buf.length,\n\t\t\t\t    NULL,\n\t\t\t\t    cert,\n\t\t\t\t    cp->peer,\n\t\t\t\t    cp->client_anchors,\n\t\t\t\t    kdc_identity->certpool,\n\t\t\t\t    &signed_data);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed signing the DH* reply: %d\", ret);\n\tgoto out;\n    }\n    *kdc_cert = cert;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &signed_data,\n\t\t\t\t  &asn1_oid_id_pkcs7_signedData,\n\t\t\t\t  content_info);\n    if (ret)\n\tgoto out;\n\n out:\n    if (ret && *kdc_cert) {\n\thx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    free_KDCDHKeyInfo(&dh_info);\n\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_mk_pa_reply_dh(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n      \t\t  pk_client_params *cp,\n\t\t  ContentInfo *content_info,\n\t\t  hx509_cert *kdc_cert)\n{\n    KDCDHKeyInfo dh_info;\n    krb5_data signed_data, buf;\n    ContentInfo contentinfo;\n    krb5_error_code ret;\n    hx509_cert cert;\n    hx509_query *q;\n    size_t size = 0;\n\n    memset(&contentinfo, 0, sizeof(contentinfo));\n    memset(&dh_info, 0, sizeof(dh_info));\n    krb5_data_zero(&signed_data);\n    krb5_data_zero(&buf);\n\n    *kdc_cert = NULL;\n\n    if (cp->keyex == USE_DH) {\n\tDH *kdc_dh = cp->u.dh.key;\n\theim_integer i;\n\n\tret = BN_to_integer(context, kdc_dh->pub_key, &i);\n\tif (ret)\n\t    return ret;\n\n\tASN1_MALLOC_ENCODE(DHPublicKey, buf.data, buf.length, &i, &size, ret);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t\t   \"DHPublicKey failed (%d)\", ret);\n\t    return ret;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tdh_info.subjectPublicKey.length = buf.length * 8;\n\tdh_info.subjectPublicKey.data = buf.data;\n\tkrb5_data_zero(&buf);\n    } else if (cp->keyex == USE_ECDH) {\n        unsigned char *p;\n        ret = _kdc_serialize_ecdh_key(context, cp->u.ecdh.key, &p,\n                                      &dh_info.subjectPublicKey.length);\n        dh_info.subjectPublicKey.data = p;\n        if (ret)\n            goto out;\n    } else\n\tkrb5_abortx(context, \"no keyex selected ?\");\n\n\n    dh_info.nonce = cp->nonce;\n\n    ASN1_MALLOC_ENCODE(KDCDHKeyInfo, buf.data, buf.length, &dh_info, &size,\n\t\t       ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t       \"KdcDHKeyInfo failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    /*\n     * Create the SignedData structure and sign the KdcDHKeyInfo\n     * filled in above\n     */\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret)\n\tgoto out;\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    if (config->pkinit_kdc_friendly_name)\n\thx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n    ret = hx509_certs_find(context->hx509ctx,\n\t\t\t   kdc_identity->certs,\n\t\t\t   q,\n\t\t\t   &cert);\n    hx509_query_free(context->hx509ctx, q);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    0,\n\t\t\t\t    &asn1_oid_id_pkdhkeydata,\n\t\t\t\t    buf.data,\n\t\t\t\t    buf.length,\n\t\t\t\t    NULL,\n\t\t\t\t    cert,\n\t\t\t\t    cp->peer,\n\t\t\t\t    cp->client_anchors,\n\t\t\t\t    kdc_identity->certpool,\n\t\t\t\t    &signed_data);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed signing the DH* reply: %d\", ret);\n\tgoto out;\n    }\n    *kdc_cert = cert;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &signed_data,\n\t\t\t\t  &asn1_oid_id_pkcs7_signedData,\n\t\t\t\t  content_info);\n    if (ret)\n\tgoto out;\n\n out:\n    if (ret && *kdc_cert) {\n\thx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    free_KDCDHKeyInfo(&dh_info);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enerate_dh_keyblock(",
          "args": [
            "ontext,",
            "p,",
            "nctype)"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "enerate_dh_keyblock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "196-278",
          "snippet": "tatic krb5_error_code\ngenerate_dh_keyblock(krb5_context context,\n\t\t     pk_client_params *client_params,\n                     krb5_enctype enctype)\n{\n    unsigned char *dh_gen_key = NULL;\n    krb5_keyblock key;\n    krb5_error_code ret;\n    size_t dh_gen_keylen, size;\n\n    memset(&key, 0, sizeof(key));\n\n    if (client_params->keyex == USE_DH) {\n\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing DH public_key\");\n\t    goto out;\n\t}\n\n\tif (!DH_generate_key(client_params->u.dh.key)) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't generate Diffie-Hellman keys\");\n\t    goto out;\n\t}\n\n\tsize = DH_size(client_params->u.dh.key);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key,client_params->u.dh.public_key, client_params->u.dh.key);\n\tif (dh_gen_keylen == (size_t)-1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't compute Diffie-Hellman key\");\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n\tret = 0;\n    } else if (client_params->keyex == USE_ECDH) {\n\tif (client_params->u.ecdh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing ECDH public_key\");\n\t    goto out;\n\t}\n        ret = _kdc_generate_ecdh_keyblock(context,\n                                          client_params->u.ecdh.public_key,\n                                          &client_params->u.ecdh.key,\n                                          &dh_gen_key, &dh_gen_keylen);\n        if (ret)\n            goto out;\n    } else {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Diffie-Hellman not selected keys\");\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   enctype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   &client_params->reply_key);\n\n out:\n    if (dh_gen_key)\n\tfree(dh_gen_key);\n    if (key.keyvalue.data)\n\tkrb5_free_keyblock_contents(context, &key);\n\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\ngenerate_dh_keyblock(krb5_context context,\n\t\t     pk_client_params *client_params,\n                     krb5_enctype enctype)\n{\n    unsigned char *dh_gen_key = NULL;\n    krb5_keyblock key;\n    krb5_error_code ret;\n    size_t dh_gen_keylen, size;\n\n    memset(&key, 0, sizeof(key));\n\n    if (client_params->keyex == USE_DH) {\n\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing DH public_key\");\n\t    goto out;\n\t}\n\n\tif (!DH_generate_key(client_params->u.dh.key)) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't generate Diffie-Hellman keys\");\n\t    goto out;\n\t}\n\n\tsize = DH_size(client_params->u.dh.key);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key,client_params->u.dh.public_key, client_params->u.dh.key);\n\tif (dh_gen_keylen == (size_t)-1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't compute Diffie-Hellman key\");\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n\tret = 0;\n    } else if (client_params->keyex == USE_ECDH) {\n\tif (client_params->u.ecdh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing ECDH public_key\");\n\t    goto out;\n\t}\n        ret = _kdc_generate_ecdh_keyblock(context,\n                                          client_params->u.ecdh.public_key,\n                                          &client_params->u.ecdh.key,\n                                          &dh_gen_key, &dh_gen_keylen);\n        if (ret)\n            goto out;\n    } else {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Diffie-Hellman not selected keys\");\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   enctype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   &client_params->reply_key);\n\n out:\n    if (dh_gen_key)\n\tfree(dh_gen_key);\n    if (key.keyvalue.data)\n\tkrb5_free_keyblock_contents(context, &key);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "unknown keyex\")"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "essionetype,",
            "essionkey)"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\",",
            "et)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ContentInfo(",
          "args": [
            "info)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ontentInfo,",
            "ep.u.encKeyPack.data,",
            "ep.u.encKeyPack.length,",
            "info,",
            "size,",
            "et)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REP(",
          "args": [
            "rep)"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "nctype,",
            "cp->reply_key)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rep,",
            ",",
            "izeof(rep))"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "No valid enctype available from client\")"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "eq->req_body.etype.val[i])"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_mk_pa_reply(krb5_context context,\n\t\t    krb5_kdc_configuration *config,\n\t\t    pk_client_params *cp,\n\t\t    const hdb_entry_ex *client,\n\t\t    krb5_enctype sessionetype,\n\t\t    const KDC_REQ *req,\n\t\t    const krb5_data *req_buffer,\n\t\t    krb5_keyblock *reply_key,\n\t\t    krb5_keyblock *sessionkey,\n\t\t    METHOD_DATA *md)\n{\n    krb5_error_code ret;\n    void *buf = NULL;\n    size_t len = 0, size = 0;\n    krb5_enctype enctype;\n    int pa_type;\n    hx509_cert kdc_cert = NULL;\n    size_t i;\n\n    if (!config->enable_pkinit) {\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    if (req->req_body.etype.len > 0) {\n\tfor (i = 0; i < req->req_body.etype.len; i++)\n\t    if (krb5_enctype_valid(context, req->req_body.etype.val[i]) == 0)\n\t\tbreak;\n\tif (req->req_body.etype.len <= i) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"No valid enctype available from client\");\n\t    goto out;\n\t}\n\tenctype = req->req_body.etype.val[i];\n    } else\n\tenctype = ETYPE_DES3_CBC_SHA1;\n\n    if (cp->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\tconst char *type, *other = \"\";\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP;\n\n\tif (cp->keyex == USE_RSA) {\n\t    ContentInfo info;\n\n\t    type = \"enckey\";\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\n\t    ret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t\t&cp->reply_key);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t\tconfig,\n\t\t\t\t\tcp,\n\t\t\t\t\treq,\n\t\t\t\t\treq_buffer,\n\t\t\t\t\t&cp->reply_key,\n\t\t\t\t\t&info,\n\t\t\t\t\t&kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t       rep.u.encKeyPack.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    ret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\tsessionkey);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\n\t} else {\n\t    ContentInfo info;\n\n\t    switch (cp->keyex) {\n\t    case USE_DH: type = \"dh\"; break;\n\t    case USE_ECDH: type = \"ecdh\"; break;\n\t    default: krb5_abortx(context, \"unknown keyex\"); break;\n\t    }\n\n\t    if (cp->dh_group_name)\n\t\tother = cp->dh_group_name;\n\n\t    rep.element = choice_PA_PK_AS_REP_dhInfo;\n\n\t    ret = generate_dh_keyblock(context, cp, enctype);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ret = pk_mk_pa_reply_dh(context, config,\n\t\t\t\t    cp,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\t    if (ret) {\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"create pa-reply-dh \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tgoto out;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(ContentInfo, rep.u.dhInfo.dhSignedData.data,\n\t\t\t       rep.u.dhInfo.dhSignedData.length, &info, &size,\n\t\t\t       ret);\n\t    free_ContentInfo(&info);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"encoding of Key ContentInfo \"\n\t\t\t\t       \"failed %d\", ret);\n\t\tfree_PA_PK_AS_REP(&rep);\n\t\tgoto out;\n\t    }\n\t    if (rep.u.encKeyPack.length != size)\n\t\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\t    /* generate the session key using the method from RFC6112 */\n\t    {\n\t\tkrb5_keyblock kdc_contribution_key;\n\t\tkrb5_crypto reply_crypto;\n\t\tkrb5_crypto kdccont_crypto;\n\t\tkrb5_data p1 = { strlen(\"PKINIT\"), \"PKINIT\"};\n\t\tkrb5_data p2 = { strlen(\"KEYEXCHANGE\"), \"KEYEXCHANGE\"};\n\t\tvoid *kckdata;\n\t\tsize_t kcklen;\n\t\tEncryptedData kx;\n\t\tvoid *kxdata;\n\t\tsize_t kxlen;\n\n\t\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t\t&kdc_contribution_key);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &cp->reply_key, enctype, &reply_crypto);\n\t\tif (ret) {\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tret = krb5_crypto_init(context, &kdc_contribution_key, sessionetype, &kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\t/* KRB-FX-CF2 */\n\t\tret = krb5_crypto_fx_cf2(context, kdccont_crypto, reply_crypto,\n\t\t\t\t\t &p1, &p2, sessionetype, sessionkey);\n\t\tkrb5_crypto_destroy(context, kdccont_crypto);\n\t\tif (ret) {\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    krb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptionKey, kckdata, kcklen,\n\t\t\t\t   &kdc_contribution_key, &size, ret);\n\t\tkrb5_free_keyblock_contents(context, &kdc_contribution_key);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX Key failed %d\", ret);\n\t\t    krb5_crypto_destroy(context, reply_crypto);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kcklen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\tret = krb5_encrypt_EncryptedData(context, reply_crypto, KRB5_KU_PA_PKINIT_KX,\n\t\t\t\t\tkckdata, kcklen, 0, &kx);\n\t\tkrb5_crypto_destroy(context, reply_crypto);\n\t\tfree(kckdata);\n\t\tif (ret) {\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tASN1_MALLOC_ENCODE(EncryptedData, kxdata, kxlen,\n\t\t\t\t   &kx, &size, ret);\n\t\tfree_EncryptedData(&kx);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret, \"encoding of PKINIT-KX failed %d\", ret);\n\t\t    free_PA_PK_AS_REP(&rep);\n\t\t    goto out;\n\t\t}\n\t\tif (kxlen != size)\n\t\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\t\t/* Add PA-PKINIT-KX */\n\t\tret = krb5_padata_add(context, md, KRB5_PADATA_PKINIT_KX, kxdata, kxlen);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed adding PKINIT-KX %d\", ret);\n\t\t    free(buf);\n\t\t    goto out;\n\t\t}\n\t    }\n\t}\n\n#define use_btmm_with_enckey 0\n\tif (use_btmm_with_enckey && rep.element == choice_PA_PK_AS_REP_encKeyPack) {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    heim_any any;\n\n\t    any.data = rep.u.encKeyPack.data;\n\t    any.length = rep.u.encKeyPack.length;\n\n\t    btmm.dhSignedData = NULL;\n\t    btmm.encKeyPack = &any;\n\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP_BTMM, buf, len, &btmm, &size, ret);\n\t} else {\n\t    ASN1_MALLOC_ENCODE(PA_PK_AS_REP, buf, len, &rep, &size, ret);\n\t}\n\n\tfree_PA_PK_AS_REP(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"encode PA-PK-AS-REP failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tkdc_log(context, config, 0, \"PK-INIT using %s %s\", type, other);\n\n    } else if (cp->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k rep;\n\tContentInfo info;\n\n\tif (cp->keyex != USE_RSA) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Windows PK-INIT doesn't support DH\");\n\t    goto out;\n\t}\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\tpa_type = KRB5_PADATA_PK_AS_REP_19;\n\trep.element = choice_PA_PK_AS_REP_Win2k_encKeyPack;\n\n\tret = krb5_generate_random_keyblock(context, enctype,\n\t\t\t\t\t    &cp->reply_key);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tret = pk_mk_pa_reply_enckey(context,\n\t\t\t\t    config,\n\t\t\t\t    cp,\n\t\t\t\t    req,\n\t\t\t\t    req_buffer,\n\t\t\t\t    &cp->reply_key,\n\t\t\t\t    &info,\n\t\t\t\t    &kdc_cert);\n\tif (ret) {\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ContentInfo, rep.u.encKeyPack.data,\n\t\t\t   rep.u.encKeyPack.length, &info, &size,\n\t\t\t   ret);\n\tfree_ContentInfo(&info);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"encoding of Key ContentInfo \"\n\t\t\t\t  \"failed %d\", ret);\n\t    free_PA_PK_AS_REP_Win2k(&rep);\n\t    goto out;\n\t}\n\tif (rep.u.encKeyPack.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REP_Win2k, buf, len, &rep, &size, ret);\n\tfree_PA_PK_AS_REP_Win2k(&rep);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t  \"encode PA-PK-AS-REP-Win2k failed %d\", ret);\n\t    goto out;\n\t}\n\tif (len != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tret = krb5_generate_random_keyblock(context, sessionetype,\n\t\t\t\t\t    sessionkey);\n\tif (ret) {\n\t    free(buf);\n\t    goto out;\n\t}\n\n    } else\n\tkrb5_abortx(context, \"PK-INIT internal error\");\n\n\n    ret = krb5_padata_add(context, md, pa_type, buf, len);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Failed adding PA-PK-AS-REP %d\", ret);\n\tfree(buf);\n\tgoto out;\n    }\n\n    if (config->pkinit_kdc_ocsp_file) {\n\n\tif (ocsp.expire == 0 && ocsp.next_update > kdc_time) {\n\t    struct stat sb;\n\t    int fd;\n\n\t    krb5_data_free(&ocsp.data);\n\n\t    ocsp.expire = 0;\n\t    ocsp.next_update = kdc_time + 60 * 5;\n\n\t    fd = open(config->pkinit_kdc_ocsp_file, O_RDONLY);\n\t    if (fd < 0) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to open ocsp data file %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\t    ret = fstat(fd, &sb);\n\t    if (ret) {\n\t\tret = errno;\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = krb5_data_alloc(&ocsp.data, sb.st_size);\n\t    if (ret) {\n\t\tclose(fd);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to stat ocsp data %d\", ret);\n\t\tgoto out_ocsp;\n\t    }\n\t    ocsp.data.length = sb.st_size;\n\t    ret = read(fd, ocsp.data.data, sb.st_size);\n\t    close(fd);\n\t    if (ret != sb.st_size) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to read ocsp data %d\", errno);\n\t\tgoto out_ocsp;\n\t    }\n\n\t    ret = hx509_ocsp_verify(context->hx509ctx,\n\t\t\t\t    kdc_time,\n\t\t\t\t    kdc_cert,\n\t\t\t\t    0,\n\t\t\t\t    ocsp.data.data, ocsp.data.length,\n\t\t\t\t    &ocsp.expire);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"PK-INIT failed to verify ocsp data %d\", ret);\n\t\tkrb5_data_free(&ocsp.data);\n\t\tocsp.expire = 0;\n\t    } else if (ocsp.expire > 180) {\n\t\tocsp.expire -= 180; /* refetch the ocsp before it expire */\n\t\tocsp.next_update = ocsp.expire;\n\t    } else {\n\t\tocsp.next_update = kdc_time;\n\t    }\n\tout_ocsp:\n\t    ret = 0;\n\t}\n\n\tif (ocsp.expire != 0 && ocsp.expire > kdc_time) {\n\n\t    ret = krb5_padata_add(context, md,\n\t\t\t\t  KRB5_PADATA_PA_PK_OCSP_RESPONSE,\n\t\t\t\t  ocsp.data.data, ocsp.data.length);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed adding OCSP response %d\", ret);\n\t\tgoto out;\n\t    }\n\t}\n    }\n\nout:\n    if (kdc_cert)\n\thx509_cert_free(kdc_cert);\n\n    if (ret == 0)\n\tret = krb5_copy_keyblock_contents(context, &cp->reply_key, reply_key);\n    return ret;\n}"
  },
  {
    "function_name": "k_mk_pa_reply_dh(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "997-1119",
    "snippet": "tatic krb5_error_code\npk_mk_pa_reply_dh(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n      \t\t  pk_client_params *cp,\n\t\t  ContentInfo *content_info,\n\t\t  hx509_cert *kdc_cert)\n{\n    KDCDHKeyInfo dh_info;\n    krb5_data signed_data, buf;\n    ContentInfo contentinfo;\n    krb5_error_code ret;\n    hx509_cert cert;\n    hx509_query *q;\n    size_t size = 0;\n\n    memset(&contentinfo, 0, sizeof(contentinfo));\n    memset(&dh_info, 0, sizeof(dh_info));\n    krb5_data_zero(&signed_data);\n    krb5_data_zero(&buf);\n\n    *kdc_cert = NULL;\n\n    if (cp->keyex == USE_DH) {\n\tDH *kdc_dh = cp->u.dh.key;\n\theim_integer i;\n\n\tret = BN_to_integer(context, kdc_dh->pub_key, &i);\n\tif (ret)\n\t    return ret;\n\n\tASN1_MALLOC_ENCODE(DHPublicKey, buf.data, buf.length, &i, &size, ret);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t\t   \"DHPublicKey failed (%d)\", ret);\n\t    return ret;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tdh_info.subjectPublicKey.length = buf.length * 8;\n\tdh_info.subjectPublicKey.data = buf.data;\n\tkrb5_data_zero(&buf);\n    } else if (cp->keyex == USE_ECDH) {\n        unsigned char *p;\n        ret = _kdc_serialize_ecdh_key(context, cp->u.ecdh.key, &p,\n                                      &dh_info.subjectPublicKey.length);\n        dh_info.subjectPublicKey.data = p;\n        if (ret)\n            goto out;\n    } else\n\tkrb5_abortx(context, \"no keyex selected ?\");\n\n\n    dh_info.nonce = cp->nonce;\n\n    ASN1_MALLOC_ENCODE(KDCDHKeyInfo, buf.data, buf.length, &dh_info, &size,\n\t\t       ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t       \"KdcDHKeyInfo failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    /*\n     * Create the SignedData structure and sign the KdcDHKeyInfo\n     * filled in above\n     */\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret)\n\tgoto out;\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    if (config->pkinit_kdc_friendly_name)\n\thx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n    ret = hx509_certs_find(context->hx509ctx,\n\t\t\t   kdc_identity->certs,\n\t\t\t   q,\n\t\t\t   &cert);\n    hx509_query_free(context->hx509ctx, q);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    0,\n\t\t\t\t    &asn1_oid_id_pkdhkeydata,\n\t\t\t\t    buf.data,\n\t\t\t\t    buf.length,\n\t\t\t\t    NULL,\n\t\t\t\t    cert,\n\t\t\t\t    cp->peer,\n\t\t\t\t    cp->client_anchors,\n\t\t\t\t    kdc_identity->certpool,\n\t\t\t\t    &signed_data);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed signing the DH* reply: %d\", ret);\n\tgoto out;\n    }\n    *kdc_cert = cert;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &signed_data,\n\t\t\t\t  &asn1_oid_id_pkcs7_signedData,\n\t\t\t\t  content_info);\n    if (ret)\n\tgoto out;\n\n out:\n    if (ret && *kdc_cert) {\n\thx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    free_KDCDHKeyInfo(&dh_info);\n\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_KDCDHKeyInfo(",
          "args": [
            "dh_info)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "signed_data)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "kdc_cert)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pk_mk_ContentInfo(",
          "args": [
            "ontext,",
            "signed_data,",
            "asn1_oid_id_pkcs7_signedData,",
            "ontent_info)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed signing the DH* reply: %d\",",
            "et)"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x509_cms_create_signed_1(",
          "args": [
            "ontext->hx509ctx,",
            ",",
            "asn1_oid_id_pkdhkeydata,",
            "uf.data,",
            "uf.length,",
            "ULL,",
            "ert,",
            "p->peer,",
            "p->client_anchors,",
            "dc_identity->certpool,",
            "signed_data)"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_find(",
          "args": [
            "ontext->hx509ctx,",
            "dc_identity->certs,",
            ",",
            "cert)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_friendly_name(",
          "args": [
            ",",
            "onfig->pkinit_kdc_friendly_name)"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_option(",
          "args": [
            ",",
            "X509_QUERY_OPTION_PRIVATE_KEY)"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_alloc(",
          "args": [
            "ontext->hx509ctx,",
            "q)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "ASN.1 encoding of \"\n\t\t\t       \"KdcDHKeyInfo failed (%d)\",",
            "et)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "DCDHKeyInfo,",
            "uf.data,",
            "uf.length,",
            "dh_info,",
            "size,",
            "et)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "no keyex selected ?\")"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_serialize_ecdh_key(",
          "args": [
            "ontext,",
            "p->u.ecdh.key,",
            "p,",
            "dh_info.subjectPublicKey.length)"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_serialize_ecdh_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit-ec.c",
          "lines": "305-316",
          "snippet": "rb5_error_code\n_kdc_serialize_ecdh_key(krb5_context context,\n                        void *key,\n                        unsigned char **out,\n                        size_t *out_len)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return serialize_ecdh_key(context, key, out, out_len);\n#else\n    return ENOTSUP;\n#endif\n}",
          "includes": [
            "include <hx509.h>",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include <hcrypto/des.h>\n#",
            "include \"kdc_locl.h\"\n#",
            "include <openssl/bn.h>\n#",
            "include <openssl/evp.h>\n#",
            "include <openssl/ecdh.h>\n#",
            "include <openssl/ec.h>\n#",
            "include <roken.h>",
            "include <config.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hx509.h>\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude <hcrypto/des.h>\n#\ninclude \"kdc_locl.h\"\n#\ninclude <openssl/bn.h>\n#\ninclude <openssl/evp.h>\n#\ninclude <openssl/ecdh.h>\n#\ninclude <openssl/ec.h>\n#\ninclude <roken.h>\ninclude <config.h>\n#\n\nrb5_error_code\n_kdc_serialize_ecdh_key(krb5_context context,\n                        void *key,\n                        unsigned char **out,\n                        size_t *out_len)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return serialize_ecdh_key(context, key, out, out_len);\n#else\n    return ENOTSUP;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "ASN.1 encoding of \"\n\t\t\t\t   \"DHPublicKey failed (%d)\",",
            "et)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_free_heim_integer(",
          "args": [
            "i)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "HPublicKey,",
            "uf.data,",
            "uf.length,",
            "i,",
            "size,",
            "et)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_to_integer(",
          "args": [
            "ontext,",
            "dc_dh->pub_key,",
            "i)"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "N_to_integer(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "803-815",
          "snippet": "tatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "signed_data)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "dh_info,",
            ",",
            "izeof(dh_info))"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "contentinfo,",
            ",",
            "izeof(contentinfo))"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_mk_pa_reply_dh(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n      \t\t  pk_client_params *cp,\n\t\t  ContentInfo *content_info,\n\t\t  hx509_cert *kdc_cert)\n{\n    KDCDHKeyInfo dh_info;\n    krb5_data signed_data, buf;\n    ContentInfo contentinfo;\n    krb5_error_code ret;\n    hx509_cert cert;\n    hx509_query *q;\n    size_t size = 0;\n\n    memset(&contentinfo, 0, sizeof(contentinfo));\n    memset(&dh_info, 0, sizeof(dh_info));\n    krb5_data_zero(&signed_data);\n    krb5_data_zero(&buf);\n\n    *kdc_cert = NULL;\n\n    if (cp->keyex == USE_DH) {\n\tDH *kdc_dh = cp->u.dh.key;\n\theim_integer i;\n\n\tret = BN_to_integer(context, kdc_dh->pub_key, &i);\n\tif (ret)\n\t    return ret;\n\n\tASN1_MALLOC_ENCODE(DHPublicKey, buf.data, buf.length, &i, &size, ret);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t\t   \"DHPublicKey failed (%d)\", ret);\n\t    return ret;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n\tdh_info.subjectPublicKey.length = buf.length * 8;\n\tdh_info.subjectPublicKey.data = buf.data;\n\tkrb5_data_zero(&buf);\n    } else if (cp->keyex == USE_ECDH) {\n        unsigned char *p;\n        ret = _kdc_serialize_ecdh_key(context, cp->u.ecdh.key, &p,\n                                      &dh_info.subjectPublicKey.length);\n        dh_info.subjectPublicKey.data = p;\n        if (ret)\n            goto out;\n    } else\n\tkrb5_abortx(context, \"no keyex selected ?\");\n\n\n    dh_info.nonce = cp->nonce;\n\n    ASN1_MALLOC_ENCODE(KDCDHKeyInfo, buf.data, buf.length, &dh_info, &size,\n\t\t       ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of \"\n\t\t\t       \"KdcDHKeyInfo failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    /*\n     * Create the SignedData structure and sign the KdcDHKeyInfo\n     * filled in above\n     */\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret)\n\tgoto out;\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    if (config->pkinit_kdc_friendly_name)\n\thx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n    ret = hx509_certs_find(context->hx509ctx,\n\t\t\t   kdc_identity->certs,\n\t\t\t   q,\n\t\t\t   &cert);\n    hx509_query_free(context->hx509ctx, q);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    0,\n\t\t\t\t    &asn1_oid_id_pkdhkeydata,\n\t\t\t\t    buf.data,\n\t\t\t\t    buf.length,\n\t\t\t\t    NULL,\n\t\t\t\t    cert,\n\t\t\t\t    cp->peer,\n\t\t\t\t    cp->client_anchors,\n\t\t\t\t    kdc_identity->certpool,\n\t\t\t\t    &signed_data);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Failed signing the DH* reply: %d\", ret);\n\tgoto out;\n    }\n    *kdc_cert = cert;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &signed_data,\n\t\t\t\t  &asn1_oid_id_pkcs7_signedData,\n\t\t\t\t  content_info);\n    if (ret)\n\tgoto out;\n\n out:\n    if (ret && *kdc_cert) {\n\thx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    free_KDCDHKeyInfo(&dh_info);\n\n    return ret;\n}"
  },
  {
    "function_name": "k_mk_pa_reply_enckey(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "817-991",
    "snippet": "tatic krb5_error_code\npk_mk_pa_reply_enckey(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      pk_client_params *cp,\n\t\t      const KDC_REQ *req,\n\t\t      const krb5_data *req_buffer,\n\t\t      krb5_keyblock *reply_key,\n\t\t      ContentInfo *content_info,\n\t\t      hx509_cert *kdc_cert)\n{\n    const heim_oid *envelopedAlg = NULL, *sdAlg = NULL, *evAlg = NULL;\n    krb5_error_code ret;\n    krb5_data buf, signed_data;\n    size_t size = 0;\n    int do_win2k = 0;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&signed_data);\n\n    *kdc_cert = NULL;\n\n    /*\n     * If the message client is a win2k-type but it send pa data\n     * 09-binding it expects a IETF (checksum) reply so there can be\n     * no replay attacks.\n     */\n\n    switch (cp->type) {\n    case PKINIT_WIN2K: {\n\tint i = 0;\n\tif (_kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_09_BINDING) == NULL\n\t    && config->pkinit_require_binding == 0)\n\t{\n\t    do_win2k = 1;\n\t}\n\tsdAlg = &asn1_oid_id_pkcs7_data;\n\tevAlg = &asn1_oid_id_pkcs7_data;\n\tenvelopedAlg = &asn1_oid_id_rsadsi_des_ede3_cbc;\n\tbreak;\n    }\n    case PKINIT_27:\n\tsdAlg = &asn1_oid_id_pkrkeydata;\n\tevAlg = &asn1_oid_id_pkcs7_signedData;\n\tbreak;\n    default:\n\tkrb5_abortx(context, \"internal pkinit error\");\n    }\n\n    if (do_win2k) {\n\tReplyKeyPack_Win2k kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tkp.nonce = cp->nonce;\n\n\tASN1_MALLOC_ENCODE(ReplyKeyPack_Win2k,\n\t\t\t   buf.data, buf.length,\n\t\t\t   &kp, &size,ret);\n\tfree_ReplyKeyPack_Win2k(&kp);\n    } else {\n\tkrb5_crypto ascrypto;\n\tReplyKeyPack kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, reply_key, 0, &ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_create_checksum(context, ascrypto, 6, 0,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &kp.asChecksum);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_destroy(context, ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ReplyKeyPack, buf.data, buf.length, &kp, &size,ret);\n\tfree_ReplyKeyPack(&kp);\n    }\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of ReplyKeyPack \"\n\t\t\t       \"failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret)\n\t    goto out;\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t\t0,\n\t\t\t\t\tsdAlg,\n\t\t\t\t\tbuf.data,\n\t\t\t\t\tbuf.length,\n\t\t\t\t\tNULL,\n\t\t\t\t\tcert,\n\t\t\t\t\tcp->peer,\n\t\t\t\t\tcp->client_anchors,\n\t\t\t\t\tkdc_identity->certpool,\n\t\t\t\t\t&signed_data);\n\t*kdc_cert = cert;\n    }\n\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    if (cp->type == PKINIT_WIN2K) {\n\tret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData,\n\t\t\t\t\t &signed_data,\n\t\t\t\t\t &buf);\n\tif (ret)\n\t    goto out;\n\tkrb5_data_free(&signed_data);\n\tsigned_data = buf;\n    }\n\n    ret = hx509_cms_envelope_1(context->hx509ctx,\n\t\t\t       HX509_CMS_EV_NO_KU_CHECK,\n\t\t\t       cp->cert,\n\t\t\t       signed_data.data, signed_data.length,\n\t\t\t       envelopedAlg,\n\t\t\t       evAlg, &buf);\n    if (ret)\n\tgoto out;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &buf,\n\t\t\t\t  &asn1_oid_id_pkcs7_envelopedData,\n\t\t\t\t  content_info);\nout:\n    if (ret && *kdc_cert) {\n        hx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "signed_data)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "kdc_cert)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pk_mk_ContentInfo(",
          "args": [
            "ontext,",
            "buf,",
            "asn1_oid_id_pkcs7_envelopedData,",
            "ontent_info)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_envelope_1(",
          "args": [
            "ontext->hx509ctx,",
            "X509_CMS_EV_NO_KU_CHECK,",
            "p->cert,",
            "igned_data.data,",
            "igned_data.length,",
            "nvelopedAlg,",
            "vAlg,",
            "buf)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "signed_data)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_wrap_ContentInfo(",
          "args": [
            "asn1_oid_id_pkcs7_signedData,",
            "signed_data,",
            "buf)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_create_signed_1(",
          "args": [
            "ontext->hx509ctx,",
            ",",
            "dAlg,",
            "uf.data,",
            "uf.length,",
            "ULL,",
            "ert,",
            "p->peer,",
            "p->client_anchors,",
            "dc_identity->certpool,",
            "signed_data)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_find(",
          "args": [
            "ontext->hx509ctx,",
            "dc_identity->certs,",
            ",",
            "cert)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_friendly_name(",
          "args": [
            ",",
            "onfig->pkinit_kdc_friendly_name)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_option(",
          "args": [
            ",",
            "X509_QUERY_OPTION_PRIVATE_KEY)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_alloc(",
          "args": [
            "ontext->hx509ctx,",
            "q)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal ASN.1 encoder error\")"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "ASN.1 encoding of ReplyKeyPack \"\n\t\t\t       \"failed (%d)\",",
            "et)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ReplyKeyPack(",
          "args": [
            "kp)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "eplyKeyPack,",
            "uf.data,",
            "uf.length,",
            "kp,",
            "size,",
            "et)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "scrypto)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "ontext,",
            "scrypto,",
            ",",
            ",",
            "eq_buffer->data,",
            "eq_buffer->length,",
            "kp.asChecksum)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "eply_key,",
            ",",
            "ascrypto)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_EncryptionKey(",
          "args": [
            "eply_key,",
            "kp.replyKey)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "kp,",
            ",",
            "izeof(kp))"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_ReplyKeyPack_Win2k(",
          "args": [
            "kp)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "eplyKeyPack_Win2k,",
            "uf.data,",
            "uf.length,",
            "kp,",
            "size,",
            "et)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_EncryptionKey(",
          "args": [
            "eply_key,",
            "kp.replyKey)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "kp,",
            ",",
            "izeof(kp))"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal pkinit error\")"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "eq,",
            "i,",
            "RB5_PADATA_PK_AS_09_BINDING)"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "signed_data)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_mk_pa_reply_enckey(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      pk_client_params *cp,\n\t\t      const KDC_REQ *req,\n\t\t      const krb5_data *req_buffer,\n\t\t      krb5_keyblock *reply_key,\n\t\t      ContentInfo *content_info,\n\t\t      hx509_cert *kdc_cert)\n{\n    const heim_oid *envelopedAlg = NULL, *sdAlg = NULL, *evAlg = NULL;\n    krb5_error_code ret;\n    krb5_data buf, signed_data;\n    size_t size = 0;\n    int do_win2k = 0;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&signed_data);\n\n    *kdc_cert = NULL;\n\n    /*\n     * If the message client is a win2k-type but it send pa data\n     * 09-binding it expects a IETF (checksum) reply so there can be\n     * no replay attacks.\n     */\n\n    switch (cp->type) {\n    case PKINIT_WIN2K: {\n\tint i = 0;\n\tif (_kdc_find_padata(req, &i, KRB5_PADATA_PK_AS_09_BINDING) == NULL\n\t    && config->pkinit_require_binding == 0)\n\t{\n\t    do_win2k = 1;\n\t}\n\tsdAlg = &asn1_oid_id_pkcs7_data;\n\tevAlg = &asn1_oid_id_pkcs7_data;\n\tenvelopedAlg = &asn1_oid_id_rsadsi_des_ede3_cbc;\n\tbreak;\n    }\n    case PKINIT_27:\n\tsdAlg = &asn1_oid_id_pkrkeydata;\n\tevAlg = &asn1_oid_id_pkcs7_signedData;\n\tbreak;\n    default:\n\tkrb5_abortx(context, \"internal pkinit error\");\n    }\n\n    if (do_win2k) {\n\tReplyKeyPack_Win2k kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tkp.nonce = cp->nonce;\n\n\tASN1_MALLOC_ENCODE(ReplyKeyPack_Win2k,\n\t\t\t   buf.data, buf.length,\n\t\t\t   &kp, &size,ret);\n\tfree_ReplyKeyPack_Win2k(&kp);\n    } else {\n\tkrb5_crypto ascrypto;\n\tReplyKeyPack kp;\n\tmemset(&kp, 0, sizeof(kp));\n\n\tret = copy_EncryptionKey(reply_key, &kp.replyKey);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, reply_key, 0, &ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_create_checksum(context, ascrypto, 6, 0,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &kp.asChecksum);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_destroy(context, ascrypto);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tASN1_MALLOC_ENCODE(ReplyKeyPack, buf.data, buf.length, &kp, &size,ret);\n\tfree_ReplyKeyPack(&kp);\n    }\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"ASN.1 encoding of ReplyKeyPack \"\n\t\t\t       \"failed (%d)\", ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN.1 encoder error\");\n\n    {\n\thx509_query *q;\n\thx509_cert cert;\n\n\tret = hx509_query_alloc(context->hx509ctx, &q);\n\tif (ret)\n\t    goto out;\n\n\thx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n\tif (config->pkinit_kdc_friendly_name)\n\t    hx509_query_match_friendly_name(q, config->pkinit_kdc_friendly_name);\n\n\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t       kdc_identity->certs,\n\t\t\t       q,\n\t\t\t       &cert);\n\thx509_query_free(context->hx509ctx, q);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t\t0,\n\t\t\t\t\tsdAlg,\n\t\t\t\t\tbuf.data,\n\t\t\t\t\tbuf.length,\n\t\t\t\t\tNULL,\n\t\t\t\t\tcert,\n\t\t\t\t\tcp->peer,\n\t\t\t\t\tcp->client_anchors,\n\t\t\t\t\tkdc_identity->certpool,\n\t\t\t\t\t&signed_data);\n\t*kdc_cert = cert;\n    }\n\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    if (cp->type == PKINIT_WIN2K) {\n\tret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData,\n\t\t\t\t\t &signed_data,\n\t\t\t\t\t &buf);\n\tif (ret)\n\t    goto out;\n\tkrb5_data_free(&signed_data);\n\tsigned_data = buf;\n    }\n\n    ret = hx509_cms_envelope_1(context->hx509ctx,\n\t\t\t       HX509_CMS_EV_NO_KU_CHECK,\n\t\t\t       cp->cert,\n\t\t\t       signed_data.data, signed_data.length,\n\t\t\t       envelopedAlg,\n\t\t\t       evAlg, &buf);\n    if (ret)\n\tgoto out;\n\n    ret = _krb5_pk_mk_ContentInfo(context,\n\t\t\t\t  &buf,\n\t\t\t\t  &asn1_oid_id_pkcs7_envelopedData,\n\t\t\t\t  content_info);\nout:\n    if (ret && *kdc_cert) {\n        hx509_cert_free(*kdc_cert);\n\t*kdc_cert = NULL;\n    }\n\n    krb5_data_free(&buf);\n    krb5_data_free(&signed_data);\n    return ret;\n}"
  },
  {
    "function_name": "N_to_integer(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "803-815",
    "snippet": "tatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "N_is_negative(",
          "args": [
            "n)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_bn2bin(",
          "args": [
            "n,",
            "nteger->data)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "nteger->length)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_num_bytes(",
          "args": [
            "n)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}"
  },
  {
    "function_name": "kdc_pk_rd_padata(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "394-797",
    "snippet": "rb5_error_code\n_kdc_pk_rd_padata(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  const KDC_REQ *req,\n\t\t  const PA_DATA *pa,\n\t\t  hdb_entry_ex *client,\n\t\t  pk_client_params **ret_params)\n{\n    pk_client_params *cp;\n    krb5_error_code ret;\n    heim_oid eContentType = { 0, NULL }, contentInfoOid = { 0, NULL };\n    krb5_data eContent = { 0, NULL };\n    krb5_data signed_content = { 0, NULL };\n    const char *type = \"unknown type\";\n    hx509_certs trust_anchors;\n    int have_data = 0;\n    const HDB_Ext_PKINIT_cert *pc;\n\n    *ret_params = NULL;\n\n    if (!config->enable_pkinit) {\n\tkdc_log(context, config, 0, \"PK-INIT request but PK-INIT not enabled\");\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    cp = calloc(1, sizeof(*cp));\n    if (cp == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t   \"MEMORY:trust-anchors\",\n\t\t\t   0, NULL, &trust_anchors);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"failed to create trust anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_merge(context->hx509ctx, trust_anchors,\n\t\t\t    kdc_identity->anchors);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    /* Add any registered certificates for this client as trust anchors */\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc != NULL) {\n\thx509_cert cert;\n\tunsigned int i;\n\n\tfor (i = 0; i < pc->len; i++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[i].cert.data,\n\t\t\t\t\tpc->val[i].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    hx509_certs_add(context->hx509ctx, trust_anchors, cert);\n\t    hx509_cert_free(cert);\n\t}\n    }\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &cp->verify_ctx);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_set_time(cp->verify_ctx, kdc_time);\n    hx509_verify_attach_anchors(cp->verify_ctx, trust_anchors);\n    hx509_certs_free(&trust_anchors);\n\n    if (config->pkinit_allow_proxy_certs)\n\thx509_verify_set_proxy_certificate(cp->verify_ctx, 1);\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tPA_PK_AS_REQ_Win2k r;\n\n\ttype = \"PK-INIT-Win2k\";\n\n\tif (_kdc_is_anon_request(&req->req_body)) {\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = decode_PA_PK_AS_REQ_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&r,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Can't decode \"\n\t\t\t\t   \"PK-AS-REQ-Win2k: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signed_auth_pack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ_Win2k(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo(win): %d\", ret);\n\t    goto out;\n\t}\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tPA_PK_AS_REQ r;\n\n\ttype = \"PK-INIT-IETF\";\n\n\tret = decode_PA_PK_AS_REQ(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &r,\n\t\t\t\t  NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode PK-AS-REQ: %d\", ret);\n\t    goto out;\n\t}\n\n\t/* XXX look at r.kdcPkId */\n\tif (r.trustedCertifiers) {\n\t    ExternalPrincipalIdentifiers *edi = r.trustedCertifiers;\n\t    unsigned int i, maxedi;\n\n\t    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t\t   \"MEMORY:client-anchors\",\n\t\t\t\t   0, NULL,\n\t\t\t\t   &cp->client_anchors);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Can't allocate client anchors: %d\",\n\t\t\t\t       ret);\n\t\tgoto out;\n\n\t    }\n\t    /*\n\t     * If the client sent more then 10 EDI, don't bother\n\t     * looking more then 10 of performance reasons.\n\t     */\n\t    maxedi = edi->len;\n\t    if (maxedi > 10)\n\t\tmaxedi = 10;\n\t    for (i = 0; i < maxedi; i++) {\n\t\tIssuerAndSerialNumber iasn;\n\t\thx509_query *q;\n\t\thx509_cert cert;\n\t\tsize_t size;\n\n\t\tif (edi->val[i].issuerAndSerialNumber == NULL)\n\t\t    continue;\n\n\t\tret = hx509_query_alloc(context->hx509ctx, &q);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t  \"Failed to allocate hx509_query\");\n\t\t    goto out;\n\t\t}\n\n\t\tret = decode_IssuerAndSerialNumber(edi->val[i].issuerAndSerialNumber->data,\n\t\t\t\t\t\t   edi->val[i].issuerAndSerialNumber->length,\n\t\t\t\t\t\t   &iasn,\n\t\t\t\t\t\t   &size);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\t\tret = hx509_query_match_issuer_serial(q, &iasn.issuer, &iasn.serialNumber);\n\t\tfree_IssuerAndSerialNumber(&iasn);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\n\t\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t\t       kdc_identity->certs,\n\t\t\t\t       q,\n\t\t\t\t       &cert);\n\t\thx509_query_free(context->hx509ctx, q);\n\t\tif (ret)\n\t\t    continue;\n\t\thx509_certs_add(context->hx509ctx,\n\t\t\t\tcp->client_anchors, cert);\n\t\thx509_cert_free(cert);\n\t    }\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signedAuthPack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo: %d\", ret);\n\t    goto out;\n\t}\n\n    } else {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\tgoto out;\n    }\n\n    ret = der_heim_oid_cmp(&contentInfoOid, &asn1_oid_id_pkcs7_signedData);\n    if (ret != 0) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PK-AS-REQ-Win2k invalid content type oid\");\n\tgoto out;\n    }\n\n    if (!have_data) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t      \"PK-AS-REQ-Win2k no signed auth pack\");\n\tgoto out;\n    }\n\n    {\n\thx509_certs signer_certs;\n\tint flags = HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH; /* BTMM */\n\n\tif (_kdc_is_anon_request(&req->req_body))\n\t    flags |= HX509_CMS_VS_ALLOW_ZERO_SIGNER;\n\n\tret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t      cp->verify_ctx,\n\t\t\t\t      flags,\n\t\t\t\t      signed_content.data,\n\t\t\t\t      signed_content.length,\n\t\t\t\t      NULL,\n\t\t\t\t      kdc_identity->certpool,\n\t\t\t\t      &eContentType,\n\t\t\t\t      &eContent,\n\t\t\t\t      &signer_certs);\n\tif (ret) {\n\t    char *s = hx509_get_error_string(context->hx509ctx, ret);\n\t    krb5_warnx(context, \"PKINIT: failed to verify signature: %s: %d\",\n\t\t       s, ret);\n\t    free(s);\n\t    goto out;\n\t}\n\n\tif (signer_certs) {\n\t    ret = hx509_get_one_cert(context->hx509ctx, signer_certs,\n\t\t\t\t     &cp->cert);\n\t    hx509_certs_free(&signer_certs);\n\t}\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Signature is correct, now verify the signed message */\n    if (der_heim_oid_cmp(&eContentType, &asn1_oid_id_pkcs7_data) != 0 &&\n\tder_heim_oid_cmp(&eContentType, &asn1_oid_id_pkauthdata) != 0)\n    {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret, \"got wrong oid for pkauthdata\");\n\tgoto out;\n    }\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tAuthPack_Win2k ap;\n\n\tret = decode_AuthPack_Win2k(eContent.data,\n\t\t\t\t    eContent.length,\n\t\t\t\t    &ap,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator_win2k(context,\n\t\t\t\t\t     &ap.pkAuthenticator,\n\t\t\t\t\t     req);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_WIN2K;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"DH not supported for windows\");\n\t    goto out;\n\t}\n\tfree_AuthPack_Win2k(&ap);\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tAuthPack ap;\n\n\tret = decode_AuthPack(eContent.data,\n\t\t\t      eContent.length,\n\t\t\t      &ap,\n\t\t\t      NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (_kdc_is_anon_request(&req->req_body) &&\n\t    ap.clientPublicValue == NULL) {\n\t    free_AuthPack(&ap);\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator(context,\n\t\t\t\t       &ap.pkAuthenticator,\n\t\t\t\t       req);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_27;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_dhpublicnumber) == 0) {\n\t\tcp->keyex = USE_DH;\n\t\tret = get_dh_param(context, config,\n\t\t\t\t   ap.clientPublicValue, cp);\n\t    } else if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_ecPublicKey) == 0) {\n\t\tcp->keyex = USE_ECDH;\n                ret = _kdc_get_ecdh_param(context, config,\n                                          ap.clientPublicValue,\n                                          &cp->u.ecdh.public_key);\n\t    } else {\n\t\tret = KRB5_BADMSGTYPE;\n\t\tkrb5_set_error_message(context, ret, \"PKINIT unknown DH mechanism\");\n\t    }\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else\n\t    cp->keyex = USE_RSA;\n\n\tret = hx509_peer_info_alloc(context->hx509ctx,\n\t\t\t\t\t&cp->peer);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (ap.supportedCMSTypes) {\n\t    ret = hx509_peer_info_set_cms_algs(context->hx509ctx,\n\t\t\t\t\t       cp->peer,\n\t\t\t\t\t       ap.supportedCMSTypes->val,\n\t\t\t\t\t       ap.supportedCMSTypes->len);\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else {\n\t    /* assume old client */\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_crypto_des_rsdi_ede3_cbc());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_rsa_with_sha1());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_sha1());\n\t}\n\tfree_AuthPack(&ap);\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    kdc_log(context, config, 0, \"PK-INIT request of type %s\", type);\n\nout:\n    if (ret)\n\tkrb5_warn(context, ret, \"PKINIT\");\n\n    if (signed_content.data)\n\tfree(signed_content.data);\n    krb5_data_free(&eContent);\n    der_free_oid(&eContentType);\n    der_free_oid(&contentInfoOid);\n    if (ret) {\n        _kdc_pk_free_client_param(context, cp);\n    } else\n\t*ret_params = cp;\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_pk_free_client_param(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_free_client_param(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "167-194",
          "snippet": "oid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\noid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "er_free_oid(",
          "args": [
            "contentInfoOid)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_free_oid(",
          "args": [
            "eContentType)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "eContent)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "igned_content.data)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "PKINIT\")"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "PK-INIT request of type %s\",",
            "ype)"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal pkinit error\")"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_add_cms_alg(",
          "args": [
            "ontext->hx509ctx,",
            "p->peer,",
            "x509_signature_sha1())"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_signature_sha1(",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_add_cms_alg(",
          "args": [
            "ontext->hx509ctx,",
            "p->peer,",
            "x509_signature_rsa_with_sha1())"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_signature_rsa_with_sha1(",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_add_cms_alg(",
          "args": [
            "ontext->hx509ctx,",
            "p->peer,",
            "x509_crypto_des_rsdi_ede3_cbc())"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_crypto_des_rsdi_ede3_cbc(",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_set_cms_algs(",
          "args": [
            "ontext->hx509ctx,",
            "p->peer,",
            "p.supportedCMSTypes->val,",
            "p.supportedCMSTypes->len)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_alloc(",
          "args": [
            "ontext->hx509ctx,",
            "cp->peer)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "PKINIT unknown DH mechanism\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_get_ecdh_param(",
          "args": [
            "ontext,",
            "onfig,",
            "p.clientPublicValue,",
            "cp->u.ecdh.public_key)"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_get_ecdh_param(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit-ec.c",
          "lines": "249-260",
          "snippet": "rb5_error_code\n_kdc_get_ecdh_param(krb5_context context,\n                    krb5_kdc_configuration *config,\n                    SubjectPublicKeyInfo *dh_key_info,\n                    void **out)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return get_ecdh_param(context, config, dh_key_info, (EC_KEY **)out);\n#else\n    return ENOTSUP;\n#endif /* HAVE_HCRYPTO_W_OPENSSL */\n}",
          "includes": [
            "include <hx509.h>",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include <hcrypto/des.h>\n#",
            "include \"kdc_locl.h\"\n#",
            "include <openssl/bn.h>\n#",
            "include <openssl/evp.h>\n#",
            "include <openssl/ecdh.h>\n#",
            "include <openssl/ec.h>\n#",
            "include <roken.h>",
            "include <config.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hx509.h>\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude <hcrypto/des.h>\n#\ninclude \"kdc_locl.h\"\n#\ninclude <openssl/bn.h>\n#\ninclude <openssl/evp.h>\n#\ninclude <openssl/ecdh.h>\n#\ninclude <openssl/ec.h>\n#\ninclude <roken.h>\ninclude <config.h>\n#\n\nrb5_error_code\n_kdc_get_ecdh_param(krb5_context context,\n                    krb5_kdc_configuration *config,\n                    SubjectPublicKeyInfo *dh_key_info,\n                    void **out)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return get_ecdh_param(context, config, dh_key_info, (EC_KEY **)out);\n#else\n    return ENOTSUP;\n#endif /* HAVE_HCRYPTO_W_OPENSSL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "er_heim_oid_cmp(",
          "args": [
            "ap.clientPublicValue->algorithm.algorithm,",
            "asn1_oid_id_ecPublicKey)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_dh_param(",
          "args": [
            "ontext,",
            "onfig,",
            "p.clientPublicValue,",
            "p)"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "et_dh_param(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "295-392",
          "snippet": "tatic krb5_error_code\nget_dh_param(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     SubjectPublicKeyInfo *dh_key_info,\n\t     pk_client_params *client_params)\n{\n    DomainParameters dhparam;\n    DH *dh = NULL;\n    krb5_error_code ret;\n\n    memset(&dhparam, 0, sizeof(dhparam));\n\n    if ((dh_key_info->subjectPublicKey.length % 8) != 0) {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PKINIT: subjectPublicKey not aligned \"\n\t\t\t       \"to 8 bit boundary\");\n\tgoto out;\n    }\n\n    if (dh_key_info->algorithm.parameters == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT missing algorithm parameter \"\n\t\t\t      \"in clientPublicValue\");\n\treturn KRB5_BADMSGTYPE;\n    }\n\n    ret = decode_DomainParameters(dh_key_info->algorithm.parameters->data,\n\t\t\t\t  dh_key_info->algorithm.parameters->length,\n\t\t\t\t  &dhparam,\n\t\t\t\t  NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Can't decode algorithm \"\n\t\t\t       \"parameters in clientPublicValue\");\n\tgoto out;\n    }\n\n    ret = _krb5_dh_group_ok(context, config->pkinit_dh_min_bits,\n\t\t\t    &dhparam.p, &dhparam.g, dhparam.q, moduli,\n\t\t\t    &client_params->dh_group_name);\n    if (ret) {\n\t/* XXX send back proposal of better group */\n\tgoto out;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n\tret = ENOMEM;\n\tkrb5_set_error_message(context, ret, \"Cannot create DH structure\");\n\tgoto out;\n    }\n    ret = KRB5_BADMSGTYPE;\n    dh->p = integer_to_BN(context, \"DH prime\", &dhparam.p);\n    if (dh->p == NULL)\n\tgoto out;\n    dh->g = integer_to_BN(context, \"DH base\", &dhparam.g);\n    if (dh->g == NULL)\n\tgoto out;\n\n    if (dhparam.q) {\n\tdh->q = integer_to_BN(context, \"DH p-1 factor\", dhparam.q);\n\tif (dh->g == NULL)\n\t    goto out;\n    }\n\n    {\n\theim_integer glue;\n\tsize_t size;\n\n\tret = decode_DHPublicKey(dh_key_info->subjectPublicKey.data,\n\t\t\t\t dh_key_info->subjectPublicKey.length / 8,\n\t\t\t\t &glue,\n\t\t\t\t &size);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tclient_params->u.dh.public_key = integer_to_BN(context,\n\t\t\t\t\t\t       \"subjectPublicKey\",\n\t\t\t\t\t\t       &glue);\n\tder_free_heim_integer(&glue);\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5_BADMSGTYPE;\n\t    goto out;\n\t}\n    }\n\n    client_params->u.dh.key = dh;\n    dh = NULL;\n    ret = 0;\n\n out:\n    if (dh)\n\tDH_free(dh);\n    free_DomainParameters(&dhparam);\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_dh_param(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     SubjectPublicKeyInfo *dh_key_info,\n\t     pk_client_params *client_params)\n{\n    DomainParameters dhparam;\n    DH *dh = NULL;\n    krb5_error_code ret;\n\n    memset(&dhparam, 0, sizeof(dhparam));\n\n    if ((dh_key_info->subjectPublicKey.length % 8) != 0) {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PKINIT: subjectPublicKey not aligned \"\n\t\t\t       \"to 8 bit boundary\");\n\tgoto out;\n    }\n\n    if (dh_key_info->algorithm.parameters == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT missing algorithm parameter \"\n\t\t\t      \"in clientPublicValue\");\n\treturn KRB5_BADMSGTYPE;\n    }\n\n    ret = decode_DomainParameters(dh_key_info->algorithm.parameters->data,\n\t\t\t\t  dh_key_info->algorithm.parameters->length,\n\t\t\t\t  &dhparam,\n\t\t\t\t  NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Can't decode algorithm \"\n\t\t\t       \"parameters in clientPublicValue\");\n\tgoto out;\n    }\n\n    ret = _krb5_dh_group_ok(context, config->pkinit_dh_min_bits,\n\t\t\t    &dhparam.p, &dhparam.g, dhparam.q, moduli,\n\t\t\t    &client_params->dh_group_name);\n    if (ret) {\n\t/* XXX send back proposal of better group */\n\tgoto out;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n\tret = ENOMEM;\n\tkrb5_set_error_message(context, ret, \"Cannot create DH structure\");\n\tgoto out;\n    }\n    ret = KRB5_BADMSGTYPE;\n    dh->p = integer_to_BN(context, \"DH prime\", &dhparam.p);\n    if (dh->p == NULL)\n\tgoto out;\n    dh->g = integer_to_BN(context, \"DH base\", &dhparam.g);\n    if (dh->g == NULL)\n\tgoto out;\n\n    if (dhparam.q) {\n\tdh->q = integer_to_BN(context, \"DH p-1 factor\", dhparam.q);\n\tif (dh->g == NULL)\n\t    goto out;\n    }\n\n    {\n\theim_integer glue;\n\tsize_t size;\n\n\tret = decode_DHPublicKey(dh_key_info->subjectPublicKey.data,\n\t\t\t\t dh_key_info->subjectPublicKey.length / 8,\n\t\t\t\t &glue,\n\t\t\t\t &size);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tclient_params->u.dh.public_key = integer_to_BN(context,\n\t\t\t\t\t\t       \"subjectPublicKey\",\n\t\t\t\t\t\t       &glue);\n\tder_free_heim_integer(&glue);\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5_BADMSGTYPE;\n\t    goto out;\n\t}\n    }\n\n    client_params->u.dh.key = dh;\n    dh = NULL;\n    ret = 0;\n\n out:\n    if (dh)\n\tDH_free(dh);\n    free_DomainParameters(&dhparam);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "er_heim_oid_cmp(",
          "args": [
            "ap.clientPublicValue->algorithm.algorithm,",
            "asn1_oid_id_dhpublicnumber)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_check_pkauthenticator(",
          "args": [
            "ontext,",
            "ap.pkAuthenticator,",
            "eq)"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "k_check_pkauthenticator(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "109-165",
          "snippet": "tatic krb5_error_code\npk_check_pkauthenticator(krb5_context context,\n\t\t\t PKAuthenticator *a,\n\t\t\t const KDC_REQ *req)\n{\n    u_char *buf = NULL;\n    size_t buf_size;\n    krb5_error_code ret;\n    size_t len = 0;\n    krb5_timestamp now;\n    Checksum checksum;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, &req->req_body, &len, ret);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n    if (buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n\n    if (a->paChecksum == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5_KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n\tgoto out;\n    }\n\n    if (der_heim_octet_string_cmp(a->paChecksum, &checksum.checksum) != 0) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KRB_ERR_GENERIC;\n    }\n\nout:\n    free_Checksum(&checksum);\n\n    return ret;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_check_pkauthenticator(krb5_context context,\n\t\t\t PKAuthenticator *a,\n\t\t\t const KDC_REQ *req)\n{\n    u_char *buf = NULL;\n    size_t buf_size;\n    krb5_error_code ret;\n    size_t len = 0;\n    krb5_timestamp now;\n    Checksum checksum;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, &req->req_body, &len, ret);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n    if (buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n\n    if (a->paChecksum == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5_KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n\tgoto out;\n    }\n\n    if (der_heim_octet_string_cmp(a->paChecksum, &checksum.checksum) != 0) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KRB_ERR_GENERIC;\n    }\n\nout:\n    free_Checksum(&checksum);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Anon not supported in RSA mode\")"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            "req->req_body)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack(",
          "args": [
            "ap)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't decode AuthPack: %d\",",
            "et)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_AuthPack(",
          "args": [
            "Content.data,",
            "Content.length,",
            "ap,",
            "ULL)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack_Win2k(",
          "args": [
            "ap)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "DH not supported for windows\")"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthPack_Win2k(",
          "args": [
            "ap)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_check_pkauthenticator_win2k(",
          "args": [
            "ontext,",
            "ap.pkAuthenticator,",
            "eq)"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "k_check_pkauthenticator_win2k(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "92-107",
          "snippet": "tatic krb5_error_code\npk_check_pkauthenticator_win2k(krb5_context context,\n\t\t\t       PKAuthenticator_Win2k *a,\n\t\t\t       const KDC_REQ *req)\n{\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n    return 0;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_check_pkauthenticator_win2k(krb5_context context,\n\t\t\t       PKAuthenticator_Win2k *a,\n\t\t\t       const KDC_REQ *req)\n{\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't decode AuthPack: %d\",",
            "et)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_AuthPack_Win2k(",
          "args": [
            "Content.data,",
            "Content.length,",
            "ap,",
            "ULL)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "got wrong oid for pkauthdata\")"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_heim_oid_cmp(",
          "args": [
            "eContentType,",
            "asn1_oid_id_pkauthdata)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_heim_oid_cmp(",
          "args": [
            "eContentType,",
            "asn1_oid_id_pkcs7_data)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_free(",
          "args": [
            "signer_certs)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_get_one_cert(",
          "args": [
            "ontext->hx509ctx,",
            "igner_certs,",
            "cp->cert)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "PKINIT: failed to verify signature: %s: %d\",",
            ",",
            "et)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_get_error_string(",
          "args": [
            "ontext->hx509ctx,",
            "et)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_verify_signed(",
          "args": [
            "ontext->hx509ctx,",
            "p->verify_ctx,",
            "lags,",
            "igned_content.data,",
            "igned_content.length,",
            "ULL,",
            "dc_identity->certpool,",
            "eContentType,",
            "eContent,",
            "signer_certs)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            "req->req_body)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "PK-AS-REQ-Win2k no signed auth pack\")"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "PK-AS-REQ-Win2k invalid content type oid\")"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_heim_oid_cmp(",
          "args": [
            "contentInfoOid,",
            "asn1_oid_id_pkcs7_signedData)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't unwrap ContentInfo: %d\",",
            "et)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REQ(",
          "args": [
            "r)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_unwrap_ContentInfo(",
          "args": [
            "r.signedAuthPack,",
            "contentInfoOid,",
            "signed_content,",
            "have_data)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "ert)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_add(",
          "args": [
            "ontext->hx509ctx,",
            "p->client_anchors,",
            "ert)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_find(",
          "args": [
            "ontext->hx509ctx,",
            "dc_identity->certs,",
            ",",
            "cert)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_IssuerAndSerialNumber(",
          "args": [
            "iasn)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_match_issuer_serial(",
          "args": [
            ",",
            "iasn.issuer,",
            "iasn.serialNumber)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_free(",
          "args": [
            "ontext->hx509ctx,",
            ")"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_IssuerAndSerialNumber(",
          "args": [
            "di->val[i].issuerAndSerialNumber->data,",
            "di->val[i].issuerAndSerialNumber->length,",
            "iasn,",
            "size)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to allocate hx509_query\")"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_query_alloc(",
          "args": [
            "ontext->hx509ctx,",
            "q)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't allocate client anchors: %d\",",
            "et)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_init(",
          "args": [
            "ontext->hx509ctx,",
            "MEMORY:client-anchors\",",
            ",",
            "ULL,",
            "cp->client_anchors)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't decode PK-AS-REQ: %d\",",
            "et)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_PK_AS_REQ(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "r,",
            "ULL)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't unwrap ContentInfo(win): %d\",",
            "et)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_PK_AS_REQ_Win2k(",
          "args": [
            "r)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cms_unwrap_ContentInfo(",
          "args": [
            "r.signed_auth_pack,",
            "contentInfoOid,",
            "signed_content,",
            "have_data)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't decode \"\n\t\t\t\t   \"PK-AS-REQ-Win2k: %d\",",
            "et)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_PK_AS_REQ_Win2k(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "r,",
            "ULL)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Anon not supported in RSA mode\")"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_anon_request(",
          "args": [
            "req->req_body)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_verify_set_proxy_certificate(",
          "args": [
            "p->verify_ctx,",
            ")"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_free(",
          "args": [
            "trust_anchors)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_verify_attach_anchors(",
          "args": [
            "p->verify_ctx,",
            "rust_anchors)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_verify_set_time(",
          "args": [
            "p->verify_ctx,",
            "dc_time)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "failed to create verify context\")"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_free(",
          "args": [
            "trust_anchors)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_verify_init_ctx(",
          "args": [
            "ontext->hx509ctx,",
            "cp->verify_ctx)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "ert)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_add(",
          "args": [
            "ontext->hx509ctx,",
            "rust_anchors,",
            "ert)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_init_data(",
          "args": [
            "ontext->hx509ctx,",
            "c->val[i].cert.data,",
            "c->val[i].cert.length,",
            "ULL)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry_get_pkinit_cert(",
          "args": [
            "client->entry,",
            "pc)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "failed to create verify context\")"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_free(",
          "args": [
            "trust_anchors)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_merge(",
          "args": [
            "ontext->hx509ctx,",
            "rust_anchors,",
            "dc_identity->anchors)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "failed to create trust anchors\")"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_init(",
          "args": [
            "ontext->hx509ctx,",
            "MEMORY:trust-anchors\",",
            ",",
            "ULL,",
            "trust_anchors)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*cp))"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_pk_rd_padata(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  const KDC_REQ *req,\n\t\t  const PA_DATA *pa,\n\t\t  hdb_entry_ex *client,\n\t\t  pk_client_params **ret_params)\n{\n    pk_client_params *cp;\n    krb5_error_code ret;\n    heim_oid eContentType = { 0, NULL }, contentInfoOid = { 0, NULL };\n    krb5_data eContent = { 0, NULL };\n    krb5_data signed_content = { 0, NULL };\n    const char *type = \"unknown type\";\n    hx509_certs trust_anchors;\n    int have_data = 0;\n    const HDB_Ext_PKINIT_cert *pc;\n\n    *ret_params = NULL;\n\n    if (!config->enable_pkinit) {\n\tkdc_log(context, config, 0, \"PK-INIT request but PK-INIT not enabled\");\n\tkrb5_clear_error_message(context);\n\treturn 0;\n    }\n\n    cp = calloc(1, sizeof(*cp));\n    if (cp == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t   \"MEMORY:trust-anchors\",\n\t\t\t   0, NULL, &trust_anchors);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"failed to create trust anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_merge(context->hx509ctx, trust_anchors,\n\t\t\t    kdc_identity->anchors);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    /* Add any registered certificates for this client as trust anchors */\n    ret = hdb_entry_get_pkinit_cert(&client->entry, &pc);\n    if (ret == 0 && pc != NULL) {\n\thx509_cert cert;\n\tunsigned int i;\n\n\tfor (i = 0; i < pc->len; i++) {\n\t    cert = hx509_cert_init_data(context->hx509ctx,\n\t\t\t\t\tpc->val[i].cert.data,\n\t\t\t\t\tpc->val[i].cert.length,\n\t\t\t\t\tNULL);\n\t    if (cert == NULL)\n\t\tcontinue;\n\t    hx509_certs_add(context->hx509ctx, trust_anchors, cert);\n\t    hx509_cert_free(cert);\n\t}\n    }\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &cp->verify_ctx);\n    if (ret) {\n\thx509_certs_free(&trust_anchors);\n\tkrb5_set_error_message(context, ret, \"failed to create verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_set_time(cp->verify_ctx, kdc_time);\n    hx509_verify_attach_anchors(cp->verify_ctx, trust_anchors);\n    hx509_certs_free(&trust_anchors);\n\n    if (config->pkinit_allow_proxy_certs)\n\thx509_verify_set_proxy_certificate(cp->verify_ctx, 1);\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tPA_PK_AS_REQ_Win2k r;\n\n\ttype = \"PK-INIT-Win2k\";\n\n\tif (_kdc_is_anon_request(&req->req_body)) {\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = decode_PA_PK_AS_REQ_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&r,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Can't decode \"\n\t\t\t\t   \"PK-AS-REQ-Win2k: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signed_auth_pack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ_Win2k(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo(win): %d\", ret);\n\t    goto out;\n\t}\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tPA_PK_AS_REQ r;\n\n\ttype = \"PK-INIT-IETF\";\n\n\tret = decode_PA_PK_AS_REQ(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &r,\n\t\t\t\t  NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode PK-AS-REQ: %d\", ret);\n\t    goto out;\n\t}\n\n\t/* XXX look at r.kdcPkId */\n\tif (r.trustedCertifiers) {\n\t    ExternalPrincipalIdentifiers *edi = r.trustedCertifiers;\n\t    unsigned int i, maxedi;\n\n\t    ret = hx509_certs_init(context->hx509ctx,\n\t\t\t\t   \"MEMORY:client-anchors\",\n\t\t\t\t   0, NULL,\n\t\t\t\t   &cp->client_anchors);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Can't allocate client anchors: %d\",\n\t\t\t\t       ret);\n\t\tgoto out;\n\n\t    }\n\t    /*\n\t     * If the client sent more then 10 EDI, don't bother\n\t     * looking more then 10 of performance reasons.\n\t     */\n\t    maxedi = edi->len;\n\t    if (maxedi > 10)\n\t\tmaxedi = 10;\n\t    for (i = 0; i < maxedi; i++) {\n\t\tIssuerAndSerialNumber iasn;\n\t\thx509_query *q;\n\t\thx509_cert cert;\n\t\tsize_t size;\n\n\t\tif (edi->val[i].issuerAndSerialNumber == NULL)\n\t\t    continue;\n\n\t\tret = hx509_query_alloc(context->hx509ctx, &q);\n\t\tif (ret) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t  \"Failed to allocate hx509_query\");\n\t\t    goto out;\n\t\t}\n\n\t\tret = decode_IssuerAndSerialNumber(edi->val[i].issuerAndSerialNumber->data,\n\t\t\t\t\t\t   edi->val[i].issuerAndSerialNumber->length,\n\t\t\t\t\t\t   &iasn,\n\t\t\t\t\t\t   &size);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\t\tret = hx509_query_match_issuer_serial(q, &iasn.issuer, &iasn.serialNumber);\n\t\tfree_IssuerAndSerialNumber(&iasn);\n\t\tif (ret) {\n\t\t    hx509_query_free(context->hx509ctx, q);\n\t\t    continue;\n\t\t}\n\n\t\tret = hx509_certs_find(context->hx509ctx,\n\t\t\t\t       kdc_identity->certs,\n\t\t\t\t       q,\n\t\t\t\t       &cert);\n\t\thx509_query_free(context->hx509ctx, q);\n\t\tif (ret)\n\t\t    continue;\n\t\thx509_certs_add(context->hx509ctx,\n\t\t\t\tcp->client_anchors, cert);\n\t\thx509_cert_free(cert);\n\t    }\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&r.signedAuthPack,\n\t\t\t\t\t   &contentInfoOid,\n\t\t\t\t\t   &signed_content,\n\t\t\t\t\t   &have_data);\n\tfree_PA_PK_AS_REQ(&r);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't unwrap ContentInfo: %d\", ret);\n\t    goto out;\n\t}\n\n    } else {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\tgoto out;\n    }\n\n    ret = der_heim_oid_cmp(&contentInfoOid, &asn1_oid_id_pkcs7_signedData);\n    if (ret != 0) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PK-AS-REQ-Win2k invalid content type oid\");\n\tgoto out;\n    }\n\n    if (!have_data) {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t      \"PK-AS-REQ-Win2k no signed auth pack\");\n\tgoto out;\n    }\n\n    {\n\thx509_certs signer_certs;\n\tint flags = HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH; /* BTMM */\n\n\tif (_kdc_is_anon_request(&req->req_body))\n\t    flags |= HX509_CMS_VS_ALLOW_ZERO_SIGNER;\n\n\tret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t      cp->verify_ctx,\n\t\t\t\t      flags,\n\t\t\t\t      signed_content.data,\n\t\t\t\t      signed_content.length,\n\t\t\t\t      NULL,\n\t\t\t\t      kdc_identity->certpool,\n\t\t\t\t      &eContentType,\n\t\t\t\t      &eContent,\n\t\t\t\t      &signer_certs);\n\tif (ret) {\n\t    char *s = hx509_get_error_string(context->hx509ctx, ret);\n\t    krb5_warnx(context, \"PKINIT: failed to verify signature: %s: %d\",\n\t\t       s, ret);\n\t    free(s);\n\t    goto out;\n\t}\n\n\tif (signer_certs) {\n\t    ret = hx509_get_one_cert(context->hx509ctx, signer_certs,\n\t\t\t\t     &cp->cert);\n\t    hx509_certs_free(&signer_certs);\n\t}\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Signature is correct, now verify the signed message */\n    if (der_heim_oid_cmp(&eContentType, &asn1_oid_id_pkcs7_data) != 0 &&\n\tder_heim_oid_cmp(&eContentType, &asn1_oid_id_pkauthdata) != 0)\n    {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret, \"got wrong oid for pkauthdata\");\n\tgoto out;\n    }\n\n    if (pa->padata_type == KRB5_PADATA_PK_AS_REQ_WIN) {\n\tAuthPack_Win2k ap;\n\n\tret = decode_AuthPack_Win2k(eContent.data,\n\t\t\t\t    eContent.length,\n\t\t\t\t    &ap,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator_win2k(context,\n\t\t\t\t\t     &ap.pkAuthenticator,\n\t\t\t\t\t     req);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_WIN2K;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"DH not supported for windows\");\n\t    goto out;\n\t}\n\tfree_AuthPack_Win2k(&ap);\n\n    } else if (pa->padata_type == KRB5_PADATA_PK_AS_REQ) {\n\tAuthPack ap;\n\n\tret = decode_AuthPack(eContent.data,\n\t\t\t      eContent.length,\n\t\t\t      &ap,\n\t\t\t      NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't decode AuthPack: %d\", ret);\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (_kdc_is_anon_request(&req->req_body) &&\n\t    ap.clientPublicValue == NULL) {\n\t    free_AuthPack(&ap);\n\t    ret = KRB5_KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Anon not supported in RSA mode\");\n\t    goto out;\n\t}\n\n\tret = pk_check_pkauthenticator(context,\n\t\t\t\t       &ap.pkAuthenticator,\n\t\t\t\t       req);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tcp->type = PKINIT_27;\n\tcp->nonce = ap.pkAuthenticator.nonce;\n\n\tif (ap.clientPublicValue) {\n\t    if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_dhpublicnumber) == 0) {\n\t\tcp->keyex = USE_DH;\n\t\tret = get_dh_param(context, config,\n\t\t\t\t   ap.clientPublicValue, cp);\n\t    } else if (der_heim_oid_cmp(&ap.clientPublicValue->algorithm.algorithm, &asn1_oid_id_ecPublicKey) == 0) {\n\t\tcp->keyex = USE_ECDH;\n                ret = _kdc_get_ecdh_param(context, config,\n                                          ap.clientPublicValue,\n                                          &cp->u.ecdh.public_key);\n\t    } else {\n\t\tret = KRB5_BADMSGTYPE;\n\t\tkrb5_set_error_message(context, ret, \"PKINIT unknown DH mechanism\");\n\t    }\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else\n\t    cp->keyex = USE_RSA;\n\n\tret = hx509_peer_info_alloc(context->hx509ctx,\n\t\t\t\t\t&cp->peer);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tif (ap.supportedCMSTypes) {\n\t    ret = hx509_peer_info_set_cms_algs(context->hx509ctx,\n\t\t\t\t\t       cp->peer,\n\t\t\t\t\t       ap.supportedCMSTypes->val,\n\t\t\t\t\t       ap.supportedCMSTypes->len);\n\t    if (ret) {\n\t\tfree_AuthPack(&ap);\n\t\tgoto out;\n\t    }\n\t} else {\n\t    /* assume old client */\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_crypto_des_rsdi_ede3_cbc());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_rsa_with_sha1());\n\t    hx509_peer_info_add_cms_alg(context->hx509ctx, cp->peer,\n\t\t\t\t\thx509_signature_sha1());\n\t}\n\tfree_AuthPack(&ap);\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    kdc_log(context, config, 0, \"PK-INIT request of type %s\", type);\n\nout:\n    if (ret)\n\tkrb5_warn(context, ret, \"PKINIT\");\n\n    if (signed_content.data)\n\tfree(signed_content.data);\n    krb5_data_free(&eContent);\n    der_free_oid(&eContentType);\n    der_free_oid(&contentInfoOid);\n    if (ret) {\n        _kdc_pk_free_client_param(context, cp);\n    } else\n\t*ret_params = cp;\n    return ret;\n}"
  },
  {
    "function_name": "et_dh_param(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "295-392",
    "snippet": "tatic krb5_error_code\nget_dh_param(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     SubjectPublicKeyInfo *dh_key_info,\n\t     pk_client_params *client_params)\n{\n    DomainParameters dhparam;\n    DH *dh = NULL;\n    krb5_error_code ret;\n\n    memset(&dhparam, 0, sizeof(dhparam));\n\n    if ((dh_key_info->subjectPublicKey.length % 8) != 0) {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PKINIT: subjectPublicKey not aligned \"\n\t\t\t       \"to 8 bit boundary\");\n\tgoto out;\n    }\n\n    if (dh_key_info->algorithm.parameters == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT missing algorithm parameter \"\n\t\t\t      \"in clientPublicValue\");\n\treturn KRB5_BADMSGTYPE;\n    }\n\n    ret = decode_DomainParameters(dh_key_info->algorithm.parameters->data,\n\t\t\t\t  dh_key_info->algorithm.parameters->length,\n\t\t\t\t  &dhparam,\n\t\t\t\t  NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Can't decode algorithm \"\n\t\t\t       \"parameters in clientPublicValue\");\n\tgoto out;\n    }\n\n    ret = _krb5_dh_group_ok(context, config->pkinit_dh_min_bits,\n\t\t\t    &dhparam.p, &dhparam.g, dhparam.q, moduli,\n\t\t\t    &client_params->dh_group_name);\n    if (ret) {\n\t/* XXX send back proposal of better group */\n\tgoto out;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n\tret = ENOMEM;\n\tkrb5_set_error_message(context, ret, \"Cannot create DH structure\");\n\tgoto out;\n    }\n    ret = KRB5_BADMSGTYPE;\n    dh->p = integer_to_BN(context, \"DH prime\", &dhparam.p);\n    if (dh->p == NULL)\n\tgoto out;\n    dh->g = integer_to_BN(context, \"DH base\", &dhparam.g);\n    if (dh->g == NULL)\n\tgoto out;\n\n    if (dhparam.q) {\n\tdh->q = integer_to_BN(context, \"DH p-1 factor\", dhparam.q);\n\tif (dh->g == NULL)\n\t    goto out;\n    }\n\n    {\n\theim_integer glue;\n\tsize_t size;\n\n\tret = decode_DHPublicKey(dh_key_info->subjectPublicKey.data,\n\t\t\t\t dh_key_info->subjectPublicKey.length / 8,\n\t\t\t\t &glue,\n\t\t\t\t &size);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tclient_params->u.dh.public_key = integer_to_BN(context,\n\t\t\t\t\t\t       \"subjectPublicKey\",\n\t\t\t\t\t\t       &glue);\n\tder_free_heim_integer(&glue);\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5_BADMSGTYPE;\n\t    goto out;\n\t}\n    }\n\n    client_params->u.dh.key = dh;\n    dh = NULL;\n    ret = 0;\n\n out:\n    if (dh)\n\tDH_free(dh);\n    free_DomainParameters(&dhparam);\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_DomainParameters(",
          "args": [
            "dhparam)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_free(",
          "args": [
            "h)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_free_heim_integer(",
          "args": [
            "glue)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nteger_to_BN(",
          "args": [
            "ontext,",
            "subjectPublicKey\",",
            "glue)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nteger_to_BN(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
          "lines": "280-293",
          "snippet": "tatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT: parsing BN failed %s\", field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}",
          "includes": [
            "include \"crypto-headers.h\"",
            "include <hx509.h>\n#",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT: parsing BN failed %s\", field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_DHPublicKey(",
          "args": [
            "h_key_info->subjectPublicKey.data,",
            "h_key_info->subjectPublicKey.length / 8,",
            "glue,",
            "size)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Cannot create DH structure\")"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_new(",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dh_group_ok(",
          "args": [
            "ontext,",
            "onfig->pkinit_dh_min_bits,",
            "dhparam.p,",
            "dhparam.g,",
            "hparam.q,",
            "oduli,",
            "client_params->dh_group_name)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't decode algorithm \"\n\t\t\t       \"parameters in clientPublicValue\")"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_DomainParameters(",
          "args": [
            "h_key_info->algorithm.parameters->data,",
            "h_key_info->algorithm.parameters->length,",
            "dhparam,",
            "ULL)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "RB5_BADMSGTYPE,",
            "PKINIT missing algorithm parameter \"\n\t\t\t      \"in clientPublicValue\")"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "PKINIT: subjectPublicKey not aligned \"\n\t\t\t       \"to 8 bit boundary\")"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "dhparam,",
            ",",
            "izeof(dhparam))"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_dh_param(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     SubjectPublicKeyInfo *dh_key_info,\n\t     pk_client_params *client_params)\n{\n    DomainParameters dhparam;\n    DH *dh = NULL;\n    krb5_error_code ret;\n\n    memset(&dhparam, 0, sizeof(dhparam));\n\n    if ((dh_key_info->subjectPublicKey.length % 8) != 0) {\n\tret = KRB5_BADMSGTYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"PKINIT: subjectPublicKey not aligned \"\n\t\t\t       \"to 8 bit boundary\");\n\tgoto out;\n    }\n\n    if (dh_key_info->algorithm.parameters == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT missing algorithm parameter \"\n\t\t\t      \"in clientPublicValue\");\n\treturn KRB5_BADMSGTYPE;\n    }\n\n    ret = decode_DomainParameters(dh_key_info->algorithm.parameters->data,\n\t\t\t\t  dh_key_info->algorithm.parameters->length,\n\t\t\t\t  &dhparam,\n\t\t\t\t  NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Can't decode algorithm \"\n\t\t\t       \"parameters in clientPublicValue\");\n\tgoto out;\n    }\n\n    ret = _krb5_dh_group_ok(context, config->pkinit_dh_min_bits,\n\t\t\t    &dhparam.p, &dhparam.g, dhparam.q, moduli,\n\t\t\t    &client_params->dh_group_name);\n    if (ret) {\n\t/* XXX send back proposal of better group */\n\tgoto out;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n\tret = ENOMEM;\n\tkrb5_set_error_message(context, ret, \"Cannot create DH structure\");\n\tgoto out;\n    }\n    ret = KRB5_BADMSGTYPE;\n    dh->p = integer_to_BN(context, \"DH prime\", &dhparam.p);\n    if (dh->p == NULL)\n\tgoto out;\n    dh->g = integer_to_BN(context, \"DH base\", &dhparam.g);\n    if (dh->g == NULL)\n\tgoto out;\n\n    if (dhparam.q) {\n\tdh->q = integer_to_BN(context, \"DH p-1 factor\", dhparam.q);\n\tif (dh->g == NULL)\n\t    goto out;\n    }\n\n    {\n\theim_integer glue;\n\tsize_t size;\n\n\tret = decode_DHPublicKey(dh_key_info->subjectPublicKey.data,\n\t\t\t\t dh_key_info->subjectPublicKey.length / 8,\n\t\t\t\t &glue,\n\t\t\t\t &size);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tclient_params->u.dh.public_key = integer_to_BN(context,\n\t\t\t\t\t\t       \"subjectPublicKey\",\n\t\t\t\t\t\t       &glue);\n\tder_free_heim_integer(&glue);\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5_BADMSGTYPE;\n\t    goto out;\n\t}\n    }\n\n    client_params->u.dh.key = dh;\n    dh = NULL;\n    ret = 0;\n\n out:\n    if (dh)\n\tDH_free(dh);\n    free_DomainParameters(&dhparam);\n    return ret;\n}"
  },
  {
    "function_name": "nteger_to_BN(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "280-293",
    "snippet": "tatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT: parsing BN failed %s\", field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "N_set_negative(",
          "args": [
            "n,",
            "->negative)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "RB5_BADMSGTYPE,",
            "PKINIT: parsing BN failed %s\",",
            "ield)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_bin2bn(",
          "args": [
            "const unsigned char *)f->data,",
            "->length,",
            "ULL)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, KRB5_BADMSGTYPE,\n\t\t\t       \"PKINIT: parsing BN failed %s\", field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}"
  },
  {
    "function_name": "enerate_dh_keyblock(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "196-278",
    "snippet": "tatic krb5_error_code\ngenerate_dh_keyblock(krb5_context context,\n\t\t     pk_client_params *client_params,\n                     krb5_enctype enctype)\n{\n    unsigned char *dh_gen_key = NULL;\n    krb5_keyblock key;\n    krb5_error_code ret;\n    size_t dh_gen_keylen, size;\n\n    memset(&key, 0, sizeof(key));\n\n    if (client_params->keyex == USE_DH) {\n\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing DH public_key\");\n\t    goto out;\n\t}\n\n\tif (!DH_generate_key(client_params->u.dh.key)) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't generate Diffie-Hellman keys\");\n\t    goto out;\n\t}\n\n\tsize = DH_size(client_params->u.dh.key);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key,client_params->u.dh.public_key, client_params->u.dh.key);\n\tif (dh_gen_keylen == (size_t)-1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't compute Diffie-Hellman key\");\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n\tret = 0;\n    } else if (client_params->keyex == USE_ECDH) {\n\tif (client_params->u.ecdh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing ECDH public_key\");\n\t    goto out;\n\t}\n        ret = _kdc_generate_ecdh_keyblock(context,\n                                          client_params->u.ecdh.public_key,\n                                          &client_params->u.ecdh.key,\n                                          &dh_gen_key, &dh_gen_keylen);\n        if (ret)\n            goto out;\n    } else {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Diffie-Hellman not selected keys\");\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   enctype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   &client_params->reply_key);\n\n out:\n    if (dh_gen_key)\n\tfree(dh_gen_key);\n    if (key.keyvalue.data)\n\tkrb5_free_keyblock_contents(context, &key);\n\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "key)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "h_gen_key)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pk_octetstring2key(",
          "args": [
            "ontext,",
            "nctype,",
            "h_gen_key,",
            "h_gen_keylen,",
            "ULL,",
            "ULL,",
            "client_params->reply_key)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Diffie-Hellman not selected keys\")"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_generate_ecdh_keyblock(",
          "args": [
            "ontext,",
            "lient_params->u.ecdh.public_key,",
            "client_params->u.ecdh.key,",
            "dh_gen_key,",
            "dh_gen_keylen)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_generate_ecdh_keyblock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit-ec.c",
          "lines": "170-184",
          "snippet": "rb5_error_code\n_kdc_generate_ecdh_keyblock(krb5_context context,\n                            void *ec_key_pk,    /* the client's public key */\n                            void **ec_key_key,  /* the KDC's ephemeral private */\n                            unsigned char **dh_gen_key, /* shared secret */\n                            size_t *dh_gen_keylen)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return generate_ecdh_keyblock(context, ec_key_pk,\n                                  (EC_KEY **)ec_key_key,\n                                  dh_gen_key, dh_gen_keylen);\n#else\n    return ENOTSUP;\n#endif /* HAVE_HCRYPTO_W_OPENSSL */\n}",
          "includes": [
            "include <hx509.h>",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include <hcrypto/des.h>\n#",
            "include \"kdc_locl.h\"\n#",
            "include <openssl/bn.h>\n#",
            "include <openssl/evp.h>\n#",
            "include <openssl/ecdh.h>\n#",
            "include <openssl/ec.h>\n#",
            "include <roken.h>",
            "include <config.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hx509.h>\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude <hcrypto/des.h>\n#\ninclude \"kdc_locl.h\"\n#\ninclude <openssl/bn.h>\n#\ninclude <openssl/evp.h>\n#\ninclude <openssl/ecdh.h>\n#\ninclude <openssl/ec.h>\n#\ninclude <roken.h>\ninclude <config.h>\n#\n\nrb5_error_code\n_kdc_generate_ecdh_keyblock(krb5_context context,\n                            void *ec_key_pk,    /* the client's public key */\n                            void **ec_key_key,  /* the KDC's ephemeral private */\n                            unsigned char **dh_gen_key, /* shared secret */\n                            size_t *dh_gen_keylen)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    return generate_ecdh_keyblock(context, ec_key_pk,\n                                  (EC_KEY **)ec_key_key,\n                                  dh_gen_key, dh_gen_keylen);\n#else\n    return ENOTSUP;\n#endif /* HAVE_HCRYPTO_W_OPENSSL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "missing ECDH public_key\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "h_gen_key,",
            ",",
            "ize)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emmove(",
          "args": [
            "h_gen_key + size,",
            "h_gen_key,",
            "h_gen_keylen)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't compute Diffie-Hellman key\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_compute_key(",
          "args": [
            "h_gen_key,",
            "lient_params->u.dh.public_key,",
            "lient_params->u.dh.key)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "ize)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_size(",
          "args": [
            "lient_params->u.dh.key)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Can't generate Diffie-Hellman keys\")"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_generate_key(",
          "args": [
            "lient_params->u.dh.key)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "missing DH public_key\")"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "key,",
            ",",
            "izeof(key))"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\ngenerate_dh_keyblock(krb5_context context,\n\t\t     pk_client_params *client_params,\n                     krb5_enctype enctype)\n{\n    unsigned char *dh_gen_key = NULL;\n    krb5_keyblock key;\n    krb5_error_code ret;\n    size_t dh_gen_keylen, size;\n\n    memset(&key, 0, sizeof(key));\n\n    if (client_params->keyex == USE_DH) {\n\n\tif (client_params->u.dh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing DH public_key\");\n\t    goto out;\n\t}\n\n\tif (!DH_generate_key(client_params->u.dh.key)) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't generate Diffie-Hellman keys\");\n\t    goto out;\n\t}\n\n\tsize = DH_size(client_params->u.dh.key);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key,client_params->u.dh.public_key, client_params->u.dh.key);\n\tif (dh_gen_keylen == (size_t)-1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Can't compute Diffie-Hellman key\");\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n\tret = 0;\n    } else if (client_params->keyex == USE_ECDH) {\n\tif (client_params->u.ecdh.public_key == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret, \"missing ECDH public_key\");\n\t    goto out;\n\t}\n        ret = _kdc_generate_ecdh_keyblock(context,\n                                          client_params->u.ecdh.public_key,\n                                          &client_params->u.ecdh.key,\n                                          &dh_gen_key, &dh_gen_keylen);\n        if (ret)\n            goto out;\n    } else {\n\tret = KRB5KRB_ERR_GENERIC;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       \"Diffie-Hellman not selected keys\");\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   enctype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   &client_params->reply_key);\n\n out:\n    if (dh_gen_key)\n\tfree(dh_gen_key);\n    if (key.keyvalue.data)\n\tkrb5_free_keyblock_contents(context, &key);\n\n    return ret;\n}"
  },
  {
    "function_name": "kdc_pk_free_client_param(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "167-194",
    "snippet": "oid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "p)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "p,",
            ",",
            "izeof(*cp))"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_certs_free(",
          "args": [
            "cp->client_anchors)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_peer_info_free(",
          "args": [
            "p->peer)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "p->dh_group_name)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "cp->reply_key)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_pk_free_client_ec_param(",
          "args": [
            "ontext,",
            "p->u.ecdh.key,",
            "p->u.ecdh.public_key)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pk_free_client_ec_param(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit-ec.c",
          "lines": "86-94",
          "snippet": "oid\n_kdc_pk_free_client_ec_param(krb5_context context,\n                             void *ec_key_pk,\n                             void *ec_key_key)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    free_client_ec_param(context, ec_key_pk, ec_key_key);\n#endif\n}",
          "includes": [
            "include <hx509.h>",
            "include <pkinit_asn1.h>",
            "include <cms_asn1.h>\n#",
            "include <rfc2459_asn1.h>\n#",
            "include <heim_asn1.h>\n#",
            "include <hcrypto/des.h>\n#",
            "include \"kdc_locl.h\"\n#",
            "include <openssl/bn.h>\n#",
            "include <openssl/evp.h>\n#",
            "include <openssl/ecdh.h>\n#",
            "include <openssl/ec.h>\n#",
            "include <roken.h>",
            "include <config.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hx509.h>\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude <hcrypto/des.h>\n#\ninclude \"kdc_locl.h\"\n#\ninclude <openssl/bn.h>\n#\ninclude <openssl/evp.h>\n#\ninclude <openssl/ecdh.h>\n#\ninclude <openssl/ec.h>\n#\ninclude <roken.h>\ninclude <config.h>\n#\n\noid\n_kdc_pk_free_client_ec_param(krb5_context context,\n                             void *ec_key_pk,\n                             void *ec_key_key)\n{\n#ifdef HAVE_HCRYPTO_W_OPENSSL\n    free_client_ec_param(context, ec_key_pk, ec_key_key);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_free(",
          "args": [
            "p->u.dh.public_key)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "H_free(",
          "args": [
            "p->u.dh.key)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_verify_destroy_ctx(",
          "args": [
            "p->verify_ctx)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x509_cert_free(",
          "args": [
            "p->cert)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\noid\n_kdc_pk_free_client_param(krb5_context context, pk_client_params *cp)\n{\n    if (cp == NULL)\n        return;\n    if (cp->cert)\n\thx509_cert_free(cp->cert);\n    if (cp->verify_ctx)\n\thx509_verify_destroy_ctx(cp->verify_ctx);\n    if (cp->keyex == USE_DH) {\n\tif (cp->u.dh.key)\n\t    DH_free(cp->u.dh.key);\n\tif (cp->u.dh.public_key)\n\t    BN_free(cp->u.dh.public_key);\n    }\n    if (cp->keyex == USE_ECDH)\n        _kdc_pk_free_client_ec_param(context, cp->u.ecdh.key,\n                                     cp->u.ecdh.public_key);\n    krb5_free_keyblock_contents(context, &cp->reply_key);\n    if (cp->dh_group_name)\n\tfree(cp->dh_group_name);\n    if (cp->peer)\n\thx509_peer_info_free(cp->peer);\n    if (cp->client_anchors)\n\thx509_certs_free(&cp->client_anchors);\n    memset(cp, 0, sizeof(*cp));\n    free(cp);\n}"
  },
  {
    "function_name": "k_check_pkauthenticator(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "109-165",
    "snippet": "tatic krb5_error_code\npk_check_pkauthenticator(krb5_context context,\n\t\t\t PKAuthenticator *a,\n\t\t\t const KDC_REQ *req)\n{\n    u_char *buf = NULL;\n    size_t buf_size;\n    krb5_error_code ret;\n    size_t len = 0;\n    krb5_timestamp now;\n    Checksum checksum;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, &req->req_body, &len, ret);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n    if (buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n\n    if (a->paChecksum == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5_KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n\tgoto out;\n    }\n\n    if (der_heim_octet_string_cmp(a->paChecksum, &checksum.checksum) != 0) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KRB_ERR_GENERIC;\n    }\n\nout:\n    free_Checksum(&checksum);\n\n    return ret;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "checksum)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_heim_octet_string_cmp(",
          "args": [
            "->paChecksum,",
            "checksum.checksum)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "ontext,",
            "ULL,",
            ",",
            "KSUMTYPE_SHA1,",
            "uf,",
            "en,",
            "checksum)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "Internal error in ASN.1 encoder\")"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "DC_REQ_BODY,",
            "uf,",
            "uf_size,",
            "req->req_body,",
            "len,",
            "et)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "->ctime - now)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_timeofday",
          "args": [
            "ontext,",
            "now)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_check_pkauthenticator(krb5_context context,\n\t\t\t PKAuthenticator *a,\n\t\t\t const KDC_REQ *req)\n{\n    u_char *buf = NULL;\n    size_t buf_size;\n    krb5_error_code ret;\n    size_t len = 0;\n    krb5_timestamp now;\n    Checksum checksum;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, &req->req_body, &len, ret);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n    if (buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret) {\n\tkrb5_clear_error_message(context);\n\treturn ret;\n    }\n\n    if (a->paChecksum == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5_KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n\tgoto out;\n    }\n\n    if (der_heim_octet_string_cmp(a->paChecksum, &checksum.checksum) != 0) {\n\tkrb5_clear_error_message(context);\n\tret = KRB5KRB_ERR_GENERIC;\n    }\n\nout:\n    free_Checksum(&checksum);\n\n    return ret;\n}"
  },
  {
    "function_name": "k_check_pkauthenticator_win2k(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/pkinit.c",
    "lines": "92-107",
    "snippet": "tatic krb5_error_code\npk_check_pkauthenticator_win2k(krb5_context context,\n\t\t\t       PKAuthenticator_Win2k *a,\n\t\t\t       const KDC_REQ *req)\n{\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n    return 0;\n}",
    "includes": [
      "include \"crypto-headers.h\"",
      "include <hx509.h>\n#",
      "include <pkinit_asn1.h>",
      "include <cms_asn1.h>\n#",
      "include <rfc2459_asn1.h>\n#",
      "include <heim_asn1.h>\n#",
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "->ctime - now)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_timeofday",
          "args": [
            "ontext,",
            "now)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"crypto-headers.h\"\ninclude <hx509.h>\n#\ninclude <pkinit_asn1.h>\ninclude <cms_asn1.h>\n#\ninclude <rfc2459_asn1.h>\n#\ninclude <heim_asn1.h>\n#\ninclude \"kdc_locl.h\"\n\ntatic krb5_error_code\npk_check_pkauthenticator_win2k(krb5_context context,\n\t\t\t       PKAuthenticator_Win2k *a,\n\t\t\t       const KDC_REQ *req)\n{\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    /* XXX cusec */\n    if (a->ctime == 0 || labs(a->ctime - now) > context->max_skew) {\n\tkrb5_clear_error_message(context);\n\treturn KRB5KRB_AP_ERR_SKEW;\n    }\n    return 0;\n}"
  }
]