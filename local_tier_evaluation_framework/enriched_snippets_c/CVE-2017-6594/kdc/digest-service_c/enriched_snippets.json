[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest-service.c",
    "lines": "236-284",
    "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_context context;\n    int ret, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if (getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if (help_flag)\n\tusage(0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\tkrb5_errx(context, 1, \"krb5_init_context\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"digest-service\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#if __APPLE__\n    {\n\theim_sipc mach;\n\theim_sipc_launchd_mach_init(\"org.h5l.ntlm-service\",\n\t\t\t\t    ntlm_service, context, &mach);\n\theim_sipc_timeout(60);\n    }\n#endif\n    {\n\theim_sipc un;\n\theim_sipc_service_unix(\"org.h5l.ntlm-service\", ntlm_service, NULL, &un);\n    }\n\n    heim_ipc_main();\n    return 0;\n}",
    "includes": [
      "include <kdc-private.h>",
      "include <getarg.h>",
      "include <heim-ipc.h>\n#",
      "include <heimntlm.h>\n#",
      "include <digest_asn1.h>\n#",
      "include \"headers.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "rb5_kdc_configuration *config;",
      "tatic int help_flag;",
      "tatic int version_flag;",
      "tatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};",
      "tatic int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eim_ipc_main(",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_sipc_service_unix(",
          "args": [
            "org.h5l.ntlm-service\",",
            "tlm_service,",
            "ULL,",
            "un)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_sipc_timeout(",
          "args": [
            "0)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_sipc_launchd_mach_init(",
          "args": [
            "org.h5l.ntlm-service\",",
            "tlm_service,",
            "ontext,",
            "mach)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kdc_set_dbinfo\")"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_set_dbinfo(",
          "args": [
            "ontext,",
            "onfig)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_set_dbinfo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/set_dbinfo.c",
          "lines": "67-111",
          "snippet": "rb5_error_code\nkrb5_kdc_set_dbinfo(krb5_context context, struct krb5_kdc_configuration *c)\n{\n    struct hdb_dbinfo *info, *d;\n    krb5_error_code ret;\n    int i;\n\n    /* fetch the databases */\n    ret = hdb_get_dbinfo(context, &info);\n    if (ret)\n\treturn ret;\n\n    d = NULL;\n    while ((d = hdb_dbinfo_get_next(info, d)) != NULL) {\n\n\tret = add_db(context, c,\n\t\t     hdb_dbinfo_get_dbname(context, d),\n\t\t     hdb_dbinfo_get_mkey_file(context, d));\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, c, 0, \"label: %s\",\n\t\thdb_dbinfo_get_label(context, d));\n\tkdc_log(context, c, 0, \"\\tdbname: %s\",\n\t\thdb_dbinfo_get_dbname(context, d));\n\tkdc_log(context, c, 0, \"\\tmkey_file: %s\",\n\t\thdb_dbinfo_get_mkey_file(context, d));\n\tkdc_log(context, c, 0, \"\\tacl_file: %s\",\n\t\thdb_dbinfo_get_acl_file(context, d));\n    }\n    hdb_free_dbinfo(context, &info);\n\n    return 0;\nout:\n    for (i = 0; i < c->num_db; i++)\n\tif (c->db[i] && c->db[i]->hdb_destroy)\n\t    (*c->db[i]->hdb_destroy)(context, c->db[i]);\n    c->num_db = 0;\n    free(c->db);\n    c->db = NULL;\n\n    hdb_free_dbinfo(context, &info);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkrb5_kdc_set_dbinfo(krb5_context context, struct krb5_kdc_configuration *c)\n{\n    struct hdb_dbinfo *info, *d;\n    krb5_error_code ret;\n    int i;\n\n    /* fetch the databases */\n    ret = hdb_get_dbinfo(context, &info);\n    if (ret)\n\treturn ret;\n\n    d = NULL;\n    while ((d = hdb_dbinfo_get_next(info, d)) != NULL) {\n\n\tret = add_db(context, c,\n\t\t     hdb_dbinfo_get_dbname(context, d),\n\t\t     hdb_dbinfo_get_mkey_file(context, d));\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, c, 0, \"label: %s\",\n\t\thdb_dbinfo_get_label(context, d));\n\tkdc_log(context, c, 0, \"\\tdbname: %s\",\n\t\thdb_dbinfo_get_dbname(context, d));\n\tkdc_log(context, c, 0, \"\\tmkey_file: %s\",\n\t\thdb_dbinfo_get_mkey_file(context, d));\n\tkdc_log(context, c, 0, \"\\tacl_file: %s\",\n\t\thdb_dbinfo_get_acl_file(context, d));\n    }\n    hdb_free_dbinfo(context, &info);\n\n    return 0;\nout:\n    for (i = 0; i < c->num_db; i++)\n\tif (c->db[i] && c->db[i]->hdb_destroy)\n\t    (*c->db[i]->hdb_destroy)(context, c->db[i]);\n    c->num_db = 0;\n    free(c->db);\n    c->db = NULL;\n\n    hdb_free_dbinfo(context, &info);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_openlog(",
          "args": [
            "ontext,",
            "digest-service\",",
            "onfig)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "dc_openlog(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "38-61",
          "snippet": "oid\nkdc_openlog(krb5_context context,\n\t    const char *service,\n\t    krb5_kdc_configuration *config)\n{\n    char **s = NULL, **p;\n    krb5_initlog(context, \"kdc\", &config->logf);\n    s = krb5_config_get_strings(context, NULL, service, \"logging\", NULL);\n    if(s == NULL)\n\ts = krb5_config_get_strings(context, NULL, \"logging\", service, NULL);\n    if(s){\n\tfor(p = s; *p; p++)\n\t    krb5_addlog_dest(context, config->logf, *p);\n\tkrb5_config_free_strings(s);\n    }else {\n\tchar *ss;\n\tif (asprintf(&ss, \"0-1/FILE:%s/%s\", hdb_db_dir(context),\n\t    KDC_LOG_FILE) < 0)\n\t    err(1, \"out of memory\");\n\tkrb5_addlog_dest(context, config->logf, ss);\n\tfree(ss);\n    }\n    krb5_set_warn_dest(context, config->logf);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_openlog(krb5_context context,\n\t    const char *service,\n\t    krb5_kdc_configuration *config)\n{\n    char **s = NULL, **p;\n    krb5_initlog(context, \"kdc\", &config->logf);\n    s = krb5_config_get_strings(context, NULL, service, \"logging\", NULL);\n    if(s == NULL)\n\ts = krb5_config_get_strings(context, NULL, \"logging\", service, NULL);\n    if(s){\n\tfor(p = s; *p; p++)\n\t    krb5_addlog_dest(context, config->logf, *p);\n\tkrb5_config_free_strings(s);\n    }else {\n\tchar *ss;\n\tif (asprintf(&ss, \"0-1/FILE:%s/%s\", hdb_db_dir(context),\n\t    KDC_LOG_FILE) < 0)\n\t    err(1, \"out of memory\");\n\tkrb5_addlog_dest(context, config->logf, ss);\n\tfree(ss);\n    }\n    krb5_set_warn_dest(context, config->logf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kdc_default_config\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_get_config(",
          "args": [
            "ontext,",
            "config)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_get_config(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/default_config.c",
          "lines": "40-262",
          "snippet": "rb5_error_code\nkrb5_kdc_get_config(krb5_context context, krb5_kdc_configuration **config)\n{\n    krb5_kdc_configuration *c;\n\n    c = calloc(1, sizeof(*c));\n    if (c == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n\treturn ENOMEM;\n    }\n\n    c->num_kdc_processes = -1;\n    c->require_preauth = TRUE;\n    c->kdc_warn_pwexpire = 0;\n    c->encode_as_rep_as_tgs_rep = FALSE;\n    c->tgt_use_strongest_session_key = FALSE;\n    c->preauth_use_strongest_session_key = FALSE;\n    c->svc_use_strongest_session_key = FALSE;\n    c->use_strongest_server_key = TRUE;\n    c->check_ticket_addresses = TRUE;\n    c->allow_null_ticket_addresses = TRUE;\n    c->allow_anonymous = FALSE;\n    c->strict_nametypes = FALSE;\n    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n    c->enable_pkinit = FALSE;\n    c->pkinit_princ_in_cert = TRUE;\n    c->pkinit_require_binding = TRUE;\n    c->db = NULL;\n    c->num_db = 0;\n    c->logf = NULL;\n\n    c->num_kdc_processes =\n        krb5_config_get_int_default(context, NULL, c->num_kdc_processes,\n\t\t\t\t    \"kdc\", \"num-kdc-processes\", NULL);\n\n    c->require_preauth =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->require_preauth,\n\t\t\t\t     \"kdc\", \"require-preauth\", NULL);\n#ifdef DIGEST\n    c->enable_digest =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-digest\", NULL);\n\n    {\n\tconst char *digests;\n\n\tdigests = krb5_config_get_string(context, NULL,\n\t\t\t\t\t \"kdc\",\n\t\t\t\t\t \"digests_allowed\", NULL);\n\tif (digests == NULL)\n\t    digests = \"ntlm-v2\";\n\tc->digests_allowed = parse_flags(digests,_kdc_digestunits, 0);\n\tif (c->digests_allowed == -1) {\n\t    kdc_log(context, c, 0,\n\t\t    \"unparsable digest units (%s), turning off digest\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t} else if (c->digests_allowed == 0) {\n\t    kdc_log(context, c, 0,\n\t\t    \"no digest enable, turning digest off\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t}\n    }\n#endif\n\n#ifdef KX509\n    c->enable_kx509 =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-kx509\", NULL);\n\n    if (c->enable_kx509) {\n\tc->kx509_template =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_template\", NULL);\n\tc->kx509_ca =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_ca\", NULL);\n\tif (c->kx509_ca == NULL || c->kx509_template == NULL) {\n\t    kdc_log(context, c, 0,\n\t\t    \"missing kx509 configuration, turning off\");\n\t    c->enable_kx509 = FALSE;\n\t}\n    }\n#endif\n\n    c->tgt_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->tgt_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"tgt-use-strongest-session-key\", NULL);\n    c->preauth_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->preauth_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"preauth-use-strongest-session-key\", NULL);\n    c->svc_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->svc_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"svc-use-strongest-session-key\", NULL);\n    c->use_strongest_server_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->use_strongest_server_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"use-strongest-server-key\", NULL);\n\n    c->check_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->check_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"check-ticket-addresses\", NULL);\n    c->allow_null_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_null_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-null-ticket-addresses\", NULL);\n\n    c->allow_anonymous =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_anonymous,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-anonymous\", NULL);\n\n    c->strict_nametypes =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->strict_nametypes,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"strict-nametypes\", NULL);\n\n    c->max_datagram_reply_length =\n\tkrb5_config_get_int_default(context,\n\t\t\t\t    NULL,\n\t\t\t\t    1400,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-kdc-datagram-reply-length\",\n\t\t\t\t    NULL);\n\n    {\n\tconst char *trpolicy_str;\n\n\ttrpolicy_str =\n\t    krb5_config_get_string_default(context, NULL, \"DEFAULT\", \"kdc\",\n\t\t\t\t\t   \"transited-policy\", NULL);\n\tif(strcasecmp(trpolicy_str, \"always-check\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n\t} else if(strcasecmp(trpolicy_str, \"allow-per-principal\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALLOW_PER_PRINCIPAL;\n\t} else if(strcasecmp(trpolicy_str, \"always-honour-request\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_HONOUR_REQUEST;\n\t} else if(strcasecmp(trpolicy_str, \"DEFAULT\") == 0) {\n\t    /* default */\n\t} else {\n\t    kdc_log(context, c, 0,\n\t\t    \"unknown transited-policy: %s, \"\n\t\t    \"reverting to default (always-check)\",\n\t\t    trpolicy_str);\n\t}\n    }\n\n    c->encode_as_rep_as_tgs_rep =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->encode_as_rep_as_tgs_rep,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"encode_as_rep_as_tgs_rep\", NULL);\n\n    c->kdc_warn_pwexpire =\n\tkrb5_config_get_time_default (context, NULL,\n\t\t\t\t      c->kdc_warn_pwexpire,\n\t\t\t\t      \"kdc\", \"kdc_warn_pwexpire\", NULL);\n\n\n    c->enable_pkinit =\n\tkrb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     c->enable_pkinit,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"enable-pkinit\",\n\t\t\t\t     NULL);\n\n\n    c->pkinit_kdc_identity =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_identity\", NULL);\n    c->pkinit_kdc_anchors =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_anchors\", NULL);\n    c->pkinit_kdc_cert_pool =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_pool\", NULL);\n    c->pkinit_kdc_revoke =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_revoke\", NULL);\n    c->pkinit_kdc_ocsp_file =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_ocsp\", NULL);\n    c->pkinit_kdc_friendly_name =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_friendly_name\", NULL);\n    c->pkinit_princ_in_cert =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_princ_in_cert,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_principal_in_certificate\",\n\t\t\t\t     NULL);\n    c->pkinit_require_binding =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_require_binding,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_win2k_require_binding\",\n\t\t\t\t     NULL);\n    c->pkinit_dh_min_bits =\n\tkrb5_config_get_int_default(context, NULL,\n\t\t\t\t    0,\n\t\t\t\t    \"kdc\", \"pkinit_dh_min_bits\", NULL);\n\n    *config = c;\n\n    return 0;\n}",
          "includes": [
            "include <parse_bytes.h>",
            "include <getarg.h>\n#",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <parse_bytes.h>\ninclude <getarg.h>\n#\ninclude \"kdc_locl.h\"\n#\n\nrb5_error_code\nkrb5_kdc_get_config(krb5_context context, krb5_kdc_configuration **config)\n{\n    krb5_kdc_configuration *c;\n\n    c = calloc(1, sizeof(*c));\n    if (c == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n\treturn ENOMEM;\n    }\n\n    c->num_kdc_processes = -1;\n    c->require_preauth = TRUE;\n    c->kdc_warn_pwexpire = 0;\n    c->encode_as_rep_as_tgs_rep = FALSE;\n    c->tgt_use_strongest_session_key = FALSE;\n    c->preauth_use_strongest_session_key = FALSE;\n    c->svc_use_strongest_session_key = FALSE;\n    c->use_strongest_server_key = TRUE;\n    c->check_ticket_addresses = TRUE;\n    c->allow_null_ticket_addresses = TRUE;\n    c->allow_anonymous = FALSE;\n    c->strict_nametypes = FALSE;\n    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n    c->enable_pkinit = FALSE;\n    c->pkinit_princ_in_cert = TRUE;\n    c->pkinit_require_binding = TRUE;\n    c->db = NULL;\n    c->num_db = 0;\n    c->logf = NULL;\n\n    c->num_kdc_processes =\n        krb5_config_get_int_default(context, NULL, c->num_kdc_processes,\n\t\t\t\t    \"kdc\", \"num-kdc-processes\", NULL);\n\n    c->require_preauth =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->require_preauth,\n\t\t\t\t     \"kdc\", \"require-preauth\", NULL);\n#ifdef DIGEST\n    c->enable_digest =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-digest\", NULL);\n\n    {\n\tconst char *digests;\n\n\tdigests = krb5_config_get_string(context, NULL,\n\t\t\t\t\t \"kdc\",\n\t\t\t\t\t \"digests_allowed\", NULL);\n\tif (digests == NULL)\n\t    digests = \"ntlm-v2\";\n\tc->digests_allowed = parse_flags(digests,_kdc_digestunits, 0);\n\tif (c->digests_allowed == -1) {\n\t    kdc_log(context, c, 0,\n\t\t    \"unparsable digest units (%s), turning off digest\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t} else if (c->digests_allowed == 0) {\n\t    kdc_log(context, c, 0,\n\t\t    \"no digest enable, turning digest off\",\n\t\t    digests);\n\t    c->enable_digest = 0;\n\t}\n    }\n#endif\n\n#ifdef KX509\n    c->enable_kx509 =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"kdc\", \"enable-kx509\", NULL);\n\n    if (c->enable_kx509) {\n\tc->kx509_template =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_template\", NULL);\n\tc->kx509_ca =\n\t    krb5_config_get_string(context, NULL,\n\t\t\t\t   \"kdc\", \"kx509_ca\", NULL);\n\tif (c->kx509_ca == NULL || c->kx509_template == NULL) {\n\t    kdc_log(context, c, 0,\n\t\t    \"missing kx509 configuration, turning off\");\n\t    c->enable_kx509 = FALSE;\n\t}\n    }\n#endif\n\n    c->tgt_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->tgt_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"tgt-use-strongest-session-key\", NULL);\n    c->preauth_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->preauth_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"preauth-use-strongest-session-key\", NULL);\n    c->svc_use_strongest_session_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->svc_use_strongest_session_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"svc-use-strongest-session-key\", NULL);\n    c->use_strongest_server_key =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->use_strongest_server_key,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"use-strongest-server-key\", NULL);\n\n    c->check_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->check_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"check-ticket-addresses\", NULL);\n    c->allow_null_ticket_addresses =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_null_ticket_addresses,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-null-ticket-addresses\", NULL);\n\n    c->allow_anonymous =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->allow_anonymous,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"allow-anonymous\", NULL);\n\n    c->strict_nametypes =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->strict_nametypes,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"strict-nametypes\", NULL);\n\n    c->max_datagram_reply_length =\n\tkrb5_config_get_int_default(context,\n\t\t\t\t    NULL,\n\t\t\t\t    1400,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-kdc-datagram-reply-length\",\n\t\t\t\t    NULL);\n\n    {\n\tconst char *trpolicy_str;\n\n\ttrpolicy_str =\n\t    krb5_config_get_string_default(context, NULL, \"DEFAULT\", \"kdc\",\n\t\t\t\t\t   \"transited-policy\", NULL);\n\tif(strcasecmp(trpolicy_str, \"always-check\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_CHECK;\n\t} else if(strcasecmp(trpolicy_str, \"allow-per-principal\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALLOW_PER_PRINCIPAL;\n\t} else if(strcasecmp(trpolicy_str, \"always-honour-request\") == 0) {\n\t    c->trpolicy = TRPOLICY_ALWAYS_HONOUR_REQUEST;\n\t} else if(strcasecmp(trpolicy_str, \"DEFAULT\") == 0) {\n\t    /* default */\n\t} else {\n\t    kdc_log(context, c, 0,\n\t\t    \"unknown transited-policy: %s, \"\n\t\t    \"reverting to default (always-check)\",\n\t\t    trpolicy_str);\n\t}\n    }\n\n    c->encode_as_rep_as_tgs_rep =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->encode_as_rep_as_tgs_rep,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"encode_as_rep_as_tgs_rep\", NULL);\n\n    c->kdc_warn_pwexpire =\n\tkrb5_config_get_time_default (context, NULL,\n\t\t\t\t      c->kdc_warn_pwexpire,\n\t\t\t\t      \"kdc\", \"kdc_warn_pwexpire\", NULL);\n\n\n    c->enable_pkinit =\n\tkrb5_config_get_bool_default(context,\n\t\t\t\t     NULL,\n\t\t\t\t     c->enable_pkinit,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"enable-pkinit\",\n\t\t\t\t     NULL);\n\n\n    c->pkinit_kdc_identity =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_identity\", NULL);\n    c->pkinit_kdc_anchors =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_anchors\", NULL);\n    c->pkinit_kdc_cert_pool =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_pool\", NULL);\n    c->pkinit_kdc_revoke =\n\tkrb5_config_get_strings(context, NULL,\n\t\t\t\t\"kdc\", \"pkinit_revoke\", NULL);\n    c->pkinit_kdc_ocsp_file =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_ocsp\", NULL);\n    c->pkinit_kdc_friendly_name =\n\tkrb5_config_get_string(context, NULL,\n\t\t\t       \"kdc\", \"pkinit_kdc_friendly_name\", NULL);\n    c->pkinit_princ_in_cert =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_princ_in_cert,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_principal_in_certificate\",\n\t\t\t\t     NULL);\n    c->pkinit_require_binding =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     c->pkinit_require_binding,\n\t\t\t\t     \"kdc\",\n\t\t\t\t     \"pkinit_win2k_require_binding\",\n\t\t\t\t     NULL);\n    c->pkinit_dh_min_bits =\n\tkrb5_config_get_int_default(context, NULL,\n\t\t\t\t    0,\n\t\t\t\t    \"kdc\", \"pkinit_dh_min_bits\", NULL);\n\n    *config = c;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "krb5_init_context\")"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_context(",
          "args": [
            "context)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit(",
          "args": [
            ")"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_version(",
          "args": [
            "ULL)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sage(",
          "args": [
            ")"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sage(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest-service.c",
          "lines": "229-234",
          "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"\");\n    exit (ret);\n}",
          "includes": [
            "include <kdc-private.h>",
            "include <getarg.h>",
            "include <heim-ipc.h>\n#",
            "include <heimntlm.h>\n#",
            "include <digest_asn1.h>\n#",
            "include \"headers.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};",
            "tatic int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include <kdc-private.h>\ninclude <getarg.h>\ninclude <heim-ipc.h>\n#\ninclude <heimntlm.h>\n#\ninclude <digest_asn1.h>\n#\ninclude \"headers.h\"\n#\n\ntatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"\");\n    exit (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "etarg(",
          "args": [
            "rgs,",
            "um_args,",
            "rgc,",
            "rgv,",
            "optidx)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etprogname(",
          "args": [
            "rgv[0])"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kdc-private.h>\ninclude <getarg.h>\ninclude <heim-ipc.h>\n#\ninclude <heimntlm.h>\n#\ninclude <digest_asn1.h>\n#\ninclude \"headers.h\"\n#\n\nrb5_kdc_configuration *config;\ntatic int help_flag;\ntatic int version_flag;\ntatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_context context;\n    int ret, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if (getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if (help_flag)\n\tusage(0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\tkrb5_errx(context, 1, \"krb5_init_context\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"digest-service\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#if __APPLE__\n    {\n\theim_sipc mach;\n\theim_sipc_launchd_mach_init(\"org.h5l.ntlm-service\",\n\t\t\t\t    ntlm_service, context, &mach);\n\theim_sipc_timeout(60);\n    }\n#endif\n    {\n\theim_sipc un;\n\theim_sipc_service_unix(\"org.h5l.ntlm-service\", ntlm_service, NULL, &un);\n    }\n\n    heim_ipc_main();\n    return 0;\n}"
  },
  {
    "function_name": "sage(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest-service.c",
    "lines": "229-234",
    "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"\");\n    exit (ret);\n}",
    "includes": [
      "include <kdc-private.h>",
      "include <getarg.h>",
      "include <heim-ipc.h>\n#",
      "include <heimntlm.h>\n#",
      "include <digest_asn1.h>\n#",
      "include \"headers.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};",
      "tatic int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xit",
          "args": [
            "et)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg_printusage",
          "args": [
            "rgs,",
            "um_args,",
            "ULL,",
            "\")"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kdc-private.h>\ninclude <getarg.h>\ninclude <heim-ipc.h>\n#\ninclude <heimntlm.h>\n#\ninclude <digest_asn1.h>\n#\ninclude \"headers.h\"\n#\n\ntatic struct getargs args[] = {\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"\");\n    exit (ret);\n}"
  },
  {
    "function_name": "tlm_service(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest-service.c",
    "lines": "53-217",
    "snippet": "tatic void\nntlm_service(void *ctx, const heim_idata *req,\n\t     const heim_icred cred,\n\t     heim_ipc_complete complete,\n\t     heim_sipc_call cctx)\n{\n    NTLMRequest2 ntq;\n    unsigned char sessionkey[16];\n    heim_idata rep = { 0, NULL };\n    krb5_context context = ctx;\n    hdb_entry_ex *user = NULL;\n    Key *key = NULL;\n    NTLMReply ntp;\n    size_t size;\n    int ret;\n    const char *domain;\n\n    kdc_log(context, config, 1, \"digest-request: uid=%d\",\n\t    (int)heim_ipc_cred_get_uid(cred));\n\n    if (heim_ipc_cred_get_uid(cred) != 0) {\n\t(*complete)(cctx, EPERM, NULL);\n\treturn;\n    }\n\n    ntp.success = 0;\n    ntp.flags = 0;\n    ntp.sessionkey = NULL;\n\n    ret = decode_NTLMRequest2(req->data, req->length, &ntq, NULL);\n    if (ret)\n\tgoto failed;\n\n    /* XXX forward to NetrLogonSamLogonEx() if not a local domain */\n    if (strcmp(ntq.loginDomainName, \"BUILTIN\") == 0) {\n\tdomain = ntq.loginDomainName;\n    } else if (strcmp(ntq.loginDomainName, \"\") == 0) {\n\tdomain = \"BUILTIN\";\n    } else {\n\tret = EINVAL;\n\tgoto failed;\n    }\n\n    kdc_log(context, config, 1, \"digest-request: user=%s/%s\",\n\t    ntq.loginUserName, domain);\n\n    if (ntq.lmchallenge.length != 8)\n\tgoto failed;\n\n    if (ntq.ntChallengeResponce.length == 0)\n\tgoto failed;\n\n    {\n\tkrb5_principal client;\n\n\tret = krb5_make_principal(context, &client, domain,\n\t\t\t\t  ntq.loginUserName, NULL);\n\tif (ret)\n\t    goto failed;\n\n\tkrb5_principal_set_type(context, client, KRB5_NT_NTLM);\n\n\tret = _kdc_db_fetch(context, config, client,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, client);\n\tif (ret)\n\t    goto failed;\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto failed;\n\t}\n    }\n\n    kdc_log(context, config, 2,\n\t    \"digest-request: found user, processing ntlm request\", ret);\n\n    if (ntq.ntChallengeResponce.length != 24) {\n\tstruct ntlm_buf infotarget, answer;\n\n\tanswer.length = ntq.ntChallengeResponce.length;\n\tanswer.data = ntq.ntChallengeResponce.data;\n\n\tret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length,\n\t\t\t\t     ntq.loginUserName,\n\t\t\t\t     ntq.loginDomainName,\n\t\t\t\t     0,\n\t\t\t\t     ntq.lmchallenge.data,\n\t\t\t\t     &answer,\n\t\t\t\t     &infotarget,\n\t\t\t\t     sessionkey);\n\tif (ret) {\n\t    goto failed;\n\t}\n\n\tfree(infotarget.data);\n\t/* XXX verify info target */\n\n    } else {\n\tstruct ntlm_buf answer;\n\n\tif (ntq.flags & NTLM_NEG_NTLM2_SESSION) {\n\t    unsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t    EVP_MD_CTX *md5ctx;\n\n\t    /* the first first 8 bytes is the challenge, what is the other 16 bytes ? */\n\t    if (ntq.lmChallengeResponce.length != 24)\n\t\tgoto failed;\n\n\t    md5ctx = EVP_MD_CTX_create();\n\t    EVP_DigestInit_ex(md5ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(md5ctx, ntq.lmchallenge.data, 8);\n\t    EVP_DigestUpdate(md5ctx, ntq.lmChallengeResponce.data, 8);\n\t    EVP_DigestFinal_ex(md5ctx, sessionhash, NULL);\n\t    EVP_MD_CTX_destroy(md5ctx);\n\t    memcpy(ntq.lmchallenge.data, sessionhash, ntq.lmchallenge.length);\n\t}\n\n\tret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\tkey->key.keyvalue.length,\n\t\t\t\t\tntq.lmchallenge.data, &answer);\n\tif (ret)\n\t    goto failed;\n\n\tif (ntq.ntChallengeResponce.length != answer.length ||\n\t    memcmp(ntq.ntChallengeResponce.data, answer.data, answer.length) != 0) {\n\t    free(answer.data);\n\t    ret = EINVAL;\n\t    goto failed;\n\t}\n\tfree(answer.data);\n\n\t{\n\t    EVP_MD_CTX *ctxp;\n\n\t    ctxp = EVP_MD_CTX_create();\n\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t    EVP_DigestUpdate(ctxp, key->key.keyvalue.data, key->key.keyvalue.length);\n\t    EVP_DigestFinal_ex(ctxp, sessionkey, NULL);\n\t    EVP_MD_CTX_destroy(ctxp);\n\t}\n    }\n\n    ntp.success = 1;\n\n    ASN1_MALLOC_ENCODE(NTLMReply, rep.data, rep.length, &ntp, &size, ret);\n    if (ret)\n\tgoto failed;\n    if (rep.length != size)\n\tabort();\n\n  failed:\n    kdc_log(context, config, 1, \"digest-request: %d\", ret);\n\n    (*complete)(cctx, ret, &rep);\n\n    free(rep.data);\n\n    free_NTLMRequest2(&ntq);\n    if (user)\n\t_kdc_free_ent (context, user);\n}",
    "includes": [
      "include <kdc-private.h>",
      "include <getarg.h>",
      "include <heim-ipc.h>\n#",
      "include <heimntlm.h>\n#",
      "include <digest_asn1.h>\n#",
      "include \"headers.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "rb5_kdc_configuration *config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_free_ent",
          "args": [
            "ontext,",
            "ser)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_NTLMRequest2(",
          "args": [
            "ntq)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ep.data)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*complete)",
          "args": [
            "ctx,",
            "et,",
            "rep)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "digest-request: %d\",",
            "et)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bort(",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "TLMReply,",
            "ep.data,",
            "ep.length,",
            "ntp,",
            "size,",
            "et)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "txp)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "txp,",
            "essionkey,",
            "ULL)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "txp,",
            "VP_md4(),",
            "ULL)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md4(",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcmp(",
          "args": [
            "tq.ntChallengeResponce.data,",
            "nswer.data,",
            "nswer.length)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ntlm_calculate_ntlm1(",
          "args": [
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length,",
            "tq.lmchallenge.data,",
            "answer)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "tq.lmchallenge.data,",
            "essionhash,",
            "tq.lmchallenge.length)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "d5ctx)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "d5ctx,",
            "essionhash,",
            "ULL)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "d5ctx,",
            "tq.lmChallengeResponce.data,",
            ")"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "d5ctx,",
            "tq.lmchallenge.data,",
            ")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "d5ctx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nfotarget.data)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ntlm_verify_ntlm2(",
          "args": [
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length,",
            "tq.loginUserName,",
            "tq.loginDomainName,",
            ",",
            "tq.lmchallenge.data,",
            "answer,",
            "infotarget,",
            "essionkey)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM missing arcfour key\")"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "user->entry,",
            "ULL,",
            "TYPE_ARCFOUR_HMAC_MD5,",
            "key)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "lient)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "lient,",
            "DB_F_GET_CLIENT,",
            "ULL,",
            "ULL,",
            "user)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_set_type(",
          "args": [
            "ontext,",
            "lient,",
            "RB5_NT_NTLM)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "client,",
            "omain,",
            "tq.loginUserName,",
            "ULL)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "tq.loginDomainName,",
            "\")"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "tq.loginDomainName,",
            "BUILTIN\")"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_NTLMRequest2(",
          "args": [
            "eq->data,",
            "eq->length,",
            "ntq,",
            "ULL)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*complete)",
          "args": [
            "ctx,",
            "PERM,",
            "ULL)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ipc_cred_get_uid(",
          "args": [
            "red)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ipc_cred_get_uid(",
          "args": [
            "red)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kdc-private.h>\ninclude <getarg.h>\ninclude <heim-ipc.h>\n#\ninclude <heimntlm.h>\n#\ninclude <digest_asn1.h>\n#\ninclude \"headers.h\"\n#\n\nrb5_kdc_configuration *config;\n\ntatic void\nntlm_service(void *ctx, const heim_idata *req,\n\t     const heim_icred cred,\n\t     heim_ipc_complete complete,\n\t     heim_sipc_call cctx)\n{\n    NTLMRequest2 ntq;\n    unsigned char sessionkey[16];\n    heim_idata rep = { 0, NULL };\n    krb5_context context = ctx;\n    hdb_entry_ex *user = NULL;\n    Key *key = NULL;\n    NTLMReply ntp;\n    size_t size;\n    int ret;\n    const char *domain;\n\n    kdc_log(context, config, 1, \"digest-request: uid=%d\",\n\t    (int)heim_ipc_cred_get_uid(cred));\n\n    if (heim_ipc_cred_get_uid(cred) != 0) {\n\t(*complete)(cctx, EPERM, NULL);\n\treturn;\n    }\n\n    ntp.success = 0;\n    ntp.flags = 0;\n    ntp.sessionkey = NULL;\n\n    ret = decode_NTLMRequest2(req->data, req->length, &ntq, NULL);\n    if (ret)\n\tgoto failed;\n\n    /* XXX forward to NetrLogonSamLogonEx() if not a local domain */\n    if (strcmp(ntq.loginDomainName, \"BUILTIN\") == 0) {\n\tdomain = ntq.loginDomainName;\n    } else if (strcmp(ntq.loginDomainName, \"\") == 0) {\n\tdomain = \"BUILTIN\";\n    } else {\n\tret = EINVAL;\n\tgoto failed;\n    }\n\n    kdc_log(context, config, 1, \"digest-request: user=%s/%s\",\n\t    ntq.loginUserName, domain);\n\n    if (ntq.lmchallenge.length != 8)\n\tgoto failed;\n\n    if (ntq.ntChallengeResponce.length == 0)\n\tgoto failed;\n\n    {\n\tkrb5_principal client;\n\n\tret = krb5_make_principal(context, &client, domain,\n\t\t\t\t  ntq.loginUserName, NULL);\n\tif (ret)\n\t    goto failed;\n\n\tkrb5_principal_set_type(context, client, KRB5_NT_NTLM);\n\n\tret = _kdc_db_fetch(context, config, client,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, client);\n\tif (ret)\n\t    goto failed;\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto failed;\n\t}\n    }\n\n    kdc_log(context, config, 2,\n\t    \"digest-request: found user, processing ntlm request\", ret);\n\n    if (ntq.ntChallengeResponce.length != 24) {\n\tstruct ntlm_buf infotarget, answer;\n\n\tanswer.length = ntq.ntChallengeResponce.length;\n\tanswer.data = ntq.ntChallengeResponce.data;\n\n\tret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length,\n\t\t\t\t     ntq.loginUserName,\n\t\t\t\t     ntq.loginDomainName,\n\t\t\t\t     0,\n\t\t\t\t     ntq.lmchallenge.data,\n\t\t\t\t     &answer,\n\t\t\t\t     &infotarget,\n\t\t\t\t     sessionkey);\n\tif (ret) {\n\t    goto failed;\n\t}\n\n\tfree(infotarget.data);\n\t/* XXX verify info target */\n\n    } else {\n\tstruct ntlm_buf answer;\n\n\tif (ntq.flags & NTLM_NEG_NTLM2_SESSION) {\n\t    unsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t    EVP_MD_CTX *md5ctx;\n\n\t    /* the first first 8 bytes is the challenge, what is the other 16 bytes ? */\n\t    if (ntq.lmChallengeResponce.length != 24)\n\t\tgoto failed;\n\n\t    md5ctx = EVP_MD_CTX_create();\n\t    EVP_DigestInit_ex(md5ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(md5ctx, ntq.lmchallenge.data, 8);\n\t    EVP_DigestUpdate(md5ctx, ntq.lmChallengeResponce.data, 8);\n\t    EVP_DigestFinal_ex(md5ctx, sessionhash, NULL);\n\t    EVP_MD_CTX_destroy(md5ctx);\n\t    memcpy(ntq.lmchallenge.data, sessionhash, ntq.lmchallenge.length);\n\t}\n\n\tret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\tkey->key.keyvalue.length,\n\t\t\t\t\tntq.lmchallenge.data, &answer);\n\tif (ret)\n\t    goto failed;\n\n\tif (ntq.ntChallengeResponce.length != answer.length ||\n\t    memcmp(ntq.ntChallengeResponce.data, answer.data, answer.length) != 0) {\n\t    free(answer.data);\n\t    ret = EINVAL;\n\t    goto failed;\n\t}\n\tfree(answer.data);\n\n\t{\n\t    EVP_MD_CTX *ctxp;\n\n\t    ctxp = EVP_MD_CTX_create();\n\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t    EVP_DigestUpdate(ctxp, key->key.keyvalue.data, key->key.keyvalue.length);\n\t    EVP_DigestFinal_ex(ctxp, sessionkey, NULL);\n\t    EVP_MD_CTX_destroy(ctxp);\n\t}\n    }\n\n    ntp.success = 1;\n\n    ASN1_MALLOC_ENCODE(NTLMReply, rep.data, rep.length, &ntp, &size, ret);\n    if (ret)\n\tgoto failed;\n    if (rep.length != size)\n\tabort();\n\n  failed:\n    kdc_log(context, config, 1, \"digest-request: %d\", ret);\n\n    (*complete)(cctx, ret, &rep);\n\n    free(rep.data);\n\n    free_NTLMRequest2(&ntq);\n    if (user)\n\t_kdc_free_ent (context, user);\n}"
  }
]