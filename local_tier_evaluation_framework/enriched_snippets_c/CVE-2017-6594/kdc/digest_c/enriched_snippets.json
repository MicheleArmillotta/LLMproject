[
  {
    "function_name": "kdc_do_digest(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
    "lines": "201-1512",
    "snippet": "rb5_error_code\n_kdc_do_digest(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       const struct DigestREQ *req, krb5_data *reply,\n\t       const char *from, struct sockaddr *addr)\n{\n    krb5_error_code ret = 0;\n    krb5_ticket *ticket = NULL;\n    krb5_auth_context ac = NULL;\n    krb5_keytab id = NULL;\n    krb5_crypto crypto = NULL;\n    DigestReqInner ireq;\n    DigestRepInner r;\n    DigestREP rep;\n    krb5_flags ap_req_options;\n    krb5_data buf;\n    size_t size;\n    krb5_storage *sp = NULL;\n    Checksum res;\n    hdb_entry_ex *server = NULL, *user = NULL;\n    hdb_entry_ex *client = NULL;\n    char *client_name = NULL, *password = NULL;\n    krb5_data serverNonce;\n\n    if(!config->enable_digest) {\n\tkdc_log(context, config, 0,\n\t\t\"Rejected digest request (disabled) from %s\", from);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(reply);\n    krb5_data_zero(&serverNonce);\n    memset(&ireq, 0, sizeof(ireq));\n    memset(&r, 0, sizeof(r));\n    memset(&rep, 0, sizeof(rep));\n    memset(&res, 0, sizeof(res));\n\n    kdc_log(context, config, 0, \"Digest request from %s\", from);\n\n    ret = krb5_kt_resolve(context, \"HDBGET:\", &id);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Can't open database for digest\");\n\tgoto out;\n    }\n\n    ret = krb5_rd_req(context,\n\t\t      &ac,\n\t\t      &req->apReq,\n\t\t      NULL,\n\t\t      id,\n\t\t      &ap_req_options,\n\t\t      &ticket);\n    if (ret)\n\tgoto out;\n\n    /* check the server principal in the ticket matches digest/R@R */\n    {\n\tkrb5_principal principal = NULL;\n\tconst char *p, *rr;\n\n\tret = krb5_ticket_get_server(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"Wrong digest server principal used\");\n\tp = krb5_principal_get_comp_string(context, principal, 0);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, KRB5_DIGEST_NAME) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tp = krb5_principal_get_comp_string(context, principal, 1);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\trr = krb5_principal_get_realm(context, principal);\n\tif (rr == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, rr) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tkrb5_clear_error_message(context);\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_SERVER, NULL, NULL, &server);\n\tif (ret)\n\t    goto out;\n\n\tkrb5_free_principal(context, principal);\n    }\n\n    /* check the client is allowed to do digest auth */\n    {\n\tkrb5_principal principal = NULL;\n\n\tret = krb5_ticket_get_client(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, principal, &client_name);\n\tif (ret) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &client);\n\tkrb5_free_principal(context, principal);\n\tif (ret)\n\t    goto out;\n\n\tif (client->entry.flags.allow_digest == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client %s tried to use digest \"\n\t\t    \"but is not allowed to\",\n\t\t    client_name);\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Client is not permitted to use digest\");\n\t    goto out;\n\t}\n    }\n\n    /* unpack request */\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getremotesubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\tif (key == NULL) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"digest: remote subkey not found\");\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     &req->innerReq, &buf);\n    krb5_crypto_destroy(context, crypto);\n    crypto = NULL;\n    if (ret)\n\tgoto out;\n\n    ret = decode_DigestReqInner(buf.data, buf.length, &ireq, NULL);\n    krb5_data_free(&buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode digest inner request\");\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"Valid digest request from %s (%s)\",\n\t    client_name, from);\n\n    /*\n     * Process the inner request\n     */\n\n    switch (ireq.element) {\n    case choice_DigestReqInner_init: {\n\tunsigned char server_nonce[16], identifier;\n\n\tRAND_pseudo_bytes(&identifier, sizeof(identifier));\n\tRAND_pseudo_bytes(server_nonce, sizeof(server_nonce));\n\n\tserver_nonce[0] = kdc_time & 0xff;\n\tserver_nonce[1] = (kdc_time >> 8) & 0xff;\n\tserver_nonce[2] = (kdc_time >> 16) & 0xff;\n\tserver_nonce[3] = (kdc_time >> 24) & 0xff;\n\n\tr.element = choice_DigestRepInner_initReply;\n\n\thex_encode(server_nonce, sizeof(server_nonce), &r.u.initReply.nonce);\n\tif (r.u.initReply.nonce == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode server nonce\");\n\t    goto out;\n\t}\n\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.init.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (ireq.u.init.channel) {\n\t    char *s;\n\t    int aret;\n\n\t    aret = asprintf(&s, \"%s-%s:%s\", r.u.initReply.nonce,\n\t\t\t    ireq.u.init.channel->cb_type,\n\t\t\t    ireq.u.init.channel->cb_binding);\n\t    if (aret == -1 || s == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed to allocate channel binding\");\n\t\tgoto out;\n\t    }\n\t    free(r.u.initReply.nonce);\n\t    r.u.initReply.nonce = s;\n\t}\n\n\tret = krb5_store_stringz(sp, r.u.initReply.nonce);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (strcasecmp(ireq.u.init.type, \"CHAP\") == 0) {\n\t    int aret;\n\n\t    r.u.initReply.identifier =\n\t\tmalloc(sizeof(*r.u.initReply.identifier));\n\t    if (r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    aret = asprintf(r.u.initReply.identifier, \"%02X\", identifier&0xff);\n\t    if (aret == -1 || *r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t} else\n\t    r.u.initReply.identifier = NULL;\n\n\tif (ireq.u.init.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.init.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_create_checksum(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   0,\n\t\t\t\t   buf.data,\n\t\t\t\t   buf.length,\n\t\t\t\t   &res);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tkrb5_data_free(&buf);\n\tif (ret)\n\t    goto out;\n\n\tASN1_MALLOC_ENCODE(Checksum, buf.data, buf.length, &res, &size, ret);\n\tfree_Checksum(&res);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to encode \"\n\t\t\t\t   \"checksum in digest request\");\n\t    goto out;\n\t}\n\tif (size != buf.length)\n\t    krb5_abortx(context, \"ASN1 internal error\");\n\n\thex_encode(buf.data, buf.length, &r.u.initReply.opaque);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (r.u.initReply.opaque == NULL) {\n\t    krb5_clear_error_message(context);\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s init request successful from %s\",\n\t\tireq.u.init.type, from);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_digestRequest: {\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.digestRequest.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_store_stringz(sp, ireq.u.digestRequest.serverNonce);\n\n\tif (ireq.u.digestRequest.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.digestRequest.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tbuf.length = strlen(ireq.u.digestRequest.opaque);\n\tbuf.data = malloc(buf.length);\n\tif (buf.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = hex_decode(ireq.u.digestRequest.opaque, buf.data, buf.length);\n\tif (ret <= 0) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode opaque\");\n\t    goto out;\n\t}\n\tbuf.length = ret;\n\n\tret = decode_Checksum(buf.data, buf.length, &res, NULL);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Failed to decode digest Checksum\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tserverNonce.length = strlen(ireq.u.digestRequest.serverNonce);\n\tserverNonce.data = malloc(serverNonce.length);\n\tif (serverNonce.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * CHAP does the checksum of the raw nonce, but do it for all\n\t * types, since we need to check the timestamp.\n\t */\n\t{\n\t    ssize_t ssize;\n\n\t    ssize = hex_decode(ireq.u.digestRequest.serverNonce,\n\t\t\t       serverNonce.data, serverNonce.length);\n\t    if (ssize <= 0) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"Failed to decode serverNonce\");\n\t\tgoto out;\n\t    }\n\t    serverNonce.length = ssize;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_verify_checksum(context, crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   buf.data, buf.length, &res);\n\tfree_Checksum(&res);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\t/* verify time */\n\t{\n\t    unsigned char *p = serverNonce.data;\n\t    uint32_t t;\n\n\t    if (serverNonce.length < 4) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"server nonce too short\");\n\t\tgoto out;\n\t    }\n\t    t = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n\n\t    if (labs((kdc_time & 0xffffffff) - t) > context->max_skew) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"time screw in server nonce \");\n\t\tgoto out;\n\t    }\n\t}\n\n\tif (strcasecmp(ireq.u.digestRequest.type, \"CHAP\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char idx;\n\n\t    if ((config->digests_allowed & CHAP_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest CHAP MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.identifier == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"Identifier missing \"\n\t\t\t\t       \"from CHAP request\");\n\t\tgoto out;\n\t    }\n\n\t    if (hex_decode(*ireq.u.digestRequest.identifier, &idx, 1) != 1) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"failed to decode identifier\");\n\t\tgoto out;\n\t    }\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, &idx, 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestUpdate(ctx, serverNonce.data, serverNonce.length);\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"CHAP reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"SASL-DIGEST-MD5\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char *A1, *A2;\n\n\t    if ((config->digests_allowed & DIGEST_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest SASL MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.nonceCount == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.clientNonce == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.qop == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.realm == NULL)\n\t\tgoto out;\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.username,\n\t\t       strlen(ireq.u.digestRequest.username));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.realm,\n\t\t       strlen(*ireq.u.digestRequest.realm));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, md, sizeof(md));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    if (ireq.u.digestRequest.authid) {\n\t\tEVP_DigestUpdate(ctx, \":\", 1);\n\t\tEVP_DigestUpdate(ctx, *ireq.u.digestRequest.authid,\n\t\t\t   strlen(*ireq.u.digestRequest.authid));\n\t    }\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\t    hex_encode(md, sizeof(md), &A1);\n\t    if (A1 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tEVP_MD_CTX_destroy(ctx);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx,\n\t\t\t     \"AUTHENTICATE:\", sizeof(\"AUTHENTICATE:\") - 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.uri,\n\t\t       strlen(*ireq.u.digestRequest.uri));\n\n\t    /* conf|int */\n\t    if (strcmp(ireq.u.digestRequest.digest, \"clear\") != 0) {\n\t\tstatic char conf_zeros[] = \":00000000000000000000000000000000\";\n\t\tEVP_DigestUpdate(ctx, conf_zeros, sizeof(conf_zeros) - 1);\n\t    }\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    hex_encode(md, sizeof(md), &A2);\n\t    if (A2 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tfree(A1);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, A1, strlen(A2));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.clientNonce,\n\t\t       strlen(*ireq.u.digestRequest.clientNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.qop,\n\t\t       strlen(*ireq.u.digestRequest.qop));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, A2, strlen(A2));\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    free(A1);\n\t    free(A2);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"DIGEST-MD5 reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"MS-CHAP-V2\") == 0) {\n\t    unsigned char md[SHA_DIGEST_LENGTH], challenge[SHA_DIGEST_LENGTH];\n\t    krb5_principal clientprincipal = NULL;\n\t    char *mdx;\n\t    const char *username;\n\t    struct ntlm_buf answer;\n\t    Key *key = NULL;\n\t    EVP_MD_CTX *ctp;\n\n\t    if ((config->digests_allowed & MS_CHAP_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"MS-CHAP-V2 not allowed\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.digestRequest.clientNonce == NULL)  {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 clientNonce missing\");\n\t\tgoto failed;\n\t    }\n\t    if (serverNonce.length != 16) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 serverNonce wrong length\");\n\t\tgoto failed;\n\t    }\n\n\t    /* strip of the domain component */\n\t    username = strchr(ireq.u.digestRequest.username, '\\\\');\n\t    if (username == NULL)\n\t\tusername = ireq.u.digestRequest.username;\n\t    else\n\t\tusername++;\n\n\t    ctp = EVP_MD_CTX_create();\n\n\t    /* ChallengeHash */\n\t    EVP_DigestInit_ex(ctp, EVP_sha1(), NULL);\n\t    {\n\t\tssize_t ssize;\n\t\tkrb5_data clientNonce;\n\n\t\tclientNonce.length = strlen(*ireq.u.digestRequest.clientNonce);\n\t\tclientNonce.data = malloc(clientNonce.length);\n\t\tif (clientNonce.data == NULL) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"malloc: out of memory\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\n\t\tssize = hex_decode(*ireq.u.digestRequest.clientNonce,\n\t\t\t\t   clientNonce.data, clientNonce.length);\n\t\tif (ssize != 16) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed to decode clientNonce\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\t\tEVP_DigestUpdate(ctp, clientNonce.data, ssize);\n\t\tfree(clientNonce.data);\n\t    }\n\t    EVP_DigestUpdate(ctp, serverNonce.data, serverNonce.length);\n\t    EVP_DigestUpdate(ctp, username, strlen(username));\n\n\t    EVP_DigestFinal_ex(ctp, challenge, NULL);\n\n\t    EVP_MD_CTX_destroy(ctp);\n\n\t    /* NtPasswordHash */\n\t    ret = krb5_parse_name(context, username, &clientprincipal);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &user);\n\t    krb5_free_principal(context, clientprincipal);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 user %s not in database\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    ret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t\t  ETYPE_ARCFOUR_HMAC_MD5, &key);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 missing arcfour key %s\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    /* ChallengeResponse */\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    hex_encode(answer.data, answer.length, &mdx);\n\t    if (mdx == NULL) {\n\t\tfree(answer.data);\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"MS-CHAP-V2 hash mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\t    free(mdx);\n\n\t    if (r.u.response.success) {\n\t\tunsigned char hashhash[MD4_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctxp;\n\n\t\tctxp = EVP_MD_CTX_create();\n\n\t\t/* hashhash */\n\t\t{\n\t\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t\t    EVP_DigestUpdate(ctxp,\n\t\t\t\t     key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length);\n\t\t    EVP_DigestFinal_ex(ctxp, hashhash, NULL);\n\t\t}\n\n\t\t/* GenerateAuthenticatorResponse */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, sizeof(hashhash));\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic1,\n\t\t\t\t sizeof(ms_chap_v2_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, md, sizeof(md));\n\t\tEVP_DigestUpdate(ctxp, challenge, 8);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic2,\n\t\t\t\t sizeof(ms_chap_v2_magic2));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tr.u.response.rsp = calloc(1, sizeof(*r.u.response.rsp));\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\thex_encode(md, sizeof(md), r.u.response.rsp);\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\t/* get_master, rfc 3079 3.4 */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, 16);\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_rfc3079_magic1,\n\t\t\t\t sizeof(ms_rfc3079_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tfree(answer.data);\n\n\t\tEVP_MD_CTX_destroy(ctxp);\n\n\t\tr.u.response.session_key =\n\t\t    calloc(1, sizeof(*r.u.response.session_key));\n\t\tif (r.u.response.session_key == NULL) {\n\t\t    krb5_clear_error_message(context);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\tret = krb5_data_copy(r.u.response.session_key, md, 16);\n\t\tif (ret) {\n\t\t    krb5_clear_error_message(context);\n\t\t    goto out;\n\t\t}\n\t    }\n\n\t} else {\n\t    int aret;\n\n\t    r.element = choice_DigestRepInner_error;\n\t    aret = asprintf(&r.u.error.reason, \"Unsupported digest type %s\",\n\t\t\t    ireq.u.digestRequest.type);\n\t    if (aret == -1 || r.u.error.reason == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t    r.u.error.code = EINVAL;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s request successful %s\",\n\t\tireq.u.digestRequest.type, ireq.u.digestRequest.username);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_ntlmInit:\n\n\tif ((config->digests_allowed & (NTLM_V1|NTLM_V1_SESSION|NTLM_V2)) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM not allowed\");\n\t    goto failed;\n\t}\n\n\tr.element = choice_DigestRepInner_ntlmInitReply;\n\n\tr.u.ntlmInitReply.flags = NTLM_NEG_UNICODE;\n\n\tif ((ireq.u.ntlmInit.flags & NTLM_NEG_UNICODE) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM client have no unicode\");\n\t    goto failed;\n\t}\n\n\tif (ireq.u.ntlmInit.flags & NTLM_NEG_NTLM)\n\t    r.u.ntlmInitReply.flags |= NTLM_NEG_NTLM;\n\telse {\n\t    kdc_log(context, config, 0, \"NTLM client doesn't support NTLM\");\n\t    goto failed;\n\t}\n\n\tr.u.ntlmInitReply.flags |=\n\t    NTLM_NEG_TARGET |\n\t    NTLM_TARGET_DOMAIN |\n\t    NTLM_ENC_128;\n\n#define ALL\t\t\t\t\t\\\n\tNTLM_NEG_SIGN|\t\t\t\t\\\n\t    NTLM_NEG_SEAL|\t\t\t\\\n\t    NTLM_NEG_ALWAYS_SIGN|\t\t\\\n\t    NTLM_NEG_NTLM2_SESSION|\t\t\\\n\t    NTLM_NEG_KEYEX\n\n\tr.u.ntlmInitReply.flags |= (ireq.u.ntlmInit.flags & (ALL));\n\n#undef ALL\n\n\tr.u.ntlmInitReply.targetname =\n\t    get_ntlm_targetname(context, client);\n\tif (r.u.ntlmInitReply.targetname == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.data = malloc(8);\n\tif (r.u.ntlmInitReply.challenge.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.length = 8;\n\tif (RAND_bytes(r.u.ntlmInitReply.challenge.data,\n\t\t       r.u.ntlmInitReply.challenge.length) != 1)\n\t    {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"out of random error\");\n\t\tgoto out;\n\t    }\n\t/* XXX fix targetinfo */\n\tALLOC(r.u.ntlmInitReply.targetinfo);\n\tif (r.u.ntlmInitReply.targetinfo == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = fill_targetinfo(context,\n\t\t\t      r.u.ntlmInitReply.targetname,\n\t\t\t      client,\n\t\t\t      r.u.ntlmInitReply.targetinfo);\n\tif (ret) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * Save data encryted in opaque for the second part of the\n\t * ntlm authentication\n\t */\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_write(sp, r.u.ntlmInitReply.challenge.data, 8);\n\tif (ret != 8) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"storage write challenge\");\n\t    goto out;\n\t}\n\tret = krb5_store_uint32(sp, r.u.ntlmInitReply.flags);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   buf.data, buf.length, &r.u.ntlmInitReply.opaque);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, config, 0, \"NTLM init from %s\", from);\n\n\tbreak;\n\n    case choice_DigestReqInner_ntlmRequest: {\n\tkrb5_principal clientprincipal;\n\tunsigned char sessionkey[16];\n\tunsigned char challenge[8];\n\tuint32_t flags;\n\tKey *key = NULL;\n\tint version;\n\n\tr.element = choice_DigestRepInner_ntlmResponse;\n\tr.u.ntlmResponse.success = 0;\n\tr.u.ntlmResponse.flags = 0;\n\tr.u.ntlmResponse.sessionkey = NULL;\n\tr.u.ntlmResponse.tickets = NULL;\n\n\t/* get username */\n\tret = krb5_parse_name(context,\n\t\t\t      ireq.u.ntlmRequest.username,\n\t\t\t      &clientprincipal);\n\tif (ret)\n\t    goto failed;\n\n\tret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, clientprincipal);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM user %s not in database\",\n\t\t\t\t   ireq.u.ntlmRequest.username);\n\t    goto failed;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto failed;\n\n\tret = krb5_decrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   ireq.u.ntlmRequest.opaque.data,\n\t\t\t   ireq.u.ntlmRequest.opaque.length, &buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt nonce from %s\", from);\n\t    goto failed;\n\t}\n\n\tsp = krb5_storage_from_data(&buf);\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_read(sp, challenge, sizeof(challenge));\n\tif (ret != sizeof(challenge)) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"NTLM storage read challenge\");\n\t    goto out;\n\t}\n\tret = krb5_ret_uint32(sp, &flags);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM storage read flags\");\n\t    goto out;\n\t}\n\tkrb5_storage_free(sp);\n\tsp = NULL;\n\tkrb5_data_free(&buf);\n\n\tif ((flags & NTLM_NEG_NTLM) == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"NTLM not negotiated\");\n\t    goto out;\n\t}\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto out;\n\t}\n\n\t/* check if this is NTLMv2 */\n\tif (ireq.u.ntlmRequest.ntlm.length != 24) {\n\t    struct ntlm_buf infotarget, answer;\n\t    char *targetname;\n\n\t    if ((config->digests_allowed & NTLM_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"NTLM v2 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    version = 2;\n\n\t    targetname = get_ntlm_targetname(context, client);\n\t    if (targetname == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    answer.length = ireq.u.ntlmRequest.ntlm.length;\n\t    answer.data = ireq.u.ntlmRequest.ntlm.data;\n\n\t    ret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t\t key->key.keyvalue.length,\n\t\t\t\t\t ireq.u.ntlmRequest.username,\n\t\t\t\t\t targetname,\n\t\t\t\t\t 0,\n\t\t\t\t\t challenge,\n\t\t\t\t\t &answer,\n\t\t\t\t\t &infotarget,\n\t\t\t\t\t sessionkey);\n\t    free(targetname);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM v2 verify failed\");\n\t\tgoto failed;\n\t    }\n\n\t    /* XXX verify infotarget matches client (checksum ?) */\n\n\t    free(infotarget.data);\n\t    /* */\n\n\t} else {\n\t    struct ntlm_buf answer;\n\n\t    version = 1;\n\n\t    if (flags & NTLM_NEG_NTLM2_SESSION) {\n\t\tunsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctx;\n\n\t\tif ((config->digests_allowed & NTLM_V1_SESSION) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1-session not allowed\");\n\t\t    ret = EINVAL;\n\t\t    goto failed;\n\t\t}\n\n\t\tif (ireq.u.ntlmRequest.lm.length != 24) {\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"LM hash have wrong length \"\n\t\t\t\t\t   \"for NTLM session key\");\n\t\t    goto failed;\n\t\t}\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\n\t\tEVP_DigestUpdate(ctx, challenge, sizeof(challenge));\n\t\tEVP_DigestUpdate(ctx, ireq.u.ntlmRequest.lm.data, 8);\n\t\tEVP_DigestFinal_ex(ctx, sessionhash, NULL);\n\t\tmemcpy(challenge, sessionhash, sizeof(challenge));\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\t    } else {\n\t\tif ((config->digests_allowed & NTLM_V1) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1 not allowed\");\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.ntlmRequest.ntlm.length != answer.length ||\n\t\tmemcmp(ireq.u.ntlmRequest.ntlm.data, answer.data, answer.length) != 0)\n\t\t{\n\t\t    free(answer.data);\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"NTLM hash mismatch\");\n\t\t    goto failed;\n\t\t}\n\t    free(answer.data);\n\n\t    {\n\t\tEVP_MD_CTX *ctx;\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md4(), NULL);\n\t\tEVP_DigestUpdate(ctx,\n\t\t\t\t key->key.keyvalue.data,\n\t\t\t\t key->key.keyvalue.length);\n\t\tEVP_DigestFinal_ex(ctx, sessionkey, NULL);\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\t    }\n\t}\n\n\tif (ireq.u.ntlmRequest.sessionkey) {\n\t    unsigned char masterkey[MD4_DIGEST_LENGTH];\n\t    EVP_CIPHER_CTX rc4;\n\t    size_t len;\n\n\t    if ((flags & NTLM_NEG_KEYEX) == 0) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM client failed to neg key \"\n\t\t\t\t       \"exchange but still sent key\");\n\t\tgoto failed;\n\t    }\n\n\t    len = ireq.u.ntlmRequest.sessionkey->length;\n\t    if (len != sizeof(masterkey)){\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM master key wrong length: %lu\",\n\t\t\t\t       (unsigned long)len);\n\t\tgoto failed;\n\t    }\n\n\n\t    EVP_CIPHER_CTX_init(&rc4);\n\t    EVP_CipherInit_ex(&rc4, EVP_rc4(), NULL, sessionkey, NULL, 1);\n\t    EVP_Cipher(&rc4,\n\t\t       masterkey, ireq.u.ntlmRequest.sessionkey->data,\n\t\t       sizeof(masterkey));\n\t    EVP_CIPHER_CTX_cleanup(&rc4);\n\n\t    r.u.ntlmResponse.sessionkey =\n\t\tmalloc(sizeof(*r.u.ntlmResponse.sessionkey));\n\t    if (r.u.ntlmResponse.sessionkey == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_data_copy(r.u.ntlmResponse.sessionkey,\n\t\t\t\t masterkey, sizeof(masterkey));\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\tr.u.ntlmResponse.success = 1;\n\tkdc_log(context, config, 0, \"NTLM version %d successful for %s\",\n\t\tversion, ireq.u.ntlmRequest.username);\n\tbreak;\n    }\n    case choice_DigestReqInner_supportedMechs:\n\n\tkdc_log(context, config, 0, \"digest supportedMechs from %s\", from);\n\n\tr.element = choice_DigestRepInner_supportedMechs;\n\tmemset(&r.u.supportedMechs, 0, sizeof(r.u.supportedMechs));\n\n\tif (config->digests_allowed & NTLM_V1)\n\t    r.u.supportedMechs.ntlm_v1 = 1;\n\tif (config->digests_allowed & NTLM_V1_SESSION)\n\t    r.u.supportedMechs.ntlm_v1_session = 1;\n\tif (config->digests_allowed & NTLM_V2)\n\t    r.u.supportedMechs.ntlm_v2 = 1;\n\tif (config->digests_allowed & DIGEST_MD5)\n\t    r.u.supportedMechs.digest_md5 = 1;\n\tif (config->digests_allowed & CHAP_MD5)\n\t    r.u.supportedMechs.chap_md5 = 1;\n\tif (config->digests_allowed & MS_CHAP_V2)\n\t    r.u.supportedMechs.ms_chap_v2 = 1;\n\tbreak;\n\n    default: {\n\tconst char *s;\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"unknown operation to digest\");\n\n\tfailed:\n\n\ts = krb5_get_error_message(context, ret);\n\tif (s == NULL) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest failed with: %s\", s);\n\n\tr.element = choice_DigestRepInner_error;\n\tr.u.error.reason = strdup(\"unknown error\");\n\tkrb5_free_error_message(context, s);\n\tif (r.u.error.reason == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.error.code = EINVAL;\n\tbreak;\n    }\n    }\n\n    ASN1_MALLOC_ENCODE(DigestRepInner, buf.data, buf.length, &r, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode inner digest reply\");\n\tgoto out;\n    }\n    if (size != buf.length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n    krb5_auth_con_addflags(context, ac, KRB5_AUTH_CONTEXT_USE_SUBKEY, NULL);\n\n    ret = krb5_mk_rep (context, ac, &rep.apRep);\n    if (ret)\n\tgoto out;\n\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getlocalsubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     buf.data, buf.length, 0,\n\t\t\t\t     &rep.innerRep);\n\n    ASN1_MALLOC_ENCODE(DigestREP, reply->data, reply->length, &rep, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode digest reply\");\n\tgoto out;\n    }\n    if (size != reply->length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n\n out:\n    if (ac)\n\tkrb5_auth_con_free(context, ac);\n    if (ret)\n\tkrb5_warn(context, ret, \"Digest request from %s failed\", from);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (id)\n\tkrb5_kt_close(context, id);\n    if (crypto)\n\tkrb5_crypto_destroy(context, crypto);\n    if (sp)\n\tkrb5_storage_free(sp);\n    if (user)\n\t_kdc_free_ent (context, user);\n    if (server)\n\t_kdc_free_ent (context, server);\n    if (client)\n\t_kdc_free_ent (context, client);\n    if (password) {\n\tmemset(password, 0, strlen(password));\n\tfree (password);\n    }\n    if (client_name)\n\tfree (client_name);\n    krb5_data_free(&buf);\n    krb5_data_free(&serverNonce);\n    free_Checksum(&res);\n    free_DigestREP(&rep);\n    free_DigestRepInner(&r);\n    free_DigestReqInner(&ireq);\n\n    return ret;\n}",
    "includes": [
      "include <hex.h>",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_DigestReqInner(",
          "args": [
            "ireq)"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_DigestRepInner(",
          "args": [
            "r)"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_DigestREP(",
          "args": [
            "rep)"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "res)"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "serverNonce)"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree",
          "args": [
            "lient_name)"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree",
          "args": [
            "assword)"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "assword,",
            ",",
            "trlen(password))"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "assword)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_free_ent",
          "args": [
            "ontext,",
            "lient)"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_close(",
          "args": [
            "ontext,",
            "d)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_ticket(",
          "args": [
            "ontext,",
            "icket)"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "Digest request from %s failed\",",
            "rom)"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "ASN1 internal error\")"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to encode digest reply\")"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "igestREP,",
            "eply->data,",
            "eply->length,",
            "rep,",
            "size,",
            "et)"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_ENCRYPT,",
            "uf.data,",
            "uf.length,",
            ",",
            "rep.innerRep)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock",
          "args": [
            "ontext,",
            "ey)"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "ey,",
            ",",
            "crypto)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_getlocalsubkey(",
          "args": [
            "ontext,",
            "c,",
            "key)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_mk_rep",
          "args": [
            "ontext,",
            "c,",
            "rep.apRep)"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_addflags(",
          "args": [
            "ontext,",
            "c,",
            "RB5_AUTH_CONTEXT_USE_SUBKEY,",
            "ULL)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "ASN1 internal error\")"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to encode inner digest reply\")"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "igestRepInner,",
            "uf.data,",
            "uf.length,",
            "r,",
            "size,",
            "et)"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            ")"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "unknown error\")"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Digest failed with: %s\",",
            ")"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "unknown operation to digest\")"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "r.u.supportedMechs,",
            ",",
            "izeof(r.u.supportedMechs))"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_copy(",
          "args": [
            ".u.ntlmResponse.sessionkey,",
            "asterkey,",
            "izeof(masterkey))"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(*r.u.ntlmResponse.sessionkey))"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_CIPHER_CTX_cleanup(",
          "args": [
            "rc4)"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_Cipher(",
          "args": [
            "rc4,",
            "asterkey,",
            "req.u.ntlmRequest.sessionkey->data,",
            "izeof(masterkey))"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_CipherInit_ex(",
          "args": [
            "rc4,",
            "VP_rc4(),",
            "ULL,",
            "essionkey,",
            "ULL,",
            ")"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_rc4(",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_CIPHER_CTX_init(",
          "args": [
            "rc4)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM master key wrong length: %lu\",",
            "unsigned long)len)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM client failed to neg key \"\n\t\t\t\t       \"exchange but still sent key\")"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tx)"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "essionkey,",
            "ULL)"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md4(),",
            "ULL)"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md4(",
          "args": [],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM hash mismatch\")"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcmp(",
          "args": [
            "req.u.ntlmRequest.ntlm.data,",
            "nswer.data,",
            "nswer.length)"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM missing arcfour key\")"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ntlm_calculate_ntlm1(",
          "args": [
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length,",
            "hallenge,",
            "answer)"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tx)"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "hallenge,",
            "essionhash,",
            "izeof(challenge))"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "essionhash,",
            "ULL)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "req.u.ntlmRequest.lm.data,",
            ")"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "hallenge,",
            "izeof(challenge))"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "LM hash have wrong length \"\n\t\t\t\t\t   \"for NTLM session key\")"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nfotarget.data)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM v2 verify failed\")"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "argetname)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ntlm_verify_ntlm2(",
          "args": [
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length,",
            "req.u.ntlmRequest.username,",
            "argetname,",
            ",",
            "hallenge,",
            "answer,",
            "infotarget,",
            "essionkey)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_ntlm_targetname(",
          "args": [
            "ontext,",
            "lient)"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "et_ntlm_targetname(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
          "lines": "82-99",
          "snippet": "tatic char *\nget_ntlm_targetname(krb5_context context,\n\t\t    hdb_entry_ex *client)\n{\n    char *targetname, *p;\n\n    targetname = strdup(krb5_principal_get_realm(context,\n\t\t\t\t\t\t client->entry.principal));\n    if (targetname == NULL)\n\treturn NULL;\n\n    p = strchr(targetname, '.');\n    if (p)\n\t*p = '\\0';\n\n    strupr(targetname);\n    return targetname;\n}",
          "includes": [
            "include <hex.h>",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic char *\nget_ntlm_targetname(krb5_context context,\n\t\t    hdb_entry_ex *client)\n{\n    char *targetname, *p;\n\n    targetname = strdup(krb5_principal_get_realm(context,\n\t\t\t\t\t\t client->entry.principal));\n    if (targetname == NULL)\n\treturn NULL;\n\n    p = strchr(targetname, '.');\n    if (p)\n\t*p = '\\0';\n\n    strupr(targetname);\n    return targetname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM missing arcfour key\")"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "user->entry,",
            "ULL,",
            "TYPE_ARCFOUR_HMAC_MD5,",
            "key)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM not negotiated\")"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM storage read flags\")"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ret_uint32(",
          "args": [
            "p,",
            "flags)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM storage read challenge\")"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_read(",
          "args": [
            "p,",
            "hallenge,",
            "izeof(challenge))"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_from_data(",
          "args": [
            "buf)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_OPAQUE,",
            "req.u.ntlmRequest.opaque.data,",
            "req.u.ntlmRequest.opaque.length,",
            "buf)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_digest_key(",
          "args": [
            "ontext,",
            "onfig,",
            "erver,",
            "crypto)"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "et_digest_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
          "lines": "57-76",
          "snippet": "tatic krb5_error_code\nget_digest_key(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       hdb_entry_ex *server,\n\t       krb5_crypto *crypto)\n{\n    krb5_error_code ret;\n    krb5_enctype enctype;\n    Key *key;\n\n    ret = _kdc_get_preferred_key(context,\n\t\t\t\t config,\n\t\t\t\t server,\n\t\t\t\t \"digest-service\",\n\t\t\t\t &enctype,\n\t\t\t\t &key);\n    if (ret)\n\treturn ret;\n    return krb5_crypto_init(context, &key->key, 0, crypto);\n}",
          "includes": [
            "include <hex.h>",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nget_digest_key(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       hdb_entry_ex *server,\n\t       krb5_crypto *crypto)\n{\n    krb5_error_code ret;\n    krb5_enctype enctype;\n    Key *key;\n\n    ret = _kdc_get_preferred_key(context,\n\t\t\t\t config,\n\t\t\t\t server,\n\t\t\t\t \"digest-service\",\n\t\t\t\t &enctype,\n\t\t\t\t &key);\n    if (ret)\n\treturn ret;\n    return krb5_crypto_init(context, &key->key, 0, crypto);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM user %s not in database\",",
            "req.u.ntlmRequest.username)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "lientprincipal)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "lientprincipal,",
            "DB_F_GET_CLIENT,",
            "ULL,",
            "ULL,",
            "user)"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "req.u.ntlmRequest.username,",
            "clientprincipal)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_OPAQUE,",
            "uf.data,",
            "uf.length,",
            "r.u.ntlmInitReply.opaque)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_to_data(",
          "args": [
            "p,",
            "buf)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            ".u.ntlmInitReply.flags)"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "storage write challenge\")"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_write(",
          "args": [
            "p,",
            ".u.ntlmInitReply.challenge.data,",
            ")"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_emem(",
          "args": [],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ill_targetinfo(",
          "args": [
            "ontext,",
            ".u.ntlmInitReply.targetname,",
            "lient,",
            ".u.ntlmInitReply.targetinfo)"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "ill_targetinfo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
          "lines": "101-137",
          "snippet": "tatic krb5_error_code\nfill_targetinfo(krb5_context context,\n\t\tchar *targetname,\n\t\thdb_entry_ex *client,\n\t\tkrb5_data *data)\n{\n    struct ntlm_targetinfo ti;\n    krb5_error_code ret;\n    struct ntlm_buf d;\n    krb5_principal p;\n    const char *str;\n\n    memset(&ti, 0, sizeof(ti));\n\n    ti.domainname = targetname;\n    p = client->entry.principal;\n    str = krb5_principal_get_comp_string(context, p, 0);\n    if (str != NULL &&\n\t(strcmp(\"host\", str) == 0 ||\n\t strcmp(\"ftp\", str) == 0 ||\n\t strcmp(\"imap\", str) == 0 ||\n\t strcmp(\"pop\", str) == 0 ||\n\t strcmp(\"smtp\", str)))\n\t{\n\t    str = krb5_principal_get_comp_string(context, p, 1);\n\t    ti.dnsservername = rk_UNCONST(str);\n\t}\n\n    ret = heim_ntlm_encode_targetinfo(&ti, 1, &d);\n    if (ret)\n\treturn ret;\n\n    data->data = d.data;\n    data->length = d.length;\n\n    return 0;\n}",
          "includes": [
            "include <hex.h>",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nfill_targetinfo(krb5_context context,\n\t\tchar *targetname,\n\t\thdb_entry_ex *client,\n\t\tkrb5_data *data)\n{\n    struct ntlm_targetinfo ti;\n    krb5_error_code ret;\n    struct ntlm_buf d;\n    krb5_principal p;\n    const char *str;\n\n    memset(&ti, 0, sizeof(ti));\n\n    ti.domainname = targetname;\n    p = client->entry.principal;\n    str = krb5_principal_get_comp_string(context, p, 0);\n    if (str != NULL &&\n\t(strcmp(\"host\", str) == 0 ||\n\t strcmp(\"ftp\", str) == 0 ||\n\t strcmp(\"imap\", str) == 0 ||\n\t strcmp(\"pop\", str) == 0 ||\n\t strcmp(\"smtp\", str)))\n\t{\n\t    str = krb5_principal_get_comp_string(context, p, 1);\n\t    ti.dnsservername = rk_UNCONST(str);\n\t}\n\n    ret = heim_ntlm_encode_targetinfo(&ti, 1, &d);\n    if (ret)\n\treturn ret;\n\n    data->data = d.data;\n    data->length = d.length;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            ".u.ntlmInitReply.targetinfo)"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "out of random error\")"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AND_bytes(",
          "args": [
            ".u.ntlmInitReply.challenge.data,",
            ".u.ntlmInitReply.challenge.length)"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ")"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf(",
          "args": [
            "r.u.error.reason,",
            "Unsupported digest type %s\",",
            "req.u.digestRequest.type)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_copy(",
          "args": [
            ".u.response.session_key,",
            "d,",
            "6)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*r.u.response.session_key))"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "txp)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "txp,",
            "d,",
            "ULL)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "s_rfc3079_magic1,",
            "izeof(ms_rfc3079_magic1))"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "nswer.data,",
            "nswer.length)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "ashhash,",
            "6)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "txp,",
            "VP_sha1(),",
            "ULL)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_sha1(",
          "args": [],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "txp)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "d,",
            "izeof(md),",
            ".u.response.rsp)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "txp)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*r.u.response.rsp))"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "txp,",
            "d,",
            "ULL)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "s_chap_v2_magic2,",
            "izeof(ms_chap_v2_magic2))"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "hallenge,",
            ")"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "d,",
            "izeof(md))"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "txp,",
            "VP_sha1(),",
            "ULL)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_sha1(",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "txp,",
            "d,",
            "ULL)"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "s_chap_v2_magic1,",
            "izeof(ms_chap_v2_magic1))"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "nswer.data,",
            "nswer.length)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "ashhash,",
            "izeof(hashhash))"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "txp,",
            "VP_sha1(),",
            "ULL)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_sha1(",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "txp,",
            "ashhash,",
            "ULL)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "txp,",
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "txp,",
            "VP_md4(),",
            "ULL)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md4(",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "dx)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "dx,",
            "req.u.digestRequest.responseData)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "nswer.data)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "nswer.data,",
            "nswer.length,",
            "mdx)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "NTLM missing arcfour key\")"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_ntlm_calculate_ntlm1(",
          "args": [
            "ey->key.keyvalue.data,",
            "ey->key.keyvalue.length,",
            "hallenge,",
            "answer)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "MS-CHAP-V2 missing arcfour key %s\",",
            "sername)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "user->entry,",
            "ULL,",
            "TYPE_ARCFOUR_HMAC_MD5,",
            "key)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "MS-CHAP-V2 user %s not in database\",",
            "sername)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "lientprincipal)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "sername,",
            "clientprincipal)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tp)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tp,",
            "hallenge,",
            "ULL)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tp,",
            "sername,",
            "trlen(username))"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "sername)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tp,",
            "erverNonce.data,",
            "erverNonce.length)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "lientNonce.data)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tp,",
            "lientNonce.data,",
            "size)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tp)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode clientNonce\")"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_decode(",
          "args": [
            "ireq.u.digestRequest.clientNonce,",
            "lientNonce.data,",
            "lientNonce.length)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tp)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "lientNonce.length)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.clientNonce)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tp,",
            "VP_sha1(),",
            "ULL)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_sha1(",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "req.u.digestRequest.username,",
            "\\\\')"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "MS-CHAP-V2 serverNonce wrong length\")"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "MS-CHAP-V2 clientNonce missing\")"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "req.u.digestRequest.type,",
            "MS-CHAP-V2\")"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "dx)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "dx,",
            "req.u.digestRequest.responseData)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "d,",
            "izeof(md),",
            "mdx)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "2)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "1)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tx)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "d,",
            "ULL)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "2,",
            "trlen(A2))"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "2)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.qop,",
            "trlen(*ireq.u.digestRequest.qop))"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.qop)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.clientNonce,",
            "trlen(*ireq.u.digestRequest.clientNonce))"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.clientNonce)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.nonceCount,",
            "trlen(*ireq.u.digestRequest.nonceCount))"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.nonceCount)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "req.u.digestRequest.serverNonce,",
            "trlen(ireq.u.digestRequest.serverNonce))"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "req.u.digestRequest.serverNonce)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "1,",
            "trlen(A2))"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "2)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "1)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "d,",
            "izeof(md),",
            "A2)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "d,",
            "ULL)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "onf_zeros,",
            "izeof(conf_zeros) - 1)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "req.u.digestRequest.digest,",
            "clear\")"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.uri,",
            "trlen(*ireq.u.digestRequest.uri))"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.uri)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "AUTHENTICATE:\",",
            "izeof(\"AUTHENTICATE:\") - 1)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tx)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "d,",
            "izeof(md),",
            "A1)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "d,",
            "ULL)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.authid,",
            "trlen(*ireq.u.digestRequest.authid))"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.authid)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.nonceCount,",
            "trlen(*ireq.u.digestRequest.nonceCount))"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.nonceCount)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "req.u.digestRequest.serverNonce,",
            "trlen(ireq.u.digestRequest.serverNonce))"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "req.u.digestRequest.serverNonce)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "d,",
            "izeof(md))"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "d,",
            "ULL)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "assword,",
            "trlen(password))"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "assword)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "ireq.u.digestRequest.realm,",
            "trlen(*ireq.u.digestRequest.realm))"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ireq.u.digestRequest.realm)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            ":\",",
            ")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "req.u.digestRequest.username,",
            "trlen(ireq.u.digestRequest.username))"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "req.u.digestRequest.username)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_password_entry(",
          "args": [
            "ontext,",
            "onfig,",
            "req.u.digestRequest.username,",
            "password)"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "et_password_entry(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
          "lines": "163-195",
          "snippet": "tatic krb5_error_code\nget_password_entry(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *username,\n\t\t   char **password)\n{\n    krb5_principal clientprincipal;\n    krb5_error_code ret;\n    hdb_entry_ex *user;\n    HDB *db;\n\n    /* get username */\n    ret = krb5_parse_name(context, username, &clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\tHDB_F_GET_CLIENT, NULL, &db, &user);\n    krb5_free_principal(context, clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = hdb_entry_get_password(context, db, &user->entry, password);\n    if (ret || password == NULL) {\n\tif (ret == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"password missing\");\n\t}\n\tmemset(user, 0, sizeof(*user));\n    }\n    _kdc_free_ent (context, user);\n    return ret;\n}",
          "includes": [
            "include <hex.h>",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nget_password_entry(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *username,\n\t\t   char **password)\n{\n    krb5_principal clientprincipal;\n    krb5_error_code ret;\n    hdb_entry_ex *user;\n    HDB *db;\n\n    /* get username */\n    ret = krb5_parse_name(context, username, &clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\tHDB_F_GET_CLIENT, NULL, &db, &user);\n    krb5_free_principal(context, clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = hdb_entry_get_password(context, db, &user->entry, password);\n    if (ret || password == NULL) {\n\tif (ret == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"password missing\");\n\t}\n\tmemset(user, 0, sizeof(*user));\n    }\n    _kdc_free_ent (context, user);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "req.u.digestRequest.type,",
            "SASL-DIGEST-MD5\")"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "dx)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "dx,",
            "req.u.digestRequest.responseData)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "d,",
            "izeof(md),",
            "mdx)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_destroy(",
          "args": [
            "tx)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestFinal_ex(",
          "args": [
            "tx,",
            "d,",
            "ULL)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "erverNonce.data,",
            "erverNonce.length)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "assword,",
            "trlen(password))"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "assword)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestUpdate(",
          "args": [
            "tx,",
            "idx,",
            ")"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_DigestInit_ex(",
          "args": [
            "tx,",
            "VP_md5(),",
            "ULL)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_md5(",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VP_MD_CTX_create(",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "failed to decode identifier\")"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_decode(",
          "args": [
            "ireq.u.digestRequest.identifier,",
            "idx,",
            ")"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Identifier missing \"\n\t\t\t\t       \"from CHAP request\")"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "req.u.digestRequest.type,",
            "CHAP\")"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "time screw in server nonce \")"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs(",
          "args": [
            "kdc_time & 0xffffffff) - t)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "server nonce too short\")"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "res)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_checksum(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_OPAQUE,",
            "uf.data,",
            "uf.length,",
            "res)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode serverNonce\")"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_decode(",
          "args": [
            "req.u.digestRequest.serverNonce,",
            "erverNonce.data,",
            "erverNonce.length)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "erverNonce.length)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "req.u.digestRequest.serverNonce)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_to_data(",
          "args": [
            "p,",
            "buf)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode digest Checksum\")"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf.data)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_Checksum(",
          "args": [
            "uf.data,",
            "uf.length,",
            "res,",
            "ULL)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode opaque\")"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_decode(",
          "args": [
            "req.u.digestRequest.opaque,",
            "uf.data,",
            "uf.length)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "uf.length)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "req.u.digestRequest.opaque)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            "ireq.u.digestRequest.hostname)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            "req.u.digestRequest.serverNonce)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            "req.u.digestRequest.type)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_emem(",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf.data)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "uf.data,",
            "uf.length,",
            "r.u.initReply.opaque)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "ASN1 internal error\")"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to encode \"\n\t\t\t\t   \"checksum in digest request\")"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "res)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "hecksum,",
            "uf.data,",
            "uf.length,",
            "res,",
            "size,",
            "et)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_OPAQUE,",
            ",",
            "uf.data,",
            "uf.length,",
            "res)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_to_data(",
          "args": [
            "p,",
            "buf)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            "ireq.u.init.hostname)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf(",
          "args": [
            ".u.initReply.identifier,",
            "%02X\",",
            "dentifier&0xff)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(*r.u.initReply.identifier))"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcasecmp(",
          "args": [
            "req.u.init.type,",
            "CHAP\")"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            ".u.initReply.nonce)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ".u.initReply.nonce)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to allocate channel binding\")"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf(",
          "args": [
            "s,",
            "%s-%s:%s\",",
            ".u.initReply.nonce,",
            "req.u.init.channel->cb_type,",
            "req.u.init.channel->cb_binding)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_stringz(",
          "args": [
            "p,",
            "req.u.init.type)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_emem(",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode server nonce\")"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_encode(",
          "args": [
            "erver_nonce,",
            "izeof(server_nonce),",
            "r.u.initReply.nonce)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AND_pseudo_bytes(",
          "args": [
            "erver_nonce,",
            "izeof(server_nonce))"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AND_pseudo_bytes(",
          "args": [
            "identifier,",
            "izeof(identifier))"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode digest inner request\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_DigestReqInner(",
          "args": [
            "uf.data,",
            "uf.length,",
            "ireq,",
            "ULL)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_DIGEST_ENCRYPT,",
            "req->innerReq,",
            "buf)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock",
          "args": [
            "ontext,",
            "ey)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "ey,",
            ",",
            "crypto)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "digest: remote subkey not found\")"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_getremotesubkey(",
          "args": [
            "ontext,",
            "c,",
            "key)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Client is not permitted to use digest\")"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rincipal,",
            "client_name)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ticket_get_client(",
          "args": [
            "ontext,",
            "icket,",
            "principal)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "r)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_comp_string(",
          "args": [
            "ontext,",
            "rincipal,",
            ")"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "RB5_DIGEST_NAME)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rincipal)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_comp_string(",
          "args": [
            "ontext,",
            "rincipal,",
            ")"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Wrong digest server principal used\")"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_ticket_get_server(",
          "args": [
            "ontext,",
            "icket,",
            "principal)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_rd_req(",
          "args": [
            "ontext,",
            "ac,",
            "req->apReq,",
            "ULL,",
            "d,",
            "ap_req_options,",
            "ticket)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_resolve(",
          "args": [
            "ontext,",
            "HDBGET:\",",
            "id)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "res,",
            ",",
            "izeof(res))"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rep,",
            ",",
            "izeof(rep))"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "r,",
            ",",
            "izeof(r))"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ireq,",
            ",",
            "izeof(ireq))"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "serverNonce)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "eply)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "buf)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\nrb5_error_code\n_kdc_do_digest(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       const struct DigestREQ *req, krb5_data *reply,\n\t       const char *from, struct sockaddr *addr)\n{\n    krb5_error_code ret = 0;\n    krb5_ticket *ticket = NULL;\n    krb5_auth_context ac = NULL;\n    krb5_keytab id = NULL;\n    krb5_crypto crypto = NULL;\n    DigestReqInner ireq;\n    DigestRepInner r;\n    DigestREP rep;\n    krb5_flags ap_req_options;\n    krb5_data buf;\n    size_t size;\n    krb5_storage *sp = NULL;\n    Checksum res;\n    hdb_entry_ex *server = NULL, *user = NULL;\n    hdb_entry_ex *client = NULL;\n    char *client_name = NULL, *password = NULL;\n    krb5_data serverNonce;\n\n    if(!config->enable_digest) {\n\tkdc_log(context, config, 0,\n\t\t\"Rejected digest request (disabled) from %s\", from);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(reply);\n    krb5_data_zero(&serverNonce);\n    memset(&ireq, 0, sizeof(ireq));\n    memset(&r, 0, sizeof(r));\n    memset(&rep, 0, sizeof(rep));\n    memset(&res, 0, sizeof(res));\n\n    kdc_log(context, config, 0, \"Digest request from %s\", from);\n\n    ret = krb5_kt_resolve(context, \"HDBGET:\", &id);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Can't open database for digest\");\n\tgoto out;\n    }\n\n    ret = krb5_rd_req(context,\n\t\t      &ac,\n\t\t      &req->apReq,\n\t\t      NULL,\n\t\t      id,\n\t\t      &ap_req_options,\n\t\t      &ticket);\n    if (ret)\n\tgoto out;\n\n    /* check the server principal in the ticket matches digest/R@R */\n    {\n\tkrb5_principal principal = NULL;\n\tconst char *p, *rr;\n\n\tret = krb5_ticket_get_server(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"Wrong digest server principal used\");\n\tp = krb5_principal_get_comp_string(context, principal, 0);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, KRB5_DIGEST_NAME) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tp = krb5_principal_get_comp_string(context, principal, 1);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\trr = krb5_principal_get_realm(context, principal);\n\tif (rr == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, rr) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tkrb5_clear_error_message(context);\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_SERVER, NULL, NULL, &server);\n\tif (ret)\n\t    goto out;\n\n\tkrb5_free_principal(context, principal);\n    }\n\n    /* check the client is allowed to do digest auth */\n    {\n\tkrb5_principal principal = NULL;\n\n\tret = krb5_ticket_get_client(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, principal, &client_name);\n\tif (ret) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &client);\n\tkrb5_free_principal(context, principal);\n\tif (ret)\n\t    goto out;\n\n\tif (client->entry.flags.allow_digest == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client %s tried to use digest \"\n\t\t    \"but is not allowed to\",\n\t\t    client_name);\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Client is not permitted to use digest\");\n\t    goto out;\n\t}\n    }\n\n    /* unpack request */\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getremotesubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\tif (key == NULL) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"digest: remote subkey not found\");\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     &req->innerReq, &buf);\n    krb5_crypto_destroy(context, crypto);\n    crypto = NULL;\n    if (ret)\n\tgoto out;\n\n    ret = decode_DigestReqInner(buf.data, buf.length, &ireq, NULL);\n    krb5_data_free(&buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode digest inner request\");\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"Valid digest request from %s (%s)\",\n\t    client_name, from);\n\n    /*\n     * Process the inner request\n     */\n\n    switch (ireq.element) {\n    case choice_DigestReqInner_init: {\n\tunsigned char server_nonce[16], identifier;\n\n\tRAND_pseudo_bytes(&identifier, sizeof(identifier));\n\tRAND_pseudo_bytes(server_nonce, sizeof(server_nonce));\n\n\tserver_nonce[0] = kdc_time & 0xff;\n\tserver_nonce[1] = (kdc_time >> 8) & 0xff;\n\tserver_nonce[2] = (kdc_time >> 16) & 0xff;\n\tserver_nonce[3] = (kdc_time >> 24) & 0xff;\n\n\tr.element = choice_DigestRepInner_initReply;\n\n\thex_encode(server_nonce, sizeof(server_nonce), &r.u.initReply.nonce);\n\tif (r.u.initReply.nonce == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode server nonce\");\n\t    goto out;\n\t}\n\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.init.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (ireq.u.init.channel) {\n\t    char *s;\n\t    int aret;\n\n\t    aret = asprintf(&s, \"%s-%s:%s\", r.u.initReply.nonce,\n\t\t\t    ireq.u.init.channel->cb_type,\n\t\t\t    ireq.u.init.channel->cb_binding);\n\t    if (aret == -1 || s == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed to allocate channel binding\");\n\t\tgoto out;\n\t    }\n\t    free(r.u.initReply.nonce);\n\t    r.u.initReply.nonce = s;\n\t}\n\n\tret = krb5_store_stringz(sp, r.u.initReply.nonce);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (strcasecmp(ireq.u.init.type, \"CHAP\") == 0) {\n\t    int aret;\n\n\t    r.u.initReply.identifier =\n\t\tmalloc(sizeof(*r.u.initReply.identifier));\n\t    if (r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    aret = asprintf(r.u.initReply.identifier, \"%02X\", identifier&0xff);\n\t    if (aret == -1 || *r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t} else\n\t    r.u.initReply.identifier = NULL;\n\n\tif (ireq.u.init.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.init.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_create_checksum(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   0,\n\t\t\t\t   buf.data,\n\t\t\t\t   buf.length,\n\t\t\t\t   &res);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tkrb5_data_free(&buf);\n\tif (ret)\n\t    goto out;\n\n\tASN1_MALLOC_ENCODE(Checksum, buf.data, buf.length, &res, &size, ret);\n\tfree_Checksum(&res);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to encode \"\n\t\t\t\t   \"checksum in digest request\");\n\t    goto out;\n\t}\n\tif (size != buf.length)\n\t    krb5_abortx(context, \"ASN1 internal error\");\n\n\thex_encode(buf.data, buf.length, &r.u.initReply.opaque);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (r.u.initReply.opaque == NULL) {\n\t    krb5_clear_error_message(context);\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s init request successful from %s\",\n\t\tireq.u.init.type, from);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_digestRequest: {\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.digestRequest.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_store_stringz(sp, ireq.u.digestRequest.serverNonce);\n\n\tif (ireq.u.digestRequest.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.digestRequest.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tbuf.length = strlen(ireq.u.digestRequest.opaque);\n\tbuf.data = malloc(buf.length);\n\tif (buf.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = hex_decode(ireq.u.digestRequest.opaque, buf.data, buf.length);\n\tif (ret <= 0) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode opaque\");\n\t    goto out;\n\t}\n\tbuf.length = ret;\n\n\tret = decode_Checksum(buf.data, buf.length, &res, NULL);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Failed to decode digest Checksum\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tserverNonce.length = strlen(ireq.u.digestRequest.serverNonce);\n\tserverNonce.data = malloc(serverNonce.length);\n\tif (serverNonce.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * CHAP does the checksum of the raw nonce, but do it for all\n\t * types, since we need to check the timestamp.\n\t */\n\t{\n\t    ssize_t ssize;\n\n\t    ssize = hex_decode(ireq.u.digestRequest.serverNonce,\n\t\t\t       serverNonce.data, serverNonce.length);\n\t    if (ssize <= 0) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"Failed to decode serverNonce\");\n\t\tgoto out;\n\t    }\n\t    serverNonce.length = ssize;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_verify_checksum(context, crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   buf.data, buf.length, &res);\n\tfree_Checksum(&res);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\t/* verify time */\n\t{\n\t    unsigned char *p = serverNonce.data;\n\t    uint32_t t;\n\n\t    if (serverNonce.length < 4) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"server nonce too short\");\n\t\tgoto out;\n\t    }\n\t    t = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n\n\t    if (labs((kdc_time & 0xffffffff) - t) > context->max_skew) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"time screw in server nonce \");\n\t\tgoto out;\n\t    }\n\t}\n\n\tif (strcasecmp(ireq.u.digestRequest.type, \"CHAP\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char idx;\n\n\t    if ((config->digests_allowed & CHAP_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest CHAP MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.identifier == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"Identifier missing \"\n\t\t\t\t       \"from CHAP request\");\n\t\tgoto out;\n\t    }\n\n\t    if (hex_decode(*ireq.u.digestRequest.identifier, &idx, 1) != 1) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"failed to decode identifier\");\n\t\tgoto out;\n\t    }\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, &idx, 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestUpdate(ctx, serverNonce.data, serverNonce.length);\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"CHAP reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"SASL-DIGEST-MD5\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char *A1, *A2;\n\n\t    if ((config->digests_allowed & DIGEST_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest SASL MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.nonceCount == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.clientNonce == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.qop == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.realm == NULL)\n\t\tgoto out;\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.username,\n\t\t       strlen(ireq.u.digestRequest.username));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.realm,\n\t\t       strlen(*ireq.u.digestRequest.realm));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, md, sizeof(md));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    if (ireq.u.digestRequest.authid) {\n\t\tEVP_DigestUpdate(ctx, \":\", 1);\n\t\tEVP_DigestUpdate(ctx, *ireq.u.digestRequest.authid,\n\t\t\t   strlen(*ireq.u.digestRequest.authid));\n\t    }\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\t    hex_encode(md, sizeof(md), &A1);\n\t    if (A1 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tEVP_MD_CTX_destroy(ctx);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx,\n\t\t\t     \"AUTHENTICATE:\", sizeof(\"AUTHENTICATE:\") - 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.uri,\n\t\t       strlen(*ireq.u.digestRequest.uri));\n\n\t    /* conf|int */\n\t    if (strcmp(ireq.u.digestRequest.digest, \"clear\") != 0) {\n\t\tstatic char conf_zeros[] = \":00000000000000000000000000000000\";\n\t\tEVP_DigestUpdate(ctx, conf_zeros, sizeof(conf_zeros) - 1);\n\t    }\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    hex_encode(md, sizeof(md), &A2);\n\t    if (A2 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tfree(A1);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, A1, strlen(A2));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.clientNonce,\n\t\t       strlen(*ireq.u.digestRequest.clientNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.qop,\n\t\t       strlen(*ireq.u.digestRequest.qop));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, A2, strlen(A2));\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    free(A1);\n\t    free(A2);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"DIGEST-MD5 reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"MS-CHAP-V2\") == 0) {\n\t    unsigned char md[SHA_DIGEST_LENGTH], challenge[SHA_DIGEST_LENGTH];\n\t    krb5_principal clientprincipal = NULL;\n\t    char *mdx;\n\t    const char *username;\n\t    struct ntlm_buf answer;\n\t    Key *key = NULL;\n\t    EVP_MD_CTX *ctp;\n\n\t    if ((config->digests_allowed & MS_CHAP_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"MS-CHAP-V2 not allowed\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.digestRequest.clientNonce == NULL)  {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 clientNonce missing\");\n\t\tgoto failed;\n\t    }\n\t    if (serverNonce.length != 16) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 serverNonce wrong length\");\n\t\tgoto failed;\n\t    }\n\n\t    /* strip of the domain component */\n\t    username = strchr(ireq.u.digestRequest.username, '\\\\');\n\t    if (username == NULL)\n\t\tusername = ireq.u.digestRequest.username;\n\t    else\n\t\tusername++;\n\n\t    ctp = EVP_MD_CTX_create();\n\n\t    /* ChallengeHash */\n\t    EVP_DigestInit_ex(ctp, EVP_sha1(), NULL);\n\t    {\n\t\tssize_t ssize;\n\t\tkrb5_data clientNonce;\n\n\t\tclientNonce.length = strlen(*ireq.u.digestRequest.clientNonce);\n\t\tclientNonce.data = malloc(clientNonce.length);\n\t\tif (clientNonce.data == NULL) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"malloc: out of memory\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\n\t\tssize = hex_decode(*ireq.u.digestRequest.clientNonce,\n\t\t\t\t   clientNonce.data, clientNonce.length);\n\t\tif (ssize != 16) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed to decode clientNonce\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\t\tEVP_DigestUpdate(ctp, clientNonce.data, ssize);\n\t\tfree(clientNonce.data);\n\t    }\n\t    EVP_DigestUpdate(ctp, serverNonce.data, serverNonce.length);\n\t    EVP_DigestUpdate(ctp, username, strlen(username));\n\n\t    EVP_DigestFinal_ex(ctp, challenge, NULL);\n\n\t    EVP_MD_CTX_destroy(ctp);\n\n\t    /* NtPasswordHash */\n\t    ret = krb5_parse_name(context, username, &clientprincipal);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &user);\n\t    krb5_free_principal(context, clientprincipal);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 user %s not in database\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    ret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t\t  ETYPE_ARCFOUR_HMAC_MD5, &key);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 missing arcfour key %s\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    /* ChallengeResponse */\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    hex_encode(answer.data, answer.length, &mdx);\n\t    if (mdx == NULL) {\n\t\tfree(answer.data);\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"MS-CHAP-V2 hash mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\t    free(mdx);\n\n\t    if (r.u.response.success) {\n\t\tunsigned char hashhash[MD4_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctxp;\n\n\t\tctxp = EVP_MD_CTX_create();\n\n\t\t/* hashhash */\n\t\t{\n\t\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t\t    EVP_DigestUpdate(ctxp,\n\t\t\t\t     key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length);\n\t\t    EVP_DigestFinal_ex(ctxp, hashhash, NULL);\n\t\t}\n\n\t\t/* GenerateAuthenticatorResponse */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, sizeof(hashhash));\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic1,\n\t\t\t\t sizeof(ms_chap_v2_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, md, sizeof(md));\n\t\tEVP_DigestUpdate(ctxp, challenge, 8);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic2,\n\t\t\t\t sizeof(ms_chap_v2_magic2));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tr.u.response.rsp = calloc(1, sizeof(*r.u.response.rsp));\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\thex_encode(md, sizeof(md), r.u.response.rsp);\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\t/* get_master, rfc 3079 3.4 */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, 16);\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_rfc3079_magic1,\n\t\t\t\t sizeof(ms_rfc3079_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tfree(answer.data);\n\n\t\tEVP_MD_CTX_destroy(ctxp);\n\n\t\tr.u.response.session_key =\n\t\t    calloc(1, sizeof(*r.u.response.session_key));\n\t\tif (r.u.response.session_key == NULL) {\n\t\t    krb5_clear_error_message(context);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\tret = krb5_data_copy(r.u.response.session_key, md, 16);\n\t\tif (ret) {\n\t\t    krb5_clear_error_message(context);\n\t\t    goto out;\n\t\t}\n\t    }\n\n\t} else {\n\t    int aret;\n\n\t    r.element = choice_DigestRepInner_error;\n\t    aret = asprintf(&r.u.error.reason, \"Unsupported digest type %s\",\n\t\t\t    ireq.u.digestRequest.type);\n\t    if (aret == -1 || r.u.error.reason == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t    r.u.error.code = EINVAL;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s request successful %s\",\n\t\tireq.u.digestRequest.type, ireq.u.digestRequest.username);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_ntlmInit:\n\n\tif ((config->digests_allowed & (NTLM_V1|NTLM_V1_SESSION|NTLM_V2)) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM not allowed\");\n\t    goto failed;\n\t}\n\n\tr.element = choice_DigestRepInner_ntlmInitReply;\n\n\tr.u.ntlmInitReply.flags = NTLM_NEG_UNICODE;\n\n\tif ((ireq.u.ntlmInit.flags & NTLM_NEG_UNICODE) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM client have no unicode\");\n\t    goto failed;\n\t}\n\n\tif (ireq.u.ntlmInit.flags & NTLM_NEG_NTLM)\n\t    r.u.ntlmInitReply.flags |= NTLM_NEG_NTLM;\n\telse {\n\t    kdc_log(context, config, 0, \"NTLM client doesn't support NTLM\");\n\t    goto failed;\n\t}\n\n\tr.u.ntlmInitReply.flags |=\n\t    NTLM_NEG_TARGET |\n\t    NTLM_TARGET_DOMAIN |\n\t    NTLM_ENC_128;\n\n#define ALL\t\t\t\t\t\\\n\tNTLM_NEG_SIGN|\t\t\t\t\\\n\t    NTLM_NEG_SEAL|\t\t\t\\\n\t    NTLM_NEG_ALWAYS_SIGN|\t\t\\\n\t    NTLM_NEG_NTLM2_SESSION|\t\t\\\n\t    NTLM_NEG_KEYEX\n\n\tr.u.ntlmInitReply.flags |= (ireq.u.ntlmInit.flags & (ALL));\n\n#undef ALL\n\n\tr.u.ntlmInitReply.targetname =\n\t    get_ntlm_targetname(context, client);\n\tif (r.u.ntlmInitReply.targetname == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.data = malloc(8);\n\tif (r.u.ntlmInitReply.challenge.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.length = 8;\n\tif (RAND_bytes(r.u.ntlmInitReply.challenge.data,\n\t\t       r.u.ntlmInitReply.challenge.length) != 1)\n\t    {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"out of random error\");\n\t\tgoto out;\n\t    }\n\t/* XXX fix targetinfo */\n\tALLOC(r.u.ntlmInitReply.targetinfo);\n\tif (r.u.ntlmInitReply.targetinfo == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = fill_targetinfo(context,\n\t\t\t      r.u.ntlmInitReply.targetname,\n\t\t\t      client,\n\t\t\t      r.u.ntlmInitReply.targetinfo);\n\tif (ret) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * Save data encryted in opaque for the second part of the\n\t * ntlm authentication\n\t */\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_write(sp, r.u.ntlmInitReply.challenge.data, 8);\n\tif (ret != 8) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"storage write challenge\");\n\t    goto out;\n\t}\n\tret = krb5_store_uint32(sp, r.u.ntlmInitReply.flags);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   buf.data, buf.length, &r.u.ntlmInitReply.opaque);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, config, 0, \"NTLM init from %s\", from);\n\n\tbreak;\n\n    case choice_DigestReqInner_ntlmRequest: {\n\tkrb5_principal clientprincipal;\n\tunsigned char sessionkey[16];\n\tunsigned char challenge[8];\n\tuint32_t flags;\n\tKey *key = NULL;\n\tint version;\n\n\tr.element = choice_DigestRepInner_ntlmResponse;\n\tr.u.ntlmResponse.success = 0;\n\tr.u.ntlmResponse.flags = 0;\n\tr.u.ntlmResponse.sessionkey = NULL;\n\tr.u.ntlmResponse.tickets = NULL;\n\n\t/* get username */\n\tret = krb5_parse_name(context,\n\t\t\t      ireq.u.ntlmRequest.username,\n\t\t\t      &clientprincipal);\n\tif (ret)\n\t    goto failed;\n\n\tret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, clientprincipal);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM user %s not in database\",\n\t\t\t\t   ireq.u.ntlmRequest.username);\n\t    goto failed;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto failed;\n\n\tret = krb5_decrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   ireq.u.ntlmRequest.opaque.data,\n\t\t\t   ireq.u.ntlmRequest.opaque.length, &buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt nonce from %s\", from);\n\t    goto failed;\n\t}\n\n\tsp = krb5_storage_from_data(&buf);\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_read(sp, challenge, sizeof(challenge));\n\tif (ret != sizeof(challenge)) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"NTLM storage read challenge\");\n\t    goto out;\n\t}\n\tret = krb5_ret_uint32(sp, &flags);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM storage read flags\");\n\t    goto out;\n\t}\n\tkrb5_storage_free(sp);\n\tsp = NULL;\n\tkrb5_data_free(&buf);\n\n\tif ((flags & NTLM_NEG_NTLM) == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"NTLM not negotiated\");\n\t    goto out;\n\t}\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto out;\n\t}\n\n\t/* check if this is NTLMv2 */\n\tif (ireq.u.ntlmRequest.ntlm.length != 24) {\n\t    struct ntlm_buf infotarget, answer;\n\t    char *targetname;\n\n\t    if ((config->digests_allowed & NTLM_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"NTLM v2 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    version = 2;\n\n\t    targetname = get_ntlm_targetname(context, client);\n\t    if (targetname == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    answer.length = ireq.u.ntlmRequest.ntlm.length;\n\t    answer.data = ireq.u.ntlmRequest.ntlm.data;\n\n\t    ret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t\t key->key.keyvalue.length,\n\t\t\t\t\t ireq.u.ntlmRequest.username,\n\t\t\t\t\t targetname,\n\t\t\t\t\t 0,\n\t\t\t\t\t challenge,\n\t\t\t\t\t &answer,\n\t\t\t\t\t &infotarget,\n\t\t\t\t\t sessionkey);\n\t    free(targetname);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM v2 verify failed\");\n\t\tgoto failed;\n\t    }\n\n\t    /* XXX verify infotarget matches client (checksum ?) */\n\n\t    free(infotarget.data);\n\t    /* */\n\n\t} else {\n\t    struct ntlm_buf answer;\n\n\t    version = 1;\n\n\t    if (flags & NTLM_NEG_NTLM2_SESSION) {\n\t\tunsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctx;\n\n\t\tif ((config->digests_allowed & NTLM_V1_SESSION) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1-session not allowed\");\n\t\t    ret = EINVAL;\n\t\t    goto failed;\n\t\t}\n\n\t\tif (ireq.u.ntlmRequest.lm.length != 24) {\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"LM hash have wrong length \"\n\t\t\t\t\t   \"for NTLM session key\");\n\t\t    goto failed;\n\t\t}\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\n\t\tEVP_DigestUpdate(ctx, challenge, sizeof(challenge));\n\t\tEVP_DigestUpdate(ctx, ireq.u.ntlmRequest.lm.data, 8);\n\t\tEVP_DigestFinal_ex(ctx, sessionhash, NULL);\n\t\tmemcpy(challenge, sessionhash, sizeof(challenge));\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\t    } else {\n\t\tif ((config->digests_allowed & NTLM_V1) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1 not allowed\");\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.ntlmRequest.ntlm.length != answer.length ||\n\t\tmemcmp(ireq.u.ntlmRequest.ntlm.data, answer.data, answer.length) != 0)\n\t\t{\n\t\t    free(answer.data);\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"NTLM hash mismatch\");\n\t\t    goto failed;\n\t\t}\n\t    free(answer.data);\n\n\t    {\n\t\tEVP_MD_CTX *ctx;\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md4(), NULL);\n\t\tEVP_DigestUpdate(ctx,\n\t\t\t\t key->key.keyvalue.data,\n\t\t\t\t key->key.keyvalue.length);\n\t\tEVP_DigestFinal_ex(ctx, sessionkey, NULL);\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\t    }\n\t}\n\n\tif (ireq.u.ntlmRequest.sessionkey) {\n\t    unsigned char masterkey[MD4_DIGEST_LENGTH];\n\t    EVP_CIPHER_CTX rc4;\n\t    size_t len;\n\n\t    if ((flags & NTLM_NEG_KEYEX) == 0) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM client failed to neg key \"\n\t\t\t\t       \"exchange but still sent key\");\n\t\tgoto failed;\n\t    }\n\n\t    len = ireq.u.ntlmRequest.sessionkey->length;\n\t    if (len != sizeof(masterkey)){\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM master key wrong length: %lu\",\n\t\t\t\t       (unsigned long)len);\n\t\tgoto failed;\n\t    }\n\n\n\t    EVP_CIPHER_CTX_init(&rc4);\n\t    EVP_CipherInit_ex(&rc4, EVP_rc4(), NULL, sessionkey, NULL, 1);\n\t    EVP_Cipher(&rc4,\n\t\t       masterkey, ireq.u.ntlmRequest.sessionkey->data,\n\t\t       sizeof(masterkey));\n\t    EVP_CIPHER_CTX_cleanup(&rc4);\n\n\t    r.u.ntlmResponse.sessionkey =\n\t\tmalloc(sizeof(*r.u.ntlmResponse.sessionkey));\n\t    if (r.u.ntlmResponse.sessionkey == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_data_copy(r.u.ntlmResponse.sessionkey,\n\t\t\t\t masterkey, sizeof(masterkey));\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\tr.u.ntlmResponse.success = 1;\n\tkdc_log(context, config, 0, \"NTLM version %d successful for %s\",\n\t\tversion, ireq.u.ntlmRequest.username);\n\tbreak;\n    }\n    case choice_DigestReqInner_supportedMechs:\n\n\tkdc_log(context, config, 0, \"digest supportedMechs from %s\", from);\n\n\tr.element = choice_DigestRepInner_supportedMechs;\n\tmemset(&r.u.supportedMechs, 0, sizeof(r.u.supportedMechs));\n\n\tif (config->digests_allowed & NTLM_V1)\n\t    r.u.supportedMechs.ntlm_v1 = 1;\n\tif (config->digests_allowed & NTLM_V1_SESSION)\n\t    r.u.supportedMechs.ntlm_v1_session = 1;\n\tif (config->digests_allowed & NTLM_V2)\n\t    r.u.supportedMechs.ntlm_v2 = 1;\n\tif (config->digests_allowed & DIGEST_MD5)\n\t    r.u.supportedMechs.digest_md5 = 1;\n\tif (config->digests_allowed & CHAP_MD5)\n\t    r.u.supportedMechs.chap_md5 = 1;\n\tif (config->digests_allowed & MS_CHAP_V2)\n\t    r.u.supportedMechs.ms_chap_v2 = 1;\n\tbreak;\n\n    default: {\n\tconst char *s;\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"unknown operation to digest\");\n\n\tfailed:\n\n\ts = krb5_get_error_message(context, ret);\n\tif (s == NULL) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest failed with: %s\", s);\n\n\tr.element = choice_DigestRepInner_error;\n\tr.u.error.reason = strdup(\"unknown error\");\n\tkrb5_free_error_message(context, s);\n\tif (r.u.error.reason == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.error.code = EINVAL;\n\tbreak;\n    }\n    }\n\n    ASN1_MALLOC_ENCODE(DigestRepInner, buf.data, buf.length, &r, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode inner digest reply\");\n\tgoto out;\n    }\n    if (size != buf.length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n    krb5_auth_con_addflags(context, ac, KRB5_AUTH_CONTEXT_USE_SUBKEY, NULL);\n\n    ret = krb5_mk_rep (context, ac, &rep.apRep);\n    if (ret)\n\tgoto out;\n\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getlocalsubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     buf.data, buf.length, 0,\n\t\t\t\t     &rep.innerRep);\n\n    ASN1_MALLOC_ENCODE(DigestREP, reply->data, reply->length, &rep, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode digest reply\");\n\tgoto out;\n    }\n    if (size != reply->length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n\n out:\n    if (ac)\n\tkrb5_auth_con_free(context, ac);\n    if (ret)\n\tkrb5_warn(context, ret, \"Digest request from %s failed\", from);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (id)\n\tkrb5_kt_close(context, id);\n    if (crypto)\n\tkrb5_crypto_destroy(context, crypto);\n    if (sp)\n\tkrb5_storage_free(sp);\n    if (user)\n\t_kdc_free_ent (context, user);\n    if (server)\n\t_kdc_free_ent (context, server);\n    if (client)\n\t_kdc_free_ent (context, client);\n    if (password) {\n\tmemset(password, 0, strlen(password));\n\tfree (password);\n    }\n    if (client_name)\n\tfree (client_name);\n    krb5_data_free(&buf);\n    krb5_data_free(&serverNonce);\n    free_Checksum(&res);\n    free_DigestREP(&rep);\n    free_DigestRepInner(&r);\n    free_DigestReqInner(&ireq);\n\n    return ret;\n}"
  },
  {
    "function_name": "et_password_entry(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
    "lines": "163-195",
    "snippet": "tatic krb5_error_code\nget_password_entry(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *username,\n\t\t   char **password)\n{\n    krb5_principal clientprincipal;\n    krb5_error_code ret;\n    hdb_entry_ex *user;\n    HDB *db;\n\n    /* get username */\n    ret = krb5_parse_name(context, username, &clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\tHDB_F_GET_CLIENT, NULL, &db, &user);\n    krb5_free_principal(context, clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = hdb_entry_get_password(context, db, &user->entry, password);\n    if (ret || password == NULL) {\n\tif (ret == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"password missing\");\n\t}\n\tmemset(user, 0, sizeof(*user));\n    }\n    _kdc_free_ent (context, user);\n    return ret;\n}",
    "includes": [
      "include <hex.h>",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_free_ent",
          "args": [
            "ontext,",
            "ser)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ser,",
            ",",
            "izeof(*user))"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "password missing\")"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry_get_password(",
          "args": [
            "ontext,",
            "b,",
            "user->entry,",
            "assword)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "lientprincipal)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "lientprincipal,",
            "DB_F_GET_CLIENT,",
            "ULL,",
            "db,",
            "user)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "ontext,",
            "sername,",
            "clientprincipal)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nget_password_entry(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *username,\n\t\t   char **password)\n{\n    krb5_principal clientprincipal;\n    krb5_error_code ret;\n    hdb_entry_ex *user;\n    HDB *db;\n\n    /* get username */\n    ret = krb5_parse_name(context, username, &clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\tHDB_F_GET_CLIENT, NULL, &db, &user);\n    krb5_free_principal(context, clientprincipal);\n    if (ret)\n\treturn ret;\n\n    ret = hdb_entry_get_password(context, db, &user->entry, password);\n    if (ret || password == NULL) {\n\tif (ret == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"password missing\");\n\t}\n\tmemset(user, 0, sizeof(*user));\n    }\n    _kdc_free_ent (context, user);\n    return ret;\n}"
  },
  {
    "function_name": "ill_targetinfo(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
    "lines": "101-137",
    "snippet": "tatic krb5_error_code\nfill_targetinfo(krb5_context context,\n\t\tchar *targetname,\n\t\thdb_entry_ex *client,\n\t\tkrb5_data *data)\n{\n    struct ntlm_targetinfo ti;\n    krb5_error_code ret;\n    struct ntlm_buf d;\n    krb5_principal p;\n    const char *str;\n\n    memset(&ti, 0, sizeof(ti));\n\n    ti.domainname = targetname;\n    p = client->entry.principal;\n    str = krb5_principal_get_comp_string(context, p, 0);\n    if (str != NULL &&\n\t(strcmp(\"host\", str) == 0 ||\n\t strcmp(\"ftp\", str) == 0 ||\n\t strcmp(\"imap\", str) == 0 ||\n\t strcmp(\"pop\", str) == 0 ||\n\t strcmp(\"smtp\", str)))\n\t{\n\t    str = krb5_principal_get_comp_string(context, p, 1);\n\t    ti.dnsservername = rk_UNCONST(str);\n\t}\n\n    ret = heim_ntlm_encode_targetinfo(&ti, 1, &d);\n    if (ret)\n\treturn ret;\n\n    data->data = d.data;\n    data->length = d.length;\n\n    return 0;\n}",
    "includes": [
      "include <hex.h>",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eim_ntlm_encode_targetinfo(",
          "args": [
            "ti,",
            ",",
            "d)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_UNCONST(",
          "args": [
            "tr)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_comp_string(",
          "args": [
            "ontext,",
            ",",
            ")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "smtp\",",
            "tr)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "pop\",",
            "tr)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "imap\",",
            "tr)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "ftp\",",
            "tr)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "host\",",
            "tr)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_comp_string(",
          "args": [
            "ontext,",
            ",",
            ")"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ti,",
            ",",
            "izeof(ti))"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nfill_targetinfo(krb5_context context,\n\t\tchar *targetname,\n\t\thdb_entry_ex *client,\n\t\tkrb5_data *data)\n{\n    struct ntlm_targetinfo ti;\n    krb5_error_code ret;\n    struct ntlm_buf d;\n    krb5_principal p;\n    const char *str;\n\n    memset(&ti, 0, sizeof(ti));\n\n    ti.domainname = targetname;\n    p = client->entry.principal;\n    str = krb5_principal_get_comp_string(context, p, 0);\n    if (str != NULL &&\n\t(strcmp(\"host\", str) == 0 ||\n\t strcmp(\"ftp\", str) == 0 ||\n\t strcmp(\"imap\", str) == 0 ||\n\t strcmp(\"pop\", str) == 0 ||\n\t strcmp(\"smtp\", str)))\n\t{\n\t    str = krb5_principal_get_comp_string(context, p, 1);\n\t    ti.dnsservername = rk_UNCONST(str);\n\t}\n\n    ret = heim_ntlm_encode_targetinfo(&ti, 1, &d);\n    if (ret)\n\treturn ret;\n\n    data->data = d.data;\n    data->length = d.length;\n\n    return 0;\n}"
  },
  {
    "function_name": "et_ntlm_targetname(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
    "lines": "82-99",
    "snippet": "tatic char *\nget_ntlm_targetname(krb5_context context,\n\t\t    hdb_entry_ex *client)\n{\n    char *targetname, *p;\n\n    targetname = strdup(krb5_principal_get_realm(context,\n\t\t\t\t\t\t client->entry.principal));\n    if (targetname == NULL)\n\treturn NULL;\n\n    p = strchr(targetname, '.');\n    if (p)\n\t*p = '\\0';\n\n    strupr(targetname);\n    return targetname;\n}",
    "includes": [
      "include <hex.h>",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trupr(",
          "args": [
            "argetname)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "argetname,",
            ".')"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "rb5_principal_get_realm(context,\n\t\t\t\t\t\t client->entry.principal))"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "lient->entry.principal)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic char *\nget_ntlm_targetname(krb5_context context,\n\t\t    hdb_entry_ex *client)\n{\n    char *targetname, *p;\n\n    targetname = strdup(krb5_principal_get_realm(context,\n\t\t\t\t\t\t client->entry.principal));\n    if (targetname == NULL)\n\treturn NULL;\n\n    p = strchr(targetname, '.');\n    if (p)\n\t*p = '\\0';\n\n    strupr(targetname);\n    return targetname;\n}"
  },
  {
    "function_name": "et_digest_key(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
    "lines": "57-76",
    "snippet": "tatic krb5_error_code\nget_digest_key(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       hdb_entry_ex *server,\n\t       krb5_crypto *crypto)\n{\n    krb5_error_code ret;\n    krb5_enctype enctype;\n    Key *key;\n\n    ret = _kdc_get_preferred_key(context,\n\t\t\t\t config,\n\t\t\t\t server,\n\t\t\t\t \"digest-service\",\n\t\t\t\t &enctype,\n\t\t\t\t &key);\n    if (ret)\n\treturn ret;\n    return krb5_crypto_init(context, &key->key, 0, crypto);\n}",
    "includes": [
      "include <hex.h>",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "key->key,",
            ",",
            "rypto)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_get_preferred_key(",
          "args": [
            "ontext,",
            "onfig,",
            "erver,",
            "digest-service\",",
            "enctype,",
            "key)"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_get_preferred_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "175-220",
          "snippet": "rb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}"
        }
      }
    ],
    "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nget_digest_key(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       hdb_entry_ex *server,\n\t       krb5_crypto *crypto)\n{\n    krb5_error_code ret;\n    krb5_enctype enctype;\n    Key *key;\n\n    ret = _kdc_get_preferred_key(context,\n\t\t\t\t config,\n\t\t\t\t server,\n\t\t\t\t \"digest-service\",\n\t\t\t\t &enctype,\n\t\t\t\t &key);\n    if (ret)\n\treturn ret;\n    return krb5_crypto_init(context, &key->key, 0, crypto);\n}"
  }
]