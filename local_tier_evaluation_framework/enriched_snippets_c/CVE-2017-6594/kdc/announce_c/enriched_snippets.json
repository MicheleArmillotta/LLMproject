[
  {
    "function_name": "bonjour_announce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "530-544",
    "snippet": "void\nbonjour_announce(krb5_context context, krb5_kdc_configuration *config)\n{\n#if defined(__APPLE__) && defined(HAVE_GCD)\n    g_queue = dispatch_queue_create(\"com.apple.kdc_announce\", NULL);\n    if (!g_queue)\n\terrx(1, \"dispatch_queue_create\");\n\n    g_store = register_notification();\n    announce_config = config;\n    announce_context = context;\n\n    create_dns_sd();\n#endif\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_dns_sd",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "create_dns_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "118-155",
          "snippet": "static void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_notification",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "register_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "496-527",
          "snippet": "static SCDynamicStoreRef\nregister_notification(void)\n{\n    SCDynamicStoreRef store;\n    CFStringRef computerNameKey;\n    CFMutableArrayRef keys;\n\n    computerNameKey = SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);\n\n    store = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR(\"Network watcher\"),\n\t\t\t\t update_all, NULL);\n    if (store == NULL)\n\terrx(1, \"SCDynamicStoreCreate\");\n\n    keys = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);\n    if (keys == NULL)\n\terrx(1, \"CFArrayCreateMutable\");\n\n    CFArrayAppendValue(keys, computerNameKey);\n    CFArrayAppendValue(keys, NetworkChangedKey_BackToMyMac);\n\n    if (SCDynamicStoreSetNotificationKeys(store, keys, NULL) == false)\n\terrx(1, \"SCDynamicStoreSetNotificationKeys\");\n\n    CFRelease(computerNameKey);\n    CFRelease(keys);\n\n    if (!SCDynamicStoreSetDispatchQueue(store, g_queue))\n\terrx(1, \"SCDynamicStoreSetDispatchQueue\");\n\n    return store;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic SCDynamicStoreRef\nregister_notification(void)\n{\n    SCDynamicStoreRef store;\n    CFStringRef computerNameKey;\n    CFMutableArrayRef keys;\n\n    computerNameKey = SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);\n\n    store = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR(\"Network watcher\"),\n\t\t\t\t update_all, NULL);\n    if (store == NULL)\n\terrx(1, \"SCDynamicStoreCreate\");\n\n    keys = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);\n    if (keys == NULL)\n\terrx(1, \"CFArrayCreateMutable\");\n\n    CFArrayAppendValue(keys, computerNameKey);\n    CFArrayAppendValue(keys, NetworkChangedKey_BackToMyMac);\n\n    if (SCDynamicStoreSetNotificationKeys(store, keys, NULL) == false)\n\terrx(1, \"SCDynamicStoreSetNotificationKeys\");\n\n    CFRelease(computerNameKey);\n    CFRelease(keys);\n\n    if (!SCDynamicStoreSetDispatchQueue(store, g_queue))\n\terrx(1, \"SCDynamicStoreSetDispatchQueue\");\n\n    return store;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"dispatch_queue_create\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_queue_create",
          "args": [
            "\"com.apple.kdc_announce\"",
            "NULL"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nvoid\nbonjour_announce(krb5_context context, krb5_kdc_configuration *config)\n{\n#if defined(__APPLE__) && defined(HAVE_GCD)\n    g_queue = dispatch_queue_create(\"com.apple.kdc_announce\", NULL);\n    if (!g_queue)\n\terrx(1, \"dispatch_queue_create\");\n\n    g_store = register_notification();\n    announce_config = config;\n    announce_context = context;\n\n    create_dns_sd();\n#endif\n}"
  },
  {
    "function_name": "register_notification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "496-527",
    "snippet": "static SCDynamicStoreRef\nregister_notification(void)\n{\n    SCDynamicStoreRef store;\n    CFStringRef computerNameKey;\n    CFMutableArrayRef keys;\n\n    computerNameKey = SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);\n\n    store = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR(\"Network watcher\"),\n\t\t\t\t update_all, NULL);\n    if (store == NULL)\n\terrx(1, \"SCDynamicStoreCreate\");\n\n    keys = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);\n    if (keys == NULL)\n\terrx(1, \"CFArrayCreateMutable\");\n\n    CFArrayAppendValue(keys, computerNameKey);\n    CFArrayAppendValue(keys, NetworkChangedKey_BackToMyMac);\n\n    if (SCDynamicStoreSetNotificationKeys(store, keys, NULL) == false)\n\terrx(1, \"SCDynamicStoreSetNotificationKeys\");\n\n    CFRelease(computerNameKey);\n    CFRelease(keys);\n\n    if (!SCDynamicStoreSetDispatchQueue(store, g_queue))\n\terrx(1, \"SCDynamicStoreSetDispatchQueue\");\n\n    return store;\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"SCDynamicStoreSetDispatchQueue\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreSetDispatchQueue",
          "args": [
            "store",
            "g_queue"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "keys"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "computerNameKey"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"SCDynamicStoreSetNotificationKeys\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreSetNotificationKeys",
          "args": [
            "store",
            "keys",
            "NULL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFArrayAppendValue",
          "args": [
            "keys",
            "NetworkChangedKey_BackToMyMac"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFArrayAppendValue",
          "args": [
            "keys",
            "computerNameKey"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"CFArrayCreateMutable\""
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFArrayCreateMutable",
          "args": [
            "kCFAllocatorDefault",
            "2",
            "&kCFTypeArrayCallBacks"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"SCDynamicStoreCreate\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreCreate",
          "args": [
            "kCFAllocatorDefault",
            "CFSTR(\"Network watcher\")",
            "update_all",
            "NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFSTR",
          "args": [
            "\"Network watcher\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreKeyCreateHostNames",
          "args": [
            "kCFAllocatorDefault"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic SCDynamicStoreRef\nregister_notification(void)\n{\n    SCDynamicStoreRef store;\n    CFStringRef computerNameKey;\n    CFMutableArrayRef keys;\n\n    computerNameKey = SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);\n\n    store = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR(\"Network watcher\"),\n\t\t\t\t update_all, NULL);\n    if (store == NULL)\n\terrx(1, \"SCDynamicStoreCreate\");\n\n    keys = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);\n    if (keys == NULL)\n\terrx(1, \"CFArrayCreateMutable\");\n\n    CFArrayAppendValue(keys, computerNameKey);\n    CFArrayAppendValue(keys, NetworkChangedKey_BackToMyMac);\n\n    if (SCDynamicStoreSetNotificationKeys(store, keys, NULL) == false)\n\terrx(1, \"SCDynamicStoreSetNotificationKeys\");\n\n    CFRelease(computerNameKey);\n    CFRelease(keys);\n\n    if (!SCDynamicStoreSetDispatchQueue(store, g_queue))\n\terrx(1, \"SCDynamicStoreSetDispatchQueue\");\n\n    return store;\n}"
  },
  {
    "function_name": "destroy_dns_sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "480-493",
    "snippet": "static void\ndestroy_dns_sd(void)\n{\n    if (g_dnsRef == NULL)\n\treturn;\n\n    delete_all();\n#ifdef REGISTER_SRV_RR\n    unregister_srv_realms();\n#endif\n\n    DNSServiceRefDeallocate(g_dnsRef);\n    g_dnsRef = NULL;\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DNSServiceRefDeallocate",
          "args": [
            "g_dnsRef"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_srv_realms",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_srv_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "289-299",
          "snippet": "static void\nunregister_srv_realms(void)\n{\n    if (g_dnsRef) {\n\tfor (i = 0; i < srvRefs.len; i++)\n\t    DNSServiceRemoveRecord(g_dnsRef, srvRefs.val[i], 0);\n    }\n    free(srvRefs.val);\n    srvRefs.len = 0;\n    srvRefs.val = NULL;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nunregister_srv_realms(void)\n{\n    if (g_dnsRef) {\n\tfor (i = 0; i < srvRefs.len; i++)\n\t    DNSServiceRemoveRecord(g_dnsRef, srvRefs.val[i], 0);\n    }\n    free(srvRefs.val);\n    srvRefs.len = 0;\n    srvRefs.val = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_all",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "delete_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "467-478",
          "snippet": "static void\ndelete_all(void)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    update_dns();\n    if (g_entries != NULL)\n\terrx(1, \"Failed to remove all bonjour entries\");\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2",
            "#define F_EXISTS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\ndelete_all(void)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    update_dns();\n    if (g_entries != NULL)\n\terrx(1, \"Failed to remove all bonjour entries\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ndestroy_dns_sd(void)\n{\n    if (g_dnsRef == NULL)\n\treturn;\n\n    delete_all();\n#ifdef REGISTER_SRV_RR\n    unregister_srv_realms();\n#endif\n\n    DNSServiceRefDeallocate(g_dnsRef);\n    g_dnsRef = NULL;\n}"
  },
  {
    "function_name": "delete_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "467-478",
    "snippet": "static void\ndelete_all(void)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    update_dns();\n    if (g_entries != NULL)\n\terrx(1, \"Failed to remove all bonjour entries\");\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_PUSH 2",
      "#define F_EXISTS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Failed to remove all bonjour entries\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dns",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "update_dns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "332-397",
          "snippet": "static void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2",
            "#define F_EXISTS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\ndelete_all(void)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    update_dns();\n    if (g_entries != NULL)\n\terrx(1, \"Failed to remove all bonjour entries\");\n}"
  },
  {
    "function_name": "update_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "420-465",
    "snippet": "static void\nupdate_all(SCDynamicStoreRef store, CFArrayRef changedKeys, void *info)\n{\n    struct entry *e;\n    CFStringRef host;\n    int i, flags = 0;\n\n    LOG(\"something changed, running update\");\n\n    host = SCDynamicStoreCopyLocalHostName(store);\n    if (host == NULL)\n\treturn;\n\n    if (g_hostname == NULL || CFStringCompare(host, g_hostname, 0) != kCFCompareEqualTo) {\n\tif (g_hostname)\n\t    CFRelease(g_hostname);\n\tg_hostname = CFRetain(host);\n\tflags = F_PUSH; /* if hostname has changed, force push */\n\n#ifdef REGISTER_SRV_RR\n\tregister_srv_realms(g_hostname);\n#endif\n    }\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tkrb5_error_code ret;\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, announce_config->db[i], &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tupdate_entries(store, *r, flags);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    update_dns();\n\n    CFRelease(host);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_PUSH 2",
      "#define F_EXISTS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "host"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dns",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "update_dns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "332-397",
          "snippet": "static void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2",
            "#define F_EXISTS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_host_realm",
          "args": [
            "announce_context",
            "realms"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_entries",
          "args": [
            "store",
            "*r",
            "flags"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "update_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "399-418",
          "snippet": "static void\nupdate_entries(SCDynamicStoreRef store, const char *realm, int flags)\n{\n    CFDictionaryRef btmm;\n\n    /* we always announce in the local domain */\n    domain_add(\"local\", realm, F_EXISTS | flags);\n\n    /* announce btmm */\n    btmm = SCDynamicStoreCopyValue(store, NetworkChangedKey_BackToMyMac);\n    if (btmm) {\n\tstruct addctx addctx;\n\n\taddctx.flags = flags;\n\taddctx.realm = realm;\n\n\tCFDictionaryApplyFunction(btmm, domains_add, &addctx);\n\tCFRelease(btmm);\n    }\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_EXISTS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_EXISTS 1\n\nstatic void\nupdate_entries(SCDynamicStoreRef store, const char *realm, int flags)\n{\n    CFDictionaryRef btmm;\n\n    /* we always announce in the local domain */\n    domain_add(\"local\", realm, F_EXISTS | flags);\n\n    /* announce btmm */\n    btmm = SCDynamicStoreCopyValue(store, NetworkChangedKey_BackToMyMac);\n    if (btmm) {\n\tstruct addctx addctx;\n\n\taddctx.flags = flags;\n\taddctx.realm = realm;\n\n\tCFDictionaryApplyFunction(btmm, domains_add, &addctx);\n\tCFRelease(btmm);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "announce_context",
            "announce_config->db[i]",
            "&realms"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_srv_realms",
          "args": [
            "g_hostname"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "register_srv_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "301-329",
          "snippet": "static void\nregister_srv_realms(CFStringRef host)\n{\n    krb5_error_code ret;\n    char *hostname;\n    size_t i;\n\n    /* first unregister old names */\n\n    hostname = CFString2utf8(host);\n    if (hostname == NULL)\n\treturn;\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tregister_srv(*r, hostname, 88);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    free(hostname);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nregister_srv_realms(CFStringRef host)\n{\n    krb5_error_code ret;\n    char *hostname;\n    size_t i;\n\n    /* first unregister old names */\n\n    hostname = CFString2utf8(host);\n    if (hostname == NULL)\n\treturn;\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tregister_srv(*r, hostname, 88);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    free(hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFRetain",
          "args": [
            "host"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "g_hostname"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFStringCompare",
          "args": [
            "host",
            "g_hostname",
            "0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreCopyLocalHostName",
          "args": [
            "store"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "\"something changed, running update\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\nupdate_all(SCDynamicStoreRef store, CFArrayRef changedKeys, void *info)\n{\n    struct entry *e;\n    CFStringRef host;\n    int i, flags = 0;\n\n    LOG(\"something changed, running update\");\n\n    host = SCDynamicStoreCopyLocalHostName(store);\n    if (host == NULL)\n\treturn;\n\n    if (g_hostname == NULL || CFStringCompare(host, g_hostname, 0) != kCFCompareEqualTo) {\n\tif (g_hostname)\n\t    CFRelease(g_hostname);\n\tg_hostname = CFRetain(host);\n\tflags = F_PUSH; /* if hostname has changed, force push */\n\n#ifdef REGISTER_SRV_RR\n\tregister_srv_realms(g_hostname);\n#endif\n    }\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tkrb5_error_code ret;\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, announce_config->db[i], &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tupdate_entries(store, *r, flags);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    update_dns();\n\n    CFRelease(host);\n}"
  },
  {
    "function_name": "update_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "399-418",
    "snippet": "static void\nupdate_entries(SCDynamicStoreRef store, const char *realm, int flags)\n{\n    CFDictionaryRef btmm;\n\n    /* we always announce in the local domain */\n    domain_add(\"local\", realm, F_EXISTS | flags);\n\n    /* announce btmm */\n    btmm = SCDynamicStoreCopyValue(store, NetworkChangedKey_BackToMyMac);\n    if (btmm) {\n\tstruct addctx addctx;\n\n\taddctx.flags = flags;\n\taddctx.realm = realm;\n\n\tCFDictionaryApplyFunction(btmm, domains_add, &addctx);\n\tCFRelease(btmm);\n    }\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_EXISTS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "btmm"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFDictionaryApplyFunction",
          "args": [
            "btmm",
            "domains_add",
            "&addctx"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCDynamicStoreCopyValue",
          "args": [
            "store",
            "NetworkChangedKey_BackToMyMac"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_add",
          "args": [
            "\"local\"",
            "realm",
            "F_EXISTS | flags"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "domain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "157-185",
          "snippet": "static void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n\nstatic void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_EXISTS 1\n\nstatic void\nupdate_entries(SCDynamicStoreRef store, const char *realm, int flags)\n{\n    CFDictionaryRef btmm;\n\n    /* we always announce in the local domain */\n    domain_add(\"local\", realm, F_EXISTS | flags);\n\n    /* announce btmm */\n    btmm = SCDynamicStoreCopyValue(store, NetworkChangedKey_BackToMyMac);\n    if (btmm) {\n\tstruct addctx addctx;\n\n\taddctx.flags = flags;\n\taddctx.realm = realm;\n\n\tCFDictionaryApplyFunction(btmm, domains_add, &addctx);\n\tCFRelease(btmm);\n    }\n}"
  },
  {
    "function_name": "update_dns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "332-397",
    "snippet": "static void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_PUSH 2",
      "#define F_EXISTS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hostname"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"failure to update entry for %s/%s\"",
            "update->domain",
            "update->realm"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dnsdata"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRegisterRecord",
          "args": [
            "g_dnsRef",
            "&update->recordRef",
            "kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery",
            "0",
            "name",
            "kDNSServiceType_TXT",
            "kDNSServiceClass_IN",
            "len+1",
            "dnsdata",
            "0",
            "dnsCallback",
            "NULL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRemoveRecord",
          "args": [
            "g_dnsRef",
            "update->recordRef",
            "0"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"malloc\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"_kerberos.%s.%s\"",
            "hostname",
            "update->domain"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"malloc\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dnsdata",
            "\"%c%s\"",
            "(int)len",
            "update->realm"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "update->realm"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "drop"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "drop->realm"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "drop->domain"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRemoveRecord",
          "args": [
            "g_dnsRef",
            "drop->recordRef",
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "\"Deleting realm %s from domain %s\"",
            "drop->realm",
            "drop->domain"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFString2utf8",
          "args": [
            "g_hostname"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "CFString2utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "75-91",
          "snippet": "static char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\nupdate_dns(void)\n{\n    DNSServiceErrorType error;\n    struct entry **e = &g_entries;\n    char *hostname;\n\n    hostname = CFString2utf8(g_hostname);\n    if (hostname == NULL)\n\treturn;\n\n    while (*e != NULL) {\n\t/* remove if this wasn't updated */\n\tif (((*e)->flags & F_EXISTS) == 0) {\n\t    struct entry *drop = *e;\n\t    *e = (*e)->next;\n\n\t    LOG(\"Deleting realm %s from domain %s\",\n\t\tdrop->realm, drop->domain);\n\n\t    if (drop->recordRef && g_dnsRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, drop->recordRef, 0);\n\t    free(drop->domain);\n\t    free(drop->realm);\n\t    free(drop);\n\t    continue;\n\t}\n\tif ((*e)->flags & F_PUSH) {\n\t    struct entry *update = *e;\n\t    char *dnsdata, *name;\n\t    size_t len;\n\n\t    len = strlen(update->realm);\n\t    asprintf(&dnsdata, \"%c%s\", (int)len, update->realm);\n\t    if (dnsdata == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    asprintf(&name, \"_kerberos.%s.%s\", hostname, update->domain);\n\t    if (name == NULL)\n\t\terrx(1, \"malloc\");\n\n\t    if (update->recordRef)\n\t\tDNSServiceRemoveRecord(g_dnsRef, update->recordRef, 0);\n\n\t    error = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t     &update->recordRef,\n\t\t\t\t\t     kDNSServiceFlagsShared | kDNSServiceFlagsAllowRemoteQuery,\n\t\t\t\t\t     0,\n\t\t\t\t\t     name,\n\t\t\t\t\t     kDNSServiceType_TXT,\n\t\t\t\t\t     kDNSServiceClass_IN,\n\t\t\t\t\t     len+1,\n\t\t\t\t\t     dnsdata,\n\t\t\t\t\t     0,\n\t\t\t\t\t     dnsCallback,\n\t\t\t\t\t     NULL);\n\t    free(name);\n\t    free(dnsdata);\n\t    if (error)\n\t\terrx(1, \"failure to update entry for %s/%s\",\n\t\t     update->domain, update->realm);\n\t}\n\te = &(*e)->next;\n    }\n    free(hostname);\n}"
  },
  {
    "function_name": "register_srv_realms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "301-329",
    "snippet": "static void\nregister_srv_realms(CFStringRef host)\n{\n    krb5_error_code ret;\n    char *hostname;\n    size_t i;\n\n    /* first unregister old names */\n\n    hostname = CFString2utf8(host);\n    if (hostname == NULL)\n\treturn;\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tregister_srv(*r, hostname, 88);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    free(hostname);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hostname"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_host_realm",
          "args": [
            "announce_context",
            "realms"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_srv",
          "args": [
            "*r",
            "hostname",
            "88"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "register_srv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "231-287",
          "snippet": "static void\nregister_srv(const char *realm, const char *hostname, int port)\n{\n    unsigned char target[1024];\n    int i;\n    int size;\n\n    /* skip registering LKDC realms */\n    if (strncmp(realm, \"LKDC:\", 5) == 0)\n\treturn;\n\n    /* encode SRV-RR */\n    target[0] = 0; /* priority */\n    target[1] = 0; /* priority */\n    target[2] = 0; /* weight */\n    target[3] = 0; /* weigth */\n    target[4] = (port >> 8) & 0xff; /* port */\n    target[5] = (port >> 0) & 0xff; /* port */\n\n    size = dn_comp(hostname, target + 6, sizeof(target) - 6, NULL, NULL);\n    if (size < 0)\n\treturn;\n\n    size += 6;\n\n    LOG(\"register SRV rr for realm %s hostname %s:%d\", realm, hostname, port);\n\n    for (i = 0; i < sizeof(register_names)/sizeof(register_names[0]); i++) {\n\tchar name[kDNSServiceMaxDomainName];\n\tDNSServiceErrorType error;\n\tvoid *ptr;\n\n\tptr = realloc(srvRefs.val, sizeof(srvRefs.val[0]) * (srvRefs.len + 1));\n\tif (ptr == NULL)\n\t    errx(1, \"malloc: out of memory\");\n\tsrvRefs.val = ptr;\n\n\tDNSServiceConstructFullName(name, NULL, register_names[i], realm);\n\n\terror = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t &srvRefs.val[srvRefs.len],\n\t\t\t\t\t kDNSServiceFlagsUnique | kDNSServiceFlagsShareConnection,\n\t\t\t\t\t 0,\n\t\t\t\t\t name,\n\t\t\t\t\t kDNSServiceType_SRV,\n\t\t\t\t\t kDNSServiceClass_IN,\n\t\t\t\t\t size,\n\t\t\t\t\t target,\n\t\t\t\t\t 0,\n\t\t\t\t\t dnsCallback,\n\t\t\t\t\t NULL);\n\tif (error) {\n\t    LOG(\"Failed to register SRV rr for realm %s: %d\", realm, error);\n\t} else\n\t    srvRefs.len++;\n    }\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nregister_srv(const char *realm, const char *hostname, int port)\n{\n    unsigned char target[1024];\n    int i;\n    int size;\n\n    /* skip registering LKDC realms */\n    if (strncmp(realm, \"LKDC:\", 5) == 0)\n\treturn;\n\n    /* encode SRV-RR */\n    target[0] = 0; /* priority */\n    target[1] = 0; /* priority */\n    target[2] = 0; /* weight */\n    target[3] = 0; /* weigth */\n    target[4] = (port >> 8) & 0xff; /* port */\n    target[5] = (port >> 0) & 0xff; /* port */\n\n    size = dn_comp(hostname, target + 6, sizeof(target) - 6, NULL, NULL);\n    if (size < 0)\n\treturn;\n\n    size += 6;\n\n    LOG(\"register SRV rr for realm %s hostname %s:%d\", realm, hostname, port);\n\n    for (i = 0; i < sizeof(register_names)/sizeof(register_names[0]); i++) {\n\tchar name[kDNSServiceMaxDomainName];\n\tDNSServiceErrorType error;\n\tvoid *ptr;\n\n\tptr = realloc(srvRefs.val, sizeof(srvRefs.val[0]) * (srvRefs.len + 1));\n\tif (ptr == NULL)\n\t    errx(1, \"malloc: out of memory\");\n\tsrvRefs.val = ptr;\n\n\tDNSServiceConstructFullName(name, NULL, register_names[i], realm);\n\n\terror = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t &srvRefs.val[srvRefs.len],\n\t\t\t\t\t kDNSServiceFlagsUnique | kDNSServiceFlagsShareConnection,\n\t\t\t\t\t 0,\n\t\t\t\t\t name,\n\t\t\t\t\t kDNSServiceType_SRV,\n\t\t\t\t\t kDNSServiceClass_IN,\n\t\t\t\t\t size,\n\t\t\t\t\t target,\n\t\t\t\t\t 0,\n\t\t\t\t\t dnsCallback,\n\t\t\t\t\t NULL);\n\tif (error) {\n\t    LOG(\"Failed to register SRV rr for realm %s: %d\", realm, error);\n\t} else\n\t    srvRefs.len++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "announce_context",
            "&realms"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFString2utf8",
          "args": [
            "host"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "CFString2utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "75-91",
          "snippet": "static char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nregister_srv_realms(CFStringRef host)\n{\n    krb5_error_code ret;\n    char *hostname;\n    size_t i;\n\n    /* first unregister old names */\n\n    hostname = CFString2utf8(host);\n    if (hostname == NULL)\n\treturn;\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tregister_srv(*r, hostname, 88);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    free(hostname);\n}"
  },
  {
    "function_name": "unregister_srv_realms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "289-299",
    "snippet": "static void\nunregister_srv_realms(void)\n{\n    if (g_dnsRef) {\n\tfor (i = 0; i < srvRefs.len; i++)\n\t    DNSServiceRemoveRecord(g_dnsRef, srvRefs.val[i], 0);\n    }\n    free(srvRefs.val);\n    srvRefs.len = 0;\n    srvRefs.val = NULL;\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "srvRefs.val"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRemoveRecord",
          "args": [
            "g_dnsRef",
            "srvRefs.val[i]",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nunregister_srv_realms(void)\n{\n    if (g_dnsRef) {\n\tfor (i = 0; i < srvRefs.len; i++)\n\t    DNSServiceRemoveRecord(g_dnsRef, srvRefs.val[i], 0);\n    }\n    free(srvRefs.val);\n    srvRefs.len = 0;\n    srvRefs.val = NULL;\n}"
  },
  {
    "function_name": "register_srv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "231-287",
    "snippet": "static void\nregister_srv(const char *realm, const char *hostname, int port)\n{\n    unsigned char target[1024];\n    int i;\n    int size;\n\n    /* skip registering LKDC realms */\n    if (strncmp(realm, \"LKDC:\", 5) == 0)\n\treturn;\n\n    /* encode SRV-RR */\n    target[0] = 0; /* priority */\n    target[1] = 0; /* priority */\n    target[2] = 0; /* weight */\n    target[3] = 0; /* weigth */\n    target[4] = (port >> 8) & 0xff; /* port */\n    target[5] = (port >> 0) & 0xff; /* port */\n\n    size = dn_comp(hostname, target + 6, sizeof(target) - 6, NULL, NULL);\n    if (size < 0)\n\treturn;\n\n    size += 6;\n\n    LOG(\"register SRV rr for realm %s hostname %s:%d\", realm, hostname, port);\n\n    for (i = 0; i < sizeof(register_names)/sizeof(register_names[0]); i++) {\n\tchar name[kDNSServiceMaxDomainName];\n\tDNSServiceErrorType error;\n\tvoid *ptr;\n\n\tptr = realloc(srvRefs.val, sizeof(srvRefs.val[0]) * (srvRefs.len + 1));\n\tif (ptr == NULL)\n\t    errx(1, \"malloc: out of memory\");\n\tsrvRefs.val = ptr;\n\n\tDNSServiceConstructFullName(name, NULL, register_names[i], realm);\n\n\terror = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t &srvRefs.val[srvRefs.len],\n\t\t\t\t\t kDNSServiceFlagsUnique | kDNSServiceFlagsShareConnection,\n\t\t\t\t\t 0,\n\t\t\t\t\t name,\n\t\t\t\t\t kDNSServiceType_SRV,\n\t\t\t\t\t kDNSServiceClass_IN,\n\t\t\t\t\t size,\n\t\t\t\t\t target,\n\t\t\t\t\t 0,\n\t\t\t\t\t dnsCallback,\n\t\t\t\t\t NULL);\n\tif (error) {\n\t    LOG(\"Failed to register SRV rr for realm %s: %d\", realm, error);\n\t} else\n\t    srvRefs.len++;\n    }\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "\"Failed to register SRV rr for realm %s: %d\"",
            "realm",
            "error"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRegisterRecord",
          "args": [
            "g_dnsRef",
            "&srvRefs.val[srvRefs.len]",
            "kDNSServiceFlagsUnique | kDNSServiceFlagsShareConnection",
            "0",
            "name",
            "kDNSServiceType_SRV",
            "kDNSServiceClass_IN",
            "size",
            "target",
            "0",
            "dnsCallback",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceConstructFullName",
          "args": [
            "name",
            "NULL",
            "register_names[i]",
            "realm"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"malloc: out of memory\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "srvRefs.val",
            "sizeof(srvRefs.val[0]) * (srvRefs.len + 1)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "\"register SRV rr for realm %s hostname %s:%d\"",
            "realm",
            "hostname",
            "port"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dn_comp",
          "args": [
            "hostname",
            "target + 6",
            "sizeof(target) - 6",
            "NULL",
            "NULL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "realm",
            "\"LKDC:\"",
            "5"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nregister_srv(const char *realm, const char *hostname, int port)\n{\n    unsigned char target[1024];\n    int i;\n    int size;\n\n    /* skip registering LKDC realms */\n    if (strncmp(realm, \"LKDC:\", 5) == 0)\n\treturn;\n\n    /* encode SRV-RR */\n    target[0] = 0; /* priority */\n    target[1] = 0; /* priority */\n    target[2] = 0; /* weight */\n    target[3] = 0; /* weigth */\n    target[4] = (port >> 8) & 0xff; /* port */\n    target[5] = (port >> 0) & 0xff; /* port */\n\n    size = dn_comp(hostname, target + 6, sizeof(target) - 6, NULL, NULL);\n    if (size < 0)\n\treturn;\n\n    size += 6;\n\n    LOG(\"register SRV rr for realm %s hostname %s:%d\", realm, hostname, port);\n\n    for (i = 0; i < sizeof(register_names)/sizeof(register_names[0]); i++) {\n\tchar name[kDNSServiceMaxDomainName];\n\tDNSServiceErrorType error;\n\tvoid *ptr;\n\n\tptr = realloc(srvRefs.val, sizeof(srvRefs.val[0]) * (srvRefs.len + 1));\n\tif (ptr == NULL)\n\t    errx(1, \"malloc: out of memory\");\n\tsrvRefs.val = ptr;\n\n\tDNSServiceConstructFullName(name, NULL, register_names[i], realm);\n\n\terror = DNSServiceRegisterRecord(g_dnsRef,\n\t\t\t\t\t &srvRefs.val[srvRefs.len],\n\t\t\t\t\t kDNSServiceFlagsUnique | kDNSServiceFlagsShareConnection,\n\t\t\t\t\t 0,\n\t\t\t\t\t name,\n\t\t\t\t\t kDNSServiceType_SRV,\n\t\t\t\t\t kDNSServiceClass_IN,\n\t\t\t\t\t size,\n\t\t\t\t\t target,\n\t\t\t\t\t 0,\n\t\t\t\t\t dnsCallback,\n\t\t\t\t\t NULL);\n\tif (error) {\n\t    LOG(\"Failed to register SRV rr for realm %s: %d\", realm, error);\n\t} else\n\t    srvRefs.len++;\n    }\n}"
  },
  {
    "function_name": "dnsCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "206-213",
    "snippet": "static void\ndnsCallback(DNSServiceRef sdRef __attribute__((unused)),\n\t    DNSRecordRef RecordRef __attribute__((unused)),\n\t    DNSServiceFlags flags __attribute__((unused)),\n\t    DNSServiceErrorType errorCode __attribute__((unused)),\n\t    void *context __attribute__((unused)))\n{\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ndnsCallback(DNSServiceRef sdRef __attribute__((unused)),\n\t    DNSRecordRef RecordRef __attribute__((unused)),\n\t    DNSServiceFlags flags __attribute__((unused)),\n\t    DNSServiceErrorType errorCode __attribute__((unused)),\n\t    void *context __attribute__((unused)))\n{\n}"
  },
  {
    "function_name": "domains_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "192-203",
    "snippet": "static void\ndomains_add(const void *key, const void *value, void *context)\n{\n    char *str = CFString2utf8((CFStringRef)value);\n    struct addctx *ctx = context;\n\n    if (str == NULL)\n\treturn;\n    if (str[0] != '\\0')\n\tdomain_add(str, ctx->realm, F_EXISTS | ctx->flags);\n    free(str);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_EXISTS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_add",
          "args": [
            "str",
            "ctx->realm",
            "F_EXISTS | ctx->flags"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "domain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "157-185",
          "snippet": "static void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n\nstatic void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFString2utf8",
          "args": [
            "(CFStringRef)value"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "CFString2utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "75-91",
          "snippet": "static char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_EXISTS 1\n\nstatic void\ndomains_add(const void *key, const void *value, void *context)\n{\n    char *str = CFString2utf8((CFStringRef)value);\n    struct addctx *ctx = context;\n\n    if (str == NULL)\n\treturn;\n    if (str[0] != '\\0')\n\tdomain_add(str, ctx->realm, F_EXISTS | ctx->flags);\n    free(str);\n}"
  },
  {
    "function_name": "domain_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "157-185",
    "snippet": "static void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [
      "#define F_PUSH 2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "e"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "e->realm"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "e->domain"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "realm"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "domain"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*e)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "\"Adding realm %s to domain %s\"",
            "realm",
            "domain"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "realm",
            "e->realm"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domain",
            "e->domain"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n\nstatic void\ndomain_add(const char *domain, const char *realm, int flag)\n{\n    struct entry *e;\n\n    for (e = g_entries; e != NULL; e = e->next) {\n\tif (strcmp(domain, e->domain) == 0 && strcmp(realm, e->realm) == 0) {\n\t    e->flags |= flag;\n\t    return;\n\t}\n    }\n\n    LOG(\"Adding realm %s to domain %s\", realm, domain);\n\n    e = calloc(1, sizeof(*e));\n    if (e == NULL)\n\treturn;\n    e->domain = strdup(domain);\n    e->realm = strdup(realm);\n    if (e->domain == NULL || e->realm == NULL) {\n\tfree(e->domain);\n\tfree(e->realm);\n\tfree(e);\n\treturn;\n    }\n    e->flags = flag | F_PUSH; /* if we allocate, we push */\n    e->next = g_entries;\n    g_entries = e;\n}"
  },
  {
    "function_name": "create_dns_sd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "118-155",
    "snippet": "static void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_resume",
          "args": [
            "g_queue"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_all",
          "args": [
            "g_store",
            "NULL",
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "update_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "420-465",
          "snippet": "static void\nupdate_all(SCDynamicStoreRef store, CFArrayRef changedKeys, void *info)\n{\n    struct entry *e;\n    CFStringRef host;\n    int i, flags = 0;\n\n    LOG(\"something changed, running update\");\n\n    host = SCDynamicStoreCopyLocalHostName(store);\n    if (host == NULL)\n\treturn;\n\n    if (g_hostname == NULL || CFStringCompare(host, g_hostname, 0) != kCFCompareEqualTo) {\n\tif (g_hostname)\n\t    CFRelease(g_hostname);\n\tg_hostname = CFRetain(host);\n\tflags = F_PUSH; /* if hostname has changed, force push */\n\n#ifdef REGISTER_SRV_RR\n\tregister_srv_realms(g_hostname);\n#endif\n    }\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tkrb5_error_code ret;\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, announce_config->db[i], &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tupdate_entries(store, *r, flags);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    update_dns();\n\n    CFRelease(host);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [
            "#define F_PUSH 2",
            "#define F_EXISTS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\n#define F_PUSH 2\n#define F_EXISTS 1\n\nstatic void\nupdate_all(SCDynamicStoreRef store, CFArrayRef changedKeys, void *info)\n{\n    struct entry *e;\n    CFStringRef host;\n    int i, flags = 0;\n\n    LOG(\"something changed, running update\");\n\n    host = SCDynamicStoreCopyLocalHostName(store);\n    if (host == NULL)\n\treturn;\n\n    if (g_hostname == NULL || CFStringCompare(host, g_hostname, 0) != kCFCompareEqualTo) {\n\tif (g_hostname)\n\t    CFRelease(g_hostname);\n\tg_hostname = CFRetain(host);\n\tflags = F_PUSH; /* if hostname has changed, force push */\n\n#ifdef REGISTER_SRV_RR\n\tregister_srv_realms(g_hostname);\n#endif\n    }\n\n    for (e = g_entries; e != NULL; e = e->next)\n\te->flags &= ~(F_EXISTS|F_PUSH);\n\n    for(i = 0; i < announce_config->num_db; i++) {\n\tkrb5_error_code ret;\n\tchar **realms, **r;\n\n\tif (announce_config->db[i]->hdb_get_realms == NULL)\n\t    continue;\n\n\tret = (announce_config->db[i]->hdb_get_realms)(announce_context, announce_config->db[i], &realms);\n\tif (ret == 0) {\n\t    for (r = realms; r && *r; r++)\n\t\tupdate_entries(store, *r, flags);\n\t    krb5_free_host_realm(announce_context, realms);\n\t}\n    }\n\n    update_dns();\n\n    CFRelease(host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispatch_resume",
          "args": [
            "s"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_source_set_cancel_handler",
          "args": [
            "s",
            "^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t}"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_release",
          "args": [
            "s"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retry_timer",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "retry_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "97-112",
          "snippet": "static void\nretry_timer(void)\n{\n    dispatch_source_t s;\n    dispatch_time_t t;\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,\n\t\t\t       0, 0, g_queue);\n    t = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);\n    dispatch_source_set_timer(s, t, 0, NSEC_PER_SEC);\n    dispatch_source_set_event_handler(s, ^{\n\t    create_dns_sd();\n\t    dispatch_release(s);\n\t});\n    dispatch_resume(s);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nretry_timer(void)\n{\n    dispatch_source_t s;\n    dispatch_time_t t;\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,\n\t\t\t       0, 0, g_queue);\n    t = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);\n    dispatch_source_set_timer(s, t, 0, NSEC_PER_SEC);\n    dispatch_source_set_event_handler(s, ^{\n\t    create_dns_sd();\n\t    dispatch_release(s);\n\t});\n    dispatch_resume(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_dns_sd",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_dns_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "480-493",
          "snippet": "static void\ndestroy_dns_sd(void)\n{\n    if (g_dnsRef == NULL)\n\treturn;\n\n    delete_all();\n#ifdef REGISTER_SRV_RR\n    unregister_srv_realms();\n#endif\n\n    DNSServiceRefDeallocate(g_dnsRef);\n    g_dnsRef = NULL;\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ndestroy_dns_sd(void)\n{\n    if (g_dnsRef == NULL)\n\treturn;\n\n    delete_all();\n#ifdef REGISTER_SRV_RR\n    unregister_srv_realms();\n#endif\n\n    DNSServiceRefDeallocate(g_dnsRef);\n    g_dnsRef = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispatch_source_set_event_handler",
          "args": [
            "s",
            "^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t}"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_source_cancel",
          "args": [
            "s"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceProcessResult",
          "args": [
            "g_dnsRef"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_source_create",
          "args": [
            "DISPATCH_SOURCE_TYPE_READ",
            "DNSServiceRefSockFD(g_dnsRef)",
            "0",
            "g_queue"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceRefSockFD",
          "args": [
            "g_dnsRef"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_suspend",
          "args": [
            "g_queue"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSServiceCreateConnection",
          "args": [
            "&g_dnsRef"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}"
  },
  {
    "function_name": "retry_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "97-112",
    "snippet": "static void\nretry_timer(void)\n{\n    dispatch_source_t s;\n    dispatch_time_t t;\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,\n\t\t\t       0, 0, g_queue);\n    t = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);\n    dispatch_source_set_timer(s, t, 0, NSEC_PER_SEC);\n    dispatch_source_set_event_handler(s, ^{\n\t    create_dns_sd();\n\t    dispatch_release(s);\n\t});\n    dispatch_resume(s);\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_resume",
          "args": [
            "s"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_source_set_event_handler",
          "args": [
            "s",
            "^{\n\t    create_dns_sd();\n\t    dispatch_release(s);\n\t}"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_release",
          "args": [
            "s"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_dns_sd",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "create_dns_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
          "lines": "118-155",
          "snippet": "static void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}",
          "includes": [
            "#include <err.h>",
            "#include <dns_sd.h>",
            "#include <resolv.h>",
            "#include <asl.h>",
            "#include <dispatch/dispatch.h>",
            "#include <SystemConfiguration/SCDynamicStoreKey.h>",
            "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
            "#include <SystemConfiguration/SCDynamicStore.h>",
            "#include <CoreFoundation/CoreFoundation.h>",
            "#include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\ncreate_dns_sd(void)\n{\n    DNSServiceErrorType error;\n    dispatch_source_t s;\n\n    error = DNSServiceCreateConnection(&g_dnsRef);\n    if (error) {\n\tretry_timer();\n\treturn;\n    }\n\n    dispatch_suspend(g_queue);\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,\n\t\t\t       DNSServiceRefSockFD(g_dnsRef),\n\t\t\t       0, g_queue);\n\n    dispatch_source_set_event_handler(s, ^{\n\t    DNSServiceErrorType ret = DNSServiceProcessResult(g_dnsRef);\n\t    /* on error tear down and set timer to recreate */\n\t    if (ret != kDNSServiceErr_NoError && ret != kDNSServiceErr_Transient) {\n\t\tdispatch_source_cancel(s);\n\t    }\n\t});\n\n    dispatch_source_set_cancel_handler(s, ^{\n\t    destroy_dns_sd();\n\t    retry_timer();\n\t    dispatch_release(s);\n\t});\n\n    dispatch_resume(s);\n\n    /* Do the first update ourself */\n    update_all(g_store, NULL, NULL);\n    dispatch_resume(g_queue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dispatch_source_set_timer",
          "args": [
            "s",
            "t",
            "0",
            "NSEC_PER_SEC"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_time",
          "args": [
            "DISPATCH_TIME_NOW",
            "5ull * NSEC_PER_SEC"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dispatch_source_create",
          "args": [
            "DISPATCH_SOURCE_TYPE_TIMER",
            "0",
            "0",
            "g_queue"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic void\nretry_timer(void)\n{\n    dispatch_source_t s;\n    dispatch_time_t t;\n\n    s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,\n\t\t\t       0, 0, g_queue);\n    t = dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC);\n    dispatch_source_set_timer(s, t, 0, NSEC_PER_SEC);\n    dispatch_source_set_event_handler(s, ^{\n\t    create_dns_sd();\n\t    dispatch_release(s);\n\t});\n    dispatch_resume(s);\n}"
  },
  {
    "function_name": "CFString2utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/announce.c",
    "lines": "75-91",
    "snippet": "static char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}",
    "includes": [
      "#include <err.h>",
      "#include <dns_sd.h>",
      "#include <resolv.h>",
      "#include <asl.h>",
      "#include <dispatch/dispatch.h>",
      "#include <SystemConfiguration/SCDynamicStoreKey.h>",
      "#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>",
      "#include <SystemConfiguration/SCDynamicStore.h>",
      "#include <CoreFoundation/CoreFoundation.h>",
      "#include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFStringGetCString",
          "args": [
            "string",
            "str",
            "size",
            "kCFStringEncodingUTF8"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFStringGetMaximumSizeForEncoding",
          "args": [
            "CFStringGetLength(string)",
            "kCFStringEncodingUTF8"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFStringGetLength",
          "args": [
            "string"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <err.h>\n#include <dns_sd.h>\n#include <resolv.h>\n#include <asl.h>\n#include <dispatch/dispatch.h>\n#include <SystemConfiguration/SCDynamicStoreKey.h>\n#include <SystemConfiguration/SCDynamicStoreCopySpecific.h>\n#include <SystemConfiguration/SCDynamicStore.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include \"kdc_locl.h\"\n\nstatic char *\nCFString2utf8(CFStringRef string)\n{\n    size_t size;\n    char *str;\n\n    size = 1 + CFStringGetMaximumSizeForEncoding(CFStringGetLength(string), kCFStringEncodingUTF8);\n    str = malloc(size);\n    if (str == NULL)\n\treturn NULL;\n\n    if (CFStringGetCString(string, str, size, kCFStringEncodingUTF8) == false) {\n\tfree(str);\n\treturn NULL;\n    }\n    return str;\n}"
  }
]