[
  {
    "function_name": "rb5_kdc_save_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "267-329",
    "snippet": "nt\nkrb5_kdc_save_request(krb5_context context,\n\t\t      const char *fn,\n\t\t      const unsigned char *buf,\n\t\t      size_t len,\n\t\t      const krb5_data *reply,\n\t\t      const struct sockaddr *sa)\n{\n    krb5_storage *sp;\n    krb5_address a;\n    int fd, ret;\n    uint32_t t;\n    krb5_data d;\n\n    memset(&a, 0, sizeof(a));\n\n    d.data = rk_UNCONST(buf);\n    d.length = len;\n    t = _kdc_now.tv_sec;\n\n    fd = open(fn, O_WRONLY|O_CREAT|O_APPEND, 0600);\n    if (fd < 0) {\n\tint saved_errno = errno;\n\tkrb5_set_error_message(context, saved_errno, \"Failed to open: %s\", fn);\n\treturn saved_errno;\n    }\n\n    sp = krb5_storage_from_fd(fd);\n    close(fd);\n    if (sp == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"Storage failed to open fd\");\n\treturn ENOMEM;\n    }\n\n    ret = krb5_sockaddr2address(context, sa, &a);\n    if (ret)\n\tgoto out;\n\n    krb5_store_uint32(sp, 1);\n    krb5_store_uint32(sp, t);\n    krb5_store_address(sp, a);\n    krb5_store_data(sp, d);\n    {\n\tDer_class cl;\n\tDer_type ty;\n\tunsigned int tag;\n\tret = der_get_tag (reply->data, reply->length,\n\t\t\t   &cl, &ty, &tag, NULL);\n\tif (ret) {\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t} else {\n\t    krb5_store_uint32(sp, MAKE_TAG(cl, ty, 0));\n\t    krb5_store_uint32(sp, tag);\n\t}\n    }\n\n    krb5_free_address(context, &a);\nout:\n    krb5_storage_free(sp);\n\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_address(",
          "args": [
            "ontext,",
            "a)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            "ag)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            "AKE_TAG(cl, ty, 0))"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AKE_TAG(",
          "args": [
            "l,",
            "y,",
            ")"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            "xffffffff)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            "xffffffff)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_get_tag",
          "args": [
            "eply->data,",
            "eply->length,",
            "cl,",
            "ty,",
            "tag,",
            "ULL)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_data(",
          "args": [
            "p,",
            ")"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_address(",
          "args": [
            "p,",
            ")"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            ")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_store_uint32(",
          "args": [
            "p,",
            ")"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_sockaddr2address(",
          "args": [
            "ontext,",
            "a,",
            "a)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "NOMEM,",
            "Storage failed to open fd\")"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_from_fd(",
          "args": [
            "d)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "aved_errno,",
            "Failed to open: %s\",",
            "n)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen(",
          "args": [
            "n,",
            "_WRONLY|O_CREAT|O_APPEND,",
            "600)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_UNCONST(",
          "args": [
            "uf)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "a,",
            ",",
            "izeof(a))"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nnt\nkrb5_kdc_save_request(krb5_context context,\n\t\t      const char *fn,\n\t\t      const unsigned char *buf,\n\t\t      size_t len,\n\t\t      const krb5_data *reply,\n\t\t      const struct sockaddr *sa)\n{\n    krb5_storage *sp;\n    krb5_address a;\n    int fd, ret;\n    uint32_t t;\n    krb5_data d;\n\n    memset(&a, 0, sizeof(a));\n\n    d.data = rk_UNCONST(buf);\n    d.length = len;\n    t = _kdc_now.tv_sec;\n\n    fd = open(fn, O_WRONLY|O_CREAT|O_APPEND, 0600);\n    if (fd < 0) {\n\tint saved_errno = errno;\n\tkrb5_set_error_message(context, saved_errno, \"Failed to open: %s\", fn);\n\treturn saved_errno;\n    }\n\n    sp = krb5_storage_from_fd(fd);\n    close(fd);\n    if (sp == NULL) {\n\tkrb5_set_error_message(context, ENOMEM, \"Storage failed to open fd\");\n\treturn ENOMEM;\n    }\n\n    ret = krb5_sockaddr2address(context, sa, &a);\n    if (ret)\n\tgoto out;\n\n    krb5_store_uint32(sp, 1);\n    krb5_store_uint32(sp, t);\n    krb5_store_address(sp, a);\n    krb5_store_data(sp, d);\n    {\n\tDer_class cl;\n\tDer_type ty;\n\tunsigned int tag;\n\tret = der_get_tag (reply->data, reply->length,\n\t\t\t   &cl, &ty, &tag, NULL);\n\tif (ret) {\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t    krb5_store_uint32(sp, 0xffffffff);\n\t} else {\n\t    krb5_store_uint32(sp, MAKE_TAG(cl, ty, 0));\n\t    krb5_store_uint32(sp, tag);\n\t}\n    }\n\n    krb5_free_address(context, &a);\nout:\n    krb5_storage_free(sp);\n\n    return 0;\n}"
  },
  {
    "function_name": "rb5_kdc_process_krb5_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "232-261",
    "snippet": "nt\nkrb5_kdc_process_krb5_request(krb5_context context,\n\t\t\t      krb5_kdc_configuration *config,\n\t\t\t      unsigned char *buf,\n\t\t\t      size_t len,\n\t\t\t      krb5_data *reply,\n\t\t\t      const char *from,\n\t\t\t      struct sockaddr *addr,\n\t\t\t      int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tif ((services[i].flags & KS_KRB5) == 0)\n\t    continue;\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim)\n\t    return ret;\n    }\n\n    return -1;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "*services[i].process)",
          "args": [
            "ontext,",
            "onfig,",
            "req_buffer,",
            "eply,",
            "rom,",
            "ddr,",
            "atagram_reply,",
            "claim)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};\n\nnt\nkrb5_kdc_process_krb5_request(krb5_context context,\n\t\t\t      krb5_kdc_configuration *config,\n\t\t\t      unsigned char *buf,\n\t\t\t      size_t len,\n\t\t\t      krb5_data *reply,\n\t\t\t      const char *from,\n\t\t\t      struct sockaddr *addr,\n\t\t\t      int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tif ((services[i].flags & KS_KRB5) == 0)\n\t    continue;\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim)\n\t    return ret;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "rb5_kdc_process_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "187-223",
    "snippet": "nt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eim_release(",
          "args": [
            "ool)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_release(",
          "args": [
            "ool)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*services[i].process)",
          "args": [
            "ontext,",
            "onfig,",
            "req_buffer,",
            "eply,",
            "rom,",
            "ddr,",
            "atagram_reply,",
            "claim)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_auto_release_create(",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};\n\nnt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}"
  },
  {
    "function_name": "dc_kx509(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "141-165",
    "snippet": "tatic krb5_error_code\nkdc_kx509(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  krb5_data *req_buffer,\n\t  krb5_data *reply,\n\t  const char *from,\n\t  struct sockaddr *addr,\n\t  int datagram_reply,\n\t  int *claim)\n{\n    Kx509Request kx509req;\n    krb5_error_code ret;\n    size_t len;\n\n    ret = _kdc_try_kx509_request(req_buffer->data, req_buffer->length,\n\t\t\t\t &kx509req, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_do_kx509(context, config, &kx509req, reply, from, addr);\n    free_Kx509Request(&kx509req);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_Kx509Request(",
          "args": [
            "kx509req)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_do_kx509(",
          "args": [
            "ontext,",
            "onfig,",
            "kx509req,",
            "eply,",
            "rom,",
            "ddr)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_try_kx509_request(",
          "args": [
            "eq_buffer->data,",
            "eq_buffer->length,",
            "kx509req,",
            "len)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_try_kx509_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kx509.c",
          "lines": "45-53",
          "snippet": "rb5_error_code\n_kdc_try_kx509_request(void *ptr, size_t len, struct Kx509Request *req, size_t *size)\n{\n    if (len < 4)\n\treturn -1;\n    if (memcmp(\"\\x00\\x00\\x02\\x00\", ptr, 4) != 0)\n\treturn -1;\n    return decode_Kx509Request(((unsigned char *)ptr) + 4, len - 4, req, size);\n}",
          "includes": [
            "include <hx509.h>",
            "include <rfc2459_asn1.h>\n#",
            "include <hex.h>\n#",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hx509.h>\ninclude <rfc2459_asn1.h>\n#\ninclude <hex.h>\n#\ninclude \"kdc_locl.h\"\n#\n\nrb5_error_code\n_kdc_try_kx509_request(void *ptr, size_t len, struct Kx509Request *req, size_t *size)\n{\n    if (len < 4)\n\treturn -1;\n    if (memcmp(\"\\x00\\x00\\x02\\x00\", ptr, 4) != 0)\n\treturn -1;\n    return decode_Kx509Request(((unsigned char *)ptr) + 4, len - 4, req, size);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nkdc_kx509(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  krb5_data *req_buffer,\n\t  krb5_data *reply,\n\t  const char *from,\n\t  struct sockaddr *addr,\n\t  int datagram_reply,\n\t  int *claim)\n{\n    Kx509Request kx509req;\n    krb5_error_code ret;\n    size_t len;\n\n    ret = _kdc_try_kx509_request(req_buffer->data, req_buffer->length,\n\t\t\t\t &kx509req, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_do_kx509(context, config, &kx509req, reply, from, addr);\n    free_Kx509Request(&kx509req);\n    return ret;\n}"
  },
  {
    "function_name": "dc_digest(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "111-135",
    "snippet": "tatic krb5_error_code\nkdc_digest(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_data *req_buffer,\n\t   krb5_data *reply,\n\t   const char *from,\n\t   struct sockaddr *addr,\n\t   int datagram_reply,\n\t   int *claim)\n{\n    DigestREQ digestreq;\n    krb5_error_code ret;\n    size_t len;\n\n    ret = decode_DigestREQ(req_buffer->data, req_buffer->length,\n\t\t\t   &digestreq, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_do_digest(context, config, &digestreq, reply, from, addr);\n    free_DigestREQ(&digestreq);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_DigestREQ(",
          "args": [
            "digestreq)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_do_digest(",
          "args": [
            "ontext,",
            "onfig,",
            "digestreq,",
            "eply,",
            "rom,",
            "ddr)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_do_digest(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/digest.c",
          "lines": "201-1512",
          "snippet": "rb5_error_code\n_kdc_do_digest(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       const struct DigestREQ *req, krb5_data *reply,\n\t       const char *from, struct sockaddr *addr)\n{\n    krb5_error_code ret = 0;\n    krb5_ticket *ticket = NULL;\n    krb5_auth_context ac = NULL;\n    krb5_keytab id = NULL;\n    krb5_crypto crypto = NULL;\n    DigestReqInner ireq;\n    DigestRepInner r;\n    DigestREP rep;\n    krb5_flags ap_req_options;\n    krb5_data buf;\n    size_t size;\n    krb5_storage *sp = NULL;\n    Checksum res;\n    hdb_entry_ex *server = NULL, *user = NULL;\n    hdb_entry_ex *client = NULL;\n    char *client_name = NULL, *password = NULL;\n    krb5_data serverNonce;\n\n    if(!config->enable_digest) {\n\tkdc_log(context, config, 0,\n\t\t\"Rejected digest request (disabled) from %s\", from);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(reply);\n    krb5_data_zero(&serverNonce);\n    memset(&ireq, 0, sizeof(ireq));\n    memset(&r, 0, sizeof(r));\n    memset(&rep, 0, sizeof(rep));\n    memset(&res, 0, sizeof(res));\n\n    kdc_log(context, config, 0, \"Digest request from %s\", from);\n\n    ret = krb5_kt_resolve(context, \"HDBGET:\", &id);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Can't open database for digest\");\n\tgoto out;\n    }\n\n    ret = krb5_rd_req(context,\n\t\t      &ac,\n\t\t      &req->apReq,\n\t\t      NULL,\n\t\t      id,\n\t\t      &ap_req_options,\n\t\t      &ticket);\n    if (ret)\n\tgoto out;\n\n    /* check the server principal in the ticket matches digest/R@R */\n    {\n\tkrb5_principal principal = NULL;\n\tconst char *p, *rr;\n\n\tret = krb5_ticket_get_server(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"Wrong digest server principal used\");\n\tp = krb5_principal_get_comp_string(context, principal, 0);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, KRB5_DIGEST_NAME) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tp = krb5_principal_get_comp_string(context, principal, 1);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\trr = krb5_principal_get_realm(context, principal);\n\tif (rr == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, rr) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tkrb5_clear_error_message(context);\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_SERVER, NULL, NULL, &server);\n\tif (ret)\n\t    goto out;\n\n\tkrb5_free_principal(context, principal);\n    }\n\n    /* check the client is allowed to do digest auth */\n    {\n\tkrb5_principal principal = NULL;\n\n\tret = krb5_ticket_get_client(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, principal, &client_name);\n\tif (ret) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &client);\n\tkrb5_free_principal(context, principal);\n\tif (ret)\n\t    goto out;\n\n\tif (client->entry.flags.allow_digest == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client %s tried to use digest \"\n\t\t    \"but is not allowed to\",\n\t\t    client_name);\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Client is not permitted to use digest\");\n\t    goto out;\n\t}\n    }\n\n    /* unpack request */\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getremotesubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\tif (key == NULL) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"digest: remote subkey not found\");\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     &req->innerReq, &buf);\n    krb5_crypto_destroy(context, crypto);\n    crypto = NULL;\n    if (ret)\n\tgoto out;\n\n    ret = decode_DigestReqInner(buf.data, buf.length, &ireq, NULL);\n    krb5_data_free(&buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode digest inner request\");\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"Valid digest request from %s (%s)\",\n\t    client_name, from);\n\n    /*\n     * Process the inner request\n     */\n\n    switch (ireq.element) {\n    case choice_DigestReqInner_init: {\n\tunsigned char server_nonce[16], identifier;\n\n\tRAND_pseudo_bytes(&identifier, sizeof(identifier));\n\tRAND_pseudo_bytes(server_nonce, sizeof(server_nonce));\n\n\tserver_nonce[0] = kdc_time & 0xff;\n\tserver_nonce[1] = (kdc_time >> 8) & 0xff;\n\tserver_nonce[2] = (kdc_time >> 16) & 0xff;\n\tserver_nonce[3] = (kdc_time >> 24) & 0xff;\n\n\tr.element = choice_DigestRepInner_initReply;\n\n\thex_encode(server_nonce, sizeof(server_nonce), &r.u.initReply.nonce);\n\tif (r.u.initReply.nonce == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode server nonce\");\n\t    goto out;\n\t}\n\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.init.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (ireq.u.init.channel) {\n\t    char *s;\n\t    int aret;\n\n\t    aret = asprintf(&s, \"%s-%s:%s\", r.u.initReply.nonce,\n\t\t\t    ireq.u.init.channel->cb_type,\n\t\t\t    ireq.u.init.channel->cb_binding);\n\t    if (aret == -1 || s == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed to allocate channel binding\");\n\t\tgoto out;\n\t    }\n\t    free(r.u.initReply.nonce);\n\t    r.u.initReply.nonce = s;\n\t}\n\n\tret = krb5_store_stringz(sp, r.u.initReply.nonce);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (strcasecmp(ireq.u.init.type, \"CHAP\") == 0) {\n\t    int aret;\n\n\t    r.u.initReply.identifier =\n\t\tmalloc(sizeof(*r.u.initReply.identifier));\n\t    if (r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    aret = asprintf(r.u.initReply.identifier, \"%02X\", identifier&0xff);\n\t    if (aret == -1 || *r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t} else\n\t    r.u.initReply.identifier = NULL;\n\n\tif (ireq.u.init.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.init.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_create_checksum(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   0,\n\t\t\t\t   buf.data,\n\t\t\t\t   buf.length,\n\t\t\t\t   &res);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tkrb5_data_free(&buf);\n\tif (ret)\n\t    goto out;\n\n\tASN1_MALLOC_ENCODE(Checksum, buf.data, buf.length, &res, &size, ret);\n\tfree_Checksum(&res);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to encode \"\n\t\t\t\t   \"checksum in digest request\");\n\t    goto out;\n\t}\n\tif (size != buf.length)\n\t    krb5_abortx(context, \"ASN1 internal error\");\n\n\thex_encode(buf.data, buf.length, &r.u.initReply.opaque);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (r.u.initReply.opaque == NULL) {\n\t    krb5_clear_error_message(context);\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s init request successful from %s\",\n\t\tireq.u.init.type, from);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_digestRequest: {\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.digestRequest.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_store_stringz(sp, ireq.u.digestRequest.serverNonce);\n\n\tif (ireq.u.digestRequest.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.digestRequest.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tbuf.length = strlen(ireq.u.digestRequest.opaque);\n\tbuf.data = malloc(buf.length);\n\tif (buf.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = hex_decode(ireq.u.digestRequest.opaque, buf.data, buf.length);\n\tif (ret <= 0) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode opaque\");\n\t    goto out;\n\t}\n\tbuf.length = ret;\n\n\tret = decode_Checksum(buf.data, buf.length, &res, NULL);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Failed to decode digest Checksum\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tserverNonce.length = strlen(ireq.u.digestRequest.serverNonce);\n\tserverNonce.data = malloc(serverNonce.length);\n\tif (serverNonce.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * CHAP does the checksum of the raw nonce, but do it for all\n\t * types, since we need to check the timestamp.\n\t */\n\t{\n\t    ssize_t ssize;\n\n\t    ssize = hex_decode(ireq.u.digestRequest.serverNonce,\n\t\t\t       serverNonce.data, serverNonce.length);\n\t    if (ssize <= 0) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"Failed to decode serverNonce\");\n\t\tgoto out;\n\t    }\n\t    serverNonce.length = ssize;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_verify_checksum(context, crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   buf.data, buf.length, &res);\n\tfree_Checksum(&res);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\t/* verify time */\n\t{\n\t    unsigned char *p = serverNonce.data;\n\t    uint32_t t;\n\n\t    if (serverNonce.length < 4) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"server nonce too short\");\n\t\tgoto out;\n\t    }\n\t    t = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n\n\t    if (labs((kdc_time & 0xffffffff) - t) > context->max_skew) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"time screw in server nonce \");\n\t\tgoto out;\n\t    }\n\t}\n\n\tif (strcasecmp(ireq.u.digestRequest.type, \"CHAP\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char idx;\n\n\t    if ((config->digests_allowed & CHAP_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest CHAP MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.identifier == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"Identifier missing \"\n\t\t\t\t       \"from CHAP request\");\n\t\tgoto out;\n\t    }\n\n\t    if (hex_decode(*ireq.u.digestRequest.identifier, &idx, 1) != 1) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"failed to decode identifier\");\n\t\tgoto out;\n\t    }\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, &idx, 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestUpdate(ctx, serverNonce.data, serverNonce.length);\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"CHAP reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"SASL-DIGEST-MD5\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char *A1, *A2;\n\n\t    if ((config->digests_allowed & DIGEST_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest SASL MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.nonceCount == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.clientNonce == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.qop == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.realm == NULL)\n\t\tgoto out;\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.username,\n\t\t       strlen(ireq.u.digestRequest.username));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.realm,\n\t\t       strlen(*ireq.u.digestRequest.realm));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, md, sizeof(md));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    if (ireq.u.digestRequest.authid) {\n\t\tEVP_DigestUpdate(ctx, \":\", 1);\n\t\tEVP_DigestUpdate(ctx, *ireq.u.digestRequest.authid,\n\t\t\t   strlen(*ireq.u.digestRequest.authid));\n\t    }\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\t    hex_encode(md, sizeof(md), &A1);\n\t    if (A1 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tEVP_MD_CTX_destroy(ctx);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx,\n\t\t\t     \"AUTHENTICATE:\", sizeof(\"AUTHENTICATE:\") - 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.uri,\n\t\t       strlen(*ireq.u.digestRequest.uri));\n\n\t    /* conf|int */\n\t    if (strcmp(ireq.u.digestRequest.digest, \"clear\") != 0) {\n\t\tstatic char conf_zeros[] = \":00000000000000000000000000000000\";\n\t\tEVP_DigestUpdate(ctx, conf_zeros, sizeof(conf_zeros) - 1);\n\t    }\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    hex_encode(md, sizeof(md), &A2);\n\t    if (A2 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tfree(A1);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, A1, strlen(A2));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.clientNonce,\n\t\t       strlen(*ireq.u.digestRequest.clientNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.qop,\n\t\t       strlen(*ireq.u.digestRequest.qop));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, A2, strlen(A2));\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    free(A1);\n\t    free(A2);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"DIGEST-MD5 reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"MS-CHAP-V2\") == 0) {\n\t    unsigned char md[SHA_DIGEST_LENGTH], challenge[SHA_DIGEST_LENGTH];\n\t    krb5_principal clientprincipal = NULL;\n\t    char *mdx;\n\t    const char *username;\n\t    struct ntlm_buf answer;\n\t    Key *key = NULL;\n\t    EVP_MD_CTX *ctp;\n\n\t    if ((config->digests_allowed & MS_CHAP_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"MS-CHAP-V2 not allowed\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.digestRequest.clientNonce == NULL)  {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 clientNonce missing\");\n\t\tgoto failed;\n\t    }\n\t    if (serverNonce.length != 16) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 serverNonce wrong length\");\n\t\tgoto failed;\n\t    }\n\n\t    /* strip of the domain component */\n\t    username = strchr(ireq.u.digestRequest.username, '\\\\');\n\t    if (username == NULL)\n\t\tusername = ireq.u.digestRequest.username;\n\t    else\n\t\tusername++;\n\n\t    ctp = EVP_MD_CTX_create();\n\n\t    /* ChallengeHash */\n\t    EVP_DigestInit_ex(ctp, EVP_sha1(), NULL);\n\t    {\n\t\tssize_t ssize;\n\t\tkrb5_data clientNonce;\n\n\t\tclientNonce.length = strlen(*ireq.u.digestRequest.clientNonce);\n\t\tclientNonce.data = malloc(clientNonce.length);\n\t\tif (clientNonce.data == NULL) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"malloc: out of memory\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\n\t\tssize = hex_decode(*ireq.u.digestRequest.clientNonce,\n\t\t\t\t   clientNonce.data, clientNonce.length);\n\t\tif (ssize != 16) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed to decode clientNonce\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\t\tEVP_DigestUpdate(ctp, clientNonce.data, ssize);\n\t\tfree(clientNonce.data);\n\t    }\n\t    EVP_DigestUpdate(ctp, serverNonce.data, serverNonce.length);\n\t    EVP_DigestUpdate(ctp, username, strlen(username));\n\n\t    EVP_DigestFinal_ex(ctp, challenge, NULL);\n\n\t    EVP_MD_CTX_destroy(ctp);\n\n\t    /* NtPasswordHash */\n\t    ret = krb5_parse_name(context, username, &clientprincipal);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &user);\n\t    krb5_free_principal(context, clientprincipal);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 user %s not in database\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    ret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t\t  ETYPE_ARCFOUR_HMAC_MD5, &key);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 missing arcfour key %s\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    /* ChallengeResponse */\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    hex_encode(answer.data, answer.length, &mdx);\n\t    if (mdx == NULL) {\n\t\tfree(answer.data);\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"MS-CHAP-V2 hash mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\t    free(mdx);\n\n\t    if (r.u.response.success) {\n\t\tunsigned char hashhash[MD4_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctxp;\n\n\t\tctxp = EVP_MD_CTX_create();\n\n\t\t/* hashhash */\n\t\t{\n\t\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t\t    EVP_DigestUpdate(ctxp,\n\t\t\t\t     key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length);\n\t\t    EVP_DigestFinal_ex(ctxp, hashhash, NULL);\n\t\t}\n\n\t\t/* GenerateAuthenticatorResponse */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, sizeof(hashhash));\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic1,\n\t\t\t\t sizeof(ms_chap_v2_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, md, sizeof(md));\n\t\tEVP_DigestUpdate(ctxp, challenge, 8);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic2,\n\t\t\t\t sizeof(ms_chap_v2_magic2));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tr.u.response.rsp = calloc(1, sizeof(*r.u.response.rsp));\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\thex_encode(md, sizeof(md), r.u.response.rsp);\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\t/* get_master, rfc 3079 3.4 */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, 16);\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_rfc3079_magic1,\n\t\t\t\t sizeof(ms_rfc3079_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tfree(answer.data);\n\n\t\tEVP_MD_CTX_destroy(ctxp);\n\n\t\tr.u.response.session_key =\n\t\t    calloc(1, sizeof(*r.u.response.session_key));\n\t\tif (r.u.response.session_key == NULL) {\n\t\t    krb5_clear_error_message(context);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\tret = krb5_data_copy(r.u.response.session_key, md, 16);\n\t\tif (ret) {\n\t\t    krb5_clear_error_message(context);\n\t\t    goto out;\n\t\t}\n\t    }\n\n\t} else {\n\t    int aret;\n\n\t    r.element = choice_DigestRepInner_error;\n\t    aret = asprintf(&r.u.error.reason, \"Unsupported digest type %s\",\n\t\t\t    ireq.u.digestRequest.type);\n\t    if (aret == -1 || r.u.error.reason == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t    r.u.error.code = EINVAL;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s request successful %s\",\n\t\tireq.u.digestRequest.type, ireq.u.digestRequest.username);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_ntlmInit:\n\n\tif ((config->digests_allowed & (NTLM_V1|NTLM_V1_SESSION|NTLM_V2)) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM not allowed\");\n\t    goto failed;\n\t}\n\n\tr.element = choice_DigestRepInner_ntlmInitReply;\n\n\tr.u.ntlmInitReply.flags = NTLM_NEG_UNICODE;\n\n\tif ((ireq.u.ntlmInit.flags & NTLM_NEG_UNICODE) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM client have no unicode\");\n\t    goto failed;\n\t}\n\n\tif (ireq.u.ntlmInit.flags & NTLM_NEG_NTLM)\n\t    r.u.ntlmInitReply.flags |= NTLM_NEG_NTLM;\n\telse {\n\t    kdc_log(context, config, 0, \"NTLM client doesn't support NTLM\");\n\t    goto failed;\n\t}\n\n\tr.u.ntlmInitReply.flags |=\n\t    NTLM_NEG_TARGET |\n\t    NTLM_TARGET_DOMAIN |\n\t    NTLM_ENC_128;\n\n#define ALL\t\t\t\t\t\\\n\tNTLM_NEG_SIGN|\t\t\t\t\\\n\t    NTLM_NEG_SEAL|\t\t\t\\\n\t    NTLM_NEG_ALWAYS_SIGN|\t\t\\\n\t    NTLM_NEG_NTLM2_SESSION|\t\t\\\n\t    NTLM_NEG_KEYEX\n\n\tr.u.ntlmInitReply.flags |= (ireq.u.ntlmInit.flags & (ALL));\n\n#undef ALL\n\n\tr.u.ntlmInitReply.targetname =\n\t    get_ntlm_targetname(context, client);\n\tif (r.u.ntlmInitReply.targetname == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.data = malloc(8);\n\tif (r.u.ntlmInitReply.challenge.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.length = 8;\n\tif (RAND_bytes(r.u.ntlmInitReply.challenge.data,\n\t\t       r.u.ntlmInitReply.challenge.length) != 1)\n\t    {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"out of random error\");\n\t\tgoto out;\n\t    }\n\t/* XXX fix targetinfo */\n\tALLOC(r.u.ntlmInitReply.targetinfo);\n\tif (r.u.ntlmInitReply.targetinfo == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = fill_targetinfo(context,\n\t\t\t      r.u.ntlmInitReply.targetname,\n\t\t\t      client,\n\t\t\t      r.u.ntlmInitReply.targetinfo);\n\tif (ret) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * Save data encryted in opaque for the second part of the\n\t * ntlm authentication\n\t */\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_write(sp, r.u.ntlmInitReply.challenge.data, 8);\n\tif (ret != 8) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"storage write challenge\");\n\t    goto out;\n\t}\n\tret = krb5_store_uint32(sp, r.u.ntlmInitReply.flags);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   buf.data, buf.length, &r.u.ntlmInitReply.opaque);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, config, 0, \"NTLM init from %s\", from);\n\n\tbreak;\n\n    case choice_DigestReqInner_ntlmRequest: {\n\tkrb5_principal clientprincipal;\n\tunsigned char sessionkey[16];\n\tunsigned char challenge[8];\n\tuint32_t flags;\n\tKey *key = NULL;\n\tint version;\n\n\tr.element = choice_DigestRepInner_ntlmResponse;\n\tr.u.ntlmResponse.success = 0;\n\tr.u.ntlmResponse.flags = 0;\n\tr.u.ntlmResponse.sessionkey = NULL;\n\tr.u.ntlmResponse.tickets = NULL;\n\n\t/* get username */\n\tret = krb5_parse_name(context,\n\t\t\t      ireq.u.ntlmRequest.username,\n\t\t\t      &clientprincipal);\n\tif (ret)\n\t    goto failed;\n\n\tret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, clientprincipal);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM user %s not in database\",\n\t\t\t\t   ireq.u.ntlmRequest.username);\n\t    goto failed;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto failed;\n\n\tret = krb5_decrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   ireq.u.ntlmRequest.opaque.data,\n\t\t\t   ireq.u.ntlmRequest.opaque.length, &buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt nonce from %s\", from);\n\t    goto failed;\n\t}\n\n\tsp = krb5_storage_from_data(&buf);\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_read(sp, challenge, sizeof(challenge));\n\tif (ret != sizeof(challenge)) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"NTLM storage read challenge\");\n\t    goto out;\n\t}\n\tret = krb5_ret_uint32(sp, &flags);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM storage read flags\");\n\t    goto out;\n\t}\n\tkrb5_storage_free(sp);\n\tsp = NULL;\n\tkrb5_data_free(&buf);\n\n\tif ((flags & NTLM_NEG_NTLM) == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"NTLM not negotiated\");\n\t    goto out;\n\t}\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto out;\n\t}\n\n\t/* check if this is NTLMv2 */\n\tif (ireq.u.ntlmRequest.ntlm.length != 24) {\n\t    struct ntlm_buf infotarget, answer;\n\t    char *targetname;\n\n\t    if ((config->digests_allowed & NTLM_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"NTLM v2 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    version = 2;\n\n\t    targetname = get_ntlm_targetname(context, client);\n\t    if (targetname == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    answer.length = ireq.u.ntlmRequest.ntlm.length;\n\t    answer.data = ireq.u.ntlmRequest.ntlm.data;\n\n\t    ret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t\t key->key.keyvalue.length,\n\t\t\t\t\t ireq.u.ntlmRequest.username,\n\t\t\t\t\t targetname,\n\t\t\t\t\t 0,\n\t\t\t\t\t challenge,\n\t\t\t\t\t &answer,\n\t\t\t\t\t &infotarget,\n\t\t\t\t\t sessionkey);\n\t    free(targetname);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM v2 verify failed\");\n\t\tgoto failed;\n\t    }\n\n\t    /* XXX verify infotarget matches client (checksum ?) */\n\n\t    free(infotarget.data);\n\t    /* */\n\n\t} else {\n\t    struct ntlm_buf answer;\n\n\t    version = 1;\n\n\t    if (flags & NTLM_NEG_NTLM2_SESSION) {\n\t\tunsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctx;\n\n\t\tif ((config->digests_allowed & NTLM_V1_SESSION) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1-session not allowed\");\n\t\t    ret = EINVAL;\n\t\t    goto failed;\n\t\t}\n\n\t\tif (ireq.u.ntlmRequest.lm.length != 24) {\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"LM hash have wrong length \"\n\t\t\t\t\t   \"for NTLM session key\");\n\t\t    goto failed;\n\t\t}\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\n\t\tEVP_DigestUpdate(ctx, challenge, sizeof(challenge));\n\t\tEVP_DigestUpdate(ctx, ireq.u.ntlmRequest.lm.data, 8);\n\t\tEVP_DigestFinal_ex(ctx, sessionhash, NULL);\n\t\tmemcpy(challenge, sessionhash, sizeof(challenge));\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\t    } else {\n\t\tif ((config->digests_allowed & NTLM_V1) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1 not allowed\");\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.ntlmRequest.ntlm.length != answer.length ||\n\t\tmemcmp(ireq.u.ntlmRequest.ntlm.data, answer.data, answer.length) != 0)\n\t\t{\n\t\t    free(answer.data);\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"NTLM hash mismatch\");\n\t\t    goto failed;\n\t\t}\n\t    free(answer.data);\n\n\t    {\n\t\tEVP_MD_CTX *ctx;\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md4(), NULL);\n\t\tEVP_DigestUpdate(ctx,\n\t\t\t\t key->key.keyvalue.data,\n\t\t\t\t key->key.keyvalue.length);\n\t\tEVP_DigestFinal_ex(ctx, sessionkey, NULL);\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\t    }\n\t}\n\n\tif (ireq.u.ntlmRequest.sessionkey) {\n\t    unsigned char masterkey[MD4_DIGEST_LENGTH];\n\t    EVP_CIPHER_CTX rc4;\n\t    size_t len;\n\n\t    if ((flags & NTLM_NEG_KEYEX) == 0) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM client failed to neg key \"\n\t\t\t\t       \"exchange but still sent key\");\n\t\tgoto failed;\n\t    }\n\n\t    len = ireq.u.ntlmRequest.sessionkey->length;\n\t    if (len != sizeof(masterkey)){\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM master key wrong length: %lu\",\n\t\t\t\t       (unsigned long)len);\n\t\tgoto failed;\n\t    }\n\n\n\t    EVP_CIPHER_CTX_init(&rc4);\n\t    EVP_CipherInit_ex(&rc4, EVP_rc4(), NULL, sessionkey, NULL, 1);\n\t    EVP_Cipher(&rc4,\n\t\t       masterkey, ireq.u.ntlmRequest.sessionkey->data,\n\t\t       sizeof(masterkey));\n\t    EVP_CIPHER_CTX_cleanup(&rc4);\n\n\t    r.u.ntlmResponse.sessionkey =\n\t\tmalloc(sizeof(*r.u.ntlmResponse.sessionkey));\n\t    if (r.u.ntlmResponse.sessionkey == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_data_copy(r.u.ntlmResponse.sessionkey,\n\t\t\t\t masterkey, sizeof(masterkey));\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\tr.u.ntlmResponse.success = 1;\n\tkdc_log(context, config, 0, \"NTLM version %d successful for %s\",\n\t\tversion, ireq.u.ntlmRequest.username);\n\tbreak;\n    }\n    case choice_DigestReqInner_supportedMechs:\n\n\tkdc_log(context, config, 0, \"digest supportedMechs from %s\", from);\n\n\tr.element = choice_DigestRepInner_supportedMechs;\n\tmemset(&r.u.supportedMechs, 0, sizeof(r.u.supportedMechs));\n\n\tif (config->digests_allowed & NTLM_V1)\n\t    r.u.supportedMechs.ntlm_v1 = 1;\n\tif (config->digests_allowed & NTLM_V1_SESSION)\n\t    r.u.supportedMechs.ntlm_v1_session = 1;\n\tif (config->digests_allowed & NTLM_V2)\n\t    r.u.supportedMechs.ntlm_v2 = 1;\n\tif (config->digests_allowed & DIGEST_MD5)\n\t    r.u.supportedMechs.digest_md5 = 1;\n\tif (config->digests_allowed & CHAP_MD5)\n\t    r.u.supportedMechs.chap_md5 = 1;\n\tif (config->digests_allowed & MS_CHAP_V2)\n\t    r.u.supportedMechs.ms_chap_v2 = 1;\n\tbreak;\n\n    default: {\n\tconst char *s;\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"unknown operation to digest\");\n\n\tfailed:\n\n\ts = krb5_get_error_message(context, ret);\n\tif (s == NULL) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest failed with: %s\", s);\n\n\tr.element = choice_DigestRepInner_error;\n\tr.u.error.reason = strdup(\"unknown error\");\n\tkrb5_free_error_message(context, s);\n\tif (r.u.error.reason == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.error.code = EINVAL;\n\tbreak;\n    }\n    }\n\n    ASN1_MALLOC_ENCODE(DigestRepInner, buf.data, buf.length, &r, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode inner digest reply\");\n\tgoto out;\n    }\n    if (size != buf.length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n    krb5_auth_con_addflags(context, ac, KRB5_AUTH_CONTEXT_USE_SUBKEY, NULL);\n\n    ret = krb5_mk_rep (context, ac, &rep.apRep);\n    if (ret)\n\tgoto out;\n\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getlocalsubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     buf.data, buf.length, 0,\n\t\t\t\t     &rep.innerRep);\n\n    ASN1_MALLOC_ENCODE(DigestREP, reply->data, reply->length, &rep, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode digest reply\");\n\tgoto out;\n    }\n    if (size != reply->length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n\n out:\n    if (ac)\n\tkrb5_auth_con_free(context, ac);\n    if (ret)\n\tkrb5_warn(context, ret, \"Digest request from %s failed\", from);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (id)\n\tkrb5_kt_close(context, id);\n    if (crypto)\n\tkrb5_crypto_destroy(context, crypto);\n    if (sp)\n\tkrb5_storage_free(sp);\n    if (user)\n\t_kdc_free_ent (context, user);\n    if (server)\n\t_kdc_free_ent (context, server);\n    if (client)\n\t_kdc_free_ent (context, client);\n    if (password) {\n\tmemset(password, 0, strlen(password));\n\tfree (password);\n    }\n    if (client_name)\n\tfree (client_name);\n    krb5_data_free(&buf);\n    krb5_data_free(&serverNonce);\n    free_Checksum(&res);\n    free_DigestREP(&rep);\n    free_DigestRepInner(&r);\n    free_DigestReqInner(&ireq);\n\n    return ret;\n}",
          "includes": [
            "include <hex.h>",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <hex.h>\ninclude \"kdc_locl.h\"\n#\n\nrb5_error_code\n_kdc_do_digest(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       const struct DigestREQ *req, krb5_data *reply,\n\t       const char *from, struct sockaddr *addr)\n{\n    krb5_error_code ret = 0;\n    krb5_ticket *ticket = NULL;\n    krb5_auth_context ac = NULL;\n    krb5_keytab id = NULL;\n    krb5_crypto crypto = NULL;\n    DigestReqInner ireq;\n    DigestRepInner r;\n    DigestREP rep;\n    krb5_flags ap_req_options;\n    krb5_data buf;\n    size_t size;\n    krb5_storage *sp = NULL;\n    Checksum res;\n    hdb_entry_ex *server = NULL, *user = NULL;\n    hdb_entry_ex *client = NULL;\n    char *client_name = NULL, *password = NULL;\n    krb5_data serverNonce;\n\n    if(!config->enable_digest) {\n\tkdc_log(context, config, 0,\n\t\t\"Rejected digest request (disabled) from %s\", from);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(reply);\n    krb5_data_zero(&serverNonce);\n    memset(&ireq, 0, sizeof(ireq));\n    memset(&r, 0, sizeof(r));\n    memset(&rep, 0, sizeof(rep));\n    memset(&res, 0, sizeof(res));\n\n    kdc_log(context, config, 0, \"Digest request from %s\", from);\n\n    ret = krb5_kt_resolve(context, \"HDBGET:\", &id);\n    if (ret) {\n\tkdc_log(context, config, 0, \"Can't open database for digest\");\n\tgoto out;\n    }\n\n    ret = krb5_rd_req(context,\n\t\t      &ac,\n\t\t      &req->apReq,\n\t\t      NULL,\n\t\t      id,\n\t\t      &ap_req_options,\n\t\t      &ticket);\n    if (ret)\n\tgoto out;\n\n    /* check the server principal in the ticket matches digest/R@R */\n    {\n\tkrb5_principal principal = NULL;\n\tconst char *p, *rr;\n\n\tret = krb5_ticket_get_server(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"Wrong digest server principal used\");\n\tp = krb5_principal_get_comp_string(context, principal, 0);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, KRB5_DIGEST_NAME) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tp = krb5_principal_get_comp_string(context, principal, 1);\n\tif (p == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\trr = krb5_principal_get_realm(context, principal);\n\tif (rr == NULL) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tif (strcmp(p, rr) != 0) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\tkrb5_clear_error_message(context);\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_SERVER, NULL, NULL, &server);\n\tif (ret)\n\t    goto out;\n\n\tkrb5_free_principal(context, principal);\n    }\n\n    /* check the client is allowed to do digest auth */\n    {\n\tkrb5_principal principal = NULL;\n\n\tret = krb5_ticket_get_client(context, ticket, &principal);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, principal, &client_name);\n\tif (ret) {\n\t    krb5_free_principal(context, principal);\n\t    goto out;\n\t}\n\n\tret = _kdc_db_fetch(context, config, principal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &client);\n\tkrb5_free_principal(context, principal);\n\tif (ret)\n\t    goto out;\n\n\tif (client->entry.flags.allow_digest == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client %s tried to use digest \"\n\t\t    \"but is not allowed to\",\n\t\t    client_name);\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Client is not permitted to use digest\");\n\t    goto out;\n\t}\n    }\n\n    /* unpack request */\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getremotesubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\tif (key == NULL) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"digest: remote subkey not found\");\n\t    goto out;\n\t}\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     &req->innerReq, &buf);\n    krb5_crypto_destroy(context, crypto);\n    crypto = NULL;\n    if (ret)\n\tgoto out;\n\n    ret = decode_DigestReqInner(buf.data, buf.length, &ireq, NULL);\n    krb5_data_free(&buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode digest inner request\");\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"Valid digest request from %s (%s)\",\n\t    client_name, from);\n\n    /*\n     * Process the inner request\n     */\n\n    switch (ireq.element) {\n    case choice_DigestReqInner_init: {\n\tunsigned char server_nonce[16], identifier;\n\n\tRAND_pseudo_bytes(&identifier, sizeof(identifier));\n\tRAND_pseudo_bytes(server_nonce, sizeof(server_nonce));\n\n\tserver_nonce[0] = kdc_time & 0xff;\n\tserver_nonce[1] = (kdc_time >> 8) & 0xff;\n\tserver_nonce[2] = (kdc_time >> 16) & 0xff;\n\tserver_nonce[3] = (kdc_time >> 24) & 0xff;\n\n\tr.element = choice_DigestRepInner_initReply;\n\n\thex_encode(server_nonce, sizeof(server_nonce), &r.u.initReply.nonce);\n\tif (r.u.initReply.nonce == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode server nonce\");\n\t    goto out;\n\t}\n\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.init.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (ireq.u.init.channel) {\n\t    char *s;\n\t    int aret;\n\n\t    aret = asprintf(&s, \"%s-%s:%s\", r.u.initReply.nonce,\n\t\t\t    ireq.u.init.channel->cb_type,\n\t\t\t    ireq.u.init.channel->cb_binding);\n\t    if (aret == -1 || s == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"Failed to allocate channel binding\");\n\t\tgoto out;\n\t    }\n\t    free(r.u.initReply.nonce);\n\t    r.u.initReply.nonce = s;\n\t}\n\n\tret = krb5_store_stringz(sp, r.u.initReply.nonce);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tif (strcasecmp(ireq.u.init.type, \"CHAP\") == 0) {\n\t    int aret;\n\n\t    r.u.initReply.identifier =\n\t\tmalloc(sizeof(*r.u.initReply.identifier));\n\t    if (r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    aret = asprintf(r.u.initReply.identifier, \"%02X\", identifier&0xff);\n\t    if (aret == -1 || *r.u.initReply.identifier == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t} else\n\t    r.u.initReply.identifier = NULL;\n\n\tif (ireq.u.init.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.init.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_create_checksum(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   0,\n\t\t\t\t   buf.data,\n\t\t\t\t   buf.length,\n\t\t\t\t   &res);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tkrb5_data_free(&buf);\n\tif (ret)\n\t    goto out;\n\n\tASN1_MALLOC_ENCODE(Checksum, buf.data, buf.length, &res, &size, ret);\n\tfree_Checksum(&res);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to encode \"\n\t\t\t\t   \"checksum in digest request\");\n\t    goto out;\n\t}\n\tif (size != buf.length)\n\t    krb5_abortx(context, \"ASN1 internal error\");\n\n\thex_encode(buf.data, buf.length, &r.u.initReply.opaque);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (r.u.initReply.opaque == NULL) {\n\t    krb5_clear_error_message(context);\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s init request successful from %s\",\n\t\tireq.u.init.type, from);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_digestRequest: {\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tret = krb5_store_stringz(sp, ireq.u.digestRequest.type);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_store_stringz(sp, ireq.u.digestRequest.serverNonce);\n\n\tif (ireq.u.digestRequest.hostname) {\n\t    ret = krb5_store_stringz(sp, *ireq.u.digestRequest.hostname);\n\t    if (ret) {\n\t\tkrb5_clear_error_message(context);\n\t\tgoto out;\n\t    }\n\t}\n\n\tbuf.length = strlen(ireq.u.digestRequest.opaque);\n\tbuf.data = malloc(buf.length);\n\tif (buf.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = hex_decode(ireq.u.digestRequest.opaque, buf.data, buf.length);\n\tif (ret <= 0) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"Failed to decode opaque\");\n\t    goto out;\n\t}\n\tbuf.length = ret;\n\n\tret = decode_Checksum(buf.data, buf.length, &res, NULL);\n\tfree(buf.data);\n\tkrb5_data_zero(&buf);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   \"Failed to decode digest Checksum\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tserverNonce.length = strlen(ireq.u.digestRequest.serverNonce);\n\tserverNonce.data = malloc(serverNonce.length);\n\tif (serverNonce.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * CHAP does the checksum of the raw nonce, but do it for all\n\t * types, since we need to check the timestamp.\n\t */\n\t{\n\t    ssize_t ssize;\n\n\t    ssize = hex_decode(ireq.u.digestRequest.serverNonce,\n\t\t\t       serverNonce.data, serverNonce.length);\n\t    if (ssize <= 0) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"Failed to decode serverNonce\");\n\t\tgoto out;\n\t    }\n\t    serverNonce.length = ssize;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_verify_checksum(context, crypto,\n\t\t\t\t   KRB5_KU_DIGEST_OPAQUE,\n\t\t\t\t   buf.data, buf.length, &res);\n\tfree_Checksum(&res);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\t/* verify time */\n\t{\n\t    unsigned char *p = serverNonce.data;\n\t    uint32_t t;\n\n\t    if (serverNonce.length < 4) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"server nonce too short\");\n\t\tgoto out;\n\t    }\n\t    t = p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n\n\t    if (labs((kdc_time & 0xffffffff) - t) > context->max_skew) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"time screw in server nonce \");\n\t\tgoto out;\n\t    }\n\t}\n\n\tif (strcasecmp(ireq.u.digestRequest.type, \"CHAP\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char idx;\n\n\t    if ((config->digests_allowed & CHAP_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest CHAP MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.identifier == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"Identifier missing \"\n\t\t\t\t       \"from CHAP request\");\n\t\tgoto out;\n\t    }\n\n\t    if (hex_decode(*ireq.u.digestRequest.identifier, &idx, 1) != 1) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"failed to decode identifier\");\n\t\tgoto out;\n\t    }\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, &idx, 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestUpdate(ctx, serverNonce.data, serverNonce.length);\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"CHAP reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"SASL-DIGEST-MD5\") == 0) {\n\t    EVP_MD_CTX *ctx;\n\t    unsigned char md[MD5_DIGEST_LENGTH];\n\t    char *mdx;\n\t    char *A1, *A2;\n\n\t    if ((config->digests_allowed & DIGEST_MD5) == 0) {\n\t\tkdc_log(context, config, 0, \"Digest SASL MD5 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    if (ireq.u.digestRequest.nonceCount == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.clientNonce == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.qop == NULL)\n\t\tgoto out;\n\t    if (ireq.u.digestRequest.realm == NULL)\n\t\tgoto out;\n\n\t    ret = get_password_entry(context, config,\n\t\t\t\t     ireq.u.digestRequest.username,\n\t\t\t\t     &password);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ctx = EVP_MD_CTX_create();\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.username,\n\t\t       strlen(ireq.u.digestRequest.username));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.realm,\n\t\t       strlen(*ireq.u.digestRequest.realm));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, password, strlen(password));\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, md, sizeof(md));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    if (ireq.u.digestRequest.authid) {\n\t\tEVP_DigestUpdate(ctx, \":\", 1);\n\t\tEVP_DigestUpdate(ctx, *ireq.u.digestRequest.authid,\n\t\t\t   strlen(*ireq.u.digestRequest.authid));\n\t    }\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\t    hex_encode(md, sizeof(md), &A1);\n\t    if (A1 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tEVP_MD_CTX_destroy(ctx);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx,\n\t\t\t     \"AUTHENTICATE:\", sizeof(\"AUTHENTICATE:\") - 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.uri,\n\t\t       strlen(*ireq.u.digestRequest.uri));\n\n\t    /* conf|int */\n\t    if (strcmp(ireq.u.digestRequest.digest, \"clear\") != 0) {\n\t\tstatic char conf_zeros[] = \":00000000000000000000000000000000\";\n\t\tEVP_DigestUpdate(ctx, conf_zeros, sizeof(conf_zeros) - 1);\n\t    }\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    hex_encode(md, sizeof(md), &A2);\n\t    if (A2 == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tfree(A1);\n\t\tgoto failed;\n\t    }\n\n\t    EVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\t    EVP_DigestUpdate(ctx, A1, strlen(A2));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, ireq.u.digestRequest.serverNonce,\n\t\t       strlen(ireq.u.digestRequest.serverNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.nonceCount,\n\t\t       strlen(*ireq.u.digestRequest.nonceCount));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.clientNonce,\n\t\t       strlen(*ireq.u.digestRequest.clientNonce));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, *ireq.u.digestRequest.qop,\n\t\t       strlen(*ireq.u.digestRequest.qop));\n\t    EVP_DigestUpdate(ctx, \":\", 1);\n\t    EVP_DigestUpdate(ctx, A2, strlen(A2));\n\n\t    EVP_DigestFinal_ex(ctx, md, NULL);\n\n\t    EVP_MD_CTX_destroy(ctx);\n\n\t    free(A1);\n\t    free(A2);\n\n\t    hex_encode(md, sizeof(md), &mdx);\n\t    if (mdx == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    free(mdx);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"DIGEST-MD5 reply mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\n\t} else if (strcasecmp(ireq.u.digestRequest.type, \"MS-CHAP-V2\") == 0) {\n\t    unsigned char md[SHA_DIGEST_LENGTH], challenge[SHA_DIGEST_LENGTH];\n\t    krb5_principal clientprincipal = NULL;\n\t    char *mdx;\n\t    const char *username;\n\t    struct ntlm_buf answer;\n\t    Key *key = NULL;\n\t    EVP_MD_CTX *ctp;\n\n\t    if ((config->digests_allowed & MS_CHAP_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"MS-CHAP-V2 not allowed\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.digestRequest.clientNonce == NULL)  {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 clientNonce missing\");\n\t\tgoto failed;\n\t    }\n\t    if (serverNonce.length != 16) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 serverNonce wrong length\");\n\t\tgoto failed;\n\t    }\n\n\t    /* strip of the domain component */\n\t    username = strchr(ireq.u.digestRequest.username, '\\\\');\n\t    if (username == NULL)\n\t\tusername = ireq.u.digestRequest.username;\n\t    else\n\t\tusername++;\n\n\t    ctp = EVP_MD_CTX_create();\n\n\t    /* ChallengeHash */\n\t    EVP_DigestInit_ex(ctp, EVP_sha1(), NULL);\n\t    {\n\t\tssize_t ssize;\n\t\tkrb5_data clientNonce;\n\n\t\tclientNonce.length = strlen(*ireq.u.digestRequest.clientNonce);\n\t\tclientNonce.data = malloc(clientNonce.length);\n\t\tif (clientNonce.data == NULL) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"malloc: out of memory\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\n\t\tssize = hex_decode(*ireq.u.digestRequest.clientNonce,\n\t\t\t\t   clientNonce.data, clientNonce.length);\n\t\tif (ssize != 16) {\n\t\t    ret = ENOMEM;\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   \"Failed to decode clientNonce\");\n\t\t    EVP_MD_CTX_destroy(ctp);\n\t\t    goto out;\n\t\t}\n\t\tEVP_DigestUpdate(ctp, clientNonce.data, ssize);\n\t\tfree(clientNonce.data);\n\t    }\n\t    EVP_DigestUpdate(ctp, serverNonce.data, serverNonce.length);\n\t    EVP_DigestUpdate(ctp, username, strlen(username));\n\n\t    EVP_DigestFinal_ex(ctp, challenge, NULL);\n\n\t    EVP_MD_CTX_destroy(ctp);\n\n\t    /* NtPasswordHash */\n\t    ret = krb5_parse_name(context, username, &clientprincipal);\n\t    if (ret)\n\t\tgoto failed;\n\n\t    ret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &user);\n\t    krb5_free_principal(context, clientprincipal);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 user %s not in database\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    ret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t\t  ETYPE_ARCFOUR_HMAC_MD5, &key);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"MS-CHAP-V2 missing arcfour key %s\",\n\t\t\t\t       username);\n\t\tgoto failed;\n\t    }\n\n\t    /* ChallengeResponse */\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    hex_encode(answer.data, answer.length, &mdx);\n\t    if (mdx == NULL) {\n\t\tfree(answer.data);\n\t\tkrb5_clear_error_message(context);\n\t\tret = ENOMEM;\n\t\tgoto out;\n\t    }\n\n\t    r.element = choice_DigestRepInner_response;\n\t    ret = strcasecmp(mdx, ireq.u.digestRequest.responseData);\n\t    if (ret == 0) {\n\t\tr.u.response.success = TRUE;\n\t    } else {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"MS-CHAP-V2 hash mismatch for %s\",\n\t\t\tireq.u.digestRequest.username);\n\t\tr.u.response.success = FALSE;\n\t    }\n\t    free(mdx);\n\n\t    if (r.u.response.success) {\n\t\tunsigned char hashhash[MD4_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctxp;\n\n\t\tctxp = EVP_MD_CTX_create();\n\n\t\t/* hashhash */\n\t\t{\n\t\t    EVP_DigestInit_ex(ctxp, EVP_md4(), NULL);\n\t\t    EVP_DigestUpdate(ctxp,\n\t\t\t\t     key->key.keyvalue.data,\n\t\t\t\t     key->key.keyvalue.length);\n\t\t    EVP_DigestFinal_ex(ctxp, hashhash, NULL);\n\t\t}\n\n\t\t/* GenerateAuthenticatorResponse */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, sizeof(hashhash));\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic1,\n\t\t\t\t sizeof(ms_chap_v2_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, md, sizeof(md));\n\t\tEVP_DigestUpdate(ctxp, challenge, 8);\n\t\tEVP_DigestUpdate(ctxp, ms_chap_v2_magic2,\n\t\t\t\t sizeof(ms_chap_v2_magic2));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tr.u.response.rsp = calloc(1, sizeof(*r.u.response.rsp));\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\thex_encode(md, sizeof(md), r.u.response.rsp);\n\t\tif (r.u.response.rsp == NULL) {\n\t\t    free(answer.data);\n\t\t    krb5_clear_error_message(context);\n\t\t    EVP_MD_CTX_destroy(ctxp);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\t/* get_master, rfc 3079 3.4 */\n\t\tEVP_DigestInit_ex(ctxp, EVP_sha1(), NULL);\n\t\tEVP_DigestUpdate(ctxp, hashhash, 16);\n\t\tEVP_DigestUpdate(ctxp, answer.data, answer.length);\n\t\tEVP_DigestUpdate(ctxp, ms_rfc3079_magic1,\n\t\t\t\t sizeof(ms_rfc3079_magic1));\n\t\tEVP_DigestFinal_ex(ctxp, md, NULL);\n\n\t\tfree(answer.data);\n\n\t\tEVP_MD_CTX_destroy(ctxp);\n\n\t\tr.u.response.session_key =\n\t\t    calloc(1, sizeof(*r.u.response.session_key));\n\t\tif (r.u.response.session_key == NULL) {\n\t\t    krb5_clear_error_message(context);\n\t\t    ret = ENOMEM;\n\t\t    goto out;\n\t\t}\n\n\t\tret = krb5_data_copy(r.u.response.session_key, md, 16);\n\t\tif (ret) {\n\t\t    krb5_clear_error_message(context);\n\t\t    goto out;\n\t\t}\n\t    }\n\n\t} else {\n\t    int aret;\n\n\t    r.element = choice_DigestRepInner_error;\n\t    aret = asprintf(&r.u.error.reason, \"Unsupported digest type %s\",\n\t\t\t    ireq.u.digestRequest.type);\n\t    if (aret == -1 || r.u.error.reason == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t    r.u.error.code = EINVAL;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest %s request successful %s\",\n\t\tireq.u.digestRequest.type, ireq.u.digestRequest.username);\n\n\tbreak;\n    }\n    case choice_DigestReqInner_ntlmInit:\n\n\tif ((config->digests_allowed & (NTLM_V1|NTLM_V1_SESSION|NTLM_V2)) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM not allowed\");\n\t    goto failed;\n\t}\n\n\tr.element = choice_DigestRepInner_ntlmInitReply;\n\n\tr.u.ntlmInitReply.flags = NTLM_NEG_UNICODE;\n\n\tif ((ireq.u.ntlmInit.flags & NTLM_NEG_UNICODE) == 0) {\n\t    kdc_log(context, config, 0, \"NTLM client have no unicode\");\n\t    goto failed;\n\t}\n\n\tif (ireq.u.ntlmInit.flags & NTLM_NEG_NTLM)\n\t    r.u.ntlmInitReply.flags |= NTLM_NEG_NTLM;\n\telse {\n\t    kdc_log(context, config, 0, \"NTLM client doesn't support NTLM\");\n\t    goto failed;\n\t}\n\n\tr.u.ntlmInitReply.flags |=\n\t    NTLM_NEG_TARGET |\n\t    NTLM_TARGET_DOMAIN |\n\t    NTLM_ENC_128;\n\n#define ALL\t\t\t\t\t\\\n\tNTLM_NEG_SIGN|\t\t\t\t\\\n\t    NTLM_NEG_SEAL|\t\t\t\\\n\t    NTLM_NEG_ALWAYS_SIGN|\t\t\\\n\t    NTLM_NEG_NTLM2_SESSION|\t\t\\\n\t    NTLM_NEG_KEYEX\n\n\tr.u.ntlmInitReply.flags |= (ireq.u.ntlmInit.flags & (ALL));\n\n#undef ALL\n\n\tr.u.ntlmInitReply.targetname =\n\t    get_ntlm_targetname(context, client);\n\tif (r.u.ntlmInitReply.targetname == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.data = malloc(8);\n\tif (r.u.ntlmInitReply.challenge.data == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.ntlmInitReply.challenge.length = 8;\n\tif (RAND_bytes(r.u.ntlmInitReply.challenge.data,\n\t\t       r.u.ntlmInitReply.challenge.length) != 1)\n\t    {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"out of random error\");\n\t\tgoto out;\n\t    }\n\t/* XXX fix targetinfo */\n\tALLOC(r.u.ntlmInitReply.targetinfo);\n\tif (r.u.ntlmInitReply.targetinfo == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = fill_targetinfo(context,\n\t\t\t      r.u.ntlmInitReply.targetname,\n\t\t\t      client,\n\t\t\t      r.u.ntlmInitReply.targetinfo);\n\tif (ret) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\t/*\n\t * Save data encryted in opaque for the second part of the\n\t * ntlm authentication\n\t */\n\tsp = krb5_storage_emem();\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_write(sp, r.u.ntlmInitReply.challenge.data, 8);\n\tif (ret != 8) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"storage write challenge\");\n\t    goto out;\n\t}\n\tret = krb5_store_uint32(sp, r.u.ntlmInitReply.flags);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = krb5_storage_to_data(sp, &buf);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   buf.data, buf.length, &r.u.ntlmInitReply.opaque);\n\tkrb5_data_free(&buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret)\n\t    goto out;\n\n\tkdc_log(context, config, 0, \"NTLM init from %s\", from);\n\n\tbreak;\n\n    case choice_DigestReqInner_ntlmRequest: {\n\tkrb5_principal clientprincipal;\n\tunsigned char sessionkey[16];\n\tunsigned char challenge[8];\n\tuint32_t flags;\n\tKey *key = NULL;\n\tint version;\n\n\tr.element = choice_DigestRepInner_ntlmResponse;\n\tr.u.ntlmResponse.success = 0;\n\tr.u.ntlmResponse.flags = 0;\n\tr.u.ntlmResponse.sessionkey = NULL;\n\tr.u.ntlmResponse.tickets = NULL;\n\n\t/* get username */\n\tret = krb5_parse_name(context,\n\t\t\t      ireq.u.ntlmRequest.username,\n\t\t\t      &clientprincipal);\n\tif (ret)\n\t    goto failed;\n\n\tret = _kdc_db_fetch(context, config, clientprincipal,\n\t\t\t    HDB_F_GET_CLIENT, NULL, NULL, &user);\n\tkrb5_free_principal(context, clientprincipal);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM user %s not in database\",\n\t\t\t\t   ireq.u.ntlmRequest.username);\n\t    goto failed;\n\t}\n\n\tret = get_digest_key(context, config, server, &crypto);\n\tif (ret)\n\t    goto failed;\n\n\tret = krb5_decrypt(context, crypto, KRB5_KU_DIGEST_OPAQUE,\n\t\t\t   ireq.u.ntlmRequest.opaque.data,\n\t\t\t   ireq.u.ntlmRequest.opaque.length, &buf);\n\tkrb5_crypto_destroy(context, crypto);\n\tcrypto = NULL;\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt nonce from %s\", from);\n\t    goto failed;\n\t}\n\n\tsp = krb5_storage_from_data(&buf);\n\tif (sp == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\n\tret = krb5_storage_read(sp, challenge, sizeof(challenge));\n\tif (ret != sizeof(challenge)) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"NTLM storage read challenge\");\n\t    goto out;\n\t}\n\tret = krb5_ret_uint32(sp, &flags);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM storage read flags\");\n\t    goto out;\n\t}\n\tkrb5_storage_free(sp);\n\tsp = NULL;\n\tkrb5_data_free(&buf);\n\n\tif ((flags & NTLM_NEG_NTLM) == 0) {\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret, \"NTLM not negotiated\");\n\t    goto out;\n\t}\n\n\tret = hdb_enctype2key(context, &user->entry, NULL,\n\t\t\t      ETYPE_ARCFOUR_HMAC_MD5, &key);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t    goto out;\n\t}\n\n\t/* check if this is NTLMv2 */\n\tif (ireq.u.ntlmRequest.ntlm.length != 24) {\n\t    struct ntlm_buf infotarget, answer;\n\t    char *targetname;\n\n\t    if ((config->digests_allowed & NTLM_V2) == 0) {\n\t\tkdc_log(context, config, 0, \"NTLM v2 not allowed\");\n\t\tgoto out;\n\t    }\n\n\t    version = 2;\n\n\t    targetname = get_ntlm_targetname(context, client);\n\t    if (targetname == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    answer.length = ireq.u.ntlmRequest.ntlm.length;\n\t    answer.data = ireq.u.ntlmRequest.ntlm.data;\n\n\t    ret = heim_ntlm_verify_ntlm2(key->key.keyvalue.data,\n\t\t\t\t\t key->key.keyvalue.length,\n\t\t\t\t\t ireq.u.ntlmRequest.username,\n\t\t\t\t\t targetname,\n\t\t\t\t\t 0,\n\t\t\t\t\t challenge,\n\t\t\t\t\t &answer,\n\t\t\t\t\t &infotarget,\n\t\t\t\t\t sessionkey);\n\t    free(targetname);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM v2 verify failed\");\n\t\tgoto failed;\n\t    }\n\n\t    /* XXX verify infotarget matches client (checksum ?) */\n\n\t    free(infotarget.data);\n\t    /* */\n\n\t} else {\n\t    struct ntlm_buf answer;\n\n\t    version = 1;\n\n\t    if (flags & NTLM_NEG_NTLM2_SESSION) {\n\t\tunsigned char sessionhash[MD5_DIGEST_LENGTH];\n\t\tEVP_MD_CTX *ctx;\n\n\t\tif ((config->digests_allowed & NTLM_V1_SESSION) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1-session not allowed\");\n\t\t    ret = EINVAL;\n\t\t    goto failed;\n\t\t}\n\n\t\tif (ireq.u.ntlmRequest.lm.length != 24) {\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"LM hash have wrong length \"\n\t\t\t\t\t   \"for NTLM session key\");\n\t\t    goto failed;\n\t\t}\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md5(), NULL);\n\n\t\tEVP_DigestUpdate(ctx, challenge, sizeof(challenge));\n\t\tEVP_DigestUpdate(ctx, ireq.u.ntlmRequest.lm.data, 8);\n\t\tEVP_DigestFinal_ex(ctx, sessionhash, NULL);\n\t\tmemcpy(challenge, sessionhash, sizeof(challenge));\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\n\t    } else {\n\t\tif ((config->digests_allowed & NTLM_V1) == 0) {\n\t\t    kdc_log(context, config, 0, \"NTLM v1 not allowed\");\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    ret = heim_ntlm_calculate_ntlm1(key->key.keyvalue.data,\n\t\t\t\t\t    key->key.keyvalue.length,\n\t\t\t\t\t    challenge, &answer);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"NTLM missing arcfour key\");\n\t\tgoto failed;\n\t    }\n\n\t    if (ireq.u.ntlmRequest.ntlm.length != answer.length ||\n\t\tmemcmp(ireq.u.ntlmRequest.ntlm.data, answer.data, answer.length) != 0)\n\t\t{\n\t\t    free(answer.data);\n\t\t    ret = EINVAL;\n\t\t    krb5_set_error_message(context, ret, \"NTLM hash mismatch\");\n\t\t    goto failed;\n\t\t}\n\t    free(answer.data);\n\n\t    {\n\t\tEVP_MD_CTX *ctx;\n\n\t\tctx = EVP_MD_CTX_create();\n\n\t\tEVP_DigestInit_ex(ctx, EVP_md4(), NULL);\n\t\tEVP_DigestUpdate(ctx,\n\t\t\t\t key->key.keyvalue.data,\n\t\t\t\t key->key.keyvalue.length);\n\t\tEVP_DigestFinal_ex(ctx, sessionkey, NULL);\n\n\t\tEVP_MD_CTX_destroy(ctx);\n\t    }\n\t}\n\n\tif (ireq.u.ntlmRequest.sessionkey) {\n\t    unsigned char masterkey[MD4_DIGEST_LENGTH];\n\t    EVP_CIPHER_CTX rc4;\n\t    size_t len;\n\n\t    if ((flags & NTLM_NEG_KEYEX) == 0) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM client failed to neg key \"\n\t\t\t\t       \"exchange but still sent key\");\n\t\tgoto failed;\n\t    }\n\n\t    len = ireq.u.ntlmRequest.sessionkey->length;\n\t    if (len != sizeof(masterkey)){\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       \"NTLM master key wrong length: %lu\",\n\t\t\t\t       (unsigned long)len);\n\t\tgoto failed;\n\t    }\n\n\n\t    EVP_CIPHER_CTX_init(&rc4);\n\t    EVP_CipherInit_ex(&rc4, EVP_rc4(), NULL, sessionkey, NULL, 1);\n\t    EVP_Cipher(&rc4,\n\t\t       masterkey, ireq.u.ntlmRequest.sessionkey->data,\n\t\t       sizeof(masterkey));\n\t    EVP_CIPHER_CTX_cleanup(&rc4);\n\n\t    r.u.ntlmResponse.sessionkey =\n\t\tmalloc(sizeof(*r.u.ntlmResponse.sessionkey));\n\t    if (r.u.ntlmResponse.sessionkey == NULL) {\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_data_copy(r.u.ntlmResponse.sessionkey,\n\t\t\t\t masterkey, sizeof(masterkey));\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\tr.u.ntlmResponse.success = 1;\n\tkdc_log(context, config, 0, \"NTLM version %d successful for %s\",\n\t\tversion, ireq.u.ntlmRequest.username);\n\tbreak;\n    }\n    case choice_DigestReqInner_supportedMechs:\n\n\tkdc_log(context, config, 0, \"digest supportedMechs from %s\", from);\n\n\tr.element = choice_DigestRepInner_supportedMechs;\n\tmemset(&r.u.supportedMechs, 0, sizeof(r.u.supportedMechs));\n\n\tif (config->digests_allowed & NTLM_V1)\n\t    r.u.supportedMechs.ntlm_v1 = 1;\n\tif (config->digests_allowed & NTLM_V1_SESSION)\n\t    r.u.supportedMechs.ntlm_v1_session = 1;\n\tif (config->digests_allowed & NTLM_V2)\n\t    r.u.supportedMechs.ntlm_v2 = 1;\n\tif (config->digests_allowed & DIGEST_MD5)\n\t    r.u.supportedMechs.digest_md5 = 1;\n\tif (config->digests_allowed & CHAP_MD5)\n\t    r.u.supportedMechs.chap_md5 = 1;\n\tif (config->digests_allowed & MS_CHAP_V2)\n\t    r.u.supportedMechs.ms_chap_v2 = 1;\n\tbreak;\n\n    default: {\n\tconst char *s;\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, \"unknown operation to digest\");\n\n\tfailed:\n\n\ts = krb5_get_error_message(context, ret);\n\tif (s == NULL) {\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"Digest failed with: %s\", s);\n\n\tr.element = choice_DigestRepInner_error;\n\tr.u.error.reason = strdup(\"unknown error\");\n\tkrb5_free_error_message(context, s);\n\tif (r.u.error.reason == NULL) {\n\t    ret = ENOMEM;\n\t    krb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t    goto out;\n\t}\n\tr.u.error.code = EINVAL;\n\tbreak;\n    }\n    }\n\n    ASN1_MALLOC_ENCODE(DigestRepInner, buf.data, buf.length, &r, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode inner digest reply\");\n\tgoto out;\n    }\n    if (size != buf.length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n    krb5_auth_con_addflags(context, ac, KRB5_AUTH_CONTEXT_USE_SUBKEY, NULL);\n\n    ret = krb5_mk_rep (context, ac, &rep.apRep);\n    if (ret)\n\tgoto out;\n\n    {\n\tkrb5_keyblock *key;\n\n\tret = krb5_auth_con_getlocalsubkey(context, ac, &key);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, key, 0, &crypto);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context, crypto, KRB5_KU_DIGEST_ENCRYPT,\n\t\t\t\t     buf.data, buf.length, 0,\n\t\t\t\t     &rep.innerRep);\n\n    ASN1_MALLOC_ENCODE(DigestREP, reply->data, reply->length, &rep, &size, ret);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to encode digest reply\");\n\tgoto out;\n    }\n    if (size != reply->length)\n\tkrb5_abortx(context, \"ASN1 internal error\");\n\n\n out:\n    if (ac)\n\tkrb5_auth_con_free(context, ac);\n    if (ret)\n\tkrb5_warn(context, ret, \"Digest request from %s failed\", from);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (id)\n\tkrb5_kt_close(context, id);\n    if (crypto)\n\tkrb5_crypto_destroy(context, crypto);\n    if (sp)\n\tkrb5_storage_free(sp);\n    if (user)\n\t_kdc_free_ent (context, user);\n    if (server)\n\t_kdc_free_ent (context, server);\n    if (client)\n\t_kdc_free_ent (context, client);\n    if (password) {\n\tmemset(password, 0, strlen(password));\n\tfree (password);\n    }\n    if (client_name)\n\tfree (client_name);\n    krb5_data_free(&buf);\n    krb5_data_free(&serverNonce);\n    free_Checksum(&res);\n    free_DigestREP(&rep);\n    free_DigestRepInner(&r);\n    free_DigestReqInner(&ireq);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecode_DigestREQ(",
          "args": [
            "eq_buffer->data,",
            "eq_buffer->length,",
            "digestreq,",
            "len)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nkdc_digest(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_data *req_buffer,\n\t   krb5_data *reply,\n\t   const char *from,\n\t   struct sockaddr *addr,\n\t   int datagram_reply,\n\t   int *claim)\n{\n    DigestREQ digestreq;\n    krb5_error_code ret;\n    size_t len;\n\n    ret = decode_DigestREQ(req_buffer->data, req_buffer->length,\n\t\t\t   &digestreq, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_do_digest(context, config, &digestreq, reply, from, addr);\n    free_DigestREQ(&digestreq);\n    return ret;\n}"
  },
  {
    "function_name": "dc_tgs_req(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "83-107",
    "snippet": "tatic krb5_error_code\nkdc_tgs_req(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    krb5_data *req_buffer,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *addr,\n\t    int datagram_reply,\n\t    int *claim)\n{\n    krb5_error_code ret;\n    KDC_REQ req;\n    size_t len;\n\n    ret = decode_TGS_REQ(req_buffer->data, req_buffer->length, &req, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_tgs_rep(context, config, &req, reply,\n\t\t       from, addr, datagram_reply);\n    free_TGS_REQ(&req);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_TGS_REQ(",
          "args": [
            "req)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_tgs_rep(",
          "args": [
            "ontext,",
            "onfig,",
            "req,",
            "eply,",
            "rom,",
            "ddr,",
            "atagram_reply)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_tgs_rep(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "2373-2502",
          "snippet": "rb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecode_TGS_REQ(",
          "args": [
            "eq_buffer->data,",
            "eq_buffer->length,",
            "req,",
            "len)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nkdc_tgs_req(krb5_context context,\n\t    krb5_kdc_configuration *config,\n\t    krb5_data *req_buffer,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *addr,\n\t    int datagram_reply,\n\t    int *claim)\n{\n    krb5_error_code ret;\n    KDC_REQ req;\n    size_t len;\n\n    ret = decode_TGS_REQ(req_buffer->data, req_buffer->length, &req, &len);\n    if (ret)\n\treturn ret;\n\n    *claim = 1;\n\n    ret = _kdc_tgs_rep(context, config, &req, reply,\n\t\t       from, addr, datagram_reply);\n    free_TGS_REQ(&req);\n    return ret;\n}"
  },
  {
    "function_name": "dc_as_req(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "50-80",
    "snippet": "tatic krb5_error_code\nkdc_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_data *req_buffer,\n\t   krb5_data *reply,\n\t   const char *from,\n\t   struct sockaddr *addr,\n\t   int datagram_reply,\n\t   int *claim)\n{\n    struct kdc_request_desc r;\n    krb5_error_code ret;\n    size_t len;\n\n    memset(&r, 0, sizeof(r));\n\n    ret = decode_AS_REQ(req_buffer->data, req_buffer->length, &r.req, &len);\n    if (ret)\n\treturn ret;\n\n    r.context = context;\n    r.config = config;\n    r.request.data = req_buffer->data;\n    r.request.length = req_buffer->length;\n\n    *claim = 1;\n\n    ret = _kdc_as_rep(&r, reply, from, addr, datagram_reply);\n    free_AS_REQ(&r.req);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_AS_REQ(",
          "args": [
            "r.req)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_as_rep(",
          "args": [
            "r,",
            "eply,",
            "rom,",
            "ddr,",
            "atagram_reply)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_as_rep(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1616-2279",
          "snippet": "rb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic const struct kdc_patypes pat[] = {\n#ifdef PKINIT\n    {\n\tKRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", PA_ANNOUNCE,\n\tpa_pkinit_validate\n    },\n    {\n\tKRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", PA_ANNOUNCE,\n\tNULL\n    },\n#else\n    { KRB5_PADATA_PK_AS_REQ, \"PK-INIT(ietf)\", 0, NULL },\n    { KRB5_PADATA_PK_AS_REQ_WIN, \"PK-INIT(win2k)\", 0, NULL },\n    { KRB5_PADATA_PKINIT_KX, \"Anonymous PK-INIT\", 0, NULL },\n#endif\n    { KRB5_PADATA_PA_PK_OCSP_RESPONSE , \"OCSP\", 0, NULL },\n    { \n\tKRB5_PADATA_ENC_TIMESTAMP , \"ENC-TS\",\n\tPA_ANNOUNCE,\n\tpa_enc_ts_validate\n    },\n    {\n\tKRB5_PADATA_ENCRYPTED_CHALLENGE , \"ENC-CHAL\",\n\tPA_ANNOUNCE | PA_REQ_FAST,\n\tpa_enc_chal_validate\n    },\n    { KRB5_PADATA_REQ_ENC_PA_REP , \"REQ-ENC-PA-REP\", 0, NULL },\n    { KRB5_PADATA_FX_FAST, \"FX-FAST\", PA_ANNOUNCE, NULL },\n    { KRB5_PADATA_FX_ERROR, \"FX-ERROR\", 0, NULL },\n    { KRB5_PADATA_FX_COOKIE, \"FX-COOKIE\", 0, NULL }\n};\n\nrb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No server in request\");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed server name from %s\", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \"No client in request\");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"AS-REQ malformed client name from %s\", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\"Request for a anonymous ticket with non \"\n\t\t\"anonymous client name: %s\", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Client (%s) from %s has no common enctypes with KDC \"\n\t\t\"to use for the session key\",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\"%s pre-authentication succeeded -- %s\",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \"Doesn't have a client key available\");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \"Bad KDC options\");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \"Ticket may not be forwardable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \"Ticket may not be proxiable\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \"Ticket may not be postdate\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \"Bad address list in requested\");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \"Client have no reply key\");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecode_AS_REQ(",
          "args": [
            "eq_buffer->data,",
            "eq_buffer->length,",
            "r.req,",
            "len)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "r,",
            ",",
            "izeof(r))"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nkdc_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_data *req_buffer,\n\t   krb5_data *reply,\n\t   const char *from,\n\t   struct sockaddr *addr,\n\t   int datagram_reply,\n\t   int *claim)\n{\n    struct kdc_request_desc r;\n    krb5_error_code ret;\n    size_t len;\n\n    memset(&r, 0, sizeof(r));\n\n    ret = decode_AS_REQ(req_buffer->data, req_buffer->length, &r.req, &len);\n    if (ret)\n\treturn ret;\n\n    r.context = context;\n    r.config = config;\n    r.request.data = req_buffer->data;\n    r.request.length = req_buffer->length;\n\n    *claim = 1;\n\n    ret = _kdc_as_rep(&r, reply, from, addr, datagram_reply);\n    free_AS_REQ(&r.req);\n    return ret;\n}"
  },
  {
    "function_name": "rb5_kdc_update_time(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
    "lines": "41-48",
    "snippet": "oid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "_kdc_now,",
            "ULL)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}"
  }
]