[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "455-508",
    "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    int optidx = 0;\n\n    setprogname(argv[0]);\n\n    ret = krb5_init_context(&kdc_context);\n    if (ret == KRB5_CONFIG_BADFORMAT)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n    else if (ret)\n\terrx (1, \"krb5_init_context failed: %d\", ret);\n\n    ret = krb5_kt_register(kdc_context, &hdb_get_kt_ops);\n    if (ret)\n\terrx (1, \"krb5_kt_register(HDB) failed: %d\", ret);\n\n    kdc_config = configure(kdc_context, argc, argv, &optidx);\n\n    argc -= optidx;\n    argv += optidx;\n\n    if (argc == 0)\n\terrx(1, \"missing operations\");\n\n    krb5_plugin_register(kdc_context, PLUGIN_TYPE_DATA,\n\t\t\t KRB5_PLUGIN_SEND_TO_KDC, &send_to_kdc);\n\n    {\n\tvoid *buf;\n\tsize_t size;\n\theim_object_t o;\n\n\tif (rk_undumpdata(argv[0], &buf, &size))\n\t    errx(1, \"undumpdata: %s\", argv[0]);\n\t\n\to = heim_json_create_with_bytes(buf, size, 10, 0, NULL);\n\tfree(buf);\n\tif (o == NULL)\n\t    errx(1, \"heim_json\");\n\t\n\t/*\n\t * do the work here\n\t */\n\t\n\teval_object(o);\n\n\theim_release(o);\n    }\n\n    krb5_free_context(kdc_context);\n    return 0;\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic krb5_kdc_configuration *kdc_config;",
      "tatic krb5_context kdc_context;",
      "tatic void eval_object(heim_object_t);",
      "tatic krb5plugin_send_to_kdc_ftable send_to_kdc = {\n    KRB5_PLUGIN_SEND_TO_KDC_VERSION_2,\n    plugin_init,\n    plugin_fini,\n    plugin_send_to_kdc,\n    plugin_send_to_realm\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_context(",
          "args": [
            "dc_context)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_release(",
          "args": [
            ")"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val_object(",
          "args": [
            ")"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "val_object(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "426-452",
          "snippet": "tatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void eval_object(heim_object_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "heim_json\")"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uf)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_json_create_with_bytes(",
          "args": [
            "uf,",
            "ize,",
            "0,",
            ",",
            "ULL)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "undumpdata: %s\",",
            "rgv[0])"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_undumpdata(",
          "args": [
            "rgv[0],",
            "buf,",
            "size)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_plugin_register(",
          "args": [
            "dc_context,",
            "LUGIN_TYPE_DATA,",
            "RB5_PLUGIN_SEND_TO_KDC,",
            "send_to_kdc)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "missing operations\")"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onfigure(",
          "args": [
            "dc_context,",
            "rgc,",
            "rgv,",
            "optidx)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "onfigure(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/config.c",
          "lines": "154-307",
          "snippet": "rb5_kdc_configuration *\nconfigure(krb5_context context, int argc, char **argv, int *optidx)\n{\n    krb5_kdc_configuration *config;\n    krb5_error_code ret;\n    \n    const char *p;\n\n    *optidx = 0;\n\n    while (getarg(args, num_args, argc, argv, optidx))\n\twarnx(\"error at argument `%s'\", argv[*optidx]);\n\n    if (help_flag)\n\tusage (0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    if (builtin_hdb_flag) {\n\tchar *list;\n\tret = hdb_list_builtin(context, &list);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"listing builtin hdb backends\");\n\tprintf(\"builtin hdb backends: %s\\n\", list);\n\tfree(list);\n\texit(0);\n    }\n\n    if(detach_from_console == -1)\n\tdetach_from_console = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t\t   \"detach\", NULL);\n\n    if (detach_from_console && daemon_child == -1)\n        roken_detach_prep(argc, argv, \"--daemon-child\");\n\n    {\n\tchar **files;\n\tint aret;\n\n\tif (config_file == NULL) {\n\t    aret = asprintf(&config_file, \"%s/kdc.conf\", hdb_db_dir(context));\n\t    if (aret == -1 || config_file == NULL)\n\t\terrx(1, \"out of memory\");\n\t}\n\n\tret = krb5_prepend_config_files_default(config_file, &files);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"getting configuration files\");\n\n\tret = krb5_set_config_files(context, files);\n\tkrb5_free_config_files(files);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"reading configuration files\");\n    }\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n    if(max_request_str)\n\tmax_request_tcp = max_request_udp = parse_bytes(max_request_str, NULL);\n\n    if(max_request_tcp == 0){\n\tp = krb5_config_get_string (context,\n\t\t\t\t    NULL,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-request\",\n\t\t\t\t    NULL);\n\tif(p)\n\t    max_request_tcp = max_request_udp = parse_bytes(p, NULL);\n    }\n\n    if(require_preauth != -1)\n\tconfig->require_preauth = require_preauth;\n\n    if(port_str == NULL){\n\tp = krb5_config_get_string(context, NULL, \"kdc\", \"ports\", NULL);\n\tif (p != NULL)\n\t    port_str = strdup(p);\n    }\n\n    explicit_addresses.len = 0;\n\n    if (addresses_str.num_strings) {\n\tint i;\n\n\tfor (i = 0; i < addresses_str.num_strings; ++i)\n\t    add_one_address (context, addresses_str.strings[i], i == 0);\n\tfree_getarg_strings (&addresses_str);\n    } else {\n\tchar **foo = krb5_config_get_strings (context, NULL,\n\t\t\t\t\t      \"kdc\", \"addresses\", NULL);\n\n\tif (foo != NULL) {\n\t    add_one_address (context, *foo++, TRUE);\n\t    while (*foo)\n\t\tadd_one_address (context, *foo++, FALSE);\n\t}\n    }\n\n    if(enable_http == -1)\n\tenable_http = krb5_config_get_bool(context, NULL, \"kdc\",\n\t\t\t\t\t   \"enable-http\", NULL);\n\n    if(request_log == NULL)\n\trequest_log = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"kdc\",\n\t\t\t\t\t     \"kdc-request-log\",\n\t\t\t\t\t     NULL);\n\n    if (krb5_config_get_string(context, NULL, \"kdc\",\n\t\t\t       \"enforce-transited-policy\", NULL))\n\tkrb5_errx(context, 1, \"enforce-transited-policy deprecated, \"\n\t\t  \"use [kdc]transited-policy instead\");\n\n    if(max_request_tcp == 0)\n\tmax_request_tcp = 64 * 1024;\n    if(max_request_udp == 0)\n\tmax_request_udp = 64 * 1024;\n\n    if (port_str == NULL)\n\tport_str = \"+\";\n\n    if(disable_des == -1)\n\tdisable_des = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t   \"disable-des\", NULL);\n    if(disable_des) {\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_CRC);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD4);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD5);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_CFB64_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_PCBC_NONE);\n    }\n\n    krb5_kdc_windc_init(context);\n\n    krb5_kdc_pkinit_config(context, config);\n\n    return config;\n}",
          "includes": [
            "include <parse_bytes.h>",
            "include <getarg.h>\n#",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char *config_file;",
            "tatic int require_preauth = -1;",
            "tatic char *max_request_str;",
            "tatic int disable_des = -1;",
            "tatic int builtin_hdb_flag;",
            "tatic int help_flag;",
            "tatic int version_flag;",
            "nt enable_http = -1;",
            "onst char *request_log;",
            "onst char *port_str;",
            "rb5_addresses explicit_addresses;",
            "ize_t max_request_udp;",
            "ize_t max_request_tcp;",
            "tatic struct getarg_strings addresses_str;",
            "tatic struct getargs args[] = {\n    {\n\t\"config-file\",\t'c',\targ_string,\t&config_file,\n\t\"location of config file\",\t\"file\"\n    },\n    {\n\t\"require-preauth\",\t'p',\targ_negative_flag, &require_preauth,\n\t\"don't require pa-data in as-reqs\", NULL\n    },\n    {\n\t\"max-request\",\t0,\targ_string, &max_request_str,\n\t\"max size for a kdc-request\", \"size\"\n    },\n    { \"enable-http\", 'H', arg_flag, &enable_http, \"turn on HTTP support\",\n   \t NULL },\n    {\t\"ports\",\t'P', \targ_string, rk_UNCONST(&port_str),\n\t\"ports to listen to\", \"portspec\"\n    },\n    {\n\t\"detach\",       0 ,      arg_flag, &detach_from_console,\n\t\"detach from console\", NULL\n    },\n    {\n        \"daemon-child\",       0 ,      arg_flag, &daemon_child,\n        \"private argument, do not use\", NULL\n    },\n#ifdef __APPLE__\n    {\n        \"bonjour\",       0 ,      arg_flag, &do_bonjour,\n        \"private argument, do not use\", NULL\n    },\n#endif\n    {\t\"addresses\",\t0,\targ_strings, &addresses_str,\n\t\"addresses to listen on\", \"list of addresses\" },\n    {\t\"disable-des\",\t0,\targ_flag, &disable_des,\n\t\"disable DES\", NULL },\n    {\t\"builtin-hdb\",\t0,\targ_flag,   &builtin_hdb_flag,\n\t\"list builtin hdb backends\", NULL},\n    {   \"runas-user\",\t0,\targ_string, &runas_string,\n\t\"run as this user when connected to network\", NULL\n    },\n    {   \"chroot\",\t0,\targ_string, &chroot_string,\n\t\"chroot directory to run in\", NULL\n    },\n    {\t\"testing\",\t0,\targ_flag,   &testing_flag, NULL, NULL },\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};",
            "tatic int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include <parse_bytes.h>\ninclude <getarg.h>\n#\ninclude \"kdc_locl.h\"\n#\n\ntatic char *config_file;\ntatic int require_preauth = -1;\ntatic char *max_request_str;\ntatic int disable_des = -1;\ntatic int builtin_hdb_flag;\ntatic int help_flag;\ntatic int version_flag;\nnt enable_http = -1;\nonst char *request_log;\nonst char *port_str;\nrb5_addresses explicit_addresses;\nize_t max_request_udp;\nize_t max_request_tcp;\ntatic struct getarg_strings addresses_str;\ntatic struct getargs args[] = {\n    {\n\t\"config-file\",\t'c',\targ_string,\t&config_file,\n\t\"location of config file\",\t\"file\"\n    },\n    {\n\t\"require-preauth\",\t'p',\targ_negative_flag, &require_preauth,\n\t\"don't require pa-data in as-reqs\", NULL\n    },\n    {\n\t\"max-request\",\t0,\targ_string, &max_request_str,\n\t\"max size for a kdc-request\", \"size\"\n    },\n    { \"enable-http\", 'H', arg_flag, &enable_http, \"turn on HTTP support\",\n   \t NULL },\n    {\t\"ports\",\t'P', \targ_string, rk_UNCONST(&port_str),\n\t\"ports to listen to\", \"portspec\"\n    },\n    {\n\t\"detach\",       0 ,      arg_flag, &detach_from_console,\n\t\"detach from console\", NULL\n    },\n    {\n        \"daemon-child\",       0 ,      arg_flag, &daemon_child,\n        \"private argument, do not use\", NULL\n    },\n#ifdef __APPLE__\n    {\n        \"bonjour\",       0 ,      arg_flag, &do_bonjour,\n        \"private argument, do not use\", NULL\n    },\n#endif\n    {\t\"addresses\",\t0,\targ_strings, &addresses_str,\n\t\"addresses to listen on\", \"list of addresses\" },\n    {\t\"disable-des\",\t0,\targ_flag, &disable_des,\n\t\"disable DES\", NULL },\n    {\t\"builtin-hdb\",\t0,\targ_flag,   &builtin_hdb_flag,\n\t\"list builtin hdb backends\", NULL},\n    {   \"runas-user\",\t0,\targ_string, &runas_string,\n\t\"run as this user when connected to network\", NULL\n    },\n    {   \"chroot\",\t0,\targ_string, &chroot_string,\n\t\"chroot directory to run in\", NULL\n    },\n    {\t\"testing\",\t0,\targ_flag,   &testing_flag, NULL, NULL },\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\nrb5_kdc_configuration *\nconfigure(krb5_context context, int argc, char **argv, int *optidx)\n{\n    krb5_kdc_configuration *config;\n    krb5_error_code ret;\n    \n    const char *p;\n\n    *optidx = 0;\n\n    while (getarg(args, num_args, argc, argv, optidx))\n\twarnx(\"error at argument `%s'\", argv[*optidx]);\n\n    if (help_flag)\n\tusage (0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    if (builtin_hdb_flag) {\n\tchar *list;\n\tret = hdb_list_builtin(context, &list);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"listing builtin hdb backends\");\n\tprintf(\"builtin hdb backends: %s\\n\", list);\n\tfree(list);\n\texit(0);\n    }\n\n    if(detach_from_console == -1)\n\tdetach_from_console = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t\t   \"detach\", NULL);\n\n    if (detach_from_console && daemon_child == -1)\n        roken_detach_prep(argc, argv, \"--daemon-child\");\n\n    {\n\tchar **files;\n\tint aret;\n\n\tif (config_file == NULL) {\n\t    aret = asprintf(&config_file, \"%s/kdc.conf\", hdb_db_dir(context));\n\t    if (aret == -1 || config_file == NULL)\n\t\terrx(1, \"out of memory\");\n\t}\n\n\tret = krb5_prepend_config_files_default(config_file, &files);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"getting configuration files\");\n\n\tret = krb5_set_config_files(context, files);\n\tkrb5_free_config_files(files);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"reading configuration files\");\n    }\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n    if(max_request_str)\n\tmax_request_tcp = max_request_udp = parse_bytes(max_request_str, NULL);\n\n    if(max_request_tcp == 0){\n\tp = krb5_config_get_string (context,\n\t\t\t\t    NULL,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-request\",\n\t\t\t\t    NULL);\n\tif(p)\n\t    max_request_tcp = max_request_udp = parse_bytes(p, NULL);\n    }\n\n    if(require_preauth != -1)\n\tconfig->require_preauth = require_preauth;\n\n    if(port_str == NULL){\n\tp = krb5_config_get_string(context, NULL, \"kdc\", \"ports\", NULL);\n\tif (p != NULL)\n\t    port_str = strdup(p);\n    }\n\n    explicit_addresses.len = 0;\n\n    if (addresses_str.num_strings) {\n\tint i;\n\n\tfor (i = 0; i < addresses_str.num_strings; ++i)\n\t    add_one_address (context, addresses_str.strings[i], i == 0);\n\tfree_getarg_strings (&addresses_str);\n    } else {\n\tchar **foo = krb5_config_get_strings (context, NULL,\n\t\t\t\t\t      \"kdc\", \"addresses\", NULL);\n\n\tif (foo != NULL) {\n\t    add_one_address (context, *foo++, TRUE);\n\t    while (*foo)\n\t\tadd_one_address (context, *foo++, FALSE);\n\t}\n    }\n\n    if(enable_http == -1)\n\tenable_http = krb5_config_get_bool(context, NULL, \"kdc\",\n\t\t\t\t\t   \"enable-http\", NULL);\n\n    if(request_log == NULL)\n\trequest_log = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"kdc\",\n\t\t\t\t\t     \"kdc-request-log\",\n\t\t\t\t\t     NULL);\n\n    if (krb5_config_get_string(context, NULL, \"kdc\",\n\t\t\t       \"enforce-transited-policy\", NULL))\n\tkrb5_errx(context, 1, \"enforce-transited-policy deprecated, \"\n\t\t  \"use [kdc]transited-policy instead\");\n\n    if(max_request_tcp == 0)\n\tmax_request_tcp = 64 * 1024;\n    if(max_request_udp == 0)\n\tmax_request_udp = 64 * 1024;\n\n    if (port_str == NULL)\n\tport_str = \"+\";\n\n    if(disable_des == -1)\n\tdisable_des = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t   \"disable-des\", NULL);\n    if(disable_des) {\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_CRC);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD4);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD5);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_CFB64_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_PCBC_NONE);\n    }\n\n    krb5_kdc_windc_init(context);\n\n    krb5_kdc_pkinit_config(context, config);\n\n    return config;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_kt_register(HDB) failed: %d\",",
            "et)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_register(",
          "args": [
            "dc_context,",
            "hdb_get_kt_ops)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_init_context failed: %d\",",
            "et)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_init_context failed to parse configuration file\")"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_context(",
          "args": [
            "kdc_context)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etprogname(",
          "args": [
            "rgv[0])"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_kdc_configuration *kdc_config;\ntatic krb5_context kdc_context;\ntatic void eval_object(heim_object_t);\ntatic krb5plugin_send_to_kdc_ftable send_to_kdc = {\n    KRB5_PLUGIN_SEND_TO_KDC_VERSION_2,\n    plugin_init,\n    plugin_fini,\n    plugin_send_to_kdc,\n    plugin_send_to_realm\n};\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    int optidx = 0;\n\n    setprogname(argv[0]);\n\n    ret = krb5_init_context(&kdc_context);\n    if (ret == KRB5_CONFIG_BADFORMAT)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n    else if (ret)\n\terrx (1, \"krb5_init_context failed: %d\", ret);\n\n    ret = krb5_kt_register(kdc_context, &hdb_get_kt_ops);\n    if (ret)\n\terrx (1, \"krb5_kt_register(HDB) failed: %d\", ret);\n\n    kdc_config = configure(kdc_context, argc, argv, &optidx);\n\n    argc -= optidx;\n    argv += optidx;\n\n    if (argc == 0)\n\terrx(1, \"missing operations\");\n\n    krb5_plugin_register(kdc_context, PLUGIN_TYPE_DATA,\n\t\t\t KRB5_PLUGIN_SEND_TO_KDC, &send_to_kdc);\n\n    {\n\tvoid *buf;\n\tsize_t size;\n\theim_object_t o;\n\n\tif (rk_undumpdata(argv[0], &buf, &size))\n\t    errx(1, \"undumpdata: %s\", argv[0]);\n\t\n\to = heim_json_create_with_bytes(buf, size, 10, 0, NULL);\n\tfree(buf);\n\tif (o == NULL)\n\t    errx(1, \"heim_json\");\n\t\n\t/*\n\t * do the work here\n\t */\n\t\n\teval_object(o);\n\n\theim_release(o);\n    }\n\n    krb5_free_context(kdc_context);\n    return 0;\n}"
  },
  {
    "function_name": "val_object(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "426-452",
    "snippet": "tatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void eval_object(heim_object_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "unsupported\")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "unsupported ops %s\",",
            "p)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val_kdestroy(",
          "args": [
            ")"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "val_kdestroy(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "396-413",
          "snippet": "tatic void\neval_kdestroy(heim_dict_t o)\n{\n    heim_string_t ccache = heim_dict_get_value(o, HSTR(\"ccache\"));;\n    krb5_error_code ret;\n    const char *name;\n    krb5_ccache cc;\n\n    heim_assert(ccache != NULL, \"ccache_missing\");\n\t\n    name = heim_string_get_utf8(ccache);\n\n    ret = krb5_cc_resolve(kdc_context, name, &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    krb5_cc_destroy(kdc_context, cc);\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic krb5_context kdc_context;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_context kdc_context;\n\ntatic void\neval_kdestroy(heim_dict_t o)\n{\n    heim_string_t ccache = heim_dict_get_value(o, HSTR(\"ccache\"));;\n    krb5_error_code ret;\n    const char *name;\n    krb5_ccache cc;\n\n    heim_assert(ccache != NULL, \"ccache_missing\");\n\t\n    name = heim_string_get_utf8(ccache);\n\n    ret = krb5_cc_resolve(kdc_context, name, &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    krb5_cc_destroy(kdc_context, cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "p,",
            "kdestroy\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val_kgetcred(",
          "args": [
            ")"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "val_kgetcred(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "340-389",
          "snippet": "tatic void\neval_kgetcred(heim_dict_t o)\n{\n    heim_string_t server, ccache;\n    krb5_get_creds_opt opt;\n    heim_bool_t nostore;\n    krb5_error_code ret;\n    krb5_ccache cc = NULL;\n    krb5_principal s;\n    krb5_creds *out = NULL;\n\n    if (ptop)\n\tptop->tgs_req++;\n\n    server = heim_dict_get_value(o, HSTR(\"server\"));\n    if (server == NULL)\n\tkrb5_errx(kdc_context, 1, \"no server\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n    if (ccache == NULL)\n\tkrb5_errx(kdc_context, 1, \"no ccache\");\n\n    nostore = heim_dict_get_value(o, HSTR(\"nostore\"));\n    if (nostore == NULL)\n\tnostore = heim_bool_create(1);\n\n    ret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(ccache), &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(server), &s);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_parse_name\");\n\n    ret = krb5_get_creds_opt_alloc(kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds_opt_alloc\");\n\n    if (heim_bool_val(nostore))\n\tkrb5_get_creds_opt_add_options(kdc_context, opt, KRB5_GC_NO_STORE);\n\n    ret = krb5_get_creds(kdc_context, opt, cc, s, &out);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds\");\n    \n    krb5_free_creds(kdc_context, out);\n    krb5_free_principal(kdc_context, s);\n    krb5_get_creds_opt_free(kdc_context, opt);\n    krb5_cc_close(kdc_context, cc);\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;",
            "tatic krb5_context kdc_context;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\ntatic krb5_context kdc_context;\n\ntatic void\neval_kgetcred(heim_dict_t o)\n{\n    heim_string_t server, ccache;\n    krb5_get_creds_opt opt;\n    heim_bool_t nostore;\n    krb5_error_code ret;\n    krb5_ccache cc = NULL;\n    krb5_principal s;\n    krb5_creds *out = NULL;\n\n    if (ptop)\n\tptop->tgs_req++;\n\n    server = heim_dict_get_value(o, HSTR(\"server\"));\n    if (server == NULL)\n\tkrb5_errx(kdc_context, 1, \"no server\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n    if (ccache == NULL)\n\tkrb5_errx(kdc_context, 1, \"no ccache\");\n\n    nostore = heim_dict_get_value(o, HSTR(\"nostore\"));\n    if (nostore == NULL)\n\tnostore = heim_bool_create(1);\n\n    ret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(ccache), &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(server), &s);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_parse_name\");\n\n    ret = krb5_get_creds_opt_alloc(kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds_opt_alloc\");\n\n    if (heim_bool_val(nostore))\n\tkrb5_get_creds_opt_add_options(kdc_context, opt, KRB5_GC_NO_STORE);\n\n    ret = krb5_get_creds(kdc_context, opt, cc, s, &out);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds\");\n    \n    krb5_free_creds(kdc_context, out);\n    krb5_free_principal(kdc_context, s);\n    krb5_get_creds_opt_free(kdc_context, opt);\n    krb5_cc_close(kdc_context, cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "p,",
            "kgetcred\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val_kinit(",
          "args": [
            ")"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "val_kinit(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "209-334",
          "snippet": "tatic void\neval_kinit(heim_dict_t o)\n{\n    heim_string_t user, password, keytab, fast_armor_cc, pk_user_id, ccache;\n    krb5_get_init_creds_opt *opt;\n    krb5_init_creds_context ctx;\n    krb5_principal client;\n    krb5_keytab ktmem = NULL;\n    krb5_ccache fast_cc = NULL;\n    krb5_error_code ret;\n\n    if (ptop)\n\tptop->as_req++;\n\n    user = heim_dict_get_value(o, HSTR(\"client\"));\n    if (user == NULL)\n\tkrb5_errx(kdc_context, 1, \"no client\");\n\n    password = heim_dict_get_value(o, HSTR(\"password\"));\n    keytab = heim_dict_get_value(o, HSTR(\"keytab\"));\n    pk_user_id = heim_dict_get_value(o, HSTR(\"pkinit-user-cert-id\"));\n    if (password == NULL && keytab == NULL && pk_user_id == NULL)\n\tkrb5_errx(kdc_context, 1, \"password, keytab, nor PKINIT user cert ID\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(user), &client);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_unparse_name\");\n\n    /* PKINIT parts */\n    ret = krb5_get_init_creds_opt_alloc (kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n\n    if (pk_user_id) {\n\theim_bool_t rsaobj = heim_dict_get_value(o, HSTR(\"pkinit-use-rsa\"));\n\tint use_rsa = rsaobj ? heim_bool_val(rsaobj) : 0;\n\n\tret = krb5_get_init_creds_opt_set_pkinit(kdc_context, opt,\n\t\t\t\t\t\t client,\n\t\t\t\t\t\t heim_string_get_utf8(pk_user_id),\n\t\t\t\t\t\t NULL, NULL, NULL,\n\t\t\t\t\t\t use_rsa ? 2 : 0,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_set_pkinit\");\n    }\n\n    ret = krb5_init_creds_init(kdc_context, client, NULL, NULL, 0, opt, &ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_init\");\n\n    fast_armor_cc = heim_dict_get_value(o, HSTR(\"fast-armor-cc\"));\n    if (fast_armor_cc) {\n\n\tret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(fast_armor_cc), &fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tret = krb5_init_creds_set_fast_ccache(kdc_context, ctx, fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_fast_ccache\");\n    }\n    \n    if (password) {\n\tret = krb5_init_creds_set_password(kdc_context, ctx, \n\t\t\t\t\t   heim_string_get_utf8(password));\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_password\");\n    }\n    if (keytab) {\n\tkrb5_keytab kt = NULL;\n\n\tret = krb5_kt_resolve(kdc_context, heim_string_get_utf8(keytab), &kt);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve\");\n\n\tret = krb5_kt_resolve(kdc_context, \"MEMORY:keytab\", &ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve(MEMORY)\");\n\n\tret = copy_keytab(kdc_context, kt, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"copy_keytab\");\n\n\tkrb5_kt_close(kdc_context, kt);\n\n\tret = krb5_init_creds_set_keytab(kdc_context, ctx, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_keytab\");\n    }\n\n    ret = krb5_init_creds_get(kdc_context, ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_get\");\n\n    if (ccache) {\n\tconst char *name = heim_string_get_utf8(ccache);\n\tkrb5_creds cred;\n\tkrb5_ccache cc;\n\n\tret = krb5_init_creds_get_creds(kdc_context, ctx, &cred);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_get_creds\");\n\n\tret = krb5_cc_resolve(kdc_context, name, &cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tkrb5_init_creds_store(kdc_context, ctx, cc);\n\n\tret = krb5_cc_close(kdc_context, cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_close\");\n\n\tkrb5_free_cred_contents(kdc_context, &cred);\n    }\n\n    krb5_init_creds_free(kdc_context, ctx);\n\n    if (ktmem)\n\tkrb5_kt_close(kdc_context, ktmem);\n    if (fast_cc)\n\tkrb5_cc_close(kdc_context, fast_cc);\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;",
            "tatic krb5_context kdc_context;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\ntatic krb5_context kdc_context;\n\ntatic void\neval_kinit(heim_dict_t o)\n{\n    heim_string_t user, password, keytab, fast_armor_cc, pk_user_id, ccache;\n    krb5_get_init_creds_opt *opt;\n    krb5_init_creds_context ctx;\n    krb5_principal client;\n    krb5_keytab ktmem = NULL;\n    krb5_ccache fast_cc = NULL;\n    krb5_error_code ret;\n\n    if (ptop)\n\tptop->as_req++;\n\n    user = heim_dict_get_value(o, HSTR(\"client\"));\n    if (user == NULL)\n\tkrb5_errx(kdc_context, 1, \"no client\");\n\n    password = heim_dict_get_value(o, HSTR(\"password\"));\n    keytab = heim_dict_get_value(o, HSTR(\"keytab\"));\n    pk_user_id = heim_dict_get_value(o, HSTR(\"pkinit-user-cert-id\"));\n    if (password == NULL && keytab == NULL && pk_user_id == NULL)\n\tkrb5_errx(kdc_context, 1, \"password, keytab, nor PKINIT user cert ID\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(user), &client);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_unparse_name\");\n\n    /* PKINIT parts */\n    ret = krb5_get_init_creds_opt_alloc (kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n\n    if (pk_user_id) {\n\theim_bool_t rsaobj = heim_dict_get_value(o, HSTR(\"pkinit-use-rsa\"));\n\tint use_rsa = rsaobj ? heim_bool_val(rsaobj) : 0;\n\n\tret = krb5_get_init_creds_opt_set_pkinit(kdc_context, opt,\n\t\t\t\t\t\t client,\n\t\t\t\t\t\t heim_string_get_utf8(pk_user_id),\n\t\t\t\t\t\t NULL, NULL, NULL,\n\t\t\t\t\t\t use_rsa ? 2 : 0,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_set_pkinit\");\n    }\n\n    ret = krb5_init_creds_init(kdc_context, client, NULL, NULL, 0, opt, &ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_init\");\n\n    fast_armor_cc = heim_dict_get_value(o, HSTR(\"fast-armor-cc\"));\n    if (fast_armor_cc) {\n\n\tret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(fast_armor_cc), &fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tret = krb5_init_creds_set_fast_ccache(kdc_context, ctx, fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_fast_ccache\");\n    }\n    \n    if (password) {\n\tret = krb5_init_creds_set_password(kdc_context, ctx, \n\t\t\t\t\t   heim_string_get_utf8(password));\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_password\");\n    }\n    if (keytab) {\n\tkrb5_keytab kt = NULL;\n\n\tret = krb5_kt_resolve(kdc_context, heim_string_get_utf8(keytab), &kt);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve\");\n\n\tret = krb5_kt_resolve(kdc_context, \"MEMORY:keytab\", &ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve(MEMORY)\");\n\n\tret = copy_keytab(kdc_context, kt, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"copy_keytab\");\n\n\tkrb5_kt_close(kdc_context, kt);\n\n\tret = krb5_init_creds_set_keytab(kdc_context, ctx, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_keytab\");\n    }\n\n    ret = krb5_init_creds_get(kdc_context, ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_get\");\n\n    if (ccache) {\n\tconst char *name = heim_string_get_utf8(ccache);\n\tkrb5_creds cred;\n\tkrb5_ccache cc;\n\n\tret = krb5_init_creds_get_creds(kdc_context, ctx, &cred);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_get_creds\");\n\n\tret = krb5_cc_resolve(kdc_context, name, &cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tkrb5_init_creds_store(kdc_context, ctx, cc);\n\n\tret = krb5_cc_close(kdc_context, cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_close\");\n\n\tkrb5_free_cred_contents(kdc_context, &cred);\n    }\n\n    krb5_init_creds_free(kdc_context, ctx);\n\n    if (ktmem)\n\tkrb5_kt_close(kdc_context, ktmem);\n    if (fast_cc)\n\tkrb5_cc_close(kdc_context, fast_cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "p,",
            "kinit\")"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val_repeat(",
          "args": [
            ")"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "val_repeat(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "162-182",
          "snippet": "tatic void\neval_repeat(heim_dict_t o)\n{\n    heim_object_t or = heim_dict_get_value(o, HSTR(\"value\"));\n    heim_number_t n = heim_dict_get_value(o, HSTR(\"num\"));\n    int i, num;\n    struct perf perf;\n\n    perf_start(&perf);\n\n    heim_assert(or != NULL, \"value missing\");\n    heim_assert(n != NULL, \"num missing\");\n\n    num = heim_number_get_int(n);\n    heim_assert(num >= 0, \"num >= 0\");\n\n    for (i = 0; i < num; i++)\n\teval_object(or);\n\n    perf_stop(&perf);\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void eval_object(heim_object_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_repeat(heim_dict_t o)\n{\n    heim_object_t or = heim_dict_get_value(o, HSTR(\"value\"));\n    heim_number_t n = heim_dict_get_value(o, HSTR(\"num\"));\n    int i, num;\n    struct perf perf;\n\n    perf_start(&perf);\n\n    heim_assert(or != NULL, \"value missing\");\n    heim_assert(n != NULL, \"num missing\");\n\n    num = heim_number_get_int(n);\n    heim_assert(num >= 0, \"num >= 0\");\n\n    for (i = 0; i < num; i++)\n\teval_object(or);\n\n    perf_stop(&perf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "p,",
            "repeat\")"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "p != NULL,",
            "op missing\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"op\"))"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "op\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_type_id(",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_array_iterate_f(",
          "args": [
            ",",
            "ULL,",
            "val_array_element)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_array_get_type_id(",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_get_tid(",
          "args": [
            ")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}"
  },
  {
    "function_name": "val_array_element(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "420-424",
    "snippet": "tatic void\neval_array_element(heim_object_t o, void *ptr, int *stop)\n{\n    eval_object(o);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void eval_object(heim_object_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "val_object(",
          "args": [
            ")"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "val_object(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "426-452",
          "snippet": "tatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void eval_object(heim_object_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}"
        }
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_array_element(heim_object_t o, void *ptr, int *stop)\n{\n    eval_object(o);\n}"
  },
  {
    "function_name": "val_kdestroy(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "396-413",
    "snippet": "tatic void\neval_kdestroy(heim_dict_t o)\n{\n    heim_string_t ccache = heim_dict_get_value(o, HSTR(\"ccache\"));;\n    krb5_error_code ret;\n    const char *name;\n    krb5_ccache cc;\n\n    heim_assert(ccache != NULL, \"ccache_missing\");\n\t\n    name = heim_string_get_utf8(ccache);\n\n    ret = krb5_cc_resolve(kdc_context, name, &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    krb5_cc_destroy(kdc_context, cc);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic krb5_context kdc_context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_cc_destroy(",
          "args": [
            "dc_context,",
            "c)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_cc_resolve\")"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_resolve(",
          "args": [
            "dc_context,",
            "ame,",
            "cc)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "cache)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "cache != NULL,",
            "ccache_missing\")"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"ccache\"))"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "ccache\")"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_context kdc_context;\n\ntatic void\neval_kdestroy(heim_dict_t o)\n{\n    heim_string_t ccache = heim_dict_get_value(o, HSTR(\"ccache\"));;\n    krb5_error_code ret;\n    const char *name;\n    krb5_ccache cc;\n\n    heim_assert(ccache != NULL, \"ccache_missing\");\n\t\n    name = heim_string_get_utf8(ccache);\n\n    ret = krb5_cc_resolve(kdc_context, name, &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    krb5_cc_destroy(kdc_context, cc);\n}"
  },
  {
    "function_name": "val_kgetcred(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "340-389",
    "snippet": "tatic void\neval_kgetcred(heim_dict_t o)\n{\n    heim_string_t server, ccache;\n    krb5_get_creds_opt opt;\n    heim_bool_t nostore;\n    krb5_error_code ret;\n    krb5_ccache cc = NULL;\n    krb5_principal s;\n    krb5_creds *out = NULL;\n\n    if (ptop)\n\tptop->tgs_req++;\n\n    server = heim_dict_get_value(o, HSTR(\"server\"));\n    if (server == NULL)\n\tkrb5_errx(kdc_context, 1, \"no server\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n    if (ccache == NULL)\n\tkrb5_errx(kdc_context, 1, \"no ccache\");\n\n    nostore = heim_dict_get_value(o, HSTR(\"nostore\"));\n    if (nostore == NULL)\n\tnostore = heim_bool_create(1);\n\n    ret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(ccache), &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(server), &s);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_parse_name\");\n\n    ret = krb5_get_creds_opt_alloc(kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds_opt_alloc\");\n\n    if (heim_bool_val(nostore))\n\tkrb5_get_creds_opt_add_options(kdc_context, opt, KRB5_GC_NO_STORE);\n\n    ret = krb5_get_creds(kdc_context, opt, cc, s, &out);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds\");\n    \n    krb5_free_creds(kdc_context, out);\n    krb5_free_principal(kdc_context, s);\n    krb5_get_creds_opt_free(kdc_context, opt);\n    krb5_cc_close(kdc_context, cc);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;",
      "tatic krb5_context kdc_context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_cc_close(",
          "args": [
            "dc_context,",
            "c)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_creds_opt_free(",
          "args": [
            "dc_context,",
            "pt)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "dc_context,",
            ")"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_creds(",
          "args": [
            "dc_context,",
            "ut)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_get_creds\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_creds(",
          "args": [
            "dc_context,",
            "pt,",
            "c,",
            ",",
            "out)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_creds_opt_add_options(",
          "args": [
            "dc_context,",
            "pt,",
            "RB5_GC_NO_STORE)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_bool_val(",
          "args": [
            "ostore)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_get_creds_opt_alloc\")"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_creds_opt_alloc(",
          "args": [
            "dc_context,",
            "opt)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_parse_name\")"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "dc_context,",
            "eim_string_get_utf8(server),",
            "s)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "erver)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_cc_resolve\")"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_resolve(",
          "args": [
            "dc_context,",
            "eim_string_get_utf8(ccache),",
            "cc)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "cache)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_bool_create(",
          "args": [
            ")"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"nostore\"))"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "nostore\")"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "dc_context,",
            ",",
            "no ccache\")"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"ccache\"))"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "ccache\")"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "dc_context,",
            ",",
            "no server\")"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"server\"))"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "server\")"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\ntatic krb5_context kdc_context;\n\ntatic void\neval_kgetcred(heim_dict_t o)\n{\n    heim_string_t server, ccache;\n    krb5_get_creds_opt opt;\n    heim_bool_t nostore;\n    krb5_error_code ret;\n    krb5_ccache cc = NULL;\n    krb5_principal s;\n    krb5_creds *out = NULL;\n\n    if (ptop)\n\tptop->tgs_req++;\n\n    server = heim_dict_get_value(o, HSTR(\"server\"));\n    if (server == NULL)\n\tkrb5_errx(kdc_context, 1, \"no server\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n    if (ccache == NULL)\n\tkrb5_errx(kdc_context, 1, \"no ccache\");\n\n    nostore = heim_dict_get_value(o, HSTR(\"nostore\"));\n    if (nostore == NULL)\n\tnostore = heim_bool_create(1);\n\n    ret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(ccache), &cc);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(server), &s);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_parse_name\");\n\n    ret = krb5_get_creds_opt_alloc(kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds_opt_alloc\");\n\n    if (heim_bool_val(nostore))\n\tkrb5_get_creds_opt_add_options(kdc_context, opt, KRB5_GC_NO_STORE);\n\n    ret = krb5_get_creds(kdc_context, opt, cc, s, &out);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_creds\");\n    \n    krb5_free_creds(kdc_context, out);\n    krb5_free_principal(kdc_context, s);\n    krb5_get_creds_opt_free(kdc_context, opt);\n    krb5_cc_close(kdc_context, cc);\n}"
  },
  {
    "function_name": "val_kinit(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "209-334",
    "snippet": "tatic void\neval_kinit(heim_dict_t o)\n{\n    heim_string_t user, password, keytab, fast_armor_cc, pk_user_id, ccache;\n    krb5_get_init_creds_opt *opt;\n    krb5_init_creds_context ctx;\n    krb5_principal client;\n    krb5_keytab ktmem = NULL;\n    krb5_ccache fast_cc = NULL;\n    krb5_error_code ret;\n\n    if (ptop)\n\tptop->as_req++;\n\n    user = heim_dict_get_value(o, HSTR(\"client\"));\n    if (user == NULL)\n\tkrb5_errx(kdc_context, 1, \"no client\");\n\n    password = heim_dict_get_value(o, HSTR(\"password\"));\n    keytab = heim_dict_get_value(o, HSTR(\"keytab\"));\n    pk_user_id = heim_dict_get_value(o, HSTR(\"pkinit-user-cert-id\"));\n    if (password == NULL && keytab == NULL && pk_user_id == NULL)\n\tkrb5_errx(kdc_context, 1, \"password, keytab, nor PKINIT user cert ID\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(user), &client);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_unparse_name\");\n\n    /* PKINIT parts */\n    ret = krb5_get_init_creds_opt_alloc (kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n\n    if (pk_user_id) {\n\theim_bool_t rsaobj = heim_dict_get_value(o, HSTR(\"pkinit-use-rsa\"));\n\tint use_rsa = rsaobj ? heim_bool_val(rsaobj) : 0;\n\n\tret = krb5_get_init_creds_opt_set_pkinit(kdc_context, opt,\n\t\t\t\t\t\t client,\n\t\t\t\t\t\t heim_string_get_utf8(pk_user_id),\n\t\t\t\t\t\t NULL, NULL, NULL,\n\t\t\t\t\t\t use_rsa ? 2 : 0,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_set_pkinit\");\n    }\n\n    ret = krb5_init_creds_init(kdc_context, client, NULL, NULL, 0, opt, &ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_init\");\n\n    fast_armor_cc = heim_dict_get_value(o, HSTR(\"fast-armor-cc\"));\n    if (fast_armor_cc) {\n\n\tret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(fast_armor_cc), &fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tret = krb5_init_creds_set_fast_ccache(kdc_context, ctx, fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_fast_ccache\");\n    }\n    \n    if (password) {\n\tret = krb5_init_creds_set_password(kdc_context, ctx, \n\t\t\t\t\t   heim_string_get_utf8(password));\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_password\");\n    }\n    if (keytab) {\n\tkrb5_keytab kt = NULL;\n\n\tret = krb5_kt_resolve(kdc_context, heim_string_get_utf8(keytab), &kt);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve\");\n\n\tret = krb5_kt_resolve(kdc_context, \"MEMORY:keytab\", &ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve(MEMORY)\");\n\n\tret = copy_keytab(kdc_context, kt, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"copy_keytab\");\n\n\tkrb5_kt_close(kdc_context, kt);\n\n\tret = krb5_init_creds_set_keytab(kdc_context, ctx, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_keytab\");\n    }\n\n    ret = krb5_init_creds_get(kdc_context, ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_get\");\n\n    if (ccache) {\n\tconst char *name = heim_string_get_utf8(ccache);\n\tkrb5_creds cred;\n\tkrb5_ccache cc;\n\n\tret = krb5_init_creds_get_creds(kdc_context, ctx, &cred);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_get_creds\");\n\n\tret = krb5_cc_resolve(kdc_context, name, &cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tkrb5_init_creds_store(kdc_context, ctx, cc);\n\n\tret = krb5_cc_close(kdc_context, cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_close\");\n\n\tkrb5_free_cred_contents(kdc_context, &cred);\n    }\n\n    krb5_init_creds_free(kdc_context, ctx);\n\n    if (ktmem)\n\tkrb5_kt_close(kdc_context, ktmem);\n    if (fast_cc)\n\tkrb5_cc_close(kdc_context, fast_cc);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;",
      "tatic krb5_context kdc_context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_cc_close(",
          "args": [
            "dc_context,",
            "ast_cc)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_close(",
          "args": [
            "dc_context,",
            "tmem)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_free(",
          "args": [
            "dc_context,",
            "tx)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_cred_contents(",
          "args": [
            "dc_context,",
            "cred)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_cc_close\")"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_close(",
          "args": [
            "dc_context,",
            "c)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_store(",
          "args": [
            "dc_context,",
            "tx,",
            "c)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_cc_resolve\")"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_resolve(",
          "args": [
            "dc_context,",
            "ame,",
            "cc)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_get_creds\")"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_get_creds(",
          "args": [
            "dc_context,",
            "tx,",
            "cred)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "cache)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_get\")"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_get(",
          "args": [
            "dc_context,",
            "tx)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_set_keytab\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_set_keytab(",
          "args": [
            "dc_context,",
            "tx,",
            "tmem)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_close(",
          "args": [
            "dc_context,",
            "t)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "copy_keytab\")"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_keytab(",
          "args": [
            "dc_context,",
            "t,",
            "tmem)"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "opy_keytab(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "188-203",
          "snippet": "tatic krb5_error_code\ncopy_keytab(krb5_context context, krb5_keytab from, krb5_keytab to)\n{\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code ret;\n\n    ret = krb5_kt_start_seq_get(context, from, &cursor);\n    if (ret)\n\treturn ret;\n    while((ret = krb5_kt_next_entry(context, from, &entry, &cursor)) == 0){\n\tkrb5_kt_add_entry(context, to, &entry);\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    return krb5_kt_end_seq_get(context, from, &cursor);\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\ncopy_keytab(krb5_context context, krb5_keytab from, krb5_keytab to)\n{\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code ret;\n\n    ret = krb5_kt_start_seq_get(context, from, &cursor);\n    if (ret)\n\treturn ret;\n    while((ret = krb5_kt_next_entry(context, from, &entry, &cursor)) == 0){\n\tkrb5_kt_add_entry(context, to, &entry);\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    return krb5_kt_end_seq_get(context, from, &cursor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_kt_resolve(MEMORY)\")"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_resolve(",
          "args": [
            "dc_context,",
            "MEMORY:keytab\",",
            "ktmem)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_kt_resolve\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_resolve(",
          "args": [
            "dc_context,",
            "eim_string_get_utf8(keytab),",
            "kt)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "eytab)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_set_password\")"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_set_password(",
          "args": [
            "dc_context,",
            "tx,",
            "eim_string_get_utf8(password))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "assword)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_set_fast_ccache\")"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_set_fast_ccache(",
          "args": [
            "dc_context,",
            "tx,",
            "ast_cc)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_cc_resolve\")"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_resolve(",
          "args": [
            "dc_context,",
            "eim_string_get_utf8(fast_armor_cc),",
            "fast_cc)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "ast_armor_cc)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"fast-armor-cc\"))"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "fast-armor-cc\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_init_creds_init\")"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_creds_init(",
          "args": [
            "dc_context,",
            "lient,",
            "ULL,",
            "ULL,",
            ",",
            "pt,",
            "ctx)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_get_init_creds_opt_set_pkinit\")"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_opt_set_pkinit(",
          "args": [
            "dc_context,",
            "pt,",
            "lient,",
            "eim_string_get_utf8(pk_user_id),",
            "ULL,",
            "ULL,",
            "ULL,",
            "se_rsa ? 2 : 0,",
            "ULL,",
            "ULL,",
            "ULL)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "k_user_id)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_bool_val(",
          "args": [
            "saobj)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"pkinit-use-rsa\"))"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "pkinit-use-rsa\")"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_get_init_creds_opt_alloc\")"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_opt_alloc",
          "args": [
            "dc_context,",
            "opt)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_unparse_name\")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_parse_name(",
          "args": [
            "dc_context,",
            "eim_string_get_utf8(user),",
            "client)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_string_get_utf8(",
          "args": [
            "ser)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"ccache\"))"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "ccache\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "dc_context,",
            ",",
            "password, keytab, nor PKINIT user cert ID\")"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"pkinit-user-cert-id\"))"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "pkinit-user-cert-id\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"keytab\"))"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "keytab\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"password\"))"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "password\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "dc_context,",
            ",",
            "no client\")"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"client\"))"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "client\")"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\ntatic krb5_context kdc_context;\n\ntatic void\neval_kinit(heim_dict_t o)\n{\n    heim_string_t user, password, keytab, fast_armor_cc, pk_user_id, ccache;\n    krb5_get_init_creds_opt *opt;\n    krb5_init_creds_context ctx;\n    krb5_principal client;\n    krb5_keytab ktmem = NULL;\n    krb5_ccache fast_cc = NULL;\n    krb5_error_code ret;\n\n    if (ptop)\n\tptop->as_req++;\n\n    user = heim_dict_get_value(o, HSTR(\"client\"));\n    if (user == NULL)\n\tkrb5_errx(kdc_context, 1, \"no client\");\n\n    password = heim_dict_get_value(o, HSTR(\"password\"));\n    keytab = heim_dict_get_value(o, HSTR(\"keytab\"));\n    pk_user_id = heim_dict_get_value(o, HSTR(\"pkinit-user-cert-id\"));\n    if (password == NULL && keytab == NULL && pk_user_id == NULL)\n\tkrb5_errx(kdc_context, 1, \"password, keytab, nor PKINIT user cert ID\");\n\n    ccache = heim_dict_get_value(o, HSTR(\"ccache\"));\n\n    ret = krb5_parse_name(kdc_context, heim_string_get_utf8(user), &client);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_unparse_name\");\n\n    /* PKINIT parts */\n    ret = krb5_get_init_creds_opt_alloc (kdc_context, &opt);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n\n    if (pk_user_id) {\n\theim_bool_t rsaobj = heim_dict_get_value(o, HSTR(\"pkinit-use-rsa\"));\n\tint use_rsa = rsaobj ? heim_bool_val(rsaobj) : 0;\n\n\tret = krb5_get_init_creds_opt_set_pkinit(kdc_context, opt,\n\t\t\t\t\t\t client,\n\t\t\t\t\t\t heim_string_get_utf8(pk_user_id),\n\t\t\t\t\t\t NULL, NULL, NULL,\n\t\t\t\t\t\t use_rsa ? 2 : 0,\n\t\t\t\t\t\t NULL, NULL, NULL);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_get_init_creds_opt_set_pkinit\");\n    }\n\n    ret = krb5_init_creds_init(kdc_context, client, NULL, NULL, 0, opt, &ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_init\");\n\n    fast_armor_cc = heim_dict_get_value(o, HSTR(\"fast-armor-cc\"));\n    if (fast_armor_cc) {\n\n\tret = krb5_cc_resolve(kdc_context, heim_string_get_utf8(fast_armor_cc), &fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tret = krb5_init_creds_set_fast_ccache(kdc_context, ctx, fast_cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_fast_ccache\");\n    }\n    \n    if (password) {\n\tret = krb5_init_creds_set_password(kdc_context, ctx, \n\t\t\t\t\t   heim_string_get_utf8(password));\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_password\");\n    }\n    if (keytab) {\n\tkrb5_keytab kt = NULL;\n\n\tret = krb5_kt_resolve(kdc_context, heim_string_get_utf8(keytab), &kt);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve\");\n\n\tret = krb5_kt_resolve(kdc_context, \"MEMORY:keytab\", &ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_kt_resolve(MEMORY)\");\n\n\tret = copy_keytab(kdc_context, kt, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"copy_keytab\");\n\n\tkrb5_kt_close(kdc_context, kt);\n\n\tret = krb5_init_creds_set_keytab(kdc_context, ctx, ktmem);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_set_keytab\");\n    }\n\n    ret = krb5_init_creds_get(kdc_context, ctx);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_init_creds_get\");\n\n    if (ccache) {\n\tconst char *name = heim_string_get_utf8(ccache);\n\tkrb5_creds cred;\n\tkrb5_ccache cc;\n\n\tret = krb5_init_creds_get_creds(kdc_context, ctx, &cred);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_init_creds_get_creds\");\n\n\tret = krb5_cc_resolve(kdc_context, name, &cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_resolve\");\n\n\tkrb5_init_creds_store(kdc_context, ctx, cc);\n\n\tret = krb5_cc_close(kdc_context, cc);\n\tif (ret)\n\t    krb5_err(kdc_context, 1, ret, \"krb5_cc_close\");\n\n\tkrb5_free_cred_contents(kdc_context, &cred);\n    }\n\n    krb5_init_creds_free(kdc_context, ctx);\n\n    if (ktmem)\n\tkrb5_kt_close(kdc_context, ktmem);\n    if (fast_cc)\n\tkrb5_cc_close(kdc_context, fast_cc);\n}"
  },
  {
    "function_name": "opy_keytab(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "188-203",
    "snippet": "tatic krb5_error_code\ncopy_keytab(krb5_context context, krb5_keytab from, krb5_keytab to)\n{\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code ret;\n\n    ret = krb5_kt_start_seq_get(context, from, &cursor);\n    if (ret)\n\treturn ret;\n    while((ret = krb5_kt_next_entry(context, from, &entry, &cursor)) == 0){\n\tkrb5_kt_add_entry(context, to, &entry);\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    return krb5_kt_end_seq_get(context, from, &cursor);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_kt_end_seq_get(",
          "args": [
            "ontext,",
            "rom,",
            "cursor)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_free_entry(",
          "args": [
            "ontext,",
            "entry)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_add_entry(",
          "args": [
            "ontext,",
            "o,",
            "entry)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_next_entry(",
          "args": [
            "ontext,",
            "rom,",
            "entry,",
            "cursor)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_start_seq_get(",
          "args": [
            "ontext,",
            "rom,",
            "cursor)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\ncopy_keytab(krb5_context context, krb5_keytab from, krb5_keytab to)\n{\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code ret;\n\n    ret = krb5_kt_start_seq_get(context, from, &cursor);\n    if (ret)\n\treturn ret;\n    while((ret = krb5_kt_next_entry(context, from, &entry, &cursor)) == 0){\n\tkrb5_kt_add_entry(context, to, &entry);\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    return krb5_kt_end_seq_get(context, from, &cursor);\n}"
  },
  {
    "function_name": "val_repeat(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "162-182",
    "snippet": "tatic void\neval_repeat(heim_dict_t o)\n{\n    heim_object_t or = heim_dict_get_value(o, HSTR(\"value\"));\n    heim_number_t n = heim_dict_get_value(o, HSTR(\"num\"));\n    int i, num;\n    struct perf perf;\n\n    perf_start(&perf);\n\n    heim_assert(or != NULL, \"value missing\");\n    heim_assert(n != NULL, \"num missing\");\n\n    num = heim_number_get_int(n);\n    heim_assert(num >= 0, \"num >= 0\");\n\n    for (i = 0; i < num; i++)\n\teval_object(or);\n\n    perf_stop(&perf);\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic void eval_object(heim_object_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "erf_stop(",
          "args": [
            "perf)"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "erf_stop(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "127-156",
          "snippet": "tatic void\nperf_stop(struct perf *perf)\n{\n    gettimeofday(&perf->stop, NULL);\n    ptop = perf->next;\n\n    if (ptop) {\n\tptop->as_req += perf->as_req;\n\tptop->tgs_req += perf->tgs_req;\n    }\n\n    timevalsub(&perf->stop, &perf->start);\n    printf(\"time: %lu.%06lu\\n\",\n\t   (unsigned long)perf->stop.tv_sec,\n\t   (unsigned long)perf->stop.tv_usec);\n\n#define USEC_PER_SEC 1000000\n\n    if (perf->as_req) {\n\tdouble as_ps = 0.0;\n\tas_ps = (perf->as_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"as-req/s %.2lf  (total %lu requests)\\n\", as_ps, perf->as_req);\n    }\n\t    \n    if (perf->tgs_req) {\n\tdouble tgs_ps = 0.0;\n\ttgs_ps = (perf->tgs_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"tgs-req/s %.2lf (total %lu requests)\\n\", tgs_ps, perf->tgs_req);\n    }\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\n\ntatic void\nperf_stop(struct perf *perf)\n{\n    gettimeofday(&perf->stop, NULL);\n    ptop = perf->next;\n\n    if (ptop) {\n\tptop->as_req += perf->as_req;\n\tptop->tgs_req += perf->tgs_req;\n    }\n\n    timevalsub(&perf->stop, &perf->start);\n    printf(\"time: %lu.%06lu\\n\",\n\t   (unsigned long)perf->stop.tv_sec,\n\t   (unsigned long)perf->stop.tv_usec);\n\n#define USEC_PER_SEC 1000000\n\n    if (perf->as_req) {\n\tdouble as_ps = 0.0;\n\tas_ps = (perf->as_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"as-req/s %.2lf  (total %lu requests)\\n\", as_ps, perf->as_req);\n    }\n\t    \n    if (perf->tgs_req) {\n\tdouble tgs_ps = 0.0;\n\ttgs_ps = (perf->tgs_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"tgs-req/s %.2lf (total %lu requests)\\n\", tgs_ps, perf->tgs_req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "val_object(",
          "args": [
            "r)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "val_object(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "426-452",
          "snippet": "tatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic void eval_object(heim_object_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_object(heim_object_t o)\n{\n    heim_tid_t t = heim_get_tid(o);\n\n    if (t == heim_array_get_type_id()) {\n\theim_array_iterate_f(o, NULL, eval_array_element);\n    } else if (t == heim_dict_get_type_id()) {\n\tconst char *op = heim_dict_get_value(o, HSTR(\"op\"));\n\n\theim_assert(op != NULL, \"op missing\");\n\n\tif (strcmp(op, \"repeat\") == 0) {\n\t    eval_repeat(o);\n\t} else if (strcmp(op, \"kinit\") == 0) {\n\t    eval_kinit(o);\n\t} else if (strcmp(op, \"kgetcred\") == 0) {\n\t    eval_kgetcred(o);\n\t} else if (strcmp(op, \"kdestroy\") == 0) {\n\t    eval_kdestroy(o);\n\t} else {\n\t    errx(1, \"unsupported ops %s\", op);\n\t}\n\n    } else\n\terrx(1, \"unsupported\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "um >= 0,",
            "num >= 0\")"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_number_get_int(",
          "args": [
            ")"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "!= NULL,",
            "num missing\")"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "r != NULL,",
            "value missing\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erf_start(",
          "args": [
            "perf)"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "erf_start(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
          "lines": "117-125",
          "snippet": "tatic void\nperf_start(struct perf *perf)\n{\n    memset(perf, 0, sizeof(*perf));\n\n    gettimeofday(&perf->start, NULL);\n    perf->next = ptop;\n    ptop = perf;\n}",
          "includes": [
            "include \"send_to_kdc_plugin.h\"",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\n\ntatic void\nperf_start(struct perf *perf)\n{\n    memset(perf, 0, sizeof(*perf));\n\n    gettimeofday(&perf->start, NULL);\n    perf->next = ptop;\n    ptop = perf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"num\"))"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "num\")"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_dict_get_value(",
          "args": [
            ",",
            "STR(\"value\"))"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STR(",
          "args": [
            "value\")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void eval_object(heim_object_t);\n\ntatic void\neval_repeat(heim_dict_t o)\n{\n    heim_object_t or = heim_dict_get_value(o, HSTR(\"value\"));\n    heim_number_t n = heim_dict_get_value(o, HSTR(\"num\"));\n    int i, num;\n    struct perf perf;\n\n    perf_start(&perf);\n\n    heim_assert(or != NULL, \"value missing\");\n    heim_assert(n != NULL, \"num missing\");\n\n    num = heim_number_get_int(n);\n    heim_assert(num >= 0, \"num >= 0\");\n\n    for (i = 0; i < num; i++)\n\teval_object(or);\n\n    perf_stop(&perf);\n}"
  },
  {
    "function_name": "erf_stop(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "127-156",
    "snippet": "tatic void\nperf_stop(struct perf *perf)\n{\n    gettimeofday(&perf->stop, NULL);\n    ptop = perf->next;\n\n    if (ptop) {\n\tptop->as_req += perf->as_req;\n\tptop->tgs_req += perf->tgs_req;\n    }\n\n    timevalsub(&perf->stop, &perf->start);\n    printf(\"time: %lu.%06lu\\n\",\n\t   (unsigned long)perf->stop.tv_sec,\n\t   (unsigned long)perf->stop.tv_usec);\n\n#define USEC_PER_SEC 1000000\n\n    if (perf->as_req) {\n\tdouble as_ps = 0.0;\n\tas_ps = (perf->as_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"as-req/s %.2lf  (total %lu requests)\\n\", as_ps, perf->as_req);\n    }\n\t    \n    if (perf->tgs_req) {\n\tdouble tgs_ps = 0.0;\n\ttgs_ps = (perf->tgs_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"tgs-req/s %.2lf (total %lu requests)\\n\", tgs_ps, perf->tgs_req);\n    }\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "tgs-req/s %.2lf (total %lu requests)\\n\",",
            "gs_ps,",
            "erf->tgs_req)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "as-req/s %.2lf  (total %lu requests)\\n\",",
            "s_ps,",
            "erf->as_req)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintf(",
          "args": [
            "time: %lu.%06lu\\n\",",
            "unsigned long)perf->stop.tv_sec,",
            "unsigned long)perf->stop.tv_usec)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imevalsub(",
          "args": [
            "perf->stop,",
            "perf->start)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "perf->stop,",
            "ULL)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\n\ntatic void\nperf_stop(struct perf *perf)\n{\n    gettimeofday(&perf->stop, NULL);\n    ptop = perf->next;\n\n    if (ptop) {\n\tptop->as_req += perf->as_req;\n\tptop->tgs_req += perf->tgs_req;\n    }\n\n    timevalsub(&perf->stop, &perf->start);\n    printf(\"time: %lu.%06lu\\n\",\n\t   (unsigned long)perf->stop.tv_sec,\n\t   (unsigned long)perf->stop.tv_usec);\n\n#define USEC_PER_SEC 1000000\n\n    if (perf->as_req) {\n\tdouble as_ps = 0.0;\n\tas_ps = (perf->as_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"as-req/s %.2lf  (total %lu requests)\\n\", as_ps, perf->as_req);\n    }\n\t    \n    if (perf->tgs_req) {\n\tdouble tgs_ps = 0.0;\n\ttgs_ps = (perf->tgs_req * USEC_PER_SEC) / (double)((perf->stop.tv_sec * USEC_PER_SEC) + perf->stop.tv_usec);\n\tprintf(\"tgs-req/s %.2lf (total %lu requests)\\n\", tgs_ps, perf->tgs_req);\n    }\n}"
  },
  {
    "function_name": "erf_start(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "117-125",
    "snippet": "tatic void\nperf_start(struct perf *perf)\n{\n    memset(perf, 0, sizeof(*perf));\n\n    gettimeofday(&perf->start, NULL);\n    perf->next = ptop;\n    ptop = perf;\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "truct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ettimeofday(",
          "args": [
            "perf->start,",
            "ULL)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "erf,",
            ",",
            "izeof(*perf))"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntruct perf {\n    unsigned long as_req;\n    unsigned long tgs_req;\n    struct timeval start;\n    struct timeval stop;\n    struct perf *next;\n} *ptop;\n\ntatic void\nperf_start(struct perf *perf)\n{\n    memset(perf, 0, sizeof(*perf));\n\n    gettimeofday(&perf->start, NULL);\n    perf->next = ptop;\n    ptop = perf;\n}"
  },
  {
    "function_name": "lugin_send_to_realm(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "87-107",
    "snippet": "tatic krb5_error_code\nplugin_send_to_realm(krb5_context context,\n\t\t     void *ctx,\n\t\t     krb5_const_realm realm,\n\t\t     time_t timeout,\n\t\t     const krb5_data *in,\n\t\t     krb5_data *out)\n{\n    int ret;\n\n    krb5_kdc_update_time(NULL);\n\n    ret = krb5_kdc_process_request(kdc_context, kdc_config,\n\t\t\t\t   in->data, in->length,\n\t\t\t\t   out, NULL, astr,\n\t\t\t\t   (struct sockaddr *)&sa, 0);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_kdc_process_request\");\n\n    return 0;\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic krb5_kdc_configuration *kdc_config;",
      "tatic krb5_context kdc_context;",
      "tatic struct sockaddr_storage sa;",
      "tatic const char *astr = \"0.0.0.0\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "dc_context,",
            ",",
            "et,",
            "krb5_kdc_process_request\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kdc_process_request(",
          "args": [
            "dc_context,",
            "dc_config,",
            "n->data,",
            "n->length,",
            "ut,",
            "ULL,",
            "str,",
            "struct sockaddr *)&sa,",
            ")"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_process_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "187-223",
          "snippet": "nt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic struct krb5_kdc_service services[] =  {\n    { KS_KRB5,\t\tkdc_as_req },\n    { KS_KRB5,\t\tkdc_tgs_req },\n#ifdef DIGEST\n    { 0,\t\tkdc_digest },\n#endif\n#ifdef KX509\n    { 0,\t\tkdc_kx509 },\n#endif\n    { 0, NULL }\n};\n\nnt\nkrb5_kdc_process_request(krb5_context context,\n\t\t\t krb5_kdc_configuration *config,\n\t\t\t unsigned char *buf,\n\t\t\t size_t len,\n\t\t\t krb5_data *reply,\n\t\t\t krb5_boolean *prependlength,\n\t\t\t const char *from,\n\t\t\t struct sockaddr *addr,\n\t\t\t int datagram_reply)\n{\n    krb5_error_code ret;\n    unsigned int i;\n    krb5_data req_buffer;\n    int claim = 0;\n    heim_auto_release_t pool = heim_auto_release_create();\n\n    req_buffer.data = buf;\n    req_buffer.length = len;\n\n    for (i = 0; services[i].process != NULL; i++) {\n\tret = (*services[i].process)(context, config, &req_buffer,\n\t\t\t\t     reply, from, addr, datagram_reply,\n\t\t\t\t     &claim);\n\tif (claim) {\n\t    if (services[i].flags & KS_NO_LENGTH)\n\t\t*prependlength = 0;\n\n\t    heim_release(pool);\n\t    return ret;\n\t}\n    }\n\n    heim_release(pool);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_kdc_update_time(",
          "args": [
            "ULL)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "rb5_kdc_update_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/process.c",
          "lines": "41-48",
          "snippet": "oid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkrb5_kdc_update_time(struct timeval *tv)\n{\n    if (tv == NULL)\n\tgettimeofday(&_kdc_now, NULL);\n    else\n\t_kdc_now = *tv;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_kdc_configuration *kdc_config;\ntatic krb5_context kdc_context;\ntatic struct sockaddr_storage sa;\ntatic const char *astr = \"0.0.0.0\";\n\ntatic krb5_error_code\nplugin_send_to_realm(krb5_context context,\n\t\t     void *ctx,\n\t\t     krb5_const_realm realm,\n\t\t     time_t timeout,\n\t\t     const krb5_data *in,\n\t\t     krb5_data *out)\n{\n    int ret;\n\n    krb5_kdc_update_time(NULL);\n\n    ret = krb5_kdc_process_request(kdc_context, kdc_config,\n\t\t\t\t   in->data, in->length,\n\t\t\t\t   out, NULL, astr,\n\t\t\t\t   (struct sockaddr *)&sa, 0);\n    if (ret)\n\tkrb5_err(kdc_context, 1, ret, \"krb5_kdc_process_request\");\n\n    return 0;\n}"
  },
  {
    "function_name": "lugin_send_to_kdc(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "76-85",
    "snippet": "tatic krb5_error_code\nplugin_send_to_kdc(krb5_context context,\n\t\t   void *ctx,\n\t\t   krb5_krbhst_info *ho,\n\t\t   time_t timeout,\n\t\t   const krb5_data *in,\n\t\t   krb5_data *out)\n{\n    return KRB5_PLUGIN_NO_HANDLE;\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nplugin_send_to_kdc(krb5_context context,\n\t\t   void *ctx,\n\t\t   krb5_krbhst_info *ho,\n\t\t   time_t timeout,\n\t\t   const krb5_data *in,\n\t\t   krb5_data *out)\n{\n    return KRB5_PLUGIN_NO_HANDLE;\n}"
  },
  {
    "function_name": "lugin_fini(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "71-74",
    "snippet": "tatic void\nplugin_fini(void *ctx)\n{\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic void\nplugin_fini(void *ctx)\n{\n}"
  },
  {
    "function_name": "lugin_init(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-tester.c",
    "lines": "64-69",
    "snippet": "tatic krb5_error_code\nplugin_init(krb5_context context, void **pctx)\n{\n    *pctx = NULL;\n    return 0;\n}",
    "includes": [
      "include \"send_to_kdc_plugin.h\"",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"send_to_kdc_plugin.h\"\ninclude \"kdc_locl.h\"\n#\n\ntatic krb5_error_code\nplugin_init(krb5_context context, void **pctx)\n{\n    *pctx = NULL;\n    return 0;\n}"
  }
]