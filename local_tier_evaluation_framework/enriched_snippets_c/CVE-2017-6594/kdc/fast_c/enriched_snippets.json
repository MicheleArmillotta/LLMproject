[
  {
    "function_name": "kdc_fast_unwrap_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "346-560",
    "snippet": "rb5_error_code\n_kdc_fast_unwrap_request(kdc_request_t r)\n{\n    krb5_principal armor_server = NULL;\n    hdb_entry_ex *armor_user = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_auth_context ac = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_flags ap_req_options;\n    Key *armor_key = NULL;\n    krb5_keyblock armorkey;\n    krb5_error_code ret;\n    krb5_ap_req ap_req;\n    unsigned char *buf = NULL;\n    KrbFastReq fastreq;\n    size_t len, size;\n    krb5_data data;\n    const PA_DATA *pa;\n    int i = 0;\n\n    /*\n     * First look for FX_COOKIE and and process it\n     */\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_COOKIE);\n    if (pa) {\n\tret = fast_parse_cookie(r, pa);\n\tif (ret)\n\t    goto out;\n    }\n\t\t\t  \n    i = 0;\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_FAST);\n    if (pa == NULL)\n\treturn 0;\n\n    ret = decode_PA_FX_FAST_REQUEST(pa->padata_value.data,\n\t\t\t\t    pa->padata_value.length,\n\t\t\t\t    &fxreq,\n\t\t\t\t    &len);\n    if (ret)\n\tgoto out;\n    if (len != pa->padata_value.length) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.element != choice_PA_FX_FAST_REQUEST_armored_data) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ FAST contain unknown type: %d\", (int)fxreq.element);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* pull out armor key */\n    if (fxreq.u.armored_data.armor == NULL) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.u.armored_data.armor->armor_type != 1) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor type not ap-req\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\t    \n    ret = krb5_decode_ap_req(r->context,\n\t\t\t     &fxreq.u.armored_data.armor->armor_value,\n\t\t\t     &ap_req);\n    if(ret) {\n\tkdc_log(r->context, r->config, 0, \"AP-REQ decode failed\");\n\tgoto out;\n    }\n\n    /* Save that principal that was in the request */\n    ret = _krb5_principalname2krb5_principal(r->context,\n\t\t\t\t\t     &armor_server,\n\t\t\t\t\t     ap_req.ticket.sname,\n\t\t\t\t\t     ap_req.ticket.realm);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(r->context, r->config, armor_server,\n\t\t\tHDB_F_GET_SERVER, NULL, NULL, &armor_user);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(r->context, r->config, 5,\n\t\t\"armor key does not have secrets at this KDC, \"\n\t\t\"need to proxy\");\n\tgoto out;\n    } else if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    ret = hdb_enctype2key(r->context, &armor_user->entry, NULL,\n\t\t\t  ap_req.ticket.enc_part.etype,\n\t\t\t  &armor_key);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = krb5_verify_ap_req2(r->context, &ac, \n\t\t\t      &ap_req,\n\t\t\t      armor_server,\n\t\t\t      &armor_key->key,\n\t\t\t      0,\n\t\t\t      &ap_req_options,\n\t\t\t      &ticket, \n\t\t\t      KRB5_KU_AP_REQ_AUTH);\n    free_AP_REQ(&ap_req);\n    if (ret)\n\tgoto out;\n\n    if (ac->remote_subkey == NULL) {\n\tkrb5_auth_con_free(r->context, ac);\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST AP-REQ remote subkey missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n\n    ret = _krb5_fast_armor_key(r->context,\n\t\t\t       ac->remote_subkey,\n\t\t\t       &ticket->ticket.key,\n\t\t\t       &armorkey,\n\t\t\t       &r->armor_crypto);\n    krb5_auth_con_free(r->context, ac);\n    krb5_free_ticket(r->context, ticket);\n    if (ret)\n\tgoto out;\n\n    krb5_free_keyblock_contents(r->context, &armorkey);\n\n    /* verify req-checksum of the outer body */\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &r->req.req_body, &size, ret);\n    if (ret)\n\tgoto out;\n    if (size != len) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    ret = krb5_verify_checksum(r->context, r->armor_crypto,\n\t\t\t       KRB5_KU_FAST_REQ_CHKSUM,\n\t\t\t       buf, len, \n\t\t\t       &fxreq.u.armored_data.req_checksum);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST request have a bad checksum\");\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(r->context, r->armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_ENC,\n\t\t\t\t     &fxreq.u.armored_data.enc_fast_req,\n\t\t\t\t     &data);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"Failed to decrypt FAST request\");\n\tgoto out;\n    }\n\n    ret = decode_KrbFastReq(data.data, data.length, &fastreq, &size);\n    if (ret) {\n\tkrb5_data_free(&data);\n\tgoto out;\n    }\n    if (data.length != size) {\n\tkrb5_data_free(&data);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n    krb5_data_free(&data);\n\n    free_KDC_REQ_BODY(&r->req.req_body);\n    ret = copy_KDC_REQ_BODY(&fastreq.req_body, &r->req.req_body);\n    if (ret)\n\tgoto out;\n\t    \n    /* check for unsupported mandatory options */\n    if (FastOptions2int(fastreq.fast_options) & 0xfffc) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST unsupported mandatory option set\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* KDC MUST ignore outer pa data preauth-14 - 6.5.5 */\n    if (r->req.padata)\n\tfree_METHOD_DATA(r->req.padata);\n    else\n\tALLOC(r->req.padata);\n\n    ret = copy_METHOD_DATA(&fastreq.padata, r->req.padata);\n    if (ret)\n\tgoto out;\n\n    free_KrbFastReq(&fastreq);\n    free_PA_FX_FAST_REQUEST(&fxreq);\n\n out:\n    if (armor_server)\n\tkrb5_free_principal(r->context, armor_server);\n    if(armor_user)\n\t_kdc_free_ent(r->context, armor_user);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_free_ent(",
          "args": [
            "->context,",
            "rmor_user)"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "->context,",
            "rmor_server)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_FX_FAST_REQUEST(",
          "args": [
            "fxreq)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KrbFastReq(",
          "args": [
            "fastreq)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_METHOD_DATA(",
          "args": [
            "fastreq.padata,",
            "->req.padata)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "->req.padata)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "->req.padata)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "->context,",
            "->config,",
            ",",
            "FAST unsupported mandatory option set\")"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "astOptions2int(",
          "args": [
            "astreq.fast_options)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_KDC_REQ_BODY(",
          "args": [
            "fastreq.req_body,",
            "r->req.req_body)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KDC_REQ_BODY(",
          "args": [
            "r->req.req_body)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_KrbFastReq(",
          "args": [
            "ata.data,",
            "ata.length,",
            "fastreq,",
            "size)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData(",
          "args": [
            "->context,",
            "->armor_crypto,",
            "RB5_KU_FAST_ENC,",
            "fxreq.u.armored_data.enc_fast_req,",
            "data)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_checksum(",
          "args": [
            "->context,",
            "->armor_crypto,",
            "RB5_KU_FAST_REQ_CHKSUM,",
            "uf,",
            "en,",
            "fxreq.u.armored_data.req_checksum)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "DC_REQ_BODY,",
            "uf,",
            "en,",
            "r->req.req_body,",
            "size,",
            "et)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "->context,",
            "armorkey)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_ticket(",
          "args": [
            "->context,",
            "icket)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "->context,",
            "c)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_fast_armor_key(",
          "args": [
            "->context,",
            "c->remote_subkey,",
            "ticket->ticket.key,",
            "armorkey,",
            "r->armor_crypto)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "->context,",
            "c)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AP_REQ(",
          "args": [
            "ap_req)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_ap_req2(",
          "args": [
            "->context,",
            "ac,",
            "ap_req,",
            "rmor_server,",
            "armor_key->key,",
            ",",
            "ap_req_options,",
            "ticket,",
            "RB5_KU_AP_REQ_AUTH)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AP_REQ(",
          "args": [
            "ap_req)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "->context,",
            "armor_user->entry,",
            "ULL,",
            "p_req.ticket.enc_part.etype,",
            "armor_key)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AP_REQ(",
          "args": [
            "ap_req)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "->context,",
            "->config,",
            "rmor_server,",
            "DB_F_GET_SERVER,",
            "ULL,",
            "ULL,",
            "armor_user)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_AP_REQ(",
          "args": [
            "ap_req)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "->context,",
            "armor_server,",
            "p_req.ticket.sname,",
            "p_req.ticket.realm)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decode_ap_req(",
          "args": [
            "->context,",
            "fxreq.u.armored_data.armor->armor_value,",
            "ap_req)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_FX_FAST_REQUEST(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "fxreq,",
            "len)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "r->req,",
            "i,",
            "RB5_PADATA_FX_FAST)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ast_parse_cookie(",
          "args": [
            ",",
            "a)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "ast_parse_cookie(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "81-127",
          "snippet": "tatic krb5_error_code\nfast_parse_cookie(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_crypto crypto = NULL;\n    krb5_error_code ret;\n    KDCFastCookie data;\n    krb5_data d1;\n    size_t len;\n\n    ret = decode_KDCFastCookie(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &data, &len);\n    if (ret)\n\treturn ret;\n\n    if (len != pa->padata_value.length || strcmp(\"H5L1\", data.version) != 0) {\n\tfree_KDCFastCookie(&data);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    ret = get_fastuser_crypto(r, data.cookie.etype, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_decrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     &data.cookie, &d1);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n\n    ret = decode_KDCFastState(d1.data, d1.length, &r->fast, &len);\n    krb5_data_free(&d1);\n    if (ret)\n\tgoto out;\n\n    if (r->fast.expiration < kdc_time) {\n\tkdc_log(r->context, r->config, 0, \"fast cookie expired\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n out:\n    free_KDCFastCookie(&data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfast_parse_cookie(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_crypto crypto = NULL;\n    krb5_error_code ret;\n    KDCFastCookie data;\n    krb5_data d1;\n    size_t len;\n\n    ret = decode_KDCFastCookie(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &data, &len);\n    if (ret)\n\treturn ret;\n\n    if (len != pa->padata_value.length || strcmp(\"H5L1\", data.version) != 0) {\n\tfree_KDCFastCookie(&data);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    ret = get_fastuser_crypto(r, data.cookie.etype, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_decrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     &data.cookie, &d1);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n\n    ret = decode_KDCFastState(d1.data, d1.length, &r->fast, &len);\n    krb5_data_free(&d1);\n    if (ret)\n\tgoto out;\n\n    if (r->fast.expiration < kdc_time) {\n\tkdc_log(r->context, r->config, 0, \"fast cookie expired\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n out:\n    free_KDCFastCookie(&data);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_unwrap_request(kdc_request_t r)\n{\n    krb5_principal armor_server = NULL;\n    hdb_entry_ex *armor_user = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_auth_context ac = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_flags ap_req_options;\n    Key *armor_key = NULL;\n    krb5_keyblock armorkey;\n    krb5_error_code ret;\n    krb5_ap_req ap_req;\n    unsigned char *buf = NULL;\n    KrbFastReq fastreq;\n    size_t len, size;\n    krb5_data data;\n    const PA_DATA *pa;\n    int i = 0;\n\n    /*\n     * First look for FX_COOKIE and and process it\n     */\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_COOKIE);\n    if (pa) {\n\tret = fast_parse_cookie(r, pa);\n\tif (ret)\n\t    goto out;\n    }\n\t\t\t  \n    i = 0;\n    pa = _kdc_find_padata(&r->req, &i, KRB5_PADATA_FX_FAST);\n    if (pa == NULL)\n\treturn 0;\n\n    ret = decode_PA_FX_FAST_REQUEST(pa->padata_value.data,\n\t\t\t\t    pa->padata_value.length,\n\t\t\t\t    &fxreq,\n\t\t\t\t    &len);\n    if (ret)\n\tgoto out;\n    if (len != pa->padata_value.length) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.element != choice_PA_FX_FAST_REQUEST_armored_data) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ FAST contain unknown type: %d\", (int)fxreq.element);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* pull out armor key */\n    if (fxreq.u.armored_data.armor == NULL) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    if (fxreq.u.armored_data.armor->armor_type != 1) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"AS-REQ armor type not ap-req\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\t    \n    ret = krb5_decode_ap_req(r->context,\n\t\t\t     &fxreq.u.armored_data.armor->armor_value,\n\t\t\t     &ap_req);\n    if(ret) {\n\tkdc_log(r->context, r->config, 0, \"AP-REQ decode failed\");\n\tgoto out;\n    }\n\n    /* Save that principal that was in the request */\n    ret = _krb5_principalname2krb5_principal(r->context,\n\t\t\t\t\t     &armor_server,\n\t\t\t\t\t     ap_req.ticket.sname,\n\t\t\t\t\t     ap_req.ticket.realm);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(r->context, r->config, armor_server,\n\t\t\tHDB_F_GET_SERVER, NULL, NULL, &armor_user);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(r->context, r->config, 5,\n\t\t\"armor key does not have secrets at this KDC, \"\n\t\t\"need to proxy\");\n\tgoto out;\n    } else if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    ret = hdb_enctype2key(r->context, &armor_user->entry, NULL,\n\t\t\t  ap_req.ticket.enc_part.etype,\n\t\t\t  &armor_key);\n    if (ret) {\n\tfree_AP_REQ(&ap_req);\n\tgoto out;\n    }\n\n    ret = krb5_verify_ap_req2(r->context, &ac, \n\t\t\t      &ap_req,\n\t\t\t      armor_server,\n\t\t\t      &armor_key->key,\n\t\t\t      0,\n\t\t\t      &ap_req_options,\n\t\t\t      &ticket, \n\t\t\t      KRB5_KU_AP_REQ_AUTH);\n    free_AP_REQ(&ap_req);\n    if (ret)\n\tgoto out;\n\n    if (ac->remote_subkey == NULL) {\n\tkrb5_auth_con_free(r->context, ac);\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST AP-REQ remote subkey missing\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n\n    ret = _krb5_fast_armor_key(r->context,\n\t\t\t       ac->remote_subkey,\n\t\t\t       &ticket->ticket.key,\n\t\t\t       &armorkey,\n\t\t\t       &r->armor_crypto);\n    krb5_auth_con_free(r->context, ac);\n    krb5_free_ticket(r->context, ticket);\n    if (ret)\n\tgoto out;\n\n    krb5_free_keyblock_contents(r->context, &armorkey);\n\n    /* verify req-checksum of the outer body */\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &r->req.req_body, &size, ret);\n    if (ret)\n\tgoto out;\n    if (size != len) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    ret = krb5_verify_checksum(r->context, r->armor_crypto,\n\t\t\t       KRB5_KU_FAST_REQ_CHKSUM,\n\t\t\t       buf, len, \n\t\t\t       &fxreq.u.armored_data.req_checksum);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST request have a bad checksum\");\n\tgoto out;\n    }\n\n    ret = krb5_decrypt_EncryptedData(r->context, r->armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_ENC,\n\t\t\t\t     &fxreq.u.armored_data.enc_fast_req,\n\t\t\t\t     &data);\n    if (ret) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"Failed to decrypt FAST request\");\n\tgoto out;\n    }\n\n    ret = decode_KrbFastReq(data.data, data.length, &fastreq, &size);\n    if (ret) {\n\tkrb5_data_free(&data);\n\tgoto out;\n    }\n    if (data.length != size) {\n\tkrb5_data_free(&data);\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\t\t\n    krb5_data_free(&data);\n\n    free_KDC_REQ_BODY(&r->req.req_body);\n    ret = copy_KDC_REQ_BODY(&fastreq.req_body, &r->req.req_body);\n    if (ret)\n\tgoto out;\n\t    \n    /* check for unsupported mandatory options */\n    if (FastOptions2int(fastreq.fast_options) & 0xfffc) {\n\tkdc_log(r->context, r->config, 0,\n\t\t\"FAST unsupported mandatory option set\");\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    /* KDC MUST ignore outer pa data preauth-14 - 6.5.5 */\n    if (r->req.padata)\n\tfree_METHOD_DATA(r->req.padata);\n    else\n\tALLOC(r->req.padata);\n\n    ret = copy_METHOD_DATA(&fastreq.padata, r->req.padata);\n    if (ret)\n\tgoto out;\n\n    free_KrbFastReq(&fastreq);\n    free_PA_FX_FAST_REQUEST(&fxreq);\n\n out:\n    if (armor_server)\n\tkrb5_free_principal(r->context, armor_server);\n    if(armor_user)\n\t_kdc_free_ent(r->context, armor_user);\n\n    return ret;\n}"
  },
  {
    "function_name": "kdc_fast_mk_error(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "239-344",
    "snippet": "rb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "e_data)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_mk_error_ext(",
          "args": [
            "ontext,",
            "uter_error,",
            "_text,",
            "e_data.length ? &e_data : NULL),",
            "rror_server,",
            "rror_client_name,",
            "rror_client_realm,",
            "sec,",
            "usec,",
            "rror_msg)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 error\")"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ETHOD_DATA,",
            "_data.data,",
            "_data.length,",
            "rror_method,",
            "size,",
            "et)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "rror_method,",
            "RB5_PADATA_FX_FAST,",
            "_data.data,",
            "_data.length)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "rror_method)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fast_mk_response(",
          "args": [
            "ontext,",
            "rmor_crypto,",
            "rror_method,",
            "ULL,",
            "ULL,",
            "eq_body->nonce,",
            "e_data)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fast_mk_response(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "180-236",
          "snippet": "rb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "rror_method)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "->context,",
            "->config,",
            ",",
            "failed to add fast cookie with: %d\",",
            "et)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "rror_method,",
            "RB5_PADATA_FX_COOKIE,",
            "ULL,",
            ")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ast_add_cookie(",
          "args": [
            ",",
            "rror_method)"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ast_add_cookie(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "129-178",
          "snippet": "tatic krb5_error_code\nfast_add_cookie(kdc_request_t r, METHOD_DATA *method_data)\n{\n    krb5_crypto crypto = NULL;\n    KDCFastCookie shell;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size;\n\n    memset(&shell, 0, sizeof(shell));\n\n    r->fast.expiration = kdc_time + FAST_EXPIRATION_TIME;\n\n    ASN1_MALLOC_ENCODE(KDCFastState, data.data, data.length, \n\t\t       &r->fast, &size, ret);\n    if (ret)\n\treturn ret;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n\n    ret = get_fastuser_crypto(r, KRB5_ENCTYPE_NULL, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_encrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     data.data, data.length, 0,\n\t\t\t\t     &shell.cookie);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n    \n    free(data.data);\n\n    shell.version = \"H5L1\";\n\n    ASN1_MALLOC_ENCODE(KDCFastCookie, data.data, data.length, \n\t\t       &shell, &size, ret);\n    free_EncryptedData(&shell.cookie);\n    if (ret)\n\tgoto out;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n    \n    ret = krb5_padata_add(r->context, method_data,\n\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t  data.data, data.length);\n out:\n    if (ret)\n\tfree(data.data);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfast_add_cookie(kdc_request_t r, METHOD_DATA *method_data)\n{\n    krb5_crypto crypto = NULL;\n    KDCFastCookie shell;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size;\n\n    memset(&shell, 0, sizeof(shell));\n\n    r->fast.expiration = kdc_time + FAST_EXPIRATION_TIME;\n\n    ASN1_MALLOC_ENCODE(KDCFastState, data.data, data.length, \n\t\t       &r->fast, &size, ret);\n    if (ret)\n\treturn ret;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n\n    ret = get_fastuser_crypto(r, KRB5_ENCTYPE_NULL, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_encrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     data.data, data.length, 0,\n\t\t\t\t     &shell.cookie);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n    \n    free(data.data);\n\n    shell.version = \"H5L1\";\n\n    ASN1_MALLOC_ENCODE(KDCFastCookie, data.data, data.length, \n\t\t       &shell, &size, ret);\n    free_EncryptedData(&shell.cookie);\n    if (ret)\n\tgoto out;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n    \n    ret = krb5_padata_add(r->context, method_data,\n\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t  data.data, data.length);\n out:\n    if (ret)\n\tfree(data.data);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "e_data)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "ontext,",
            "rror_method,",
            "RB5_PADATA_FX_ERROR,",
            "_data.data,",
            "_data.length)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_mk_error_ext(",
          "args": [
            "ontext,",
            "uter_error,",
            "_text,",
            "ULL,",
            "rror_server,",
            "rror_client_name,",
            "rror_client_realm,",
            "ULL,",
            "ULL,",
            "e_data)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "fastrep,",
            ",",
            "izeof(fastrep))"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "fxfastrep,",
            ",",
            "izeof(fxfastrep))"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "e_data)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}"
  },
  {
    "function_name": "kdc_fast_mk_response(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "180-236",
    "snippet": "rb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 error\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_FX_FAST_REPLY(",
          "args": [
            "fxfastrep)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_FX_FAST_REPLY,",
            "ata->data,",
            "ata->length,",
            "fxfastrep,",
            "size,",
            "et)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "buf)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "rmor_crypto,",
            "RB5_KU_FAST_REP,",
            "uf.data,",
            "uf.length,",
            ",",
            "fxfastrep.u.armored_data.enc_fast_rep)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 error\")"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "rbFastResponse,",
            "uf.data,",
            "uf.length,",
            "fastrep,",
            "size,",
            "et)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "ata)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "fastrep,",
            ",",
            "izeof(fastrep))"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "fxfastrep,",
            ",",
            "izeof(fxfastrep))"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_response(krb5_context context,\n\t\t      krb5_crypto armor_crypto,\n\t\t      METHOD_DATA *pa_data,\n\t\t      krb5_keyblock *strengthen_key,\n\t\t      KrbFastFinished *finished,\n\t\t      krb5uint32 nonce,\n\t\t      krb5_data *data)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    krb5_data buf;\n    size_t size;\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n    krb5_data_zero(data);\n\n    if (pa_data) {\n\tfastrep.padata.val = pa_data->val;\n\tfastrep.padata.len = pa_data->len;\n    }\n    fastrep.strengthen_key = strengthen_key;\n    fastrep.finished = finished;\n    fastrep.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KrbFastResponse, buf.data, buf.length,\n\t\t       &fastrep, &size, ret);\n    if (ret)\n\treturn ret;\n    if (buf.length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    fxfastrep.element = choice_PA_FX_FAST_REPLY_armored_data;\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     armor_crypto,\n\t\t\t\t     KRB5_KU_FAST_REP,\n\t\t\t\t     buf.data,\n\t\t\t\t     buf.length,\n\t\t\t\t     0,\n\t\t\t\t     &fxfastrep.u.armored_data.enc_fast_rep);\n    krb5_data_free(&buf);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REPLY, data->data, data->length,\n\t\t       &fxfastrep, &size, ret);\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n    if (ret)\n\treturn ret;\n    if (data->length != size)\n\tkrb5_abortx(context, \"internal asn.1 error\");\n    \n    return 0;\n}"
  },
  {
    "function_name": "ast_add_cookie(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "129-178",
    "snippet": "tatic krb5_error_code\nfast_add_cookie(kdc_request_t r, METHOD_DATA *method_data)\n{\n    krb5_crypto crypto = NULL;\n    KDCFastCookie shell;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size;\n\n    memset(&shell, 0, sizeof(shell));\n\n    r->fast.expiration = kdc_time + FAST_EXPIRATION_TIME;\n\n    ASN1_MALLOC_ENCODE(KDCFastState, data.data, data.length, \n\t\t       &r->fast, &size, ret);\n    if (ret)\n\treturn ret;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n\n    ret = get_fastuser_crypto(r, KRB5_ENCTYPE_NULL, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_encrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     data.data, data.length, 0,\n\t\t\t\t     &shell.cookie);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n    \n    free(data.data);\n\n    shell.version = \"H5L1\";\n\n    ASN1_MALLOC_ENCODE(KDCFastCookie, data.data, data.length, \n\t\t       &shell, &size, ret);\n    free_EncryptedData(&shell.cookie);\n    if (ret)\n\tgoto out;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n    \n    ret = krb5_padata_add(r->context, method_data,\n\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t  data.data, data.length);\n out:\n    if (ret)\n\tfree(data.data);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_padata_add(",
          "args": [
            "->context,",
            "ethod_data,",
            "RB5_PADATA_FX_COOKIE,",
            "ata.data,",
            "ata.length)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "ize == data.length,",
            "internal asn1 encoder error\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "shell.cookie)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "DCFastCookie,",
            "ata.data,",
            "ata.length,",
            "shell,",
            "size,",
            "et)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "rypto)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "->context,",
            "rypto,",
            "RB5_KU_H5L_COOKIE,",
            "ata.data,",
            "ata.length,",
            ",",
            "shell.cookie)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_fastuser_crypto(",
          "args": [
            ",",
            "RB5_ENCTYPE_NULL,",
            "crypto)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "et_fastuser_crypto(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "38-78",
          "snippet": "tatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eim_assert(",
          "args": [
            "ize == data.length,",
            "internal asn1 encoder error\")"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "DCFastState,",
            "ata.data,",
            "ata.length,",
            "r->fast,",
            "size,",
            "et)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "shell,",
            ",",
            "izeof(shell))"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfast_add_cookie(kdc_request_t r, METHOD_DATA *method_data)\n{\n    krb5_crypto crypto = NULL;\n    KDCFastCookie shell;\n    krb5_error_code ret;\n    krb5_data data;\n    size_t size;\n\n    memset(&shell, 0, sizeof(shell));\n\n    r->fast.expiration = kdc_time + FAST_EXPIRATION_TIME;\n\n    ASN1_MALLOC_ENCODE(KDCFastState, data.data, data.length, \n\t\t       &r->fast, &size, ret);\n    if (ret)\n\treturn ret;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n\n    ret = get_fastuser_crypto(r, KRB5_ENCTYPE_NULL, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_encrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     data.data, data.length, 0,\n\t\t\t\t     &shell.cookie);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n    \n    free(data.data);\n\n    shell.version = \"H5L1\";\n\n    ASN1_MALLOC_ENCODE(KDCFastCookie, data.data, data.length, \n\t\t       &shell, &size, ret);\n    free_EncryptedData(&shell.cookie);\n    if (ret)\n\tgoto out;\n    heim_assert(size == data.length, \"internal asn1 encoder error\");\n    \n    ret = krb5_padata_add(r->context, method_data,\n\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t  data.data, data.length);\n out:\n    if (ret)\n\tfree(data.data);\n    return ret;\n}"
  },
  {
    "function_name": "ast_parse_cookie(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "81-127",
    "snippet": "tatic krb5_error_code\nfast_parse_cookie(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_crypto crypto = NULL;\n    krb5_error_code ret;\n    KDCFastCookie data;\n    krb5_data d1;\n    size_t len;\n\n    ret = decode_KDCFastCookie(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &data, &len);\n    if (ret)\n\treturn ret;\n\n    if (len != pa->padata_value.length || strcmp(\"H5L1\", data.version) != 0) {\n\tfree_KDCFastCookie(&data);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    ret = get_fastuser_crypto(r, data.cookie.etype, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_decrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     &data.cookie, &d1);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n\n    ret = decode_KDCFastState(d1.data, d1.length, &r->fast, &len);\n    krb5_data_free(&d1);\n    if (ret)\n\tgoto out;\n\n    if (r->fast.expiration < kdc_time) {\n\tkdc_log(r->context, r->config, 0, \"fast cookie expired\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n out:\n    free_KDCFastCookie(&data);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_KDCFastCookie(",
          "args": [
            "data)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "->context,",
            "->config,",
            ",",
            "fast cookie expired\")"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "d1)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_KDCFastState(",
          "args": [
            "1.data,",
            "1.length,",
            "r->fast,",
            "len)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "->context,",
            "rypto)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData(",
          "args": [
            "->context,",
            "rypto,",
            "RB5_KU_H5L_COOKIE,",
            "data.cookie,",
            "d1)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_fastuser_crypto(",
          "args": [
            ",",
            "ata.cookie.etype,",
            "crypto)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "et_fastuser_crypto(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "38-78",
          "snippet": "tatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_KDCFastCookie(",
          "args": [
            "data)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "H5L1\",",
            "ata.version)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_KDCFastCookie(",
          "args": [
            "a->padata_value.data,",
            "a->padata_value.length,",
            "data,",
            "len)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfast_parse_cookie(kdc_request_t r, const PA_DATA *pa)\n{\n    krb5_crypto crypto = NULL;\n    krb5_error_code ret;\n    KDCFastCookie data;\n    krb5_data d1;\n    size_t len;\n\n    ret = decode_KDCFastCookie(pa->padata_value.data,\n\t\t\t       pa->padata_value.length,\n\t\t\t       &data, &len);\n    if (ret)\n\treturn ret;\n\n    if (len != pa->padata_value.length || strcmp(\"H5L1\", data.version) != 0) {\n\tfree_KDCFastCookie(&data);\n\treturn KRB5KDC_ERR_POLICY;\n    }\n\n    ret = get_fastuser_crypto(r, data.cookie.etype, &crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_decrypt_EncryptedData(r->context, crypto,\n\t\t\t\t     KRB5_KU_H5L_COOKIE,\n\t\t\t\t     &data.cookie, &d1);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\tgoto out;\n\n    ret = decode_KDCFastState(d1.data, d1.length, &r->fast, &len);\n    krb5_data_free(&d1);\n    if (ret)\n\tgoto out;\n\n    if (r->fast.expiration < kdc_time) {\n\tkdc_log(r->context, r->config, 0, \"fast cookie expired\");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n out:\n    free_KDCFastCookie(&data);\n\n    return ret;\n}"
  },
  {
    "function_name": "et_fastuser_crypto(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
    "lines": "38-78",
    "snippet": "tatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdc_free_ent(",
          "args": [
            "->context,",
            "ast_user)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "->context,",
            "cookie_key->key,",
            ",",
            "rypto)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "->context,",
            "fast_user->entry,",
            "ULL,",
            "nctype,",
            "cookie_key)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_get_preferred_key(",
          "args": [
            "->context,",
            "->config,",
            "ast_user,",
            "fast-cookie\",",
            "enctype,",
            "cookie_key)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_get_preferred_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "175-220",
          "snippet": "rb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "->context,",
            "ast_princ)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "->context,",
            "->config,",
            "ast_princ,",
            "DB_F_GET_CLIENT,",
            "ULL,",
            "ULL,",
            "fast_user)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "->context,",
            "fast_princ,",
            "RB5_WELLKNOWN_ORG_H5L_REALM,",
            "RB5_WELLKNOWN_NAME,",
            "org.h5l.fast-cookie\",",
            "ULL)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nget_fastuser_crypto(kdc_request_t r, krb5_enctype enctype, krb5_crypto *crypto)\n{\n    krb5_principal fast_princ;\n    hdb_entry_ex *fast_user = NULL;\n    Key *cookie_key = NULL;\n    krb5_error_code ret;\n\n    *crypto = NULL;\n\n    ret = krb5_make_principal(r->context, &fast_princ,\n\t\t\t      KRB5_WELLKNOWN_ORG_H5L_REALM,\n\t\t\t      KRB5_WELLKNOWN_NAME, \"org.h5l.fast-cookie\", NULL);\n    if (ret)\n\tgoto out;\n\n    ret = _kdc_db_fetch(r->context, r->config, fast_princ,\n\t\t\tHDB_F_GET_CLIENT, NULL, NULL, &fast_user);\n    krb5_free_principal(r->context, fast_princ);\n    if (ret)\n\tgoto out;\n\n    if (enctype == KRB5_ENCTYPE_NULL)\n\tret = _kdc_get_preferred_key(r->context, r->config, fast_user,\n\t\t\t\t     \"fast-cookie\", &enctype, &cookie_key);\n    else\n\tret = hdb_enctype2key(r->context, &fast_user->entry, NULL,\n\t\t\t      enctype, &cookie_key);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(r->context, &cookie_key->key, 0, crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    if (fast_user)\n\t_kdc_free_ent(r->context, fast_user);\n\n    return ret;\n}"
  }
]