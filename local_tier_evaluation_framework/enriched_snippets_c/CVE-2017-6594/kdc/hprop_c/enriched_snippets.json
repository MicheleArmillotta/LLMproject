[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "383-473",
    "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_ccache ccache = NULL;\n    HDB *db = NULL;\n    int optidx = 0;\n\n    int type, exit_code;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if(ret)\n\texit(1);\n\n    /* We may be reading an old database encrypted with a DES master key. */\n    ret = krb5_allow_weak_crypto(context, 1);\n    if(ret)\n        krb5_err(context, 1, ret, \"krb5_allow_weak_crypto\");\n\n    if(local_realm)\n\tkrb5_set_default_realm(context, local_realm);\n\n    if(encrypt_flag && decrypt_flag)\n\tkrb5_errx(context, 1,\n\t\t  \"only one of `--encrypt' and `--decrypt' is meaningful\");\n\n    if(source_type != NULL) {\n\ttype = parse_source_type(source_type);\n\tif(type == 0)\n\t    krb5_errx(context, 1, \"unknown source type `%s'\", source_type);\n    } else\n\ttype = HPROP_HEIMDAL;\n\n    if(!to_stdout)\n\tget_creds(context, &ccache);\n\n    if(decrypt_flag || encrypt_flag) {\n\tret = hdb_read_master_key(context, mkeyfile, &mkey5);\n\tif(ret && ret != ENOENT)\n\t    krb5_err(context, 1, ret, \"hdb_read_master_key\");\n\tif(ret)\n\t    krb5_errx(context, 1, \"No master key file found\");\n    }\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tif (database == NULL)\n\t    krb5_errx(context, 1, \"no dump file specified\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_create (context, &db, database);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"hdb_create: %s\", database);\n\tret = db->hdb_open(context, db, O_RDONLY, 0);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"db->hdb_open\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown dump type `%d'\", type);\n\tbreak;\n    }\n\n    if (to_stdout)\n\texit_code = dump_database (context, type, database, db);\n    else\n\texit_code = propagate_database (context, type, database,\n\t\t\t\t\tdb, ccache, optidx, argc, argv);\n\n    if(ccache != NULL)\n\tkrb5_cc_destroy(context, ccache);\n\n    if(db != NULL)\n\t(*db->hdb_destroy)(context, db);\n\n    krb5_free_context(context);\n    return exit_code;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int version_flag;",
      "tatic int help_flag;",
      "tatic const char *database;",
      "tatic char *mkeyfile;",
      "tatic int to_stdout;",
      "tatic int encrypt_flag;",
      "tatic int decrypt_flag;",
      "tatic hdb_master_key mkey5;",
      "tatic char *source_type;",
      "tatic char *local_realm=NULL;",
      "truct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};",
      "tatic int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_context(",
          "args": [
            "ontext)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*db->hdb_destroy)",
          "args": [
            "ontext,",
            "b)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_destroy(",
          "args": [
            "ontext,",
            "cache)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ropagate_database",
          "args": [
            "ontext,",
            "ype,",
            "atabase,",
            "b,",
            "cache,",
            "ptidx,",
            "rgc,",
            "rgv)"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ropagate_database",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "273-381",
          "snippet": "tatic int\npropagate_database (krb5_context context, int type,\n\t\t    const char *database_name,\n\t\t    HDB *db, krb5_ccache ccache,\n\t\t    int optidx, int argc, char **argv)\n{\n    krb5_principal server;\n    krb5_error_code ret;\n    int i, failed = 0;\n\n    for(i = optidx; i < argc; i++){\n\tkrb5_auth_context auth_context;\n\tint fd;\n\tstruct prop_data pd;\n\tkrb5_data data;\n\n\tchar *port, portstr[NI_MAXSERV];\n\tchar *host = argv[i];\n\n\tport = strchr(host, ':');\n\tif(port == NULL) {\n\t    snprintf(portstr, sizeof(portstr), \"%u\",\n\t\t     ntohs(krb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT)));\n\t    port = portstr;\n\t} else\n\t    *port++ = '\\0';\n\n\tfd = open_socket(context, host, port);\n\tif(fd < 0) {\n\t    failed++;\n\t    krb5_warn (context, errno, \"connect %s\", host);\n\t    continue;\n\t}\n\n\tret = krb5_sname_to_principal(context, argv[i],\n\t\t\t\t      HPROP_NAME, KRB5_NT_SRV_HST, &server);\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sname_to_principal(%s)\", host);\n\t    close(fd);\n\t    continue;\n\t}\n\n        if (local_realm) {\n            krb5_realm my_realm;\n            krb5_get_default_realm(context,&my_realm);\n            krb5_principal_set_realm(context,server,my_realm);\n\t    krb5_xfree(my_realm);\n        }\n\n\tauth_context = NULL;\n\tret = krb5_sendauth(context,\n\t\t\t    &auth_context,\n\t\t\t    &fd,\n\t\t\t    HPROP_VERSION,\n\t\t\t    NULL,\n\t\t\t    server,\n\t\t\t    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,\n\t\t\t    NULL, /* in_data */\n\t\t\t    NULL, /* in_creds */\n\t\t\t    ccache,\n\t\t\t    NULL,\n\t\t\t    NULL,\n\t\t\t    NULL);\n\n\tkrb5_free_principal(context, server);\n\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sendauth (%s)\", host);\n\t    goto next_host;\n\t}\n\n\tpd.context      = context;\n\tpd.auth_context = auth_context;\n\tpd.sock         = fd;\n\n\tret = iterate (context, database_name, db, type, &pd);\n\tif (ret) {\n\t    krb5_warnx(context, \"iterate to host %s failed\", host);\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tkrb5_data_zero (&data);\n\tret = krb5_write_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_write_priv_message\");\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tret = krb5_read_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_read_priv_message: %s\", host);\n\t    failed++;\n\t    goto next_host;\n\t} else\n\t    krb5_data_free (&data);\n\n    next_host:\n\tkrb5_auth_con_free(context, auth_context);\n\tclose(fd);\n    }\n    if (failed)\n\treturn 1;\n    return 0;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char *local_realm=NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic char *local_realm=NULL;\n\ntatic int\npropagate_database (krb5_context context, int type,\n\t\t    const char *database_name,\n\t\t    HDB *db, krb5_ccache ccache,\n\t\t    int optidx, int argc, char **argv)\n{\n    krb5_principal server;\n    krb5_error_code ret;\n    int i, failed = 0;\n\n    for(i = optidx; i < argc; i++){\n\tkrb5_auth_context auth_context;\n\tint fd;\n\tstruct prop_data pd;\n\tkrb5_data data;\n\n\tchar *port, portstr[NI_MAXSERV];\n\tchar *host = argv[i];\n\n\tport = strchr(host, ':');\n\tif(port == NULL) {\n\t    snprintf(portstr, sizeof(portstr), \"%u\",\n\t\t     ntohs(krb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT)));\n\t    port = portstr;\n\t} else\n\t    *port++ = '\\0';\n\n\tfd = open_socket(context, host, port);\n\tif(fd < 0) {\n\t    failed++;\n\t    krb5_warn (context, errno, \"connect %s\", host);\n\t    continue;\n\t}\n\n\tret = krb5_sname_to_principal(context, argv[i],\n\t\t\t\t      HPROP_NAME, KRB5_NT_SRV_HST, &server);\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sname_to_principal(%s)\", host);\n\t    close(fd);\n\t    continue;\n\t}\n\n        if (local_realm) {\n            krb5_realm my_realm;\n            krb5_get_default_realm(context,&my_realm);\n            krb5_principal_set_realm(context,server,my_realm);\n\t    krb5_xfree(my_realm);\n        }\n\n\tauth_context = NULL;\n\tret = krb5_sendauth(context,\n\t\t\t    &auth_context,\n\t\t\t    &fd,\n\t\t\t    HPROP_VERSION,\n\t\t\t    NULL,\n\t\t\t    server,\n\t\t\t    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,\n\t\t\t    NULL, /* in_data */\n\t\t\t    NULL, /* in_creds */\n\t\t\t    ccache,\n\t\t\t    NULL,\n\t\t\t    NULL,\n\t\t\t    NULL);\n\n\tkrb5_free_principal(context, server);\n\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sendauth (%s)\", host);\n\t    goto next_host;\n\t}\n\n\tpd.context      = context;\n\tpd.auth_context = auth_context;\n\tpd.sock         = fd;\n\n\tret = iterate (context, database_name, db, type, &pd);\n\tif (ret) {\n\t    krb5_warnx(context, \"iterate to host %s failed\", host);\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tkrb5_data_zero (&data);\n\tret = krb5_write_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_write_priv_message\");\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tret = krb5_read_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_read_priv_message: %s\", host);\n\t    failed++;\n\t    goto next_host;\n\t} else\n\t    krb5_data_free (&data);\n\n    next_host:\n\tkrb5_auth_con_free(context, auth_context);\n\tclose(fd);\n    }\n    if (failed)\n\treturn 1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ump_database",
          "args": [
            "ontext,",
            "ype,",
            "atabase,",
            "b)"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ump_database",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "250-271",
          "snippet": "tatic int\ndump_database (krb5_context context, int type,\n\t       const char *database_name, HDB *db)\n{\n    krb5_error_code ret;\n    struct prop_data pd;\n    krb5_data data;\n\n    pd.context      = context;\n    pd.auth_context = NULL;\n    pd.sock         = STDOUT_FILENO;\n\n    ret = iterate (context, database_name, db, type, &pd);\n    if (ret)\n\tkrb5_errx(context, 1, \"iterate failure\");\n    krb5_data_zero (&data);\n    ret = krb5_write_message (context, &pd.sock, &data);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_write_message\");\n\n    return 0;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int\ndump_database (krb5_context context, int type,\n\t       const char *database_name, HDB *db)\n{\n    krb5_error_code ret;\n    struct prop_data pd;\n    krb5_data data;\n\n    pd.context      = context;\n    pd.auth_context = NULL;\n    pd.sock         = STDOUT_FILENO;\n\n    ret = iterate (context, database_name, db, type, &pd);\n    if (ret)\n\tkrb5_errx(context, 1, \"iterate failure\");\n    krb5_data_zero (&data);\n    ret = krb5_write_message (context, &pd.sock, &data);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_write_message\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "unknown dump type `%d'\",",
            "ype)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "db->hdb_open\")"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b->hdb_open",
          "args": [
            "ontext,",
            "b,",
            "_RDONLY,",
            ")"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "hdb_create: %s\",",
            "atabase)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_create",
          "args": [
            "ontext,",
            "db,",
            "atabase)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "no dump file specified\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "No master key file found\")"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "hdb_read_master_key\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_read_master_key(",
          "args": [
            "ontext,",
            "keyfile,",
            "mkey5)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_creds(",
          "args": [
            "ontext,",
            "ccache)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "et_creds(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "154-198",
          "snippet": "tatic void\nget_creds(krb5_context context, krb5_ccache *cache)\n{\n    krb5_keytab keytab;\n    krb5_principal client;\n    krb5_error_code ret;\n    krb5_get_init_creds_opt *init_opts;\n    krb5_preauthtype preauth = KRB5_PADATA_ENC_TIMESTAMP;\n    krb5_creds creds;\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_register\");\n\n    ret = krb5_kt_resolve(context, ktname, &keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_resolve\");\n\n    ret = krb5_make_principal(context, &client, NULL,\n\t\t\t      \"kadmin\", HPROP_NAME, NULL);\n    if(ret) krb5_err(context, 1, ret, \"krb5_make_principal\");\n\n    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);\n\n    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds\");\n\n    krb5_get_init_creds_opt_free(context, init_opts);\n\n    ret = krb5_kt_close(context, keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_close\");\n\n    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_new_unique\");\n\n    ret = krb5_cc_initialize(context, *cache, client);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_initialize\");\n\n    krb5_free_principal(context, client);\n\n    ret = krb5_cc_store_cred(context, *cache, &creds);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_store_cred\");\n\n    krb5_free_cred_contents(context, &creds);\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic const char *ktname = HPROP_KEYTAB;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic const char *ktname = HPROP_KEYTAB;\n\ntatic void\nget_creds(krb5_context context, krb5_ccache *cache)\n{\n    krb5_keytab keytab;\n    krb5_principal client;\n    krb5_error_code ret;\n    krb5_get_init_creds_opt *init_opts;\n    krb5_preauthtype preauth = KRB5_PADATA_ENC_TIMESTAMP;\n    krb5_creds creds;\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_register\");\n\n    ret = krb5_kt_resolve(context, ktname, &keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_resolve\");\n\n    ret = krb5_make_principal(context, &client, NULL,\n\t\t\t      \"kadmin\", HPROP_NAME, NULL);\n    if(ret) krb5_err(context, 1, ret, \"krb5_make_principal\");\n\n    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);\n\n    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds\");\n\n    krb5_get_init_creds_opt_free(context, init_opts);\n\n    ret = krb5_kt_close(context, keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_close\");\n\n    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_new_unique\");\n\n    ret = krb5_cc_initialize(context, *cache, client);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_initialize\");\n\n    krb5_free_principal(context, client);\n\n    ret = krb5_cc_store_cred(context, *cache, &creds);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_store_cred\");\n\n    krb5_free_cred_contents(context, &creds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "unknown source type `%s'\",",
            "ource_type)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arse_source_type(",
          "args": [
            "ource_type)"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "arse_source_type(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "213-222",
          "snippet": "tatic int\nparse_source_type(const char *s)\n{\n    size_t i;\n    for(i = 0; i < sizeof(types) / sizeof(types[0]); i++) {\n\tif(strstr(types[i].name, s) == types[i].name)\n\t    return types[i].type;\n    }\n    return 0;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "truct {\n    int type;\n    const char *name;\n} types[] = {\n    { HPROP_HEIMDAL,\t\"heimdal\" },\n    { HPROP_MIT_DUMP,\t\"mit-dump\" }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntruct {\n    int type;\n    const char *name;\n} types[] = {\n    { HPROP_HEIMDAL,\t\"heimdal\" },\n    { HPROP_MIT_DUMP,\t\"mit-dump\" }\n};\n\ntatic int\nparse_source_type(const char *s)\n{\n    size_t i;\n    for(i = 0; i < sizeof(types) / sizeof(types[0]); i++) {\n\tif(strstr(types[i].name, s) == types[i].name)\n\t    return types[i].type;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "only one of `--encrypt' and `--decrypt' is meaningful\")"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_default_realm(",
          "args": [
            "ontext,",
            "ocal_realm)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_allow_weak_crypto\")"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_allow_weak_crypto(",
          "args": [
            "ontext,",
            ")"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit(",
          "args": [
            ")"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_context(",
          "args": [
            "context)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xit(",
          "args": [
            ")"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_version(",
          "args": [
            "ULL)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sage(",
          "args": [
            ")"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "sage(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "147-152",
          "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"[host[:port]] ...\");\n    exit (ret);\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "truct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};",
            "tatic int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntruct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"[host[:port]] ...\");\n    exit (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "etarg(",
          "args": [
            "rgs,",
            "um_args,",
            "rgc,",
            "rgv,",
            "optidx)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etprogname(",
          "args": [
            "rgv[0])"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic int version_flag;\ntatic int help_flag;\ntatic const char *database;\ntatic char *mkeyfile;\ntatic int to_stdout;\ntatic int encrypt_flag;\ntatic int decrypt_flag;\ntatic hdb_master_key mkey5;\ntatic char *source_type;\ntatic char *local_realm=NULL;\ntruct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_ccache ccache = NULL;\n    HDB *db = NULL;\n    int optidx = 0;\n\n    int type, exit_code;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if(ret)\n\texit(1);\n\n    /* We may be reading an old database encrypted with a DES master key. */\n    ret = krb5_allow_weak_crypto(context, 1);\n    if(ret)\n        krb5_err(context, 1, ret, \"krb5_allow_weak_crypto\");\n\n    if(local_realm)\n\tkrb5_set_default_realm(context, local_realm);\n\n    if(encrypt_flag && decrypt_flag)\n\tkrb5_errx(context, 1,\n\t\t  \"only one of `--encrypt' and `--decrypt' is meaningful\");\n\n    if(source_type != NULL) {\n\ttype = parse_source_type(source_type);\n\tif(type == 0)\n\t    krb5_errx(context, 1, \"unknown source type `%s'\", source_type);\n    } else\n\ttype = HPROP_HEIMDAL;\n\n    if(!to_stdout)\n\tget_creds(context, &ccache);\n\n    if(decrypt_flag || encrypt_flag) {\n\tret = hdb_read_master_key(context, mkeyfile, &mkey5);\n\tif(ret && ret != ENOENT)\n\t    krb5_err(context, 1, ret, \"hdb_read_master_key\");\n\tif(ret)\n\t    krb5_errx(context, 1, \"No master key file found\");\n    }\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tif (database == NULL)\n\t    krb5_errx(context, 1, \"no dump file specified\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_create (context, &db, database);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"hdb_create: %s\", database);\n\tret = db->hdb_open(context, db, O_RDONLY, 0);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"db->hdb_open\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown dump type `%d'\", type);\n\tbreak;\n    }\n\n    if (to_stdout)\n\texit_code = dump_database (context, type, database, db);\n    else\n\texit_code = propagate_database (context, type, database,\n\t\t\t\t\tdb, ccache, optidx, argc, argv);\n\n    if(ccache != NULL)\n\tkrb5_cc_destroy(context, ccache);\n\n    if(db != NULL)\n\t(*db->hdb_destroy)(context, db);\n\n    krb5_free_context(context);\n    return exit_code;\n}"
  },
  {
    "function_name": "ropagate_database",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "273-381",
    "snippet": "tatic int\npropagate_database (krb5_context context, int type,\n\t\t    const char *database_name,\n\t\t    HDB *db, krb5_ccache ccache,\n\t\t    int optidx, int argc, char **argv)\n{\n    krb5_principal server;\n    krb5_error_code ret;\n    int i, failed = 0;\n\n    for(i = optidx; i < argc; i++){\n\tkrb5_auth_context auth_context;\n\tint fd;\n\tstruct prop_data pd;\n\tkrb5_data data;\n\n\tchar *port, portstr[NI_MAXSERV];\n\tchar *host = argv[i];\n\n\tport = strchr(host, ':');\n\tif(port == NULL) {\n\t    snprintf(portstr, sizeof(portstr), \"%u\",\n\t\t     ntohs(krb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT)));\n\t    port = portstr;\n\t} else\n\t    *port++ = '\\0';\n\n\tfd = open_socket(context, host, port);\n\tif(fd < 0) {\n\t    failed++;\n\t    krb5_warn (context, errno, \"connect %s\", host);\n\t    continue;\n\t}\n\n\tret = krb5_sname_to_principal(context, argv[i],\n\t\t\t\t      HPROP_NAME, KRB5_NT_SRV_HST, &server);\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sname_to_principal(%s)\", host);\n\t    close(fd);\n\t    continue;\n\t}\n\n        if (local_realm) {\n            krb5_realm my_realm;\n            krb5_get_default_realm(context,&my_realm);\n            krb5_principal_set_realm(context,server,my_realm);\n\t    krb5_xfree(my_realm);\n        }\n\n\tauth_context = NULL;\n\tret = krb5_sendauth(context,\n\t\t\t    &auth_context,\n\t\t\t    &fd,\n\t\t\t    HPROP_VERSION,\n\t\t\t    NULL,\n\t\t\t    server,\n\t\t\t    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,\n\t\t\t    NULL, /* in_data */\n\t\t\t    NULL, /* in_creds */\n\t\t\t    ccache,\n\t\t\t    NULL,\n\t\t\t    NULL,\n\t\t\t    NULL);\n\n\tkrb5_free_principal(context, server);\n\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sendauth (%s)\", host);\n\t    goto next_host;\n\t}\n\n\tpd.context      = context;\n\tpd.auth_context = auth_context;\n\tpd.sock         = fd;\n\n\tret = iterate (context, database_name, db, type, &pd);\n\tif (ret) {\n\t    krb5_warnx(context, \"iterate to host %s failed\", host);\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tkrb5_data_zero (&data);\n\tret = krb5_write_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_write_priv_message\");\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tret = krb5_read_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_read_priv_message: %s\", host);\n\t    failed++;\n\t    goto next_host;\n\t} else\n\t    krb5_data_free (&data);\n\n    next_host:\n\tkrb5_auth_con_free(context, auth_context);\n\tclose(fd);\n    }\n    if (failed)\n\treturn 1;\n    return 0;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic char *local_realm=NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "uth_context)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free",
          "args": [
            "data)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "krb5_read_priv_message: %s\",",
            "ost)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_read_priv_message(",
          "args": [
            "ontext,",
            "uth_context,",
            "fd,",
            "data)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "krb5_write_priv_message\")"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_write_priv_message(",
          "args": [
            "ontext,",
            "uth_context,",
            "fd,",
            "data)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero",
          "args": [
            "data)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warnx(",
          "args": [
            "ontext,",
            "iterate to host %s failed\",",
            "ost)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "terate",
          "args": [
            "ontext,",
            "atabase_name,",
            "b,",
            "ype,",
            "pd)"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "terate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "224-248",
          "snippet": "tatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "krb5_sendauth (%s)\",",
            "ost)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "erver)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_sendauth(",
          "args": [
            "ontext,",
            "auth_context,",
            "fd,",
            "PROP_VERSION,",
            "ULL,",
            "erver,",
            "P_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,",
            "ULL,",
            "* in_data */\nULL,",
            "* in_creds */\ncache,",
            "ULL,",
            "ULL,",
            "ULL)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_xfree(",
          "args": [
            "y_realm)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_set_realm(",
          "args": [
            "ontext,",
            "erver,",
            "y_realm)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_default_realm(",
          "args": [
            "ontext,",
            "my_realm)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose(",
          "args": [
            "d)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "krb5_sname_to_principal(%s)\",",
            "ost)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_sname_to_principal(",
          "args": [
            "ontext,",
            "rgv[i],",
            "PROP_NAME,",
            "RB5_NT_SRV_HST,",
            "server)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn",
          "args": [
            "ontext,",
            "rrno,",
            "connect %s\",",
            "ost)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen_socket(",
          "args": [
            "ontext,",
            "ost,",
            "ort)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "pen_socket(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "53-87",
          "snippet": "tatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nprintf(",
          "args": [
            "ortstr,",
            "izeof(portstr),",
            "%u\",",
            "tohs(krb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT)))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tohs(",
          "args": [
            "rb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT))"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_getportbyname",
          "args": [
            "ontext,",
            "hprop\",",
            "tcp\",",
            "PROP_PORT)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "ost,",
            ":')"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic char *local_realm=NULL;\n\ntatic int\npropagate_database (krb5_context context, int type,\n\t\t    const char *database_name,\n\t\t    HDB *db, krb5_ccache ccache,\n\t\t    int optidx, int argc, char **argv)\n{\n    krb5_principal server;\n    krb5_error_code ret;\n    int i, failed = 0;\n\n    for(i = optidx; i < argc; i++){\n\tkrb5_auth_context auth_context;\n\tint fd;\n\tstruct prop_data pd;\n\tkrb5_data data;\n\n\tchar *port, portstr[NI_MAXSERV];\n\tchar *host = argv[i];\n\n\tport = strchr(host, ':');\n\tif(port == NULL) {\n\t    snprintf(portstr, sizeof(portstr), \"%u\",\n\t\t     ntohs(krb5_getportbyname (context, \"hprop\", \"tcp\",\n\t\t\t\t\t       HPROP_PORT)));\n\t    port = portstr;\n\t} else\n\t    *port++ = '\\0';\n\n\tfd = open_socket(context, host, port);\n\tif(fd < 0) {\n\t    failed++;\n\t    krb5_warn (context, errno, \"connect %s\", host);\n\t    continue;\n\t}\n\n\tret = krb5_sname_to_principal(context, argv[i],\n\t\t\t\t      HPROP_NAME, KRB5_NT_SRV_HST, &server);\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sname_to_principal(%s)\", host);\n\t    close(fd);\n\t    continue;\n\t}\n\n        if (local_realm) {\n            krb5_realm my_realm;\n            krb5_get_default_realm(context,&my_realm);\n            krb5_principal_set_realm(context,server,my_realm);\n\t    krb5_xfree(my_realm);\n        }\n\n\tauth_context = NULL;\n\tret = krb5_sendauth(context,\n\t\t\t    &auth_context,\n\t\t\t    &fd,\n\t\t\t    HPROP_VERSION,\n\t\t\t    NULL,\n\t\t\t    server,\n\t\t\t    AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY,\n\t\t\t    NULL, /* in_data */\n\t\t\t    NULL, /* in_creds */\n\t\t\t    ccache,\n\t\t\t    NULL,\n\t\t\t    NULL,\n\t\t\t    NULL);\n\n\tkrb5_free_principal(context, server);\n\n\tif(ret) {\n\t    failed++;\n\t    krb5_warn(context, ret, \"krb5_sendauth (%s)\", host);\n\t    goto next_host;\n\t}\n\n\tpd.context      = context;\n\tpd.auth_context = auth_context;\n\tpd.sock         = fd;\n\n\tret = iterate (context, database_name, db, type, &pd);\n\tif (ret) {\n\t    krb5_warnx(context, \"iterate to host %s failed\", host);\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tkrb5_data_zero (&data);\n\tret = krb5_write_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_write_priv_message\");\n\t    failed++;\n\t    goto next_host;\n\t}\n\n\tret = krb5_read_priv_message(context, auth_context, &fd, &data);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"krb5_read_priv_message: %s\", host);\n\t    failed++;\n\t    goto next_host;\n\t} else\n\t    krb5_data_free (&data);\n\n    next_host:\n\tkrb5_auth_con_free(context, auth_context);\n\tclose(fd);\n    }\n    if (failed)\n\treturn 1;\n    return 0;\n}"
  },
  {
    "function_name": "ump_database",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "250-271",
    "snippet": "tatic int\ndump_database (krb5_context context, int type,\n\t       const char *database_name, HDB *db)\n{\n    krb5_error_code ret;\n    struct prop_data pd;\n    krb5_data data;\n\n    pd.context      = context;\n    pd.auth_context = NULL;\n    pd.sock         = STDOUT_FILENO;\n\n    ret = iterate (context, database_name, db, type, &pd);\n    if (ret)\n\tkrb5_errx(context, 1, \"iterate failure\");\n    krb5_data_zero (&data);\n    ret = krb5_write_message (context, &pd.sock, &data);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_write_message\");\n\n    return 0;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_write_message\")"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_write_message",
          "args": [
            "ontext,",
            "pd.sock,",
            "data)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero",
          "args": [
            "data)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "iterate failure\")"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "terate",
          "args": [
            "ontext,",
            "atabase_name,",
            "b,",
            "ype,",
            "pd)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "terate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "224-248",
          "snippet": "tatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic int\ndump_database (krb5_context context, int type,\n\t       const char *database_name, HDB *db)\n{\n    krb5_error_code ret;\n    struct prop_data pd;\n    krb5_data data;\n\n    pd.context      = context;\n    pd.auth_context = NULL;\n    pd.sock         = STDOUT_FILENO;\n\n    ret = iterate (context, database_name, db, type, &pd);\n    if (ret)\n\tkrb5_errx(context, 1, \"iterate failure\");\n    krb5_data_zero (&data);\n    ret = krb5_write_message (context, &pd.sock, &data);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_write_message\");\n\n    return 0;\n}"
  },
  {
    "function_name": "terate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "224-248",
    "snippet": "tatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_errx(",
          "args": [
            "ontext,",
            ",",
            "unknown prop type: %d\",",
            "ype)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "hdb_foreach\")"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_foreach(",
          "args": [
            "ontext,",
            "b,",
            "DB_F_DECRYPT,",
            "5_prop,",
            "d)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "mit_prop_dump\")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_prop_dump(",
          "args": [
            "d,",
            "atabase_name)"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "it_prop_dump(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
          "lines": "134-220",
          "snippet": "nt\nmit_prop_dump(void *arg, const char *file)\n{\n    krb5_error_code ret;\n    size_t line_bufsz = 0;\n    size_t line_len = 0;\n    char *line = NULL;\n    int lineno = 0;\n    FILE *f;\n    struct hdb_entry_ex ent;\n    struct prop_data *pd = arg;\n    krb5_storage *sp = NULL;\n    krb5_data kdb_ent;\n\n    memset(&ent, 0, sizeof (ent));\n    f = fopen(file, \"r\");\n    if (f == NULL)\n\treturn errno;\n\n    ret = ENOMEM;\n    sp = krb5_storage_emem();\n    if (!sp)\n        goto out;\n    while ((ret = my_fgetln(f, &line, &line_bufsz, &line_len)) == 0 &&\n           !feof(f)) {\n        char *p = line;\n        char *q;\n        lineno++;\n\n\tif(strncmp(line, \"kdb5_util\", strlen(\"kdb5_util\")) == 0) {\n\t    int major;\n            q = nexttoken(&p);\n            if (strcmp(q, \"kdb5_util\"))\n                errx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"load_dump\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"version\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* x.0 */\n\t    if (sscanf(q, \"%d\", &major) != 1)\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    if (major != 4 && major != 5 && major != 6)\n\t\terrx(1, \"unknown dump file format, got %d, expected 4-6\",\n\t\t     major);\n\t    continue;\n\t} else if(strncmp(p, \"policy\", strlen(\"policy\")) == 0) {\n            warnx(\"line: %d: ignoring policy (not supported)\", lineno);\n\t    continue;\n\t} else if(strncmp(p, \"princ\", strlen(\"princ\")) != 0) {\n\t    warnx(\"line %d: not a principal\", lineno);\n\t    continue;\n\t}\n        krb5_storage_truncate(sp, 0);\n        ret = _hdb_mit_dump2mitdb_entry(pd->context, line, sp);\n        if (ret) {\n            if (ret > 0)\n                warn(\"line: %d: failed to parse; ignoring\", lineno);\n            else\n                warnx(\"line: %d: failed to parse; ignoring\", lineno);\n            continue;\n        }\n        ret = krb5_storage_to_data(sp, &kdb_ent);\n        if (ret) break;\n        ret = _hdb_mdb_value2entry(pd->context, &kdb_ent, 0, &ent.entry);\n        krb5_data_free(&kdb_ent);\n        if (ret) {\n            warnx(\"line: %d: failed to store; ignoring\", lineno);\n            continue;\n        }\n\tret = v5_prop(pd->context, NULL, &ent, arg);\n        hdb_free_entry(pd->context, &ent);\n        if (ret) break;\n    }\n\nout:\n    fclose(f);\n    free(line);\n    if (sp)\n        krb5_storage_free(sp);\n    if (ret && ret == ENOMEM)\n        errx(1, \"out of memory\");\n    if (ret)\n        errx(1, \"line %d: problem parsing dump line\", lineno);\n    return ret;\n}",
          "includes": [
            "include <kadm5/admin.h>",
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "xtern krb5_error_code _hdb_mdb_value2entry(krb5_context context,\n                                            krb5_data *data,\n                                            krb5_kvno target_kvno,\n                                            hdb_entry *entry);",
            "xtern int _hdb_mit_dump2mitdb_entry(krb5_context context,\n                                     char *line,\n                                     krb5_storage *sp);"
          ],
          "called_functions": [],
          "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\nxtern krb5_error_code _hdb_mdb_value2entry(krb5_context context,\n                                            krb5_data *data,\n                                            krb5_kvno target_kvno,\n                                            hdb_entry *entry);\nxtern int _hdb_mit_dump2mitdb_entry(krb5_context context,\n                                     char *line,\n                                     krb5_storage *sp);\n\nnt\nmit_prop_dump(void *arg, const char *file)\n{\n    krb5_error_code ret;\n    size_t line_bufsz = 0;\n    size_t line_len = 0;\n    char *line = NULL;\n    int lineno = 0;\n    FILE *f;\n    struct hdb_entry_ex ent;\n    struct prop_data *pd = arg;\n    krb5_storage *sp = NULL;\n    krb5_data kdb_ent;\n\n    memset(&ent, 0, sizeof (ent));\n    f = fopen(file, \"r\");\n    if (f == NULL)\n\treturn errno;\n\n    ret = ENOMEM;\n    sp = krb5_storage_emem();\n    if (!sp)\n        goto out;\n    while ((ret = my_fgetln(f, &line, &line_bufsz, &line_len)) == 0 &&\n           !feof(f)) {\n        char *p = line;\n        char *q;\n        lineno++;\n\n\tif(strncmp(line, \"kdb5_util\", strlen(\"kdb5_util\")) == 0) {\n\t    int major;\n            q = nexttoken(&p);\n            if (strcmp(q, \"kdb5_util\"))\n                errx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"load_dump\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"version\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* x.0 */\n\t    if (sscanf(q, \"%d\", &major) != 1)\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    if (major != 4 && major != 5 && major != 6)\n\t\terrx(1, \"unknown dump file format, got %d, expected 4-6\",\n\t\t     major);\n\t    continue;\n\t} else if(strncmp(p, \"policy\", strlen(\"policy\")) == 0) {\n            warnx(\"line: %d: ignoring policy (not supported)\", lineno);\n\t    continue;\n\t} else if(strncmp(p, \"princ\", strlen(\"princ\")) != 0) {\n\t    warnx(\"line %d: not a principal\", lineno);\n\t    continue;\n\t}\n        krb5_storage_truncate(sp, 0);\n        ret = _hdb_mit_dump2mitdb_entry(pd->context, line, sp);\n        if (ret) {\n            if (ret > 0)\n                warn(\"line: %d: failed to parse; ignoring\", lineno);\n            else\n                warnx(\"line: %d: failed to parse; ignoring\", lineno);\n            continue;\n        }\n        ret = krb5_storage_to_data(sp, &kdb_ent);\n        if (ret) break;\n        ret = _hdb_mdb_value2entry(pd->context, &kdb_ent, 0, &ent.entry);\n        krb5_data_free(&kdb_ent);\n        if (ret) {\n            warnx(\"line: %d: failed to store; ignoring\", lineno);\n            continue;\n        }\n\tret = v5_prop(pd->context, NULL, &ent, arg);\n        hdb_free_entry(pd->context, &ent);\n        if (ret) break;\n    }\n\nout:\n    fclose(f);\n    free(line);\n    if (sp)\n        krb5_storage_free(sp);\n    if (ret && ret == ENOMEM)\n        errx(1, \"out of memory\");\n    if (ret)\n        errx(1, \"line %d: problem parsing dump line\", lineno);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic int\niterate (krb5_context context,\n\t const char *database_name,\n\t HDB *db,\n\t int type,\n\t struct prop_data *pd)\n{\n    int ret;\n\n    switch(type) {\n    case HPROP_MIT_DUMP:\n\tret = mit_prop_dump(pd, database_name);\n\tif (ret)\n\t    krb5_warn(context, ret, \"mit_prop_dump\");\n\tbreak;\n    case HPROP_HEIMDAL:\n\tret = hdb_foreach(context, db, HDB_F_DECRYPT, v5_prop, pd);\n\tif(ret)\n\t    krb5_warn(context, ret, \"hdb_foreach\");\n\tbreak;\n    default:\n\tkrb5_errx(context, 1, \"unknown prop type: %d\", type);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "arse_source_type(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "213-222",
    "snippet": "tatic int\nparse_source_type(const char *s)\n{\n    size_t i;\n    for(i = 0; i < sizeof(types) / sizeof(types[0]); i++) {\n\tif(strstr(types[i].name, s) == types[i].name)\n\t    return types[i].type;\n    }\n    return 0;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "truct {\n    int type;\n    const char *name;\n} types[] = {\n    { HPROP_HEIMDAL,\t\"heimdal\" },\n    { HPROP_MIT_DUMP,\t\"mit-dump\" }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trstr(",
          "args": [
            "ypes[i].name,",
            ")"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntruct {\n    int type;\n    const char *name;\n} types[] = {\n    { HPROP_HEIMDAL,\t\"heimdal\" },\n    { HPROP_MIT_DUMP,\t\"mit-dump\" }\n};\n\ntatic int\nparse_source_type(const char *s)\n{\n    size_t i;\n    for(i = 0; i < sizeof(types) / sizeof(types[0]); i++) {\n\tif(strstr(types[i].name, s) == types[i].name)\n\t    return types[i].type;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "et_creds(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "154-198",
    "snippet": "tatic void\nget_creds(krb5_context context, krb5_ccache *cache)\n{\n    krb5_keytab keytab;\n    krb5_principal client;\n    krb5_error_code ret;\n    krb5_get_init_creds_opt *init_opts;\n    krb5_preauthtype preauth = KRB5_PADATA_ENC_TIMESTAMP;\n    krb5_creds creds;\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_register\");\n\n    ret = krb5_kt_resolve(context, ktname, &keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_resolve\");\n\n    ret = krb5_make_principal(context, &client, NULL,\n\t\t\t      \"kadmin\", HPROP_NAME, NULL);\n    if(ret) krb5_err(context, 1, ret, \"krb5_make_principal\");\n\n    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);\n\n    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds\");\n\n    krb5_get_init_creds_opt_free(context, init_opts);\n\n    ret = krb5_kt_close(context, keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_close\");\n\n    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_new_unique\");\n\n    ret = krb5_cc_initialize(context, *cache, client);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_initialize\");\n\n    krb5_free_principal(context, client);\n\n    ret = krb5_cc_store_cred(context, *cache, &creds);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_store_cred\");\n\n    krb5_free_cred_contents(context, &creds);\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const char *ktname = HPROP_KEYTAB;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_cred_contents(",
          "args": [
            "ontext,",
            "creds)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_cc_store_cred\")"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_store_cred(",
          "args": [
            "ontext,",
            "cache,",
            "creds)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "lient)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_cc_initialize\")"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_initialize(",
          "args": [
            "ontext,",
            "cache,",
            "lient)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_cc_new_unique\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_cc_new_unique(",
          "args": [
            "ontext,",
            "rb5_cc_type_memory,",
            "ULL,",
            "ache)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kt_close\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_close(",
          "args": [
            "ontext,",
            "eytab)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_opt_free(",
          "args": [
            "ontext,",
            "nit_opts)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_get_init_creds\")"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_keytab(",
          "args": [
            "ontext,",
            "creds,",
            "lient,",
            "eytab,",
            ",",
            "ULL,",
            "nit_opts)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_opt_set_preauth_list(",
          "args": [
            "nit_opts,",
            "preauth,",
            ")"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_get_init_creds_opt_alloc\")"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_init_creds_opt_alloc(",
          "args": [
            "ontext,",
            "init_opts)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_make_principal\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "client,",
            "ULL,",
            "kadmin\",",
            "PROP_NAME,",
            "ULL)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kt_resolve\")"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_resolve(",
          "args": [
            "ontext,",
            "tname,",
            "keytab)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_err(",
          "args": [
            "ontext,",
            ",",
            "et,",
            "krb5_kt_register\")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_register(",
          "args": [
            "ontext,",
            "hdb_get_kt_ops)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic const char *ktname = HPROP_KEYTAB;\n\ntatic void\nget_creds(krb5_context context, krb5_ccache *cache)\n{\n    krb5_keytab keytab;\n    krb5_principal client;\n    krb5_error_code ret;\n    krb5_get_init_creds_opt *init_opts;\n    krb5_preauthtype preauth = KRB5_PADATA_ENC_TIMESTAMP;\n    krb5_creds creds;\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_register\");\n\n    ret = krb5_kt_resolve(context, ktname, &keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_resolve\");\n\n    ret = krb5_make_principal(context, &client, NULL,\n\t\t\t      \"kadmin\", HPROP_NAME, NULL);\n    if(ret) krb5_err(context, 1, ret, \"krb5_make_principal\");\n\n    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds_opt_alloc\");\n    krb5_get_init_creds_opt_set_preauth_list(init_opts, &preauth, 1);\n\n    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab, 0, NULL, init_opts);\n    if(ret) krb5_err(context, 1, ret, \"krb5_get_init_creds\");\n\n    krb5_get_init_creds_opt_free(context, init_opts);\n\n    ret = krb5_kt_close(context, keytab);\n    if(ret) krb5_err(context, 1, ret, \"krb5_kt_close\");\n\n    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_new_unique\");\n\n    ret = krb5_cc_initialize(context, *cache, client);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_initialize\");\n\n    krb5_free_principal(context, client);\n\n    ret = krb5_cc_store_cred(context, *cache, &creds);\n    if(ret) krb5_err(context, 1, ret, \"krb5_cc_store_cred\");\n\n    krb5_free_cred_contents(context, &creds);\n}"
  },
  {
    "function_name": "sage(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "147-152",
    "snippet": "tatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"[host[:port]] ...\");\n    exit (ret);\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "truct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};",
      "tatic int num_args = sizeof(args) / sizeof(args[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xit",
          "args": [
            "et)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg_printusage",
          "args": [
            "rgs,",
            "um_args,",
            "ULL,",
            "[host[:port]] ...\")"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntruct getargs args[] = {\n    { \"master-key\", 'm', arg_string, &mkeyfile, \"v5 master key file\", \"file\" },\n    { \"database\", 'd',\targ_string, rk_UNCONST(&database), \"database\", \"file\" },\n    { \"source\",   0,\targ_string, &source_type, \"type of database to read\",\n      \"heimdal\"\n      \"|mit-dump\"\n    },\n\n    { \"keytab\",   'k',\targ_string, rk_UNCONST(&ktname),\n      \"keytab to use for authentication\", \"keytab\" },\n    { \"v5-realm\", 'R',  arg_string, &local_realm, \"v5 realm to use\", NULL },\n    { \"decrypt\",  'D',  arg_flag,   &decrypt_flag,   \"decrypt keys\", NULL },\n    { \"encrypt\",  'E',  arg_flag,   &encrypt_flag,   \"encrypt keys\", NULL },\n    { \"stdout\",\t  'n',  arg_flag,   &to_stdout, \"dump to stdout\", NULL },\n    { \"verbose\",  'v',\targ_flag, &verbose_flag, NULL, NULL },\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\ntatic void\nusage(int ret)\n{\n    arg_printusage (args, num_args, NULL, \"[host[:port]] ...\");\n    exit (ret);\n}"
  },
  {
    "function_name": "5_prop(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "89-124",
    "snippet": "rb5_error_code\nv5_prop(krb5_context context, HDB *db, hdb_entry_ex *entry, void *appdata)\n{\n    krb5_error_code ret;\n    struct prop_data *pd = appdata;\n    krb5_data data;\n\n    if(encrypt_flag) {\n\tret = hdb_seal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_seal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n    if(decrypt_flag) {\n\tret = hdb_unseal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_unseal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n\n    ret = hdb_entry2value(context, &entry->entry, &data);\n    if(ret) {\n\tkrb5_warn(context, ret, \"hdb_entry2value\");\n\treturn ret;\n    }\n\n    if(to_stdout)\n\tret = krb5_write_message(context, &pd->sock, &data);\n    else\n\tret = krb5_write_priv_message(context, pd->auth_context,\n\t\t\t\t      &pd->sock, &data);\n    krb5_data_free(&data);\n    return ret;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int to_stdout;",
      "tatic int encrypt_flag;",
      "tatic int decrypt_flag;",
      "tatic hdb_master_key mkey5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_write_priv_message(",
          "args": [
            "ontext,",
            "d->auth_context,",
            "pd->sock,",
            "data)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_write_message(",
          "args": [
            "ontext,",
            "pd->sock,",
            "data)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "hdb_entry2value\")"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry2value(",
          "args": [
            "ontext,",
            "entry->entry,",
            "data)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "hdb_unseal_keys_mkey\")"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_unseal_keys_mkey(",
          "args": [
            "ontext,",
            "entry->entry,",
            "key5)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "hdb_seal_keys_mkey\")"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_seal_keys_mkey(",
          "args": [
            "ontext,",
            "entry->entry,",
            "key5)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic int to_stdout;\ntatic int encrypt_flag;\ntatic int decrypt_flag;\ntatic hdb_master_key mkey5;\n\nrb5_error_code\nv5_prop(krb5_context context, HDB *db, hdb_entry_ex *entry, void *appdata)\n{\n    krb5_error_code ret;\n    struct prop_data *pd = appdata;\n    krb5_data data;\n\n    if(encrypt_flag) {\n\tret = hdb_seal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_seal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n    if(decrypt_flag) {\n\tret = hdb_unseal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_unseal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n\n    ret = hdb_entry2value(context, &entry->entry, &data);\n    if(ret) {\n\tkrb5_warn(context, ret, \"hdb_entry2value\");\n\treturn ret;\n    }\n\n    if(to_stdout)\n\tret = krb5_write_message(context, &pd->sock, &data);\n    else\n\tret = krb5_write_priv_message(context, pd->auth_context,\n\t\t\t\t      &pd->sock, &data);\n    krb5_data_free(&data);\n    return ret;\n}"
  },
  {
    "function_name": "pen_socket(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
    "lines": "53-87",
    "snippet": "tatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}",
    "includes": [
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reeaddrinfo",
          "args": [
            "i)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arnx",
          "args": [
            "failed to contact %s\",",
            "ostname)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reeaddrinfo",
          "args": [
            "i)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose",
          "args": [
            ")"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arn",
          "args": [
            "connect(%s)\",",
            "ostname)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect",
          "args": [
            ",",
            "->ai_addr,",
            "->ai_addrlen)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket",
          "args": [
            "->ai_family,",
            "->ai_socktype,",
            "->ai_protocol)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "pen_socket(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "53-87",
          "snippet": "tatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "arnx",
          "args": [
            "%s: %s\",",
            "ostname,",
            "ai_strerror(error))"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ai_strerror(",
          "args": [
            "rror)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etaddrinfo",
          "args": [
            "ostname,",
            "ort,",
            "hints,",
            "ai)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset",
          "args": [
            "hints,",
            ",",
            "izeof(hints))"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"hprop.h\"\n\ntatic int\nopen_socket(krb5_context context, const char *hostname, const char *port)\n{\n    struct addrinfo *ai, *a;\n    struct addrinfo hints;\n    int error;\n\n    memset (&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    error = getaddrinfo (hostname, port, &hints, &ai);\n    if (error) {\n\twarnx (\"%s: %s\", hostname, gai_strerror(error));\n\treturn -1;\n    }\n\n    for (a = ai; a != NULL; a = a->ai_next) {\n\tint s;\n\n\ts = socket (a->ai_family, a->ai_socktype, a->ai_protocol);\n\tif (s < 0)\n\t    continue;\n\tif (connect (s, a->ai_addr, a->ai_addrlen) < 0) {\n\t    warn (\"connect(%s)\", hostname);\n\t    close (s);\n\t    continue;\n\t}\n\tfreeaddrinfo (ai);\n\treturn s;\n    }\n    warnx (\"failed to contact %s\", hostname);\n    freeaddrinfo (ai);\n    return -1;\n}"
  }
]