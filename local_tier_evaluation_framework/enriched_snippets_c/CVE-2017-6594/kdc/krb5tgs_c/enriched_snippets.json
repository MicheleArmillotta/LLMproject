[
  {
    "function_name": "kdc_tgs_rep(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "2373-2502",
    "snippet": "rb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "uth_data)"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "uth_data)"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_free_ent(",
          "args": [
            "ontext,",
            "rbtgt)"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_ticket(",
          "args": [
            "ontext,",
            "icket)"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "usec)"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "sec)"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "error_method)"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fast_mk_error(",
          "args": [
            "ontext,",
            "ULL,",
            "error_method,",
            "ULL,",
            "ULL,",
            "et,",
            "ULL,",
            "ULL,",
            "ULL,",
            "ULL,",
            "sec,",
            "usec,",
            "ata)"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fast_mk_error(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/fast.c",
          "lines": "239-344",
          "snippet": "rb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_fast_mk_error(krb5_context context,\n\t\t   kdc_request_t r,\n\t\t   METHOD_DATA *error_method,\n\t\t   krb5_crypto armor_crypto,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   krb5_error_code outer_error,\n\t\t   const char *e_text,\n\t\t   krb5_principal error_server,\n\t\t   const PrincipalName *error_client_name,\n\t\t   const Realm *error_client_realm,\n\t\t   time_t *csec, int *cusec,\n\t\t   krb5_data *error_msg)\n{\n    krb5_error_code ret;\n    krb5_data e_data;\n    size_t size;\n\n    krb5_data_zero(&e_data);\n\n    if (armor_crypto) {\n\tPA_FX_FAST_REPLY fxfastrep;\n\tKrbFastResponse fastrep;\n\n\tmemset(&fxfastrep, 0, sizeof(fxfastrep));\n\tmemset(&fastrep, 0, sizeof(fastrep));\n\t    \n\t/* first add the KRB-ERROR to the fast errors */\n\n\tret = krb5_mk_error_ext(context,\n\t\t\t\touter_error,\n\t\t\t\te_text,\n\t\t\t\tNULL,\n\t\t\t\terror_server,\n\t\t\t\terror_client_name,\n\t\t\t\terror_client_realm,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\t&e_data);\n\tif (ret)\n\t    return ret;\n\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_ERROR,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret) {\n\t    krb5_data_free(&e_data);\n\t    return ret;\n\t}\n\n\tif (/* hide_principal */ 0) {\n\t    error_client_name = NULL;\n\t    error_client_realm = NULL;\n\t    error_server = NULL;\n\t    e_text = NULL;\n\t}\n\n\tif (r)\n\t    ret = fast_add_cookie(r, error_method);\n\telse\n\t    ret = krb5_padata_add(context, error_method,\n\t\t\t\t  KRB5_PADATA_FX_COOKIE,\n\t\t\t\t  NULL, 0);\n\tif (ret) {\n\t    kdc_log(r->context, r->config, 0, \"failed to add fast cookie with: %d\", ret);\n\t    free_METHOD_DATA(error_method);\n\t    return ret;\n\t}\n\t\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    error_method, NULL, NULL, \n\t\t\t\t    req_body->nonce, &e_data);\n\tfree_METHOD_DATA(error_method);\n\tif (ret)\n\t    return ret;\n\t\n\tret = krb5_padata_add(context, error_method,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      e_data.data, e_data.length);\n\tif (ret)\n\t    return ret;\n    }\n\n    if (error_method && error_method->len) {\n\tASN1_MALLOC_ENCODE(METHOD_DATA, e_data.data, e_data.length, \n\t\t\t   error_method, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (e_data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n    }\n    \n    ret = krb5_mk_error_ext(context,\n\t\t\t    outer_error,\n\t\t\t    e_text,\n\t\t\t    (e_data.length ? &e_data : NULL),\n\t\t\t    error_server,\n\t\t\t    error_client_name,\n\t\t\t    error_client_realm,\n\t\t\t    csec,\n\t\t\t    cusec,\n\t\t\t    error_msg);\n    krb5_data_free(&e_data);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            "0,",
            "tgs-req: sending error: %d to client\",",
            "et)"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock(",
          "args": [
            "ontext,",
            "eplykey)"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "ata)"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gs_build_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "eq,",
            "req->req_body,",
            "rbtgt,",
            "rbtgt_etype,",
            "eplykey,",
            "k_is_subkey,",
            "icket,",
            "ata,",
            "rom,",
            "e_text,",
            "auth_data,",
            "rom_addr)"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "gs_build_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "1493-2367",
          "snippet": "tatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "eq,",
            "i,",
            "RB5_PADATA_FX_FAST)"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gs_parse_request(",
          "args": [
            "ontext,",
            "onfig,",
            "req->req_body,",
            "gs_req,",
            "krbtgt,",
            "krbtgt_etype,",
            "ticket,",
            "e_text,",
            "rom,",
            "rom_addr,",
            "csec,",
            "cusec,",
            "auth_data,",
            "replykey,",
            "rk_is_subkey)"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "gs_parse_request(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "1131-1415",
          "snippet": "tatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_tgs_rep(krb5_context context,\n\t     krb5_kdc_configuration *config,\n\t     KDC_REQ *req,\n\t     krb5_data *data,\n\t     const char *from,\n\t     struct sockaddr *from_addr,\n\t     int datagram_reply)\n{\n    AuthorizationData *auth_data = NULL;\n    krb5_error_code ret;\n    int i = 0;\n    const PA_DATA *tgs_req;\n\n    hdb_entry_ex *krbtgt = NULL;\n    krb5_ticket *ticket = NULL;\n    const char *e_text = NULL;\n    krb5_enctype krbtgt_etype = ETYPE_NULL;\n\n    krb5_keyblock *replykey = NULL;\n    int rk_is_subkey = 0;\n    time_t *csec = NULL;\n    int *cusec = NULL;\n\n    if(req->padata == NULL){\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED; /* XXX ??? */\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-DATA\", from);\n\tgoto out;\n    }\n\n    tgs_req = _kdc_find_padata(req, &i, KRB5_PADATA_TGS_REQ);\n\n    if(tgs_req == NULL){\n\tret = KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ from %s without PA-TGS-REQ\", from);\n\tgoto out;\n    }\n    ret = tgs_parse_request(context, config,\n\t\t\t    &req->req_body, tgs_req,\n\t\t\t    &krbtgt,\n\t\t\t    &krbtgt_etype,\n\t\t\t    &ticket,\n\t\t\t    &e_text,\n\t\t\t    from, from_addr,\n\t\t\t    &csec, &cusec,\n\t\t\t    &auth_data,\n\t\t\t    &replykey,\n\t\t\t    &rk_is_subkey);\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* kdc_log() is called in tgs_parse_request() */\n\tgoto out;\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed parsing TGS-REQ from %s\", from);\n\tgoto out;\n    }\n\n    {\n\tconst PA_DATA *pa = _kdc_find_padata(req, &i, KRB5_PADATA_FX_FAST);\n\tif (pa)\n\t    kdc_log(context, config, 10, \"Got TGS FAST request\"); \n    }\n\n\n    ret = tgs_build_reply(context,\n\t\t\t  config,\n\t\t\t  req,\n\t\t\t  &req->req_body,\n\t\t\t  krbtgt,\n\t\t\t  krbtgt_etype,\n\t\t\t  replykey,\n\t\t\t  rk_is_subkey,\n\t\t\t  ticket,\n\t\t\t  data,\n\t\t\t  from,\n\t\t\t  &e_text,\n\t\t\t  &auth_data,\n\t\t\t  from_addr);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\"Failed building TGS-REP to %s\", from);\n\tgoto out;\n    }\n\n    /* */\n    if (datagram_reply && data->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(data);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\te_text = \"Reply packet too large\";\n    }\n\nout:\n    if (replykey)\n\tkrb5_free_keyblock(context, replykey);\n\n    if(ret && ret != HDB_ERR_NOT_FOUND_HERE && data->data == NULL){\n\t/* XXX add fast wrapping on the error */\n\tMETHOD_DATA error_method = { 0, NULL };\n\t\n\n\tkdc_log(context, config, 10, \"tgs-req: sending error: %d to client\", ret);\n\tret = _kdc_fast_mk_error(context, NULL,\n\t\t\t\t &error_method,\n\t\t\t\t NULL,\n\t\t\t\t NULL,\n\t\t\t\t ret, NULL,\n\t\t\t\t NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t csec, cusec,\n\t\t\t\t data);\n\tfree_METHOD_DATA(&error_method);\n    }\n    free(csec);\n    free(cusec);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if(krbtgt)\n\t_kdc_free_ent(context, krbtgt);\n\n    if (auth_data) {\n\tfree_AuthorizationData(auth_data);\n\tfree(auth_data);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "gs_build_reply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "1493-2367",
    "snippet": "tatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_EncTicketPart(",
          "args": [
            "adtkt)"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_METHOD_DATA(",
          "args": [
            "enc_pa_data)"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ef_realm)"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rbtgt_out_principal)"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_free_ent(",
          "args": [
            "ontext,",
            "4u2self_impersonated_client)"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_free_ent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "163-168",
          "snippet": "oid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_free_ent(krb5_context context, hdb_entry_ex *ent)\n{\n    hdb_free_entry (context, ent);\n    free (ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_keyblock_contents(",
          "args": [
            "ontext,",
            "sessionkey)"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "rspac)"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_capath(",
          "args": [
            "ontext,",
            "apath)"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "rbtgt_out_n)"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gs_make_reply(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "p,",
            "gt,",
            "eplykey,",
            "k_is_subkey,",
            "key,",
            "sessionkey,",
            "vno,",
            "auth_data,",
            "erver,",
            "sp,",
            "pn,",
            "lient,",
            "p,",
            "rbtgt_out,",
            "key_sign->key.keytype,",
            "pp,",
            "rspac,",
            "enc_pa_data,",
            "_text,",
            "eply)"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "gs_make_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "723-1011",
          "snippet": "tatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Add server referral METHOD-DATA failed\")"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "pa.padata_value)"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_METHOD_DATA(",
          "args": [
            "enc_pa_data,",
            "pa)"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uild_server_referral(",
          "args": [
            "ontext,",
            "onfig,",
            "rypto,",
            "ef_realm,",
            "ULL,",
            ",",
            "pa.padata_value)"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "uild_server_referral(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "1417-1491",
          "snippet": "tatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "sessionkey,",
            ",",
            "crypto)"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_check_addresses(",
          "args": [
            "ontext,",
            "onfig,",
            "gt->caddr,",
            "rom_addr)"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_check_addresses(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1431-1470",
          "snippet": "rb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "rbtgt->entry.principal,",
            "erver->entry.principal)"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_check_flags(",
          "args": [
            "ontext,",
            "onfig,",
            "lient,",
            "pn,",
            "erver,",
            "pn,",
            "ALSE)"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "dc_check_flags(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1296-1423",
          "snippet": "rb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_KRB5SignedPath(",
          "args": [
            "ontext,",
            "onfig,",
            "rbtgt,",
            "p,",
            "adtkt,",
            "ULL,",
            "ad_signedpath)"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "heck_KRB5SignedPath(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "186-273",
          "snippet": "tatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_PAC(",
          "args": [
            "ontext,",
            "onfig,",
            "p,",
            "p,",
            "lient,",
            "erver,",
            "rbtgt,",
            "clientkey->key,",
            "key,",
            "tkey_sign->key,",
            "adtkt,",
            "rspac,",
            "ad_signedpath)"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "heck_PAC(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "279-367",
          "snippet": "tatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "rspac)"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erify_flags(",
          "args": [
            "ontext,",
            "onfig,",
            "adtkt,",
            "pn)"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_constrained_delegation(",
          "args": [
            "ontext,",
            "onfig,",
            "lientdb,",
            "lient,",
            "erver,",
            "p)"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "heck_constrained_delegation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "505-556",
          "snippet": "tatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "dpn)"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "dp,",
            "->sname,",
            "->realm)"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "tpn)"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "tp,",
            "dtkt.cname,",
            "dtkt.crealm)"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_ticket(",
          "args": [
            "ontext,",
            ",",
            "clientkey->key,",
            "adtkt,",
            ")"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "client->entry,",
            "db_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),",
            "->enc_part.etype,",
            "clientkey)"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_kvno2keys(",
          "args": [
            "ontext,",
            "client->entry,",
            "->enc_part.kvno ? * t->enc_part.kvno : 0)"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_s4u2self(",
          "args": [
            "ontext,",
            "onfig,",
            "lientdb,",
            "lient,",
            "p)"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "heck_s4u2self(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "565-586",
          "snippet": "tatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_pac_free(",
          "args": [
            "ontext,",
            ")"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pac_sign(",
          "args": [
            "ontext,",
            ",",
            "icket->ticket.authtime,",
            "4u2self_impersonated_client->entry.principal,",
            "key,",
            "tkey_sign->key,",
            "rspac)"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_pac_generate(",
          "args": [
            "ontext,",
            "4u2self_impersonated_client,",
            "p)"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pac_generate(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
          "lines": "74-90",
          "snippet": "rb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int have_plugin = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "p,",
            "DB_F_GET_CLIENT | flags,",
            "ULL,",
            "s4u2self_impersonated_clientdb,",
            "s4u2self_impersonated_client)"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "rspac)"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "tpn)"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_S4U2Self(",
          "args": [
            "self)"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "tp,",
            "elf.name,",
            "elf.realm)"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_S4U2Self(",
          "args": [
            "self)"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "datack)"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_checksum(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_OTHER_CKSUM,",
            "atack.data,",
            "atack.length,",
            "self.cksum)"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "datack)"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_S4U2Self(",
          "args": [
            "self)"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "tgt->key,",
            ",",
            "crypto)"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_s4u2self_to_checksumdata(",
          "args": [
            "ontext,",
            "self,",
            "datack)"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_PA_S4U2Self(",
          "args": [
            "data->padata_value.data,",
            "data->padata_value.length,",
            "self,",
            "ULL)"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_find_padata(",
          "args": [
            "eq,",
            "i,",
            "RB5_PADATA_FOR_USER)"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_padata(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "71-83",
          "snippet": "onst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nonst PA_DATA*\n_kdc_find_padata(const KDC_REQ *req, int *start, int type)\n{\n    if (req->padata == NULL)\n\treturn NULL;\n\n    while((size_t)*start < req->padata->len){\n\t(*start)++;\n\tif(req->padata->val[*start - 1].padata_type == (unsigned)type)\n\t    return &req->padata->val[*start - 1];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rb5_principal_get_realm(context, cp),",
            "rbtgt_realm)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "rbtgt_out->entry.principal)"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "krbtgt_out->entry,",
            "ULL,",
            "key_sign->key.keytype,",
            "tkey_sign)"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_get_preferred_key(",
          "args": [
            "ontext,",
            "onfig,",
            "rbtgt_out,",
            "rbtgt_out_n,",
            "ULL,",
            "tkey_sign)"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_get_preferred_key(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "175-220",
          "snippet": "rb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_get_preferred_key(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       hdb_entry_ex *h,\n\t\t       const char *name,\n\t\t       krb5_enctype *enctype,\n\t\t       Key **key)\n{\n    krb5_error_code ret;\n    int i;\n\n    if (config->use_strongest_server_key) {\n\tconst krb5_enctype *p = krb5_kerberos_enctypes(context);\n\n\tfor (i = 0; p[i] != (krb5_enctype)ETYPE_NULL; i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, p[i]))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL, p[i], key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = p[i];\n\t    return 0;\n\t}\n    } else {\n\t*key = NULL;\n\n\tfor (i = 0; i < h->entry.keys.len; i++) {\n\t    if (krb5_enctype_valid(context, h->entry.keys.val[i].key.keytype) != 0 &&\n\t\t!_kdc_is_weak_exception(h->entry.principal, h->entry.keys.val[i].key.keytype))\n\t\tcontinue;\n\t    ret = hdb_enctype2key(context, &h->entry, NULL,\n\t\t\t\t  h->entry.keys.val[i].key.keytype, key);\n\t    if (ret != 0)\n\t\tcontinue;\n\t    if (enctype != NULL)\n\t\t*enctype = (*key)->key.keytype;\n\t    return 0;\n\t}\n    }\n\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   \"No valid kerberos key found for %s\", name);\n    return EINVAL; /* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tpn)"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rbtgt_out->entry.principal,",
            "ktpn)"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "rb5_principal_get_realm(context, server->entry.principal),",
            "rb5_principal_get_realm(context, krbtgt_out->entry.principal))"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "rbtgt_out->entry.principal)"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "erver->entry.principal)"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tpn)"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rbtgt->entry.principal,",
            "ktpn)"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rbtgt_out_principal,",
            "krbtgt_out_n)"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "krbtgt_out_principal,",
            "ur_realm,",
            "RB5_TGS_NAME,",
            "ur_realm,",
            "ULL)"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "krbtgt->entry,",
            "ULL,",
            "* XXX use the right kvno! */\nrbtgt_etype,",
            "tkey_check)"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_generate_random_keyblock(",
          "args": [
            "ontext,",
            "type,",
            "sessionkey)"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_find_etype(",
          "args": [
            "ontext,",
            "rb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key,",
            "ALSE,",
            "erver,",
            "->etype.val,",
            "->etype.len,",
            "etype,",
            "ULL)"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_find_etype(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "125-246",
          "snippet": "rb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n\n    if (enctype == (krb5_enctype)ETYPE_NULL) {\n        /*\n         * if the service principal is one for which there is a known 1DES\n         * exception and no other enctype matches both the client request and\n         * the service key list, provide a DES-CBC-CRC key.\n         */\n\tif (ret_key == NULL &&\n\t    _kdc_is_weak_exception(princ->entry.principal, ETYPE_DES_CBC_CRC)) {\n            ret = 0;\n            enctype = ETYPE_DES_CBC_CRC;\n        } else {\n            ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n        }\n    }\n\n    if (ret == 0) {\n\tif (ret_enctype != NULL)\n\t    *ret_enctype = enctype;\n\tif (ret_key != NULL)\n\t    *ret_key = key;\n    }\n\n    krb5_free_salt (context, def_salt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_is_krbtgt(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_host_realm(",
          "args": [
            "ontext,",
            "ealms)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_host_realm(",
          "args": [
            "ontext,",
            "ealms)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "ealms[0])"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ef_realm)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_host_realm(",
          "args": [
            "ontext,",
            "ealms)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "spn)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "sp,",
            ",",
            "RB5_TGS_NAME,",
            "ealms[0],",
            "ULL)"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "ealms[0],",
            "p->realm)"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eed_referral(",
          "args": [
            "ontext,",
            "onfig,",
            "b->kdc_options,",
            "p,",
            "realms)"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "eed_referral(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "1093-1129",
          "snippet": "tatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "spn)"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "sp,",
            ",",
            "RB5_TGS_NAME,",
            "ef_realm,",
            "ULL)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enomem(",
          "args": [
            "ontext)"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "ew_rlm)"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ef_realm)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_find_capath(",
          "args": [
            "ontext,",
            "gt->crealm,",
            "ur_realm,",
            "eq_rlm,",
            "RUE,",
            "capath,",
            "num_capath)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_krbtgt_realm(",
          "args": [
            "sp->name)"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "et_krbtgt_realm(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "40-48",
          "snippet": "tatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "spn)"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "pn)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_make_principal(",
          "args": [
            "ontext,",
            "sp,",
            ",",
            "RB5_TGS_NAME,",
            "ef_realm,",
            "ULL)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "p)"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enomem(",
          "args": [
            "ontext)"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "erver->entry.principal->realm)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ef_realm)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nparse_flags",
          "args": [
            "DCOptions2int(b->kdc_options),",
            "sn1_KDCOptions_units(),",
            "pt_str,",
            "izeof(opt_str))"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sn1_KDCOptions_units(",
          "args": [],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DCOptions2int(",
          "args": [
            "->kdc_options)"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "cpn)"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "cp,",
            "gt->cname,",
            "gt->crealm)"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "p,",
            "spn)"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "sp,",
            "s,",
            ")"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erify_flags(",
          "args": [
            "ontext,",
            "onfig,",
            "adtkt,",
            "pn)"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_ticket(",
          "args": [
            "ontext,",
            ",",
            "uukey->key,",
            "adtkt,",
            ")"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "uu->entry,",
            "ULL,",
            "->enc_part.etype,",
            "uukey)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            ")"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "p,",
            "->sname,",
            "->realm)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "enc_pa_data,",
            ",",
            "izeof(enc_pa_data))"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_zero(",
          "args": [
            "rspac)"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "adtkt,",
            ",",
            "izeof(adtkt))"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "sessionkey,",
            ",",
            "izeof(sessionkey))"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_comp_string(",
          "args": [
            "ontext,",
            "rbtgt->entry.principal,",
            ")"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_build_reply(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ *req,\n\t\tKDC_REQ_BODY *b,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_enctype krbtgt_etype,\n\t\tconst krb5_keyblock *replykey,\n\t\tint rk_is_subkey,\n\t\tkrb5_ticket *ticket,\n\t\tkrb5_data *reply,\n\t\tconst char *from,\n\t\tconst char **e_text,\n\t\tAuthorizationData **auth_data,\n\t\tconst struct sockaddr *from_addr)\n{\n    krb5_error_code ret;\n    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;\n    krb5_principal krbtgt_out_principal = NULL;\n    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;\n    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;\n    HDB *clientdb, *s4u2self_impersonated_clientdb;\n    krb5_realm ref_realm = NULL;\n    EncTicketPart *tgt = &ticket->ticket;\n    krb5_principals spp = NULL;\n    const EncryptionKey *ekey;\n    krb5_keyblock sessionkey;\n    krb5_kvno kvno;\n    krb5_data rspac;\n    const char *our_realm = /* Realm of this KDC */\n        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);\n    char **capath = NULL;\n    size_t num_capath = 0;\n\n    hdb_entry_ex *krbtgt_out = NULL;\n\n    METHOD_DATA enc_pa_data;\n\n    PrincipalName *s;\n    Realm r;\n    EncTicketPart adtkt;\n    char opt_str[128];\n    int signedpath = 0;\n\n    Key *tkey_check;\n    Key *tkey_sign;\n    int flags = HDB_F_FOR_TGS_REQ;\n\n    memset(&sessionkey, 0, sizeof(sessionkey));\n    memset(&adtkt, 0, sizeof(adtkt));\n    krb5_data_zero(&rspac);\n    memset(&enc_pa_data, 0, sizeof(enc_pa_data));\n\n    s = b->sname;\n    r = b->realm;\n\n    /* \n     * Always to do CANON, see comment below about returned server principal (rsp).\n     */\n    flags |= HDB_F_CANON;\n\n    if(b->kdc_options.enc_tkt_in_skey){\n\tTicket *t;\n\thdb_entry_ex *uu;\n\tkrb5_principal p;\n\tKey *uukey;\n\tkrb5uint32 second_kvno = 0;\n\tkrb5uint32 *kvno_ptr = NULL;\n\n\tif(b->additional_tickets == NULL ||\n\t   b->additional_tickets->len == 0){\n\t    ret = KRB5KDC_ERR_BADOPTION; /* ? */\n\t    kdc_log(context, config, 0,\n\t\t    \"No second ticket present in request\");\n\t    goto out;\n\t}\n\tt = &b->additional_tickets->val[0];\n\tif(!get_krbtgt_realm(&t->sname)){\n\t    kdc_log(context, config, 0,\n\t\t    \"Additional ticket is not a ticket-granting ticket\");\n\t    ret = KRB5KDC_ERR_POLICY;\n\t    goto out;\n\t}\n\t_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);\n\tif(t->enc_part.kvno){\n\t    second_kvno = *t->enc_part.kvno;\n\t    kvno_ptr = &second_kvno;\n\t}\n\tret = _kdc_db_fetch(context, config, p,\n\t\t\t    HDB_F_GET_KRBTGT, kvno_ptr,\n\t\t\t    NULL, &uu);\n\tkrb5_free_principal(context, p);\n\tif(ret){\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n\tret = hdb_enctype2key(context, &uu->entry, NULL,\n\t\t\t      t->enc_part.etype, &uukey);\n\tif(ret){\n\t    _kdc_free_ent(context, uu);\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\tret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);\n\t_kdc_free_ent(context, uu);\n\tif(ret)\n\t    goto out;\n\n\tret = verify_flags(context, config, &adtkt, spn);\n\tif (ret)\n\t    goto out;\n\n\ts = &adtkt.cname;\n\tr = adtkt.crealm;\n    }\n\n    _krb5_principalname2krb5_principal(context, &sp, *s, r);\n    ret = krb5_unparse_name(context, sp, &spn);\n    if (ret)\n\tgoto out;\n    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);\n    ret = krb5_unparse_name(context, cp, &cpn);\n    if (ret)\n\tgoto out;\n    unparse_flags (KDCOptions2int(b->kdc_options),\n\t\t   asn1_KDCOptions_units(),\n\t\t   opt_str, sizeof(opt_str));\n    if(*opt_str)\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s [%s]\",\n\t\tcpn, from, spn, opt_str);\n    else\n\tkdc_log(context, config, 0,\n\t\t\"TGS-REQ %s from %s for %s\", cpn, from, spn);\n\n    /*\n     * Fetch server\n     */\n\nserver_lookup:\n    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,\n\t\t\tNULL, NULL, &server);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\", sp);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n        free(ref_realm);\n\tref_realm = strdup(server->entry.principal->realm);\n\tif (ref_realm == NULL) {\n            ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 5,\n\t\t\"Returning a referral to realm %s for \"\n\t\t\"server %s.\",\n\t\tref_realm, spn);\n\tkrb5_free_principal(context, sp);\n\tsp = NULL;\n\tret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t  ref_realm, NULL);\n\tif (ret)\n\t    goto out;\n\tfree(spn);\n        spn = NULL;\n\tret = krb5_unparse_name(context, sp, &spn);\n\tif (ret)\n\t    goto out;\n\n\tgoto server_lookup;\n    } else if (ret) {\n\tconst char *new_rlm, *msg;\n\tRealm req_rlm;\n\tkrb5_realm *realms;\n\n\tif ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {\n            if (capath == NULL) {\n                /* With referalls, hierarchical capaths are always enabled */\n                ret = _krb5_find_capath(context, tgt->crealm, our_realm,\n                                        req_rlm, TRUE, &capath, &num_capath);\n                if (ret)\n                    goto out;\n            }\n            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;\n            if (new_rlm) {\n                kdc_log(context, config, 5, \"krbtgt from %s via %s for \"\n                        \"realm %s not found, trying %s\", tgt->crealm,\n                        our_realm, req_rlm, new_rlm);\n\n                free(ref_realm);\n                ref_realm = strdup(new_rlm);\n                if (ref_realm == NULL) {\n                    ret = krb5_enomem(context);\n                    goto out;\n                }\n\n                krb5_free_principal(context, sp);\n                sp = NULL;\n                krb5_make_principal(context, &sp, r,\n                                    KRB5_TGS_NAME, ref_realm, NULL);\n                free(spn);\n                spn = NULL;\n                ret = krb5_unparse_name(context, sp, &spn);\n                if (ret)\n                    goto out;\n                goto server_lookup;\n            }\n\t} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {\n\t    if (strcmp(realms[0], sp->realm) != 0) {\n\t\tkdc_log(context, config, 5,\n\t\t\t\"Returning a referral to realm %s for \"\n\t\t\t\"server %s that was not found\",\n\t\t\trealms[0], spn);\n\t\tkrb5_free_principal(context, sp);\n                sp = NULL;\n\t\tkrb5_make_principal(context, &sp, r, KRB5_TGS_NAME,\n\t\t\t\t    realms[0], NULL);\n\t\tfree(spn);\n                spn = NULL;\n\t\tret = krb5_unparse_name(context, sp, &spn);\n\t\tif (ret) {\n\t\t    krb5_free_host_realm(context, realms);\n\t\t    goto out;\n\t\t}\n\n                free(ref_realm);\n\t\tref_realm = strdup(realms[0]);\n\n\t\tkrb5_free_host_realm(context, realms);\n\t\tgoto server_lookup;\n\t    }\n\t    krb5_free_host_realm(context, realms);\n\t}\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Server not found in database: %s: %s\", spn, msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == HDB_ERR_NOENTRY)\n\t    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /* the name returned to the client depend on what was asked for,\n     * return canonical name if kdc_options.canonicalize was set, the\n     * client wants the true name of the principal, if not it just\n     * wants the name its asked for.\n     */\n\n    if (b->kdc_options.canonicalize)\n\trsp = server->entry.principal;\n    else\n\trsp = sp;\n\n\n    /*\n     * Select enctype, return key and kvno.\n     */\n\n    {\n\tkrb5_enctype etype;\n\n\tif(b->kdc_options.enc_tkt_in_skey) {\n\t    size_t i;\n\t    ekey = &adtkt.key;\n\t    for(i = 0; i < b->etype.len; i++)\n\t\tif (b->etype.val[i] == adtkt.key.keytype)\n\t\t    break;\n\t    if(i == b->etype.len) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Addition ticket have not matching etypes\");\n\t\tkrb5_clear_error_message(context);\n\t\tret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\t\tgoto out;\n\t    }\n\t    etype = b->etype.val[i];\n\t    kvno = 0;\n\t} else {\n\t    Key *skey;\n\n\t    ret = _kdc_find_etype(context,\n\t\t\t\t  krb5_principal_is_krbtgt(context, sp) ?\n\t\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t\t  server, b->etype.val, b->etype.len, &etype,\n\t\t\t\t  NULL);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no support for etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ret = _kdc_get_preferred_key(context, config, server, spn,\n\t\t\t\t\t NULL, &skey);\n\t    if(ret) {\n\t\tkdc_log(context, config, 0,\n\t\t\t\"Server (%s) has no supported etypes\", spn);\n\t\tgoto out;\n\t    }\n\t    ekey = &skey->key;\n\t    kvno = server->entry.kvno;\n\t}\n\n\tret = krb5_generate_random_keyblock(context, etype, &sessionkey);\n\tif (ret)\n\t    goto out;\n    }\n\n    /*\n     * Check that service is in the same realm as the krbtgt. If it's\n     * not the same, it's someone that is using a uni-directional trust\n     * backward.\n     */\n\n    /*\n     * Validate authoriation data\n     */\n\n    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use the right kvno! */\n\t\t\t  krbtgt_etype, &tkey_check);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC check\");\n\tgoto out;\n    }\n\n    /* \n     * Now refetch the primary krbtgt, and get the current kvno (the\n     * sign check may have been on an old kvno, and the server may\n     * have been an incoming trust)\n     */\n    \n    ret = krb5_make_principal(context,\n                              &krbtgt_out_principal,\n                              our_realm,\n                              KRB5_TGS_NAME,\n                              our_realm,\n                              NULL);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);\n    if (ret) {\n        kdc_log(context, config, 0,\n                \"Failed to make krbtgt principal name object for \"\n                \"authz-data signatures\");\n        goto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,\n\t\t\tHDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);\n    if (ret) {\n\tchar *ktpn = NULL;\n\tret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"No such principal %s (needed for authz-data signature keys) \"\n\t\t\"while processing TGS-REQ for service %s with krbtg %s\",\n\t\tkrbtgt_out_n, spn, (ret == 0) ? ktpn : \"<unknown>\");\n\tfree(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    /* \n     * The first realm is the realm of the service, the second is\n     * krbtgt/<this>/@REALM component of the krbtgt DN the request was\n     * encrypted to.  The redirection via the krbtgt_out entry allows\n     * the DB to possibly correct the case of the realm (Samba4 does\n     * this) before the strcmp() \n     */\n    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),\n\t       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {\n\tchar *ktpn;\n\tret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);\n\tkdc_log(context, config, 0,\n\t\t\"Request with wrong krbtgt: %s\",\n\t\t(ret == 0) ? ktpn : \"<unknown>\");\n\tif(ret == 0)\n\t    free(ktpn);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,\n\t\t\t\t NULL, &tkey_sign);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,\n\t\t\t  tkey_sign->key.keytype, &tkey_sign);\n    if(ret) {\n\tkdc_log(context, config, 0,\n\t\t    \"Failed to find key for krbtgt PAC signature\");\n\tgoto out;\n    }\n\n    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,\n\t\t\tNULL, &clientdb, &client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* This is OK, we are just trying to find out if they have\n\t * been disabled or deleted in the meantime, missing secrets\n\t * is OK */\n    } else if(ret){\n\tconst char *krbtgt_realm, *msg;\n\n\t/*\n\t * If the client belongs to the same realm as our krbtgt, it\n\t * should exist in the local database.\n\t *\n\t */\n\n\tkrbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);\n\n\tif(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {\n\t    if (ret == HDB_ERR_NOENTRY)\n\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    kdc_log(context, config, 1, \"Client no longer in database: %s\",\n\t\t    cpn);\n\t    goto out;\n\t}\n\n\tmsg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 1, \"Client not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n    }\n\n    ret = check_PAC(context, config, cp, NULL,\n\t\t    client, server, krbtgt,\n\t\t    &tkey_check->key,\n\t\t    ekey, &tkey_sign->key,\n\t\t    tgt, &rspac, &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"Verify PAC failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /* also check the krbtgt for signature */\n    ret = check_KRB5SignedPath(context,\n\t\t\t       config,\n\t\t\t       krbtgt,\n\t\t\t       cp,\n\t\t\t       tgt,\n\t\t\t       &spp,\n\t\t\t       &signedpath);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0,\n\t\t\"KRB5SignedPath check failed for %s (%s) from %s with %s\",\n\t\tspn, cpn, from, msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    /*\n     * Process request\n     */\n\n    /* by default the tgt principal matches the client principal */\n    tp = cp;\n    tpn = cpn;\n\n    if (client) {\n\tconst PA_DATA *sdata;\n\tint i = 0;\n\n\tsdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);\n\tif (sdata) {\n\t    krb5_crypto crypto;\n\t    krb5_data datack;\n\t    PA_S4U2Self self;\n\t    const char *str;\n\n\t    ret = decode_PA_S4U2Self(sdata->padata_value.data,\n\t\t\t\t     sdata->padata_value.length,\n\t\t\t\t     &self, NULL);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"Failed to decode PA-S4U2Self\");\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkrb5_data_free(&datack);\n\t\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = krb5_verify_checksum(context,\n\t\t\t\t       crypto,\n\t\t\t\t       KRB5_KU_OTHER_CKSUM,\n\t\t\t\t       datack.data,\n\t\t\t\t       datack.length,\n\t\t\t\t       &self.cksum);\n\t    krb5_data_free(&datack);\n\t    krb5_crypto_destroy(context, crypto);\n\t    if (ret) {\n\t\tconst char *msg = krb5_get_error_message(context, ret);\n\t\tfree_PA_S4U2Self(&self);\n\t\tkdc_log(context, config, 0,\n\t\t\t\"krb5_verify_checksum failed for S4U2Self: %s\", msg);\n\t\tkrb5_free_error_message(context, msg);\n\t\tgoto out;\n\t    }\n\n\t    ret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t     &tp,\n\t\t\t\t\t\t     self.name,\n\t\t\t\t\t\t     self.realm);\n\t    free_PA_S4U2Self(&self);\n\t    if (ret)\n\t\tgoto out;\n\n\t    ret = krb5_unparse_name(context, tp, &tpn);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /* If we were about to put a PAC into the ticket, we better fix it to be the right PAC */\n\t    if(rspac.data) {\n\t\tkrb5_pac p = NULL;\n\t\tkrb5_data_free(&rspac);\n\t\tret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,\n\t\t\t\t    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);\n\t\tif (ret) {\n\t\t    const char *msg;\n\n\t\t    /*\n\t\t     * If the client belongs to the same realm as our krbtgt, it\n\t\t     * should exist in the local database.\n\t\t     *\n\t\t     */\n\n\t\t    if (ret == HDB_ERR_NOENTRY)\n\t\t\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t\t    msg = krb5_get_error_message(context, ret);\n\t\t    kdc_log(context, config, 1,\n\t\t\t    \"S2U4Self principal to impersonate %s not found in database: %s\",\n\t\t\t    tpn, msg);\n\t\t    krb5_free_error_message(context, msg);\n\t\t    goto out;\n\t\t}\n\t\tret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);\n\t\tif (ret) {\n\t\t    kdc_log(context, config, 0, \"PAC generation failed for -- %s\",\n\t\t\t    tpn);\n\t\t    goto out;\n\t\t}\n\t\tif (p != NULL) {\n\t\t    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,\n\t\t\t\t\t s4u2self_impersonated_client->entry.principal,\n\t\t\t\t\t ekey, &tkey_sign->key,\n\t\t\t\t\t &rspac);\n\t\t    krb5_pac_free(context, p);\n\t\t    if (ret) {\n\t\t\tkdc_log(context, config, 0, \"PAC signing failed for -- %s\",\n\t\t\t\ttpn);\n\t\t\tgoto out;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * Check that service doing the impersonating is\n\t     * requesting a ticket to it-self.\n\t     */\n\t    ret = check_s4u2self(context, config, clientdb, client, sp);\n\t    if (ret) {\n\t\tkdc_log(context, config, 0, \"S4U2Self: %s is not allowed \"\n\t\t\t\"to impersonate to service \"\n\t\t\t\"(tried for user %s to service %s)\",\n\t\t\tcpn, tpn, spn);\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * If the service isn't trusted for authentication to\n\t     * delegation, remove the forward flag.\n\t     */\n\n\t    if (client->entry.flags.trusted_for_delegation) {\n\t\tstr = \"[forwardable]\";\n\t    } else {\n\t\tb->kdc_options.forwardable = 0;\n\t\tstr = \"\";\n\t    }\n\t    kdc_log(context, config, 0, \"s4u2self %s impersonating %s to \"\n\t\t    \"service %s %s\", cpn, tpn, spn, str);\n\t}\n    }\n\n    /*\n     * Constrained delegation\n     */\n\n    if (client != NULL\n\t&& b->additional_tickets != NULL\n\t&& b->additional_tickets->len != 0\n\t&& b->kdc_options.enc_tkt_in_skey == 0)\n    {\n\tint ad_signedpath = 0;\n\tKey *clientkey;\n\tTicket *t;\n\n\t/*\n\t * Require that the KDC have issued the service's krbtgt (not\n\t * self-issued ticket with kimpersonate(1).\n\t */\n\tif (!signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Constrained delegation done on service ticket %s/%s\",\n\t\t    cpn, spn);\n\t    goto out;\n\t}\n\n\tt = &b->additional_tickets->val[0];\n\n\tret = hdb_enctype2key(context, &client->entry,\n\t\t\t      hdb_kvno2keys(context, &client->entry,\n\t\t\t\t\t    t->enc_part.kvno ? * t->enc_part.kvno : 0),\n\t\t\t      t->enc_part.etype, &clientkey);\n\tif(ret){\n\t    ret = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */\n\t    goto out;\n\t}\n\n\tret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"failed to decrypt ticket for \"\n\t\t    \"constrained delegation from %s to %s \", cpn, spn);\n\t    goto out;\n\t}\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &tp,\n\t\t\t\t\t\t adtkt.cname,\n\t\t\t\t\t\t adtkt.crealm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, tp, &tpn);\n\tif (ret)\n\t    goto out;\n\n\tret = _krb5_principalname2krb5_principal(context,\n\t\t\t\t\t\t &dp,\n\t\t\t\t\t\t t->sname,\n\t\t\t\t\t\t t->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, dp, &dpn);\n\tif (ret)\n\t    goto out;\n\n\t/* check that ticket is valid */\n\tif (adtkt.flags.forwardable == 0) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Missing forwardable flag on ticket for \"\n\t\t    \"constrained delegation from %s (%s) as %s to %s \",\n\t\t    cpn, dpn, tpn, spn);\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    goto out;\n\t}\n\n\tret = check_constrained_delegation(context, config, clientdb,\n\t\t\t\t\t   client, server, sp);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"constrained delegation from %s (%s) as %s to %s not allowed\",\n\t\t    cpn, dpn, tpn, spn);\n\t    goto out;\n\t}\n\n\tret = verify_flags(context, config, &adtkt, tpn);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkrb5_data_free(&rspac);\n\n\t/*\n\t * generate the PAC for the user.\n\t *\n\t * TODO: pass in t->sname and t->realm and build\n\t * a S4U_DELEGATION_INFO blob to the PAC.\n\t */\n\tret = check_PAC(context, config, tp, dp,\n\t\t\tclient, server, krbtgt,\n\t\t\t&clientkey->key,\n\t\t\tekey, &tkey_sign->key,\n\t\t\t&adtkt, &rspac, &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"Verify delegated PAC failed to %s for client\"\n\t\t    \"%s (%s) as %s from %s with %s\",\n\t\t    spn, cpn, dpn, tpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\t/*\n\t * Check that the KDC issued the user's ticket.\n\t */\n\tret = check_KRB5SignedPath(context,\n\t\t\t\t   config,\n\t\t\t\t   krbtgt,\n\t\t\t\t   cp,\n\t\t\t\t   &adtkt,\n\t\t\t\t   NULL,\n\t\t\t\t   &ad_signedpath);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0,\n\t\t    \"KRB5SignedPath check from service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s failed with %s\",\n\t\t    spn, tpn, dpn, cpn, from, msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\n\tif (!ad_signedpath) {\n\t    ret = KRB5KDC_ERR_BADOPTION;\n\t    kdc_log(context, config, 0,\n\t\t    \"Ticket not signed with PAC nor SignedPath service %s failed \"\n\t\t    \"for delegation to %s for client %s (%s)\"\n\t\t    \"from %s\",\n\t\t    spn, tpn, dpn, cpn, from);\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \"constrained delegation for %s \"\n\t\t\"from %s (%s) to %s\", tpn, cpn, dpn, spn);\n    }\n\n    /*\n     * Check flags\n     */\n\n    ret = kdc_check_flags(context, config,\n\t\t\t  client, cpn,\n\t\t\t  server, spn,\n\t\t\t  FALSE);\n    if(ret)\n\tgoto out;\n\n    if((b->kdc_options.validate || b->kdc_options.renew) &&\n       !krb5_principal_compare(context,\n\t\t\t       krbtgt->entry.principal,\n\t\t\t       server->entry.principal)){\n\tkdc_log(context, config, 0, \"Inconsistent request.\");\n\tret = KRB5KDC_ERR_SERVER_NOMATCH;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tkdc_log(context, config, 0, \"Request from wrong address\");\n\tgoto out;\n    }\n\n    /*\n     * If this is an referral, add server referral data to the\n     * auth_data reply .\n     */\n    if (ref_realm) {\n\tPA_DATA pa;\n\tkrb5_crypto crypto;\n\n\tkdc_log(context, config, 0,\n\t\t\"Adding server referral to %s\", ref_realm);\n\n\tret = krb5_crypto_init(context, &sessionkey, 0, &crypto);\n\tif (ret)\n\t    goto out;\n\n\tret = build_server_referral(context, config, crypto, ref_realm,\n\t\t\t\t    NULL, s, &pa.padata_value);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed building server referral\");\n\t    goto out;\n\t}\n\tpa.padata_type = KRB5_PADATA_SERVER_REFERRAL;\n\n\tret = add_METHOD_DATA(&enc_pa_data, &pa);\n\tkrb5_data_free(&pa.padata_value);\n\tif (ret) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Add server referral METHOD-DATA failed\");\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = tgs_make_reply(context,\n\t\t\t config,\n\t\t\t b,\n\t\t\t tp,\n\t\t\t tgt,\n\t\t\t replykey,\n\t\t\t rk_is_subkey,\n\t\t\t ekey,\n\t\t\t &sessionkey,\n\t\t\t kvno,\n\t\t\t *auth_data,\n\t\t\t server,\n\t\t\t rsp,\n\t\t\t spn,\n\t\t\t client,\n\t\t\t cp,\n\t\t\t krbtgt_out,\n\t\t\t tkey_sign->key.keytype,\n\t\t\t spp,\n\t\t\t &rspac,\n\t\t\t &enc_pa_data,\n\t\t\t e_text,\n\t\t\t reply);\n\nout:\n    if (tpn != cpn)\n\t    free(tpn);\n    free(spn);\n    free(cpn);\n    free(dpn);\n    free(krbtgt_out_n);\n    _krb5_free_capath(context, capath);\n\n    krb5_data_free(&rspac);\n    krb5_free_keyblock_contents(context, &sessionkey);\n    if(krbtgt_out)\n\t_kdc_free_ent(context, krbtgt_out);\n    if(server)\n\t_kdc_free_ent(context, server);\n    if(client)\n\t_kdc_free_ent(context, client);\n    if(s4u2self_impersonated_client)\n\t_kdc_free_ent(context, s4u2self_impersonated_client);\n\n    if (tp && tp != cp)\n\tkrb5_free_principal(context, tp);\n    krb5_free_principal(context, cp);\n    krb5_free_principal(context, dp);\n    krb5_free_principal(context, sp);\n    krb5_free_principal(context, krbtgt_out_principal);\n    free(ref_realm);\n    free_METHOD_DATA(&enc_pa_data);\n\n    free_EncTicketPart(&adtkt);\n\n    return ret;\n}"
  },
  {
    "function_name": "uild_server_referral(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "1417-1491",
    "snippet": "tatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "NOMEM,",
            "malloc: out of memory\")"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_ServerReferralData(",
          "args": [
            "ref)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_EncryptedData(",
          "args": [
            "ed)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "ncryptedData,",
            "utdata->data,",
            "utdata->length,",
            "ed,",
            "size,",
            "et)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_encrypt_EncryptedData(",
          "args": [
            "ontext,",
            "ession,",
            "RB5_KU_PA_SERVER_REFERRAL,",
            "ata.data,",
            "ata.length,",
            "* kvno */,",
            "ed)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_PA_ServerReferralData(",
          "args": [
            "ref)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "A_ServerReferralData,",
            "ata.data,",
            "ata.length,",
            "ref,",
            "size,",
            "et)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_PrincipalName(",
          "args": [
            "equested_principal,",
            "ef.requested_principal_name)"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "ef.requested_principal_name)"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_PrincipalName(",
          "args": [
            "rue_principal_name,",
            "ef.true_principal_name)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "ef.true_principal_name)"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "eferred_realm)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "ef.referred_realm)"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ref,",
            ",",
            "izeof(ref))"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nbuild_server_referral(krb5_context context,\n\t\t      krb5_kdc_configuration *config,\n\t\t      krb5_crypto session,\n\t\t      krb5_const_realm referred_realm,\n\t\t      const PrincipalName *true_principal_name,\n\t\t      const PrincipalName *requested_principal,\n\t\t      krb5_data *outdata)\n{\n    PA_ServerReferralData ref;\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_data data;\n    size_t size = 0;\n\n    memset(&ref, 0, sizeof(ref));\n\n    if (referred_realm) {\n\tALLOC(ref.referred_realm);\n\tif (ref.referred_realm == NULL)\n\t    goto eout;\n\t*ref.referred_realm = strdup(referred_realm);\n\tif (*ref.referred_realm == NULL)\n\t    goto eout;\n    }\n    if (true_principal_name) {\n\tALLOC(ref.true_principal_name);\n\tif (ref.true_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(true_principal_name, ref.true_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n    if (requested_principal) {\n\tALLOC(ref.requested_principal_name);\n\tif (ref.requested_principal_name == NULL)\n\t    goto eout;\n\tret = copy_PrincipalName(requested_principal,\n\t\t\t\t ref.requested_principal_name);\n\tif (ret)\n\t    goto eout;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_ServerReferralData,\n\t\t       data.data, data.length,\n\t\t       &ref, &size, ret);\n    free_PA_ServerReferralData(&ref);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    ret = krb5_encrypt_EncryptedData(context, session,\n\t\t\t\t     KRB5_KU_PA_SERVER_REFERRAL,\n\t\t\t\t     data.data, data.length,\n\t\t\t\t     0 /* kvno */, &ed);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData,\n\t\t       outdata->data, outdata->length,\n\t\t       &ed, &size, ret);\n    free_EncryptedData(&ed);\n    if (ret)\n\treturn ret;\n    if (outdata->length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n    return 0;\neout:\n    free_PA_ServerReferralData(&ref);\n    krb5_set_error_message(context, ENOMEM, \"malloc: out of memory\");\n    return ENOMEM;\n}"
  },
  {
    "function_name": "gs_parse_request(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "1131-1415",
    "snippet": "tatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_AP_REQ(",
          "args": [
            "ap_req)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Failed to decode authorization data\")"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "auth_data)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_AuthorizationData(",
          "args": [
            "d.data,",
            "d.length,",
            "auth_data,",
            "ULL)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "auth_data)"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decrypt_EncryptedData",
          "args": [
            "ontext,",
            "rypto,",
            "sage,",
            "->enc_authorization_data,",
            "ad)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "ubkey,",
            ",",
            "crypto)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_getkey(",
          "args": [
            "ontext,",
            "c,",
            "subkey)"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_getremotesubkey(",
          "args": [
            "ontext,",
            "c,",
            "subkey)"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_free(",
          "args": [
            "ontext,",
            "c)"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gs_check_authenticator(",
          "args": [
            "ontext,",
            "onfig,",
            "c,",
            ",",
            "_text,",
            "(*ticket)->ticket.key)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_authenticator(",
          "args": [
            "ontext,",
            "auth)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_authenticator(",
          "args": [
            "ontext,",
            "auth)"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(**cusec))"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_authenticator(",
          "args": [
            "ontext,",
            "auth)"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(**csec))"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_auth_con_getauthenticator(",
          "args": [
            "ontext,",
            "c,",
            "auth)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rinc)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_ap_req2(",
          "args": [
            "ontext,",
            "ac,",
            "ap_req,",
            "rinc,",
            "tkey->key,",
            "erify_ap_req_flags,",
            "ap_req_options,",
            "icket,",
            "RB5_KU_TGS_REQ_AUTH)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "tr)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rinc,",
            "p)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_to_string(",
          "args": [
            "ontext,",
            "p_req.ticket.enc_part.etype,",
            "str)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "(*krbtgt)->entry,",
            "rbtgt_keys,",
            "p_req.ticket.enc_part.etype,",
            "tkey)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_kvno2keys(",
          "args": [
            "ontext,",
            "(*krbtgt)->entry,",
            "rbtgt_kvno_try)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rinc)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rinc,",
            "p)"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rinc)"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rinc,",
            "p)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rinc)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rinc,",
            "p)"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            ")"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_free_principal(",
          "args": [
            "ontext,",
            "rinc)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_unparse_name(",
          "args": [
            "ontext,",
            "rinc,",
            "p)"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_db_fetch(",
          "args": [
            "ontext,",
            "onfig,",
            "rinc,",
            "DB_F_GET_KRBTGT,",
            "krbtgt_kvno,",
            "ULL,",
            "rbtgt)"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_db_fetch(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/misc.c",
          "lines": "54-161",
          "snippet": "rb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_db_fetch(krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      krb5_const_principal principal,\n\t      unsigned flags,\n\t      krb5uint32 *kvno_ptr,\n\t      HDB **db,\n\t      hdb_entry_ex **h)\n{\n    hdb_entry_ex *ent = NULL;\n    krb5_error_code ret = HDB_ERR_NOENTRY;\n    int i;\n    unsigned kvno = 0;\n    krb5_principal enterprise_principal = NULL;\n    krb5_const_principal princ;\n\n    *h = NULL;\n\n    if (!name_type_ok(context, config, principal))\n        goto out2;\n\n    if (kvno_ptr != NULL && *kvno_ptr != 0) {\n\tkvno = *kvno_ptr;\n\tflags |= HDB_F_KVNO_SPECIFIED;\n    } else {\n\tflags |= HDB_F_ALL_KVNOS;\n    }\n\n    ent = calloc(1, sizeof (*ent));\n    if (ent == NULL)\n        return krb5_enomem(context);\n\n    if (principal->name.name_type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        if (principal->name.name_string.len != 1) {\n            ret = KRB5_PARSE_MALFORMED;\n            krb5_set_error_message(context, ret,\n                                   \"malformed request: \"\n                                   \"enterprise name with %d name components\",\n                                   principal->name.name_string.len);\n            goto out;\n        }\n        ret = krb5_parse_name(context, principal->name.name_string.val[0],\n                              &enterprise_principal);\n        if (ret)\n            goto out;\n    }\n\n    for (i = 0; i < config->num_db; i++) {\n\tret = config->db[i]->hdb_open(context, config->db[i], O_RDONLY, 0);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    kdc_log(context, config, 0, \"Failed to open database: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    continue;\n\t}\n\n        princ = principal;\n        if (!(config->db[i]->hdb_capability_flags & HDB_CAP_F_HANDLE_ENTERPRISE_PRINCIPAL) && enterprise_principal)\n            princ = enterprise_principal;\n\n\tret = config->db[i]->hdb_fetch_kvno(context,\n\t\t\t\t\t    config->db[i],\n\t\t\t\t\t    princ,\n\t\t\t\t\t    flags | HDB_F_DECRYPT,\n\t\t\t\t\t    kvno,\n\t\t\t\t\t    ent);\n\tconfig->db[i]->hdb_close(context, config->db[i]);\n\n\tswitch (ret) {\n\tcase HDB_ERR_WRONG_REALM:\n\t    /*\n\t     * the ent->entry.principal just contains hints for the client\n\t     * to retry. This is important for enterprise principal routing\n\t     * between trusts.\n\t     */\n\t    /* fall through */\n\tcase 0:\n\t    if (db)\n\t\t*db = config->db[i];\n\t    *h = ent;\n            ent = NULL;\n            goto out;\n\n\tcase HDB_ERR_NOENTRY:\n\t    /* Check the other databases */\n\t    continue;\n\n\tdefault:\n\t    /* \n\t     * This is really important, because errors like\n\t     * HDB_ERR_NOT_FOUND_HERE (used to indicate to Samba that\n\t     * the RODC on which this code is running does not have\n\t     * the key we need, and so a proxy to the KDC is required)\n\t     * have specific meaning, and need to be propogated up.\n\t     */\n\t    goto out;\n\t}\n    }\n\nout2:\n    if (ret == HDB_ERR_NOENTRY) {\n\tkrb5_set_error_message(context, ret, \"no such entry found in hdb\");\n    }\nout:\n    krb5_free_principal(context, enterprise_principal);\n    free(ent);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_principalname2krb5_principal(",
          "args": [
            "ontext,",
            "princ,",
            "p_req.ticket.sname,",
            "p_req.ticket.realm)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_krbtgt_realm(",
          "args": [
            "ap_req.ticket.sname)"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "et_krbtgt_realm(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "40-48",
          "snippet": "tatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_free_error_message(",
          "args": [
            "ontext,",
            "sg)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_get_error_message(",
          "args": [
            "ontext,",
            "et)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_decode_ap_req(",
          "args": [
            "ontext,",
            "tgs_req->padata_value,",
            "ap_req)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ap_req,",
            ",",
            "izeof(ap_req))"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_parse_request(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  KDC_REQ_BODY *b,\n\t\t  const PA_DATA *tgs_req,\n\t\t  hdb_entry_ex **krbtgt,\n\t\t  krb5_enctype *krbtgt_etype,\n\t\t  krb5_ticket **ticket,\n\t\t  const char **e_text,\n\t\t  const char *from,\n\t\t  const struct sockaddr *from_addr,\n\t\t  time_t **csec,\n\t\t  int **cusec,\n\t\t  AuthorizationData **auth_data,\n\t\t  krb5_keyblock **replykey,\n\t\t  int *rk_is_subkey)\n{\n    static char failed[] = \"<unparse_name failed>\";\n    krb5_ap_req ap_req;\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_auth_context ac = NULL;\n    krb5_flags ap_req_options;\n    krb5_flags verify_ap_req_flags;\n    krb5_crypto crypto;\n    krb5uint32 krbtgt_kvno;     /* kvno used for the PA-TGS-REQ AP-REQ Ticket */\n    krb5uint32 krbtgt_kvno_try;\n    int kvno_search_tries = 4;  /* number of kvnos to try when tkt_vno == 0 */\n    const Keys *krbtgt_keys;/* keyset for TGT tkt_vno */\n    Key *tkey;\n    krb5_keyblock *subkey = NULL;\n    unsigned usage;\n\n    *auth_data = NULL;\n    *csec  = NULL;\n    *cusec = NULL;\n    *replykey = NULL;\n\n    memset(&ap_req, 0, sizeof(ap_req));\n    ret = krb5_decode_ap_req(context, &tgs_req->padata_value, &ap_req);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to decode AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    if(!get_krbtgt_realm(&ap_req.ticket.sname)){\n\t/* XXX check for ticket.sname == req.sname */\n\tkdc_log(context, config, 0, \"PA-DATA is not a ticket-granting ticket\");\n\tret = KRB5KDC_ERR_POLICY; /* ? */\n\tgoto out;\n    }\n\n    _krb5_principalname2krb5_principal(context,\n\t\t\t\t       &princ,\n\t\t\t\t       ap_req.ticket.sname,\n\t\t\t\t       ap_req.ticket.realm);\n\n    krbtgt_kvno = ap_req.ticket.enc_part.kvno ? *ap_req.ticket.enc_part.kvno : 0;\n    ret = _kdc_db_fetch(context, config, princ, HDB_F_GET_KRBTGT,\n\t\t\t&krbtgt_kvno, NULL, krbtgt);\n\n    if (ret == HDB_ERR_NOT_FOUND_HERE) {\n\t/* XXX Factor out this unparsing of the same princ all over */\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have secrets at \"\n\t\t\"this KDC, need to proxy\", p);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_NOT_FOUND_HERE;\n\tgoto out;\n    } else if (ret == HDB_ERR_KVNO_NOT_FOUND) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Ticket-granting ticket account %s does not have keys for \"\n\t\t\"kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret == HDB_ERR_NO_MKEY) {\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 5,\n\t\t\"Missing master key for decrypting keys for ticket-granting \"\n\t\t\"ticket account %s with kvno %d at this KDC\", p, krbtgt_kvno);\n\tif (ret == 0)\n\t    free(p);\n\tret = HDB_ERR_KVNO_NOT_FOUND;\n\tgoto out;\n    } else if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tchar *p;\n\tret = krb5_unparse_name(context, princ, &p);\n\tif (ret != 0)\n\t    p = failed;\n\tkrb5_free_principal(context, princ);\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket not found in database: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tif (ret == 0)\n\t    free(p);\n\tret = KRB5KRB_AP_ERR_NOT_US;\n\tgoto out;\n    }\n\n    krbtgt_kvno_try = krbtgt_kvno ? krbtgt_kvno : (*krbtgt)->entry.kvno;\n    *krbtgt_etype = ap_req.ticket.enc_part.etype;\n\nnext_kvno:\n    krbtgt_keys = hdb_kvno2keys(context, &(*krbtgt)->entry, krbtgt_kvno_try);\n    ret = hdb_enctype2key(context, &(*krbtgt)->entry, krbtgt_keys,\n\t\t\t  ap_req.ticket.enc_part.etype, &tkey);\n    if (ret && krbtgt_kvno == 0 && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    } else if (ret) {\n\tchar *str = NULL, *p = NULL;\n\n\tkrb5_enctype_to_string(context, ap_req.ticket.enc_part.etype, &str);\n\tkrb5_unparse_name(context, princ, &p);\n \tkdc_log(context, config, 0,\n\t\t\"No server key with enctype %s found for %s\",\n\t\tstr ? str : \"<unknown enctype>\",\n\t\tp ? p : \"<unparse_name failed>\");\n\tfree(str);\n\tfree(p);\n\tret = KRB5KRB_AP_ERR_BADKEYVER;\n\tgoto out;\n    }\n\n    if (b->kdc_options.validate)\n\tverify_ap_req_flags = KRB5_VERIFY_AP_REQ_IGNORE_INVALID;\n    else\n\tverify_ap_req_flags = 0;\n\n    ret = krb5_verify_ap_req2(context,\n\t\t\t      &ac,\n\t\t\t      &ap_req,\n\t\t\t      princ,\n\t\t\t      &tkey->key,\n\t\t\t      verify_ap_req_flags,\n\t\t\t      &ap_req_options,\n\t\t\t      ticket,\n\t\t\t      KRB5_KU_TGS_REQ_AUTH);\n    if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY && kvno_search_tries > 0) {\n\tkvno_search_tries--;\n\tkrbtgt_kvno_try--;\n\tgoto next_kvno;\n    }\n\n    krb5_free_principal(context, princ);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to verify AP-REQ: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n\n    {\n\tkrb5_authenticator auth;\n\n\tret = krb5_auth_con_getauthenticator(context, ac, &auth);\n\tif (ret == 0) {\n\t    *csec   = malloc(sizeof(**csec));\n\t    if (*csec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **csec  = auth->ctime;\n\t    *cusec  = malloc(sizeof(**cusec));\n\t    if (*cusec == NULL) {\n\t\tkrb5_free_authenticator(context, &auth);\n\t\tkdc_log(context, config, 0, \"malloc failed\");\n\t\tgoto out;\n\t    }\n\t    **cusec  = auth->cusec;\n\t    krb5_free_authenticator(context, &auth);\n\t}\n    }\n\n    ret = tgs_check_authenticator(context, config,\n\t\t\t\t  ac, b, e_text, &(*ticket)->ticket.key);\n    if (ret) {\n\tkrb5_auth_con_free(context, ac);\n\tgoto out;\n    }\n\n    usage = KRB5_KU_TGS_REQ_AUTH_DAT_SUBKEY;\n    *rk_is_subkey = 1;\n\n    ret = krb5_auth_con_getremotesubkey(context, ac, &subkey);\n    if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0, \"Failed to get remote subkey: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tgoto out;\n    }\n    if(subkey == NULL){\n\tusage = KRB5_KU_TGS_REQ_AUTH_DAT_SESSION;\n\t*rk_is_subkey = 0;\n\n\tret = krb5_auth_con_getkey(context, ac, &subkey);\n\tif(ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"Failed to get session key: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n    }\n    if(subkey == NULL){\n\tkrb5_auth_con_free(context, ac);\n\tkdc_log(context, config, 0,\n\t\t\"Failed to get key for enc-authorization-data\");\n\tret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\tgoto out;\n    }\n\n    *replykey = subkey;\n\n    if (b->enc_authorization_data) {\n\tkrb5_data ad;\n\n\tret = krb5_crypto_init(context, subkey, 0, &crypto);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(context, ret);\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\t    krb5_free_error_message(context, msg);\n\t    goto out;\n\t}\n\tret = krb5_decrypt_EncryptedData (context,\n\t\t\t\t\t  crypto,\n\t\t\t\t\t  usage,\n\t\t\t\t\t  b->enc_authorization_data,\n\t\t\t\t\t  &ad);\n\tkrb5_crypto_destroy(context, crypto);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    kdc_log(context, config, 0,\n\t\t    \"Failed to decrypt enc-authorization-data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tALLOC(*auth_data);\n\tif (*auth_data == NULL) {\n\t    krb5_auth_con_free(context, ac);\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n\tret = decode_AuthorizationData(ad.data, ad.length, *auth_data, NULL);\n\tif(ret){\n\t    krb5_auth_con_free(context, ac);\n\t    free(*auth_data);\n\t    *auth_data = NULL;\n\t    kdc_log(context, config, 0, \"Failed to decode authorization data\");\n\t    ret = KRB5KRB_AP_ERR_BAD_INTEGRITY; /* ? */\n\t    goto out;\n\t}\n    }\n\n    krb5_auth_con_free(context, ac);\n\nout:\n    free_AP_REQ(&ap_req);\n\n    return ret;\n}"
  },
  {
    "function_name": "eed_referral(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "1093-1129",
    "snippet": "tatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_get_host_realm_int(",
          "args": [
            "ontext,",
            "ame,",
            "ALSE,",
            "ealms)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Searching referral for %s\",",
            "ame)"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "ame)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "NOMEM,",
            "_(\"malloc: out of memory\", \"\"))"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_(",
          "args": [
            "malloc: out of memory\",",
            "\")"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(char *)*2)"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_boolean\nneed_referral(krb5_context context, krb5_kdc_configuration *config,\n\t      const KDCOptions * const options, krb5_principal server,\n\t      krb5_realm **realms)\n{\n    const char *name;\n\n    if(!options->canonicalize && server->name.name_type != KRB5_NT_SRV_INST)\n\treturn FALSE;\n\n    if (server->name.name_string.len == 1)\n\tname = server->name.name_string.val[0];\n    else if (server->name.name_string.len == 3) {\n\t/*\n\t  This is used to give referrals for the\n\t  E3514235-4B06-11D1-AB04-00C04FC2DCD2/NTDSGUID/DNSDOMAIN\n\t  SPN form, which is used for inter-domain communication in AD\n\t */\n\tname = server->name.name_string.val[2];\n\tkdc_log(context, config, 0, \"Giving 3 part referral for %s\", name);\n\t*realms = malloc(sizeof(char *)*2);\n\tif (*realms == NULL) {\n\t    krb5_set_error_message(context, ENOMEM, N_(\"malloc: out of memory\", \"\"));\n\t    return FALSE;\n\t}\n\t(*realms)[0] = strdup(name);\n\t(*realms)[1] = NULL;\n\treturn TRUE;\n    } else if (server->name.name_string.len > 1)\n\tname = server->name.name_string.val[1];\n    else\n\treturn FALSE;\n\n    kdc_log(context, config, 0, \"Searching referral for %s\", name);\n\n    return _krb5_get_host_realm_int(context, name, FALSE, realms) == 0;\n}"
  },
  {
    "function_name": "gs_make_reply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "723-1011",
    "snippet": "tatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_EncryptionKey(",
          "args": [
            "et.key)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "t.key.keyvalue.data,",
            ",",
            "t.key.keyvalue.length)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_LastReq(",
          "args": [
            "ek.last_req)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "t.authorization_data)"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "t.authorization_data)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "t.renew_till)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "t.starttime)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_TransitedEncoding(",
          "args": [
            "et.transited)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_TGS_REP(",
          "args": [
            "rep)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_enctype_disable(",
          "args": [
            "ontext,",
            "erverkey->keytype)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_encode_reply(",
          "args": [
            "ontext,",
            "onfig,",
            "ULL,",
            ",",
            "rep,",
            "et,",
            "ek,",
            "erverkey->keytype,",
            "vno,",
            "erverkey,",
            ",",
            "eplykey,",
            "k_is_subkey,",
            "_text,",
            "eply)"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_encode_reply(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "810-987",
          "snippet": "rb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_encode_reply(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  krb5_crypto armor_crypto, uint32_t nonce,\n\t\t  KDC_REP *rep, EncTicketPart *et, EncKDCRepPart *ek,\n\t\t  krb5_enctype etype,\n\t\t  int skvno, const EncryptionKey *skey,\n\t\t  int ckvno, const EncryptionKey *reply_key,\n\t\t  int rk_is_subkey,\n\t\t  const char **e_text,\n\t\t  krb5_data *reply)\n{\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    krb5_error_code ret;\n    krb5_crypto crypto;\n\n    ASN1_MALLOC_ENCODE(EncTicketPart, buf, buf_size, et, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode ticket: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len)\n\tkrb5_abortx(context, \"Internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, skey, etype, &crypto);\n    if (ret) {\n        const char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\tfree(buf);\n\treturn ret;\n    }\n\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_TICKET,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     skvno,\n\t\t\t\t     &rep->ticket.enc_part);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encrypt data: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n\n    if (armor_crypto) {\n\tkrb5_data data;\n\tkrb5_keyblock *strengthen_key = NULL;\n\tKrbFastFinished finished;\n\n\tkdc_log(context, config, 0, \"FAST armor protection\");\n\n\tmemset(&finished, 0, sizeof(finished));\n\tkrb5_data_zero(&data);\n\n\tfinished.timestamp = kdc_time;\n\tfinished.usec = 0;\n\tfinished.crealm = et->crealm;\n\tfinished.cname = et->cname;\n\n\tASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t   &rep->ticket, &len, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != len)\n\t    krb5_abortx(context, \"internal asn.1 error\");\n\n\tret = krb5_create_checksum(context, armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED, 0,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &finished.ticket_checksum);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tret = _kdc_fast_mk_response(context, armor_crypto,\n\t\t\t\t    rep->padata, strengthen_key, &finished,\n\t\t\t\t    nonce, &data);\n\tfree_Checksum(&finished.ticket_checksum);\n\tif (ret)\n\t    return ret;\n\n\tif (rep->padata) {\n\t    free_METHOD_DATA(rep->padata);\n\t} else {\n\t    rep->padata = calloc(1, sizeof(*(rep->padata)));\n\t    if (rep->padata == NULL) {\n\t\tkrb5_data_free(&data);\n\t\treturn ENOMEM;\n\t    }\n\t}\n\n\tret = krb5_padata_add(context, rep->padata,\n\t\t\t      KRB5_PADATA_FX_FAST,\n\t\t\t      data.data, data.length);\n\tif (ret)\n\t    return ret;\n\n\t/*\n\t * Hide client name of privacy reasons\n\t */\n\tif (1 /* r->fast_options.hide_client_names */) {\n\t    rep->crealm[0] = '\\0';\n\t    free_PrincipalName(&rep->cname);\n\t    rep->cname.name_type = 0;\n\t}\n    }\n\n    if(rep->msg_type == krb_as_rep && !config->encode_as_rep_as_tgs_rep)\n\tASN1_MALLOC_ENCODE(EncASRepPart, buf, buf_size, ek, &len, ret);\n    else\n\tASN1_MALLOC_ENCODE(EncTGSRepPart, buf, buf_size, ek, &len, ret);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    ret = krb5_crypto_init(context, reply_key, 0, &crypto);\n    if (ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tfree(buf);\n\tkdc_log(context, config, 0, \"krb5_crypto_init failed: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(rep->msg_type == krb_as_rep) {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(AS_REP, buf, buf_size, rep, &len, ret);\n    } else {\n\tkrb5_encrypt_EncryptedData(context,\n\t\t\t\t   crypto,\n\t\t\t\t   rk_is_subkey ? KRB5_KU_TGS_REP_ENC_PART_SUB_KEY : KRB5_KU_TGS_REP_ENC_PART_SESSION,\n\t\t\t\t   buf,\n\t\t\t\t   len,\n\t\t\t\t   ckvno,\n\t\t\t\t   &rep->enc_part);\n\tfree(buf);\n\tASN1_MALLOC_ENCODE(TGS_REP, buf, buf_size, rep, &len, ret);\n    }\n    krb5_crypto_destroy(context, crypto);\n    if(ret) {\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \"Failed to encode KDC-REP: %s\", msg);\n\tkrb5_free_error_message(context, msg);\n\treturn ret;\n    }\n    if(buf_size != len) {\n\tfree(buf);\n\tkdc_log(context, config, 0, \"Internal error in ASN.1 encoder\");\n\t*e_text = \"KDC internal error\";\n\treturn KRB5KRB_ERR_GENERIC;\n    }\n    reply->data = buf;\n    reply->length = buf_size;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_enctype_enable(",
          "args": [
            "ontext,",
            "erverkey->keytype)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_is_weak_exception(",
          "args": [
            "erver->entry.principal,",
            "erverkey->keytype)"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_is_weak_exception(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "90-100",
          "snippet": "rb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_boolean\n_kdc_is_weak_exception(krb5_principal principal, krb5_enctype etype)\n{\n    if (principal->name.name_string.len > 0 &&\n\tstrcmp(principal->name.name_string.val[0], \"afs\") == 0 &&\n\t(etype == (krb5_enctype)ETYPE_DES_CBC_CRC\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD4\n\t || etype == (krb5_enctype)ETYPE_DES_CBC_MD5))\n\treturn TRUE;\n    return FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_enctype_valid(",
          "args": [
            "ontext,",
            "erverkey->keytype)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_METHOD_DATA(",
          "args": [
            "nc_pa_data,",
            "ep.padata)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*rep.padata))"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_add_KRB5SignedPath(",
          "args": [
            "ontext,",
            "onfig,",
            "rbtgt,",
            "rbtgt_etype,",
            "lient_principal,",
            "ULL,",
            "pp,",
            "et)"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_add_KRB5SignedPath(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "102-184",
          "snippet": "rb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "k.srealm)"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_krbtgt_realm(",
          "args": [
            "ek.sname)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "et_krbtgt_realm(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "40-48",
          "snippet": "tatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_log_timestamp(",
          "args": [
            "ontext,",
            "onfig,",
            "TGS-REQ\",",
            "t.authtime,",
            "t.starttime,",
            "t.endtime,",
            "t.renew_till)"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_log_timestamp(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "283-311",
          "snippet": "oid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_log_timestamp(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   const char *type,\n\t\t   KerberosTime authtime, KerberosTime *starttime,\n\t\t   KerberosTime endtime, KerberosTime *renew_till)\n{\n    char authtime_str[100], starttime_str[100],\n\tendtime_str[100], renewtime_str[100];\n\n    krb5_format_time(context, authtime,\n\t\t     authtime_str, sizeof(authtime_str), TRUE);\n    if (starttime)\n\tkrb5_format_time(context, *starttime,\n\t\t\t starttime_str, sizeof(starttime_str), TRUE);\n    else\n\tstrlcpy(starttime_str, \"unset\", sizeof(starttime_str));\n    krb5_format_time(context, endtime,\n\t\t     endtime_str, sizeof(endtime_str), TRUE);\n    if (renew_till)\n\tkrb5_format_time(context, *renew_till,\n\t\t\t renewtime_str, sizeof(renewtime_str), TRUE);\n    else\n\tstrlcpy(renewtime_str, \"unset\", sizeof(renewtime_str));\n\n    kdc_log(context, config, 5,\n\t    \"%s authtime: %s starttime: %s endtime: %s renew till: %s\",\n\t    type, authtime_str, starttime_str, endtime_str, renewtime_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*ek.last_req.val))"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_copy_keyblock_contents(",
          "args": [
            "ontext,",
            "essionkey,",
            "et.key)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationDataElement(",
          "args": [
            "ad->val[ad->len - 1])"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "t.authorization_data)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "t.authorization_data)"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ind_KRB5SignedPath(",
          "args": [
            "ontext,",
            "t.authorization_data,",
            "ULL)"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ind_KRB5SignedPath(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "59-100",
          "snippet": "tatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_AuthorizationData(",
          "args": [
            "t.authorization_data,",
            "auth_data->val[i])"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "malloc: out of memory\")"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ",",
            "izeof(*et.authorization_data))"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_tkt_add_if_relevant_ad(",
          "args": [
            "ontext,",
            "et,",
            "RB5_AUTHDATA_WIN2K_PAC,",
            "spac)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "t.renew_till)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in(",
          "args": [
            "et.starttime,",
            "t.endtime)"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "ain(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
          "lines": "53-212",
          "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int version_flag;",
            "tatic int help_flag;",
            "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
            "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int version_flag;\ntatic int help_flag;\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "t.renew_till)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_PrincipalName(",
          "args": [
            "tgt_name->name,",
            "rep.cname)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "tgt_name->realm,",
            "rep.crealm)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal2principalname(",
          "args": [
            "rep.ticket.sname,",
            "erver_principal)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Realm(",
          "args": [
            "server_principal->realm,",
            "rep.ticket.realm)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ix_transited_encoding(",
          "args": [
            "ontext,",
            "onfig,",
            "f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),",
            "tgt->transited,",
            "et,",
            "rb5_principal_get_realm(context, client_principal),",
            "rb5_principal_get_realm(context, server->entry.principal),",
            "rb5_principal_get_realm(context, krbtgt->entry.principal))"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ix_transited_encoding(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "613-720",
          "snippet": "tatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "rbtgt->entry.principal)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "erver->entry.principal)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_get_realm(",
          "args": [
            "ontext,",
            "lient_principal)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(",
          "args": [
            "erver)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RINCIPAL_FORCE_TRANSITED_CHECK(",
          "args": [
            "erver)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_tgs_flags(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "gt,",
            "et)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "heck_tgs_flags(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "373-499",
          "snippet": "tatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "t.starttime)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_fix_time(",
          "args": [
            "b->till)"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fix_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "38-46",
          "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
        }
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ek,",
            ",",
            "izeof(ek))"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "et,",
            ",",
            "izeof(et))"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "rep,",
            ",",
            "izeof(rep))"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}"
  },
  {
    "function_name": "ix_transited_encoding(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "613-720",
    "snippet": "tatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ealms)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ealms[i])"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "Encoding transited encoding\")"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_domain_x500_encode(",
          "args": [
            "ealms,",
            "um_realms,",
            "et->transited.contents)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "cross-realm %s -> %s\",",
            "lient_realm,",
            "erver_realm)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_check_transited(",
          "args": [
            "ontext,",
            "lient_realm,",
            "erver_realm,",
            "ealms,",
            "um_realms,",
            "ULL)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "s)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "cross-realm %s -> %s via [%s]\",",
            "lient_realm,",
            "erver_realm,",
            "s)"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trlcat(",
          "args": [
            "s,",
            "ealms[i],",
            ")"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcat(",
          "args": [
            "s,",
            ", \",",
            ")"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            ")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "ealms[i])"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "lient_realm,",
            "erver_realm)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trdup(",
          "args": [
            "gt_realm)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "ealms,",
            "num_realms + 1) * sizeof(*realms))"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "erver_realm,",
            "gt_realm)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "lient_realm,",
            "gt_realm)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_warn(",
          "args": [
            "ontext,",
            "et,",
            "Decoding transited encoding\")"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_domain_x500_decode(",
          "args": [
            "ontext,",
            "r->contents,",
            "realms,",
            "num_realms,",
            "lient_realm,",
            "erver_realm)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}"
  },
  {
    "function_name": "erify_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "592-607",
    "snippet": "tatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 0, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 0, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Ticket not valid (%s)\",",
            "str)"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nverify_flags (krb5_context context,\n\t      krb5_kdc_configuration *config,\n\t      const EncTicketPart *et,\n\t      const char *pstr)\n{\n    if(et->endtime < kdc_time){\n\tkdc_log(context, config, 0, \"Ticket expired (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_EXPIRED;\n    }\n    if(et->flags.invalid){\n\tkdc_log(context, config, 0, \"Ticket not valid (%s)\", pstr);\n\treturn KRB5KRB_AP_ERR_TKT_NYV;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "heck_s4u2self(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "565-586",
    "snippet": "tatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lientdb->hdb_check_s4u2self",
          "args": [
            "ontext,",
            "lientdb,",
            "lient,",
            "erver)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "lient->entry.principal,",
            "erver)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_s4u2self(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       HDB *clientdb,\n\t       hdb_entry_ex *client,\n\t       krb5_const_principal server)\n{\n    krb5_error_code ret;\n\n    /* if client does a s4u2self to itself, that ok */\n    if (krb5_principal_compare(context, client->entry.principal, server) == TRUE)\n\treturn 0;\n\n    if (clientdb->hdb_check_s4u2self) {\n\tret = clientdb->hdb_check_s4u2self(context, clientdb, client, server);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    return ret;\n}"
  },
  {
    "function_name": "heck_constrained_delegation(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "505-556",
    "snippet": "tatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Bad request for constrained delegation\")"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "arget,",
            "acl->val[i])"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_clear_error_message(",
          "args": [
            "ontext)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_entry_get_ConstrainedDelegACL(",
          "args": [
            "client->entry,",
            "acl)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_principal_compare(",
          "args": [
            "ontext,",
            "lient->entry.principal,",
            "erver->entry.principal)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lientdb->hdb_check_constrained_delegation",
          "args": [
            "ontext,",
            "lientdb,",
            "lient,",
            "arget)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_realm_compare(",
          "args": [
            "ontext,",
            "lient->entry.principal,",
            "erver->entry.principal)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_constrained_delegation(krb5_context context,\n\t\t\t     krb5_kdc_configuration *config,\n\t\t\t     HDB *clientdb,\n\t\t\t     hdb_entry_ex *client,\n\t\t\t     hdb_entry_ex *server,\n\t\t\t     krb5_const_principal target)\n{\n    const HDB_Ext_Constrained_delegation_acl *acl;\n    krb5_error_code ret;\n    size_t i;\n\n    /*\n     * constrained_delegation (S4U2Proxy) only works within\n     * the same realm. We use the already canonicalized version\n     * of the principals here, while \"target\" is the principal\n     * provided by the client.\n     */\n    if(!krb5_realm_compare(context, client->entry.principal, server->entry.principal)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\tkdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n\treturn ret;\n    }\n\n    if (clientdb->hdb_check_constrained_delegation) {\n\tret = clientdb->hdb_check_constrained_delegation(context, clientdb, client, target);\n\tif (ret == 0)\n\t    return 0;\n    } else {\n\t/* if client delegates to itself, that ok */\n\tif (krb5_principal_compare(context, client->entry.principal, server->entry.principal) == TRUE)\n\t    return 0;\n\n\tret = hdb_entry_get_ConstrainedDelegACL(&client->entry, &acl);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    return ret;\n\t}\n\n\tif (acl) {\n\t    for (i = 0; i < acl->len; i++) {\n\t\tif (krb5_principal_compare(context, target, &acl->val[i]) == TRUE)\n\t\t    return 0;\n\t    }\n\t}\n\tret = KRB5KDC_ERR_BADOPTION;\n    }\n    kdc_log(context, config, 0,\n\t    \"Bad request for constrained delegation\");\n    return ret;\n}"
  },
  {
    "function_name": "heck_tgs_flags(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "373-499",
    "snippet": "tatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "Request for anonymous ticket\")"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in(",
          "args": [
            "et->renew_till,",
            "t->endtime)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ain(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kdc-replay.c",
          "lines": "53-212",
          "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int version_flag;",
            "tatic int help_flag;",
            "truct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};",
            "tatic const int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int version_flag;\ntatic int help_flag;\ntruct getargs args[] = {\n    { \"version\",   0,\targ_flag, &version_flag, NULL, NULL },\n    { \"help\",     'h',\targ_flag, &help_flag,    NULL, NULL }\n};\ntatic const int num_args = sizeof(args) / sizeof(args[0]);\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    krb5_storage *sp;\n    int fd, optidx = 0;\n\n    setprogname(argv[0]);\n\n    if(getarg(args, num_args, argc, argv, &optidx))\n\tusage(1);\n\n    if(help_flag)\n\tusage(0);\n\n    if(version_flag){\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    ret = krb5_init_context(&context);\n    if (ret)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc-replay\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n#ifdef PKINIT\n    if (config->enable_pkinit) {\n\tif (config->pkinit_kdc_identity == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no identity\");\n\n\tif (config->pkinit_kdc_anchors == NULL)\n\t    krb5_errx(context, 1, \"pkinit enabled but no X509 anchors\");\n\n\tkrb5_kdc_pk_initialize(context, config,\n\t\t\t       config->pkinit_kdc_identity,\n\t\t\t       config->pkinit_kdc_anchors,\n\t\t\t       config->pkinit_kdc_cert_pool,\n\t\t\t       config->pkinit_kdc_revoke);\n\n    }\n#endif /* PKINIT */\n\n    if (argc != 2)\n\terrx(1, \"argc != 2\");\n\n    printf(\"kdc replay\\n\");\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd < 0)\n\terr(1, \"open: %s\", argv[1]);\n\n    sp = krb5_storage_from_fd(fd);\n    if (sp == NULL)\n\tkrb5_errx(context, 1, \"krb5_storage_from_fd\");\n\n    while(1) {\n\tstruct sockaddr_storage sa;\n\tkrb5_socklen_t salen = sizeof(sa);\n\tstruct timeval tv;\n\tkrb5_address a;\n\tkrb5_data d, r;\n\tuint32_t t, clty, tag;\n\tchar astr[80];\n\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret == HEIM_ERR_EOF)\n\t    break;\n\telse if (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(version)\");\n\tif (t != 1)\n\t    krb5_errx(context, 1, \"version not 1\");\n\tret = krb5_ret_uint32(sp, &t);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(time)\");\n\tret = krb5_ret_address(sp, &a);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_address\");\n\tret = krb5_ret_data(sp, &d);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_data\");\n\tret = krb5_ret_uint32(sp, &clty);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(class|type)\");\n\tret = krb5_ret_uint32(sp, &tag);\n\tif (ret)\n\t    krb5_errx(context, 1, \"krb5_ret_uint32(tag)\");\n\n\n\tret = krb5_addr2sockaddr (context, &a, (struct sockaddr *)&sa,\n\t\t\t\t  &salen, 88);\n\tif (ret == KRB5_PROG_ATYPE_NOSUPP)\n\t    goto out;\n\telse if (ret)\n\t    krb5_err(context, 1, ret, \"krb5_addr2sockaddr\");\n\n\tret = krb5_print_address(&a, astr, sizeof(astr), NULL);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_print_address\");\n\n\tprintf(\"processing request from %s, %lu bytes\\n\",\n\t       astr, (unsigned long)d.length);\n\n\tr.length = 0;\n\tr.data = NULL;\n\n\ttv.tv_sec = t;\n\ttv.tv_usec = 0;\n\n\tkrb5_kdc_update_time(&tv);\n\tkrb5_set_real_time(context, tv.tv_sec, 0);\n\n\tret = krb5_kdc_process_request(context, config, d.data, d.length,\n\t\t\t\t       &r, NULL, astr,\n\t\t\t\t       (struct sockaddr *)&sa, 0);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"krb5_kdc_process_request\");\n\n\tif (r.length) {\n\t    Der_class cl;\n\t    Der_type ty;\n\t    unsigned int tag2;\n\t    ret = der_get_tag (r.data, r.length,\n\t\t\t       &cl, &ty, &tag2, NULL);\n\t    if (MAKE_TAG(cl, ty, 0) != clty)\n\t\tkrb5_errx(context, 1, \"class|type mismatch: %d != %d\",\n\t\t\t  (int)MAKE_TAG(cl, ty, 0), (int)clty);\n\t    if (tag != tag2)\n\t\tkrb5_errx(context, 1, \"tag mismatch\");\n\n\t    krb5_data_free(&r);\n\t} else {\n\t    if (clty != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"clty not invalid\");\n\t    if (tag != 0xffffffff)\n\t\tkrb5_errx(context, 1, \"tag not invalid\");\n\t}\n\n    out:\n\tkrb5_data_free(&d);\n\tkrb5_free_address(context, &a);\n    }\n\n    krb5_storage_free(sp);\n    krb5_free_context(context);\n\n    printf(\"done\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdc_fix_time(",
          "args": [
            "b->rtime)"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_fix_time(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "38-46",
          "snippet": "oid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\n_kdc_fix_time(time_t **t)\n{\n    if(*t == NULL){\n\tALLOC(*t);\n\t**t = MAX_TIME;\n    }\n    if(**t == 0) **t = MAX_TIME; /* fix for old clients */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLOC(",
          "args": [
            "t->renew_till)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_tgs_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\tKDC_REQ_BODY *b, const EncTicketPart *tgt, EncTicketPart *et)\n{\n    KDCOptions f = b->kdc_options;\n\n    if(f.validate){\n\tif(!tgt->flags.invalid || tgt->starttime == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request to validate ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(*tgt->starttime > kdc_time){\n\t    kdc_log(context, config, 0,\n\t\t    \"Early request to validate ticket\");\n\t    return KRB5KRB_AP_ERR_TKT_NYV;\n\t}\n\t/* XXX  tkt = tgt */\n\tet->flags.invalid = 0;\n    }else if(tgt->flags.invalid){\n\tkdc_log(context, config, 0,\n\t\t\"Ticket-granting ticket has INVALID flag set\");\n\treturn KRB5KRB_AP_ERR_TKT_INVALID;\n    }\n\n    if(f.forwardable){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwardable = 1;\n    }\n    if(f.forwarded){\n\tif(!tgt->flags.forwardable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to forward non-forwardable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.forwarded = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.forwarded)\n\tet->flags.forwarded = 1;\n\n    if(f.proxiable){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxiable = 1;\n    }\n    if(f.proxy){\n\tif(!tgt->flags.proxiable){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to proxy non-proxiable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.proxy = 1;\n\tet->caddr = b->addresses;\n    }\n    if(tgt->flags.proxy)\n\tet->flags.proxy = 1;\n\n    if(f.allow_postdate){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for post-datable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.may_postdate = 1;\n    }\n    if(f.postdated){\n\tif(!tgt->flags.may_postdate){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for postdated ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tif(b->from)\n\t    *et->starttime = *b->from;\n\tet->flags.postdated = 1;\n\tet->flags.invalid = 1;\n    }else if(b->from && *b->from > kdc_time + context->max_skew){\n\tkdc_log(context, config, 0, \"Ticket cannot be postdated\");\n\treturn KRB5KDC_ERR_CANNOT_POSTDATE;\n    }\n\n    if(f.renewable){\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Bad request for renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\tet->flags.renewable = 1;\n\tALLOC(et->renew_till);\n\t_kdc_fix_time(&b->rtime);\n\t*et->renew_till = *b->rtime;\n    }\n    if(f.renew){\n\ttime_t old_life;\n\tif(!tgt->flags.renewable || tgt->renew_till == NULL){\n\t    kdc_log(context, config, 0,\n\t\t    \"Request to renew non-renewable ticket\");\n\t    return KRB5KDC_ERR_BADOPTION;\n\t}\n\told_life = tgt->endtime;\n\tif(tgt->starttime)\n\t    old_life -= *tgt->starttime;\n\telse\n\t    old_life -= tgt->authtime;\n\tet->endtime = *et->starttime + old_life;\n\tif (et->renew_till != NULL)\n\t    et->endtime = min(*et->renew_till, et->endtime);\n    }\n\n#if 0\n    /* checks for excess flags */\n    if(f.request_anonymous && !config->allow_anonymous){\n\tkdc_log(context, config, 0,\n\t\t\"Request for anonymous ticket\");\n\treturn KRB5KDC_ERR_BADOPTION;\n    }\n#endif\n    return 0;\n}"
  },
  {
    "function_name": "heck_PAC(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "279-367",
    "snippet": "tatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "child)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_pac_free(",
          "args": [
            "ontext,",
            "ac)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_pac_sign(",
          "args": [
            "ontext,",
            "ac,",
            "kt->authtime,",
            "lient_principal,",
            "erver_sign_key,",
            "rbtgt_sign_key,",
            "spac)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_pac_free(",
          "args": [
            "ontext,",
            "ac)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_pac_verify(",
          "args": [
            "ontext,",
            "lient_principal,",
            "elegated_proxy_principal,",
            "lient,",
            "erver,",
            "rbtgt,",
            "pac,",
            "signed_pac)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "kdc_pac_verify(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
          "lines": "121-147",
          "snippet": "rb5_error_code\n_kdc_pac_verify(krb5_context context,\n\t\tconst krb5_principal client_principal,\n\t\tconst krb5_principal delegated_proxy_principal,\n\t\thdb_entry_ex *client,\n\t\thdb_entry_ex *server,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_pac *pac,\n\t\tint *verified)\n{\n    struct verify_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client_principal = client_principal;\n    uc.delegated_proxy_principal = delegated_proxy_principal;\n    uc.client = client;\n    uc.server = server;\n    uc.krbtgt = krbtgt;\n    uc.pac = pac;\n    uc.verified = verified;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, verify);\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int have_plugin = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_pac_verify(krb5_context context,\n\t\tconst krb5_principal client_principal,\n\t\tconst krb5_principal delegated_proxy_principal,\n\t\thdb_entry_ex *client,\n\t\thdb_entry_ex *server,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_pac *pac,\n\t\tint *verified)\n{\n    struct verify_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client_principal = client_principal;\n    uc.delegated_proxy_principal = delegated_proxy_principal;\n    uc.client = client;\n    uc.server = server;\n    uc.krbtgt = krbtgt;\n    uc.pac = pac;\n    uc.verified = verified;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, verify);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_pac_free(",
          "args": [
            "ontext,",
            "ac)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_pac_verify(",
          "args": [
            "ontext,",
            "ac,",
            "kt->authtime,",
            "lient_principal,",
            "erver_check_key,",
            "ULL)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "child)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_pac_parse(",
          "args": [
            "ontext,",
            "hild.val[j].ad_data.data,",
            "hild.val[j].ad_data.length,",
            "pac)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\",",
            "et)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_AuthorizationData(",
          "args": [
            "d->val[i].ad_data.data,",
            "d->val[i].ad_data.length,",
            "child,",
            "ULL)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_PAC(krb5_context context,\n\t  krb5_kdc_configuration *config,\n\t  const krb5_principal client_principal,\n\t  const krb5_principal delegated_proxy_principal,\n\t  hdb_entry_ex *client,\n\t  hdb_entry_ex *server,\n\t  hdb_entry_ex *krbtgt,\n\t  const EncryptionKey *server_check_key,\n\t  const EncryptionKey *server_sign_key,\n\t  const EncryptionKey *krbtgt_sign_key,\n\t  EncTicketPart *tkt,\n\t  krb5_data *rspac,\n\t  int *signedpath)\n{\n    AuthorizationData *ad = tkt->authorization_data;\n    unsigned i, j;\n    krb5_error_code ret;\n\n    if (ad == NULL || ad->len == 0)\n\treturn 0;\n\n    for (i = 0; i < ad->len; i++) {\n\tAuthorizationData child;\n\n\tif (ad->val[i].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\t    continue;\n\n\tret = decode_AuthorizationData(ad->val[i].ad_data.data,\n\t\t\t\t       ad->val[i].ad_data.length,\n\t\t\t\t       &child,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t\t   \"IF_RELEVANT with %d\", ret);\n\t    return ret;\n\t}\n\tfor (j = 0; j < child.len; j++) {\n\n\t    if (child.val[j].ad_type == KRB5_AUTHDATA_WIN2K_PAC) {\n\t\tint signed_pac = 0;\n\t\tkrb5_pac pac;\n\n\t\t/* Found PAC */\n\t\tret = krb5_pac_parse(context,\n\t\t\t\t     child.val[j].ad_data.data,\n\t\t\t\t     child.val[j].ad_data.length,\n\t\t\t\t     &pac);\n\t\tfree_AuthorizationData(&child);\n\t\tif (ret)\n\t\t    return ret;\n\n\t\tret = krb5_pac_verify(context, pac, tkt->authtime,\n\t\t\t\t      client_principal,\n\t\t\t\t      server_check_key, NULL);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\tret = _kdc_pac_verify(context, client_principal,\n\t\t\t\t      delegated_proxy_principal,\n\t\t\t\t      client, server, krbtgt, &pac, &signed_pac);\n\t\tif (ret) {\n\t\t    krb5_pac_free(context, pac);\n\t\t    return ret;\n\t\t}\n\n\t\t/*\n\t\t * Only re-sign PAC if we could verify it with the PAC\n\t\t * function. The no-verify case happens when we get in\n\t\t * a PAC from cross realm from a Windows domain and\n\t\t * that there is no PAC verification function.\n\t\t */\n\t\tif (signed_pac) {\n\t\t    *signedpath = 1;\n\t\t    ret = _krb5_pac_sign(context, pac, tkt->authtime,\n\t\t\t\t\t client_principal,\n\t\t\t\t\t server_sign_key, krbtgt_sign_key, rspac);\n\t\t}\n\t\tkrb5_pac_free(context, pac);\n\n\t\treturn ret;\n\t    }\n\t}\n\tfree_AuthorizationData(&child);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "heck_KRB5SignedPath(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "186-273",
    "snippet": "tatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "delegated)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_Principals(",
          "args": [
            "delegated,",
            "p.delegated)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "izeof(*sp.delegated))"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_log(",
          "args": [
            "ontext,",
            "onfig,",
            ",",
            "KRB5SignedPath not signed correctly, not marking as signed\")"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "dc_log(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/log.c",
          "lines": "86-97",
          "snippet": "oid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\noid\nkdc_log(krb5_context context,\n\tkrb5_kdc_configuration *config,\n\tint level, const char *fmt, ...)\n{\n    va_list ap;\n    char *s;\n    va_start(ap, fmt);\n    s = kdc_log_msg_va(context, config, level, fmt, ap);\n    if(s) free(s);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_verify_checksum(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_KRB5SIGNEDPATH,",
            "ata.data,",
            "ata.length,",
            "sp.cksum)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "key->key,",
            ",",
            "crypto)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "krbtgt->entry,",
            "ULL,",
            "* XXX use correct kvno! */\np.etype,",
            "key)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_KRB5SignedPath(",
          "args": [
            "sp)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "RB5SignedPathData,",
            "ata.data,",
            "ata.length,",
            "spd,",
            "size,",
            "et)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_KRB5SignedPath(",
          "args": [
            "ata.data,",
            "ata.length,",
            "sp,",
            "ULL)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ind_KRB5SignedPath(",
          "args": [
            "ontext,",
            "kt->authorization_data,",
            "data)"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ind_KRB5SignedPath(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
          "lines": "59-100",
          "snippet": "tatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\ncheck_KRB5SignedPath(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     hdb_entry_ex *krbtgt,\n\t\t     krb5_principal cp,\n\t\t     EncTicketPart *tkt,\n\t\t     krb5_principals *delegated,\n\t\t     int *signedpath)\n{\n    krb5_error_code ret;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n\n    if (delegated)\n\t*delegated = NULL;\n\n    ret = find_KRB5SignedPath(context, tkt->authorization_data, &data);\n    if (ret == 0) {\n\tKRB5SignedPathData spd;\n\tKRB5SignedPath sp;\n\tsize_t size = 0;\n\n\tret = decode_KRB5SignedPath(data.data, data.length, &sp, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    return ret;\n\n\tspd.client = cp;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = sp.delegated;\n\tspd.method_data = sp.method_data;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    return ret;\n\t}\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n\n\t{\n\t    Key *key;\n\t    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, /* XXX use correct kvno! */\n\t\t\t\t  sp.etype, &key);\n\t    if (ret == 0)\n\t\tret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\t    if (ret) {\n\t\tfree(data.data);\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ret;\n\t    }\n\t}\n\tret = krb5_verify_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH,\n\t\t\t\t   data.data, data.length,\n\t\t\t\t   &sp.cksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tfree(data.data);\n\tif (ret) {\n\t    free_KRB5SignedPath(&sp);\n\t    kdc_log(context, config, 5,\n\t\t    \"KRB5SignedPath not signed correctly, not marking as signed\");\n\t    return 0;\n\t}\n\n\tif (delegated && sp.delegated) {\n\n\t    *delegated = malloc(sizeof(*sp.delegated));\n\t    if (*delegated == NULL) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\treturn ENOMEM;\n\t    }\n\n\t    ret = copy_Principals(*delegated, sp.delegated);\n\t    if (ret) {\n\t\tfree_KRB5SignedPath(&sp);\n\t\tfree(*delegated);\n\t\t*delegated = NULL;\n\t\treturn ret;\n\t    }\n\t}\n\tfree_KRB5SignedPath(&sp);\n\n\t*signedpath = 1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "kdc_add_KRB5SignedPath(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "102-184",
    "snippet": "rb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "data)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdc_tkt_add_if_relevant_ad(",
          "args": [
            "ontext,",
            "kt,",
            "RB5_AUTHDATA_SIGNTICKET,",
            "data)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_Checksum(",
          "args": [
            "sp.cksum)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "RB5SignedPath,",
            "ata.data,",
            "ata.length,",
            "sp,",
            "size,",
            "et)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_destroy(",
          "args": [
            "ontext,",
            "rypto)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_create_checksum(",
          "args": [
            "ontext,",
            "rypto,",
            "RB5_KU_KRB5SIGNEDPATH,",
            ",",
            "ata.data,",
            "ata.length,",
            "sp.cksum)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ata.data)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_crypto_init(",
          "args": [
            "ontext,",
            "key->key,",
            ",",
            "crypto)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_enctype2key(",
          "args": [
            "ontext,",
            "krbtgt->entry,",
            "ULL,",
            "nctype,",
            "key)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_abortx(",
          "args": [
            "ontext,",
            "internal asn.1 encoder error\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SN1_MALLOC_ENCODE(",
          "args": [
            "RB5SignedPathData,",
            "ata.data,",
            "ata.length,",
            "spd,",
            "size,",
            "et)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_Principals(",
          "args": [
            "rincipals,",
            "erver)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\n_kdc_add_KRB5SignedPath(krb5_context context,\n\t\t\tkrb5_kdc_configuration *config,\n\t\t\thdb_entry_ex *krbtgt,\n\t\t\tkrb5_enctype enctype,\n\t\t\tkrb5_principal client,\n\t\t\tkrb5_const_principal server,\n\t\t\tkrb5_principals principals,\n\t\t\tEncTicketPart *tkt)\n{\n    krb5_error_code ret;\n    KRB5SignedPath sp;\n    krb5_data data;\n    krb5_crypto crypto = NULL;\n    size_t size = 0;\n\n    if (server && principals) {\n\tret = add_Principals(principals, server);\n\tif (ret)\n\t    return ret;\n    }\n\n    {\n\tKRB5SignedPathData spd;\n\n\tspd.client = client;\n\tspd.authtime = tkt->authtime;\n\tspd.delegated = principals;\n\tspd.method_data = NULL;\n\n\tASN1_MALLOC_ENCODE(KRB5SignedPathData, data.data, data.length,\n\t\t\t   &spd, &size, ret);\n\tif (ret)\n\t    return ret;\n\tif (data.length != size)\n\t    krb5_abortx(context, \"internal asn.1 encoder error\");\n    }\n\n    {\n\tKey *key;\n\tret = hdb_enctype2key(context, &krbtgt->entry, NULL, enctype, &key);\n\tif (ret == 0)\n\t    ret = krb5_crypto_init(context, &key->key, 0, &crypto);\n\tif (ret) {\n\t    free(data.data);\n\t    return ret;\n\t}\n    }\n\n    /*\n     * Fill in KRB5SignedPath\n     */\n\n    sp.etype = enctype;\n    sp.delegated = principals;\n    sp.method_data = NULL;\n\n    ret = krb5_create_checksum(context, crypto, KRB5_KU_KRB5SIGNEDPATH, 0,\n\t\t\t       data.data, data.length, &sp.cksum);\n    krb5_crypto_destroy(context, crypto);\n    free(data.data);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(KRB5SignedPath, data.data, data.length, &sp, &size, ret);\n    free_Checksum(&sp.cksum);\n    if (ret)\n\treturn ret;\n    if (data.length != size)\n\tkrb5_abortx(context, \"internal asn.1 encoder error\");\n\n\n    /*\n     * Add IF-RELEVANT(KRB5SignedPath) to the last slot in\n     * authorization data field.\n     */\n\n    ret = _kdc_tkt_add_if_relevant_ad(context, tkt,\n\t\t\t\t      KRB5_AUTHDATA_SIGNTICKET, &data);\n    krb5_data_free(&data);\n\n    return ret;\n}"
  },
  {
    "function_name": "ind_KRB5SignedPath(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "59-100",
    "snippet": "tatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "child)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er_copy_octet_string(",
          "args": [
            "child.val[0].ad_data,",
            "ata)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "child)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_AuthorizationData(",
          "args": [
            "child)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_set_error_message(",
          "args": [
            "ontext,",
            "et,",
            "Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\",",
            "et)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecode_AuthorizationData(",
          "args": [
            "d->val[pos].ad_data.data,",
            "d->val[pos].ad_data.length,",
            "child,",
            "ULL)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code\nfind_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}"
  },
  {
    "function_name": "et_krbtgt_realm(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/krb5tgs.c",
    "lines": "40-48",
    "snippet": "tatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "->name_string.val[0],",
            "RB5_TGS_NAME)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic Realm\nget_krbtgt_realm(const PrincipalName *p)\n{\n    if(p->name_string.len == 2\n       && strcmp(p->name_string.val[0], KRB5_TGS_NAME) == 0)\n\treturn p->name_string.val[1];\n    else\n\treturn NULL;\n}"
  }
]