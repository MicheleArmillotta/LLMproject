[
  {
    "function_name": "kdc_check_access(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "174-204",
    "snippet": "rb5_error_code\n_kdc_check_access(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  hdb_entry_ex *client_ex, const char *client_name,\n\t\t  hdb_entry_ex *server_ex, const char *server_name,\n\t\t  KDC_REQ *req,\n\t\t  METHOD_DATA *method_data)\n{\n    krb5_error_code ret = KRB5_PLUGIN_NO_HANDLE;\n    struct check_uc uc;\n\n    if (have_plugin) {\n        uc.config = config;\n        uc.client_ex = client_ex;\n        uc.client_name = client_name;\n        uc.server_ex = server_ex;\n        uc.server_name = server_name;\n        uc.req = req;\n        uc.method_data = method_data;\n\n        ret = _krb5_plugin_run_f(context, \"krb5\", \"windc\",\n                                 KRB5_WINDC_PLUGIN_MINOR, 0, &uc, check);\n    }\n\n    if (ret == KRB5_PLUGIN_NO_HANDLE)\n\treturn kdc_check_flags(context, config,\n\t\t\t       client_ex, client_name,\n\t\t\t       server_ex, server_name,\n\t\t\t       req->msg_type == krb_as_req);\n    return ret;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int have_plugin = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dc_check_flags(",
          "args": [
            "ontext,",
            "onfig,",
            "lient_ex,",
            "lient_name,",
            "erver_ex,",
            "erver_name,",
            "eq->msg_type == krb_as_req)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "dc_check_flags(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/kerberos5.c",
          "lines": "1296-1423",
          "snippet": "rb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) is locked out\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client (%s) has invalid bit set\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as client -- %s\", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client not yet valid until %s -- %s\",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client expired at %s -- %s\",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key must be changed -- %s\", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Client's key has expired at %s -- %s\",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Client server locked out -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \"Server has invalid flag set -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \"Principal may not act as server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \"AS-REQ is required for server -- %s\", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server not yet valid until %s -- %s\",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server expired at %s -- %s\",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \"Server's key has expired at -- %s\",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_plugin_run_f(",
          "args": [
            "ontext,",
            "krb5\",",
            "windc\",",
            "RB5_WINDC_PLUGIN_MINOR,",
            ",",
            "uc,",
            "heck)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_check_access(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  hdb_entry_ex *client_ex, const char *client_name,\n\t\t  hdb_entry_ex *server_ex, const char *server_name,\n\t\t  KDC_REQ *req,\n\t\t  METHOD_DATA *method_data)\n{\n    krb5_error_code ret = KRB5_PLUGIN_NO_HANDLE;\n    struct check_uc uc;\n\n    if (have_plugin) {\n        uc.config = config;\n        uc.client_ex = client_ex;\n        uc.client_name = client_name;\n        uc.server_ex = server_ex;\n        uc.server_name = server_name;\n        uc.req = req;\n        uc.method_data = method_data;\n\n        ret = _krb5_plugin_run_f(context, \"krb5\", \"windc\",\n                                 KRB5_WINDC_PLUGIN_MINOR, 0, &uc, check);\n    }\n\n    if (ret == KRB5_PLUGIN_NO_HANDLE)\n\treturn kdc_check_flags(context, config,\n\t\t\t       client_ex, client_name,\n\t\t\t       server_ex, server_name,\n\t\t\t       req->msg_type == krb_as_req);\n    return ret;\n}"
  },
  {
    "function_name": "heck(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "159-171",
    "snippet": "tatic krb5_error_code KRB5_LIB_CALL\ncheck(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct check_uc *uc = (struct check_uc *)userctx;    \n\n    if (ft->client_access == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    return ft->client_access((void *)plug, context, uc->config, \n\t\t\t     uc->client_ex, uc->client_name, \n\t\t\t     uc->server_ex, uc->server_name, \n\t\t\t     uc->req, uc->method_data);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->client_access",
          "args": [
            "void *)plug,",
            "ontext,",
            "c->config,",
            "c->client_ex,",
            "c->client_name,",
            "c->server_ex,",
            "c->server_name,",
            "c->req,",
            "c->method_data)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code KRB5_LIB_CALL\ncheck(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct check_uc *uc = (struct check_uc *)userctx;    \n\n    if (ft->client_access == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    return ft->client_access((void *)plug, context, uc->config, \n\t\t\t     uc->client_ex, uc->client_name, \n\t\t\t     uc->server_ex, uc->server_name, \n\t\t\t     uc->req, uc->method_data);\n}"
  },
  {
    "function_name": "kdc_pac_verify(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "121-147",
    "snippet": "rb5_error_code\n_kdc_pac_verify(krb5_context context,\n\t\tconst krb5_principal client_principal,\n\t\tconst krb5_principal delegated_proxy_principal,\n\t\thdb_entry_ex *client,\n\t\thdb_entry_ex *server,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_pac *pac,\n\t\tint *verified)\n{\n    struct verify_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client_principal = client_principal;\n    uc.delegated_proxy_principal = delegated_proxy_principal;\n    uc.client = client;\n    uc.server = server;\n    uc.krbtgt = krbtgt;\n    uc.pac = pac;\n    uc.verified = verified;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, verify);\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int have_plugin = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_plugin_run_f(",
          "args": [
            "ontext,",
            "krb5\",",
            "windc\",",
            "RB5_WINDC_PLUGIN_MINOR,",
            ",",
            "uc,",
            "erify)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_pac_verify(krb5_context context,\n\t\tconst krb5_principal client_principal,\n\t\tconst krb5_principal delegated_proxy_principal,\n\t\thdb_entry_ex *client,\n\t\thdb_entry_ex *server,\n\t\thdb_entry_ex *krbtgt,\n\t\tkrb5_pac *pac,\n\t\tint *verified)\n{\n    struct verify_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client_principal = client_principal;\n    uc.delegated_proxy_principal = delegated_proxy_principal;\n    uc.client = client;\n    uc.server = server;\n    uc.krbtgt = krbtgt;\n    uc.pac = pac;\n    uc.verified = verified;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, verify);\n    return 0;\n}"
  },
  {
    "function_name": "erify(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "102-119",
    "snippet": "tatic krb5_error_code KRB5_LIB_CALL\nverify(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct verify_uc *uc = (struct verify_uc *)userctx;    \n    krb5_error_code ret;\n\n    if (ft->pac_verify == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    ret = ft->pac_verify((void *)plug, context,\n\t\t\t uc->client_principal,\n\t\t\t uc->delegated_proxy_principal,\n\t\t\t uc->client, uc->server, uc->krbtgt, uc->pac);\n    if (ret == 0)\n\t(*uc->verified) = 1;\n\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->pac_verify",
          "args": [
            "void *)plug,",
            "ontext,",
            "c->client_principal,",
            "c->delegated_proxy_principal,",
            "c->client,",
            "c->server,",
            "c->krbtgt,",
            "c->pac)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code KRB5_LIB_CALL\nverify(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct verify_uc *uc = (struct verify_uc *)userctx;    \n    krb5_error_code ret;\n\n    if (ft->pac_verify == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    ret = ft->pac_verify((void *)plug, context,\n\t\t\t uc->client_principal,\n\t\t\t uc->delegated_proxy_principal,\n\t\t\t uc->client, uc->server, uc->krbtgt, uc->pac);\n    if (ret == 0)\n\t(*uc->verified) = 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "kdc_pac_generate(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "74-90",
    "snippet": "rb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int have_plugin = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_plugin_run_f(",
          "args": [
            "ontext,",
            "krb5\",",
            "windc\",",
            "RB5_WINDC_PLUGIN_MINOR,",
            ",",
            "uc,",
            "enerate)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\nrb5_error_code\n_kdc_pac_generate(krb5_context context,\n\t\t  hdb_entry_ex *client,\n\t\t  krb5_pac *pac)\n{\n    struct generate_uc uc;\n\n    if (!have_plugin)\n\treturn 0;\n\n    uc.client = client;\n    uc.pac = pac;\n\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, &uc, generate);\n    return 0;\n}"
  },
  {
    "function_name": "enerate(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "62-71",
    "snippet": "tatic krb5_error_code KRB5_LIB_CALL\ngenerate(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct generate_uc *uc = (struct generate_uc *)userctx;    \n\n    if (ft->pac_generate == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    return ft->pac_generate((void *)plug, context, uc->client, uc->pac);\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->pac_generate",
          "args": [
            "void *)plug,",
            "ontext,",
            "c->client,",
            "c->pac)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic krb5_error_code KRB5_LIB_CALL\ngenerate(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    krb5plugin_windc_ftable *ft = (krb5plugin_windc_ftable *)plug;\n    struct generate_uc *uc = (struct generate_uc *)userctx;    \n\n    if (ft->pac_generate == NULL)\n\treturn KRB5_PLUGIN_NO_HANDLE;\n    return ft->pac_generate((void *)plug, context, uc->client, uc->pac);\n}"
  },
  {
    "function_name": "rb5_kdc_windc_init(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "49-55",
    "snippet": "rb5_error_code\nkrb5_kdc_windc_init(krb5_context context)\n{\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, NULL, load);\n    return 0;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_plugin_run_f(",
          "args": [
            "ontext,",
            "krb5\",",
            "windc\",",
            "RB5_WINDC_PLUGIN_MINOR,",
            ",",
            "ULL,",
            "oad)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"kdc_locl.h\"\n\nrb5_error_code\nkrb5_kdc_windc_init(krb5_context context)\n{\n    (void)_krb5_plugin_run_f(context, \"krb5\", \"windc\",\n\t\t\t     KRB5_WINDC_PLUGIN_MINOR, 0, NULL, load);\n    return 0;\n}"
  },
  {
    "function_name": "oad(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/windc.c",
    "lines": "42-47",
    "snippet": "tatic krb5_error_code KRB5_LIB_CALL\nload(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    have_plugin = 1;\n    return KRB5_PLUGIN_NO_HANDLE;\n}",
    "includes": [
      "include \"kdc_locl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int have_plugin = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic int have_plugin = 0;\n\ntatic krb5_error_code KRB5_LIB_CALL\nload(krb5_context context, const void *plug, void *plugctx, void *userctx)\n{\n    have_plugin = 1;\n    return KRB5_PLUGIN_NO_HANDLE;\n}"
  }
]