[
  {
    "function_name": "it_prop_dump(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
    "lines": "134-220",
    "snippet": "nt\nmit_prop_dump(void *arg, const char *file)\n{\n    krb5_error_code ret;\n    size_t line_bufsz = 0;\n    size_t line_len = 0;\n    char *line = NULL;\n    int lineno = 0;\n    FILE *f;\n    struct hdb_entry_ex ent;\n    struct prop_data *pd = arg;\n    krb5_storage *sp = NULL;\n    krb5_data kdb_ent;\n\n    memset(&ent, 0, sizeof (ent));\n    f = fopen(file, \"r\");\n    if (f == NULL)\n\treturn errno;\n\n    ret = ENOMEM;\n    sp = krb5_storage_emem();\n    if (!sp)\n        goto out;\n    while ((ret = my_fgetln(f, &line, &line_bufsz, &line_len)) == 0 &&\n           !feof(f)) {\n        char *p = line;\n        char *q;\n        lineno++;\n\n\tif(strncmp(line, \"kdb5_util\", strlen(\"kdb5_util\")) == 0) {\n\t    int major;\n            q = nexttoken(&p);\n            if (strcmp(q, \"kdb5_util\"))\n                errx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"load_dump\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"version\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* x.0 */\n\t    if (sscanf(q, \"%d\", &major) != 1)\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    if (major != 4 && major != 5 && major != 6)\n\t\terrx(1, \"unknown dump file format, got %d, expected 4-6\",\n\t\t     major);\n\t    continue;\n\t} else if(strncmp(p, \"policy\", strlen(\"policy\")) == 0) {\n            warnx(\"line: %d: ignoring policy (not supported)\", lineno);\n\t    continue;\n\t} else if(strncmp(p, \"princ\", strlen(\"princ\")) != 0) {\n\t    warnx(\"line %d: not a principal\", lineno);\n\t    continue;\n\t}\n        krb5_storage_truncate(sp, 0);\n        ret = _hdb_mit_dump2mitdb_entry(pd->context, line, sp);\n        if (ret) {\n            if (ret > 0)\n                warn(\"line: %d: failed to parse; ignoring\", lineno);\n            else\n                warnx(\"line: %d: failed to parse; ignoring\", lineno);\n            continue;\n        }\n        ret = krb5_storage_to_data(sp, &kdb_ent);\n        if (ret) break;\n        ret = _hdb_mdb_value2entry(pd->context, &kdb_ent, 0, &ent.entry);\n        krb5_data_free(&kdb_ent);\n        if (ret) {\n            warnx(\"line: %d: failed to store; ignoring\", lineno);\n            continue;\n        }\n\tret = v5_prop(pd->context, NULL, &ent, arg);\n        hdb_free_entry(pd->context, &ent);\n        if (ret) break;\n    }\n\nout:\n    fclose(f);\n    free(line);\n    if (sp)\n        krb5_storage_free(sp);\n    if (ret && ret == ENOMEM)\n        errx(1, \"out of memory\");\n    if (ret)\n        errx(1, \"line %d: problem parsing dump line\", lineno);\n    return ret;\n}",
    "includes": [
      "include <kadm5/admin.h>",
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "xtern krb5_error_code _hdb_mdb_value2entry(krb5_context context,\n                                            krb5_data *data,\n                                            krb5_kvno target_kvno,\n                                            hdb_entry *entry);",
      "xtern int _hdb_mit_dump2mitdb_entry(krb5_context context,\n                                     char *line,\n                                     krb5_storage *sp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "line %d: problem parsing dump line\",",
            "ineno)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "out of memory\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_free(",
          "args": [
            "p)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "ine)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close(",
          "args": [
            ")"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_free_entry(",
          "args": [
            "d->context,",
            "ent)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "5_prop(",
          "args": [
            "d->context,",
            "ULL,",
            "ent,",
            "rg)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "5_prop(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/hprop.c",
          "lines": "89-124",
          "snippet": "rb5_error_code\nv5_prop(krb5_context context, HDB *db, hdb_entry_ex *entry, void *appdata)\n{\n    krb5_error_code ret;\n    struct prop_data *pd = appdata;\n    krb5_data data;\n\n    if(encrypt_flag) {\n\tret = hdb_seal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_seal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n    if(decrypt_flag) {\n\tret = hdb_unseal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_unseal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n\n    ret = hdb_entry2value(context, &entry->entry, &data);\n    if(ret) {\n\tkrb5_warn(context, ret, \"hdb_entry2value\");\n\treturn ret;\n    }\n\n    if(to_stdout)\n\tret = krb5_write_message(context, &pd->sock, &data);\n    else\n\tret = krb5_write_priv_message(context, pd->auth_context,\n\t\t\t\t      &pd->sock, &data);\n    krb5_data_free(&data);\n    return ret;\n}",
          "includes": [
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int to_stdout;",
            "tatic int encrypt_flag;",
            "tatic int decrypt_flag;",
            "tatic hdb_master_key mkey5;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"hprop.h\"\n\ntatic int to_stdout;\ntatic int encrypt_flag;\ntatic int decrypt_flag;\ntatic hdb_master_key mkey5;\n\nrb5_error_code\nv5_prop(krb5_context context, HDB *db, hdb_entry_ex *entry, void *appdata)\n{\n    krb5_error_code ret;\n    struct prop_data *pd = appdata;\n    krb5_data data;\n\n    if(encrypt_flag) {\n\tret = hdb_seal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_seal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n    if(decrypt_flag) {\n\tret = hdb_unseal_keys_mkey(context, &entry->entry, mkey5);\n\tif (ret) {\n\t    krb5_warn(context, ret, \"hdb_unseal_keys_mkey\");\n\t    return ret;\n\t}\n    }\n\n    ret = hdb_entry2value(context, &entry->entry, &data);\n    if(ret) {\n\tkrb5_warn(context, ret, \"hdb_entry2value\");\n\treturn ret;\n    }\n\n    if(to_stdout)\n\tret = krb5_write_message(context, &pd->sock, &data);\n    else\n\tret = krb5_write_priv_message(context, pd->auth_context,\n\t\t\t\t      &pd->sock, &data);\n    krb5_data_free(&data);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arnx(",
          "args": [
            "line: %d: failed to store; ignoring\",",
            "ineno)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_data_free(",
          "args": [
            "kdb_ent)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hdb_mdb_value2entry(",
          "args": [
            "d->context,",
            "kdb_ent,",
            ",",
            "ent.entry)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_to_data(",
          "args": [
            "p,",
            "kdb_ent)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arnx(",
          "args": [
            "line: %d: failed to parse; ignoring\",",
            "ineno)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arn(",
          "args": [
            "line: %d: failed to parse; ignoring\",",
            "ineno)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hdb_mit_dump2mitdb_entry(",
          "args": [
            "d->context,",
            "ine,",
            "p)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_storage_truncate(",
          "args": [
            "p,",
            ")"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arnx(",
          "args": [
            "line %d: not a principal\",",
            "ineno)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            ",",
            "princ\",",
            "trlen(\"princ\"))"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "princ\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arnx(",
          "args": [
            "line: %d: ignoring policy (not supported)\",",
            "ineno)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            ",",
            "policy\",",
            "trlen(\"policy\"))"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "policy\")"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "unknown dump file format, got %d, expected 4-6\",",
            "ajor)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "line %d: unknown version\",",
            "ineno)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanf(",
          "args": [
            ",",
            "%d\",",
            "major)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exttoken(",
          "args": [
            "p)"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "exttoken(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
          "lines": "88-96",
          "snippet": "tatic char *\nnexttoken(char **p)\n{\n    char *q;\n    do {\n\tq = strsep(p, \" \\t\");\n    } while(q && *q == '\\0');\n    return q;\n}",
          "includes": [
            "include <kadm5/admin.h>",
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\ntatic char *\nnexttoken(char **p)\n{\n    char *q;\n    do {\n\tq = strsep(p, \" \\t\");\n    } while(q && *q == '\\0');\n    return q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "line %d: unknown version\",",
            "ineno)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "version\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "line %d: unknown version\",",
            "ineno)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "load_dump\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "line %d: unknown version\",",
            "ineno)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            ",",
            "kdb5_util\")"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            "ine,",
            "kdb5_util\",",
            "trlen(\"kdb5_util\"))"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "kdb5_util\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eof(",
          "args": [
            ")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y_fgetln(",
          "args": [
            ",",
            "line,",
            "line_bufsz,",
            "line_len)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "y_fgetln(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
          "lines": "101-132",
          "snippet": "tatic int\nmy_fgetln(FILE *f, char **buf, size_t *sz, size_t *len)\n{\n    char *p, *n;\n\n    if (!*buf) {\n        *buf = malloc(*sz ? *sz : 2048);\n        if (!*buf)\n            return ENOMEM;\n        if (!*sz)\n            *sz = 2048;\n    }\n    *len = 0;\n    while ((p = fgets(&(*buf)[*len], *sz - *len, f))) {\n        *len = strlen(*buf);\n        if (feof(f))\n            return 0;\n        if (strchr(*buf, '\\n'))\n            return 0;\n        n = realloc(*buf, *sz + (*sz >> 1));\n        if (!n) {\n            free(*buf);\n            *buf = NULL;\n            *sz = 0;\n            *len = 0;\n            return ENOMEM;\n        }\n        *buf = n;\n        *sz += *sz >> 1;\n    }\n    return 0; /* *len == 0 || no EOL -> EOF */\n}",
          "includes": [
            "include <kadm5/admin.h>",
            "include \"hprop.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\ntatic int\nmy_fgetln(FILE *f, char **buf, size_t *sz, size_t *len)\n{\n    char *p, *n;\n\n    if (!*buf) {\n        *buf = malloc(*sz ? *sz : 2048);\n        if (!*buf)\n            return ENOMEM;\n        if (!*sz)\n            *sz = 2048;\n    }\n    *len = 0;\n    while ((p = fgets(&(*buf)[*len], *sz - *len, f))) {\n        *len = strlen(*buf);\n        if (feof(f))\n            return 0;\n        if (strchr(*buf, '\\n'))\n            return 0;\n        n = realloc(*buf, *sz + (*sz >> 1));\n        if (!n) {\n            free(*buf);\n            *buf = NULL;\n            *sz = 0;\n            *len = 0;\n            return ENOMEM;\n        }\n        *buf = n;\n        *sz += *sz >> 1;\n    }\n    return 0; /* *len == 0 || no EOL -> EOF */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb5_storage_emem(",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open(",
          "args": [
            "ile,",
            "r\")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "ent,",
            ",",
            "izeof (ent))"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\nxtern krb5_error_code _hdb_mdb_value2entry(krb5_context context,\n                                            krb5_data *data,\n                                            krb5_kvno target_kvno,\n                                            hdb_entry *entry);\nxtern int _hdb_mit_dump2mitdb_entry(krb5_context context,\n                                     char *line,\n                                     krb5_storage *sp);\n\nnt\nmit_prop_dump(void *arg, const char *file)\n{\n    krb5_error_code ret;\n    size_t line_bufsz = 0;\n    size_t line_len = 0;\n    char *line = NULL;\n    int lineno = 0;\n    FILE *f;\n    struct hdb_entry_ex ent;\n    struct prop_data *pd = arg;\n    krb5_storage *sp = NULL;\n    krb5_data kdb_ent;\n\n    memset(&ent, 0, sizeof (ent));\n    f = fopen(file, \"r\");\n    if (f == NULL)\n\treturn errno;\n\n    ret = ENOMEM;\n    sp = krb5_storage_emem();\n    if (!sp)\n        goto out;\n    while ((ret = my_fgetln(f, &line, &line_bufsz, &line_len)) == 0 &&\n           !feof(f)) {\n        char *p = line;\n        char *q;\n        lineno++;\n\n\tif(strncmp(line, \"kdb5_util\", strlen(\"kdb5_util\")) == 0) {\n\t    int major;\n            q = nexttoken(&p);\n            if (strcmp(q, \"kdb5_util\"))\n                errx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"load_dump\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* load_dump */\n\t    if (strcmp(q, \"version\"))\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    q = nexttoken(&p); /* x.0 */\n\t    if (sscanf(q, \"%d\", &major) != 1)\n\t\terrx(1, \"line %d: unknown version\", lineno);\n\t    if (major != 4 && major != 5 && major != 6)\n\t\terrx(1, \"unknown dump file format, got %d, expected 4-6\",\n\t\t     major);\n\t    continue;\n\t} else if(strncmp(p, \"policy\", strlen(\"policy\")) == 0) {\n            warnx(\"line: %d: ignoring policy (not supported)\", lineno);\n\t    continue;\n\t} else if(strncmp(p, \"princ\", strlen(\"princ\")) != 0) {\n\t    warnx(\"line %d: not a principal\", lineno);\n\t    continue;\n\t}\n        krb5_storage_truncate(sp, 0);\n        ret = _hdb_mit_dump2mitdb_entry(pd->context, line, sp);\n        if (ret) {\n            if (ret > 0)\n                warn(\"line: %d: failed to parse; ignoring\", lineno);\n            else\n                warnx(\"line: %d: failed to parse; ignoring\", lineno);\n            continue;\n        }\n        ret = krb5_storage_to_data(sp, &kdb_ent);\n        if (ret) break;\n        ret = _hdb_mdb_value2entry(pd->context, &kdb_ent, 0, &ent.entry);\n        krb5_data_free(&kdb_ent);\n        if (ret) {\n            warnx(\"line: %d: failed to store; ignoring\", lineno);\n            continue;\n        }\n\tret = v5_prop(pd->context, NULL, &ent, arg);\n        hdb_free_entry(pd->context, &ent);\n        if (ret) break;\n    }\n\nout:\n    fclose(f);\n    free(line);\n    if (sp)\n        krb5_storage_free(sp);\n    if (ret && ret == ENOMEM)\n        errx(1, \"out of memory\");\n    if (ret)\n        errx(1, \"line %d: problem parsing dump line\", lineno);\n    return ret;\n}"
  },
  {
    "function_name": "y_fgetln(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
    "lines": "101-132",
    "snippet": "tatic int\nmy_fgetln(FILE *f, char **buf, size_t *sz, size_t *len)\n{\n    char *p, *n;\n\n    if (!*buf) {\n        *buf = malloc(*sz ? *sz : 2048);\n        if (!*buf)\n            return ENOMEM;\n        if (!*sz)\n            *sz = 2048;\n    }\n    *len = 0;\n    while ((p = fgets(&(*buf)[*len], *sz - *len, f))) {\n        *len = strlen(*buf);\n        if (feof(f))\n            return 0;\n        if (strchr(*buf, '\\n'))\n            return 0;\n        n = realloc(*buf, *sz + (*sz >> 1));\n        if (!n) {\n            free(*buf);\n            *buf = NULL;\n            *sz = 0;\n            *len = 0;\n            return ENOMEM;\n        }\n        *buf = n;\n        *sz += *sz >> 1;\n    }\n    return 0; /* *len == 0 || no EOL -> EOF */\n}",
    "includes": [
      "include <kadm5/admin.h>",
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(",
          "args": [
            "buf)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealloc(",
          "args": [
            "buf,",
            "sz + (*sz >> 1))"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "buf,",
            "\\n')"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eof(",
          "args": [
            ")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "buf)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gets(",
          "args": [
            "(*buf)[*len],",
            "sz - *len,",
            ")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(",
          "args": [
            "sz ? *sz : 2048)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\ntatic int\nmy_fgetln(FILE *f, char **buf, size_t *sz, size_t *len)\n{\n    char *p, *n;\n\n    if (!*buf) {\n        *buf = malloc(*sz ? *sz : 2048);\n        if (!*buf)\n            return ENOMEM;\n        if (!*sz)\n            *sz = 2048;\n    }\n    *len = 0;\n    while ((p = fgets(&(*buf)[*len], *sz - *len, f))) {\n        *len = strlen(*buf);\n        if (feof(f))\n            return 0;\n        if (strchr(*buf, '\\n'))\n            return 0;\n        n = realloc(*buf, *sz + (*sz >> 1));\n        if (!n) {\n            free(*buf);\n            *buf = NULL;\n            *sz = 0;\n            *len = 0;\n            return ENOMEM;\n        }\n        *buf = n;\n        *sz += *sz >> 1;\n    }\n    return 0; /* *len == 0 || no EOL -> EOF */\n}"
  },
  {
    "function_name": "exttoken(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/mit_dump.c",
    "lines": "88-96",
    "snippet": "tatic char *\nnexttoken(char **p)\n{\n    char *q;\n    do {\n\tq = strsep(p, \" \\t\");\n    } while(q && *q == '\\0');\n    return q;\n}",
    "includes": [
      "include <kadm5/admin.h>",
      "include \"hprop.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trsep(",
          "args": [
            ",",
            "\\t\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <kadm5/admin.h>\ninclude \"hprop.h\"\n\ntatic char *\nnexttoken(char **p)\n{\n    char *q;\n    do {\n\tq = strsep(p, \" \\t\");\n    } while(q && *q == '\\0');\n    return q;\n}"
  }
]