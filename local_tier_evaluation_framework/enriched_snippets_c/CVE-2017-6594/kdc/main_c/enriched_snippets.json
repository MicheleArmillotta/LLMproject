[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/main.c",
    "lines": "113-179",
    "snippet": "nt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    int optidx = 0;\n\n    setprogname(argv[0]);\n\n    ret = krb5_init_context(&context);\n    if (ret == KRB5_CONFIG_BADFORMAT)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n    else if (ret)\n\terrx (1, \"krb5_init_context failed: %d\", ret);\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if (ret)\n\terrx (1, \"krb5_kt_register(HDB) failed: %d\", ret);\n\n    config = configure(context, argc, argv, &optidx);\n\n#ifdef HAVE_SIGACTION\n    {\n\tstruct sigaction sa;\n\n\tsa.sa_flags = 0;\n\tsa.sa_handler = sigterm;\n\tsigemptyset(&sa.sa_mask);\n\n\tsigaction(SIGINT, &sa, NULL);\n\tsigaction(SIGTERM, &sa, NULL);\n#ifdef SIGXCPU\n\tsigaction(SIGXCPU, &sa, NULL);\n#endif\n\n#ifdef SIGCHLD\n\tsa.sa_handler = sigchld;\n\tsigaction(SIGCHLD, &sa, NULL);\n#endif\n\n\tsa.sa_handler = SIG_IGN;\n#ifdef SIGPIPE\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n    }\n#else\n    signal(SIGINT, sigterm);\n    signal(SIGTERM, sigterm);\n#ifdef SIGCHLD\n    signal(SIGCHLD, sigchld);\n#endif\n#ifdef SIGXCPU\n    signal(SIGXCPU, sigterm);\n#endif\n#ifdef SIGPIPE\n    signal(SIGPIPE, SIG_IGN);\n#endif\n#endif\n    rk_pidfile(NULL);\n\n    switch_environment();\n\n    start_kdc(context, config, argv[0]);\n    krb5_free_context(context);\n    return 0;\n}",
    "includes": [
      "include <cap-ng.h>\n#",
      "include <util.h>\n#",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb5_free_context(",
          "args": [
            "ontext)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tart_kdc(",
          "args": [
            "ontext,",
            "onfig,",
            "rgv[0])"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "tart_kdc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/connect.c",
          "lines": "1094-1273",
          "snippet": "oid\nstart_kdc(krb5_context context,\n\t  krb5_kdc_configuration *config, const char *argv0)\n{\n    struct timeval tv1;\n    struct timeval tv2;\n    struct descr *d;\n    unsigned int ndescr;\n    pid_t pid = -1;\n#ifdef HAVE_FORK\n    pid_t *pids;\n    int max_kdcs = config->num_kdc_processes;\n    int num_kdcs = 0;\n    int i;\n    int islive[2];\n#endif\n\n#ifdef __APPLE__\n    if (do_bonjour > 0)\n        bonjour_kid(context, config, argv0, NULL);\n#endif\n\n#ifdef HAVE_FORK\n#ifdef _SC_NPROCESSORS_ONLN\n    if (max_kdcs < 1)\n\tmax_kdcs = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n    if (max_kdcs < 1)\n\tmax_kdcs = 1;\n\n    pids = calloc(max_kdcs, sizeof(*pids));\n    if (!pids)\n\tkrb5_err(context, 1, errno, \"malloc\");\n\n    /*\n     * We open a socketpair of which we hand one end to each of our kids.\n     * When we exit, for whatever reason, the children will notice an EOF\n     * on their end and be able to cleanly exit.\n     */\n\n    if (socketpair(PF_LOCAL, SOCK_STREAM, 0, islive) == -1)\n\tkrb5_errx(context, 1, \"socketpair\");\n    socket_set_nonblocking(islive[1], 1);\n#endif\n\n    ndescr = init_sockets(context, config, &d);\n    if(ndescr <= 0)\n\tkrb5_errx(context, 1, \"No sockets!\");\n\n#ifdef HAVE_FORK\n\n# ifdef __APPLE__\n    if (do_bonjour < 0)\n        bonjour_kid(context, config, argv0, islive);\n# endif\n\n    kdc_log(context, config, 0, \"KDC started master process pid=%d\", getpid());\n#else\n    kdc_log(context, config, 0, \"KDC started pid=%d\", getpid());\n#endif\n\n    roken_detach_finish(NULL, daemon_child);\n\n    tv1.tv_sec  = 0;\n    tv1.tv_usec = 0;\n\n#ifdef HAVE_FORK\n    if (!testing_flag) {\n        /* Note that we might never execute the body of this loop */\n        while (exit_flag == 0) {\n\n            /* Slow down the creation of KDCs... */\n\n            gettimeofday(&tv2, NULL);\n            if (tv1.tv_sec == tv2.tv_sec && tv2.tv_usec - tv1.tv_usec < 25000) {\n#if 0\t/* XXXrcd: should print a message... */\n                kdc_log(context, config, 0, \"Spawning KDCs too quickly, \"\n                    \"pausing for 50ms\");\n#endif\n                select_sleep(12500);\n                continue;\n            }\n\n            if (num_kdcs >= max_kdcs) {\n                num_kdcs -= reap_kid(context, config, pids, max_kdcs, 0);\n                continue;\n            }\n\n            if (num_kdcs > 0)\n                num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n\n            pid = fork();\n            switch (pid) {\n            case 0:\n                close(islive[0]);\n                loop(context, config, d, ndescr, islive[1]);\n                exit(0);\n            case -1:\n                /* XXXrcd: hmmm, do something useful?? */\n                kdc_log(context, config, 0,\n                        \"KDC master process could not fork worker process\");\n                sleep(10);\n                break;\n            default:\n                for (i=0; i < max_kdcs; i++) {\n                    if (pids[i] == 0) {\n                        pids[i] = pid;\n                        break;\n                    }\n                }\n                kdc_log(context, config, 0, \"KDC worker process started: %d\",\n                        pid);\n                num_kdcs++;\n                gettimeofday(&tv1, NULL);\n                break;\n            }\n        }\n\n        /* Closing these sockets should cause the kids to die... */\n\n        close(islive[0]);\n        close(islive[1]);\n\n        /* Close our listener sockets before terminating workers */\n        for (i = 0; i < ndescr; ++i)\n            clear_descr(&d[i]);\n\n        gettimeofday(&tv1, NULL);\n        tv2 = tv1;\n\n        /* Reap every 10ms, terminate stragglers once a second, give up after 10 */\n        for (;;) {\n            struct timeval tv3;\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                goto end;\n            /*\n             * Using select to sleep will fail with EINTR if we receive a\n             * SIGCHLD.  This is desirable.\n             */\n            select_sleep(10000);\n            gettimeofday(&tv3, NULL);\n            if (tv3.tv_sec - tv1.tv_sec > 10 ||\n                (tv3.tv_sec - tv1.tv_sec == 10 && tv3.tv_usec >= tv1.tv_usec))\n                break;\n            if (tv3.tv_sec - tv2.tv_sec > 1 ||\n                (tv3.tv_sec - tv2.tv_sec == 1 && tv3.tv_usec >= tv2.tv_usec)) {\n                kill_kids(pids, max_kdcs, SIGTERM);\n                tv2 = tv3;\n            }\n        }\n\n        /* Kill stragglers and reap every 200ms, give up after 15s */\n        for (;;) {\n            kill_kids(pids, max_kdcs, SIGKILL);\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                break;\n            select_sleep(200000);\n            gettimeofday(&tv2, NULL);\n            if (tv2.tv_sec - tv1.tv_sec > 15 ||\n                (tv2.tv_sec - tv1.tv_sec == 15 && tv2.tv_usec >= tv1.tv_usec))\n                break;\n        }\n\n     end:\n        kdc_log(context, config, 0, \"KDC master process exiting\", pid);\n        free(pids);\n    } else {\n        loop(context, config, d, ndescr, -1);\n        kdc_log(context, config, 0, \"KDC exiting\", pid);\n    }\n#else\n    loop(context, config, d, ndescr, -1);\n    kdc_log(context, config, 0, \"KDC exiting\", pid);\n#endif\n\n    free(d);\n}",
          "includes": [
            "include \"kdc_locl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "tatic pid_t bonjour_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"kdc_locl.h\"\n\ntatic pid_t bonjour_pid = -1;\n\noid\nstart_kdc(krb5_context context,\n\t  krb5_kdc_configuration *config, const char *argv0)\n{\n    struct timeval tv1;\n    struct timeval tv2;\n    struct descr *d;\n    unsigned int ndescr;\n    pid_t pid = -1;\n#ifdef HAVE_FORK\n    pid_t *pids;\n    int max_kdcs = config->num_kdc_processes;\n    int num_kdcs = 0;\n    int i;\n    int islive[2];\n#endif\n\n#ifdef __APPLE__\n    if (do_bonjour > 0)\n        bonjour_kid(context, config, argv0, NULL);\n#endif\n\n#ifdef HAVE_FORK\n#ifdef _SC_NPROCESSORS_ONLN\n    if (max_kdcs < 1)\n\tmax_kdcs = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n    if (max_kdcs < 1)\n\tmax_kdcs = 1;\n\n    pids = calloc(max_kdcs, sizeof(*pids));\n    if (!pids)\n\tkrb5_err(context, 1, errno, \"malloc\");\n\n    /*\n     * We open a socketpair of which we hand one end to each of our kids.\n     * When we exit, for whatever reason, the children will notice an EOF\n     * on their end and be able to cleanly exit.\n     */\n\n    if (socketpair(PF_LOCAL, SOCK_STREAM, 0, islive) == -1)\n\tkrb5_errx(context, 1, \"socketpair\");\n    socket_set_nonblocking(islive[1], 1);\n#endif\n\n    ndescr = init_sockets(context, config, &d);\n    if(ndescr <= 0)\n\tkrb5_errx(context, 1, \"No sockets!\");\n\n#ifdef HAVE_FORK\n\n# ifdef __APPLE__\n    if (do_bonjour < 0)\n        bonjour_kid(context, config, argv0, islive);\n# endif\n\n    kdc_log(context, config, 0, \"KDC started master process pid=%d\", getpid());\n#else\n    kdc_log(context, config, 0, \"KDC started pid=%d\", getpid());\n#endif\n\n    roken_detach_finish(NULL, daemon_child);\n\n    tv1.tv_sec  = 0;\n    tv1.tv_usec = 0;\n\n#ifdef HAVE_FORK\n    if (!testing_flag) {\n        /* Note that we might never execute the body of this loop */\n        while (exit_flag == 0) {\n\n            /* Slow down the creation of KDCs... */\n\n            gettimeofday(&tv2, NULL);\n            if (tv1.tv_sec == tv2.tv_sec && tv2.tv_usec - tv1.tv_usec < 25000) {\n#if 0\t/* XXXrcd: should print a message... */\n                kdc_log(context, config, 0, \"Spawning KDCs too quickly, \"\n                    \"pausing for 50ms\");\n#endif\n                select_sleep(12500);\n                continue;\n            }\n\n            if (num_kdcs >= max_kdcs) {\n                num_kdcs -= reap_kid(context, config, pids, max_kdcs, 0);\n                continue;\n            }\n\n            if (num_kdcs > 0)\n                num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n\n            pid = fork();\n            switch (pid) {\n            case 0:\n                close(islive[0]);\n                loop(context, config, d, ndescr, islive[1]);\n                exit(0);\n            case -1:\n                /* XXXrcd: hmmm, do something useful?? */\n                kdc_log(context, config, 0,\n                        \"KDC master process could not fork worker process\");\n                sleep(10);\n                break;\n            default:\n                for (i=0; i < max_kdcs; i++) {\n                    if (pids[i] == 0) {\n                        pids[i] = pid;\n                        break;\n                    }\n                }\n                kdc_log(context, config, 0, \"KDC worker process started: %d\",\n                        pid);\n                num_kdcs++;\n                gettimeofday(&tv1, NULL);\n                break;\n            }\n        }\n\n        /* Closing these sockets should cause the kids to die... */\n\n        close(islive[0]);\n        close(islive[1]);\n\n        /* Close our listener sockets before terminating workers */\n        for (i = 0; i < ndescr; ++i)\n            clear_descr(&d[i]);\n\n        gettimeofday(&tv1, NULL);\n        tv2 = tv1;\n\n        /* Reap every 10ms, terminate stragglers once a second, give up after 10 */\n        for (;;) {\n            struct timeval tv3;\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                goto end;\n            /*\n             * Using select to sleep will fail with EINTR if we receive a\n             * SIGCHLD.  This is desirable.\n             */\n            select_sleep(10000);\n            gettimeofday(&tv3, NULL);\n            if (tv3.tv_sec - tv1.tv_sec > 10 ||\n                (tv3.tv_sec - tv1.tv_sec == 10 && tv3.tv_usec >= tv1.tv_usec))\n                break;\n            if (tv3.tv_sec - tv2.tv_sec > 1 ||\n                (tv3.tv_sec - tv2.tv_sec == 1 && tv3.tv_usec >= tv2.tv_usec)) {\n                kill_kids(pids, max_kdcs, SIGTERM);\n                tv2 = tv3;\n            }\n        }\n\n        /* Kill stragglers and reap every 200ms, give up after 15s */\n        for (;;) {\n            kill_kids(pids, max_kdcs, SIGKILL);\n            num_kdcs -= reap_kids(context, config, pids, max_kdcs);\n            if (num_kdcs == 0 && bonjour_pid <= 0)\n                break;\n            select_sleep(200000);\n            gettimeofday(&tv2, NULL);\n            if (tv2.tv_sec - tv1.tv_sec > 15 ||\n                (tv2.tv_sec - tv1.tv_sec == 15 && tv2.tv_usec >= tv1.tv_usec))\n                break;\n        }\n\n     end:\n        kdc_log(context, config, 0, \"KDC master process exiting\", pid);\n        free(pids);\n    } else {\n        loop(context, config, d, ndescr, -1);\n        kdc_log(context, config, 0, \"KDC exiting\", pid);\n    }\n#else\n    loop(context, config, d, ndescr, -1);\n    kdc_log(context, config, 0, \"KDC exiting\", pid);\n#endif\n\n    free(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "witch_environment(",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_pidfile(",
          "args": [
            "ULL)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal(",
          "args": [
            "IGPIPE,",
            "IG_IGN)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal(",
          "args": [
            "IGXCPU,",
            "igterm)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal(",
          "args": [
            "IGCHLD,",
            "igchld)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal(",
          "args": [
            "IGTERM,",
            "igterm)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal(",
          "args": [
            "IGINT,",
            "igterm)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igaction(",
          "args": [
            "IGPIPE,",
            "sa,",
            "ULL)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igaction(",
          "args": [
            "IGCHLD,",
            "sa,",
            "ULL)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igaction(",
          "args": [
            "IGXCPU,",
            "sa,",
            "ULL)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igaction(",
          "args": [
            "IGTERM,",
            "sa,",
            "ULL)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igaction(",
          "args": [
            "IGINT,",
            "sa,",
            "ULL)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igemptyset(",
          "args": [
            "sa.sa_mask)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onfigure(",
          "args": [
            "ontext,",
            "rgc,",
            "rgv,",
            "optidx)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "onfigure(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/config.c",
          "lines": "154-307",
          "snippet": "rb5_kdc_configuration *\nconfigure(krb5_context context, int argc, char **argv, int *optidx)\n{\n    krb5_kdc_configuration *config;\n    krb5_error_code ret;\n    \n    const char *p;\n\n    *optidx = 0;\n\n    while (getarg(args, num_args, argc, argv, optidx))\n\twarnx(\"error at argument `%s'\", argv[*optidx]);\n\n    if (help_flag)\n\tusage (0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    if (builtin_hdb_flag) {\n\tchar *list;\n\tret = hdb_list_builtin(context, &list);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"listing builtin hdb backends\");\n\tprintf(\"builtin hdb backends: %s\\n\", list);\n\tfree(list);\n\texit(0);\n    }\n\n    if(detach_from_console == -1)\n\tdetach_from_console = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t\t   \"detach\", NULL);\n\n    if (detach_from_console && daemon_child == -1)\n        roken_detach_prep(argc, argv, \"--daemon-child\");\n\n    {\n\tchar **files;\n\tint aret;\n\n\tif (config_file == NULL) {\n\t    aret = asprintf(&config_file, \"%s/kdc.conf\", hdb_db_dir(context));\n\t    if (aret == -1 || config_file == NULL)\n\t\terrx(1, \"out of memory\");\n\t}\n\n\tret = krb5_prepend_config_files_default(config_file, &files);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"getting configuration files\");\n\n\tret = krb5_set_config_files(context, files);\n\tkrb5_free_config_files(files);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"reading configuration files\");\n    }\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n    if(max_request_str)\n\tmax_request_tcp = max_request_udp = parse_bytes(max_request_str, NULL);\n\n    if(max_request_tcp == 0){\n\tp = krb5_config_get_string (context,\n\t\t\t\t    NULL,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-request\",\n\t\t\t\t    NULL);\n\tif(p)\n\t    max_request_tcp = max_request_udp = parse_bytes(p, NULL);\n    }\n\n    if(require_preauth != -1)\n\tconfig->require_preauth = require_preauth;\n\n    if(port_str == NULL){\n\tp = krb5_config_get_string(context, NULL, \"kdc\", \"ports\", NULL);\n\tif (p != NULL)\n\t    port_str = strdup(p);\n    }\n\n    explicit_addresses.len = 0;\n\n    if (addresses_str.num_strings) {\n\tint i;\n\n\tfor (i = 0; i < addresses_str.num_strings; ++i)\n\t    add_one_address (context, addresses_str.strings[i], i == 0);\n\tfree_getarg_strings (&addresses_str);\n    } else {\n\tchar **foo = krb5_config_get_strings (context, NULL,\n\t\t\t\t\t      \"kdc\", \"addresses\", NULL);\n\n\tif (foo != NULL) {\n\t    add_one_address (context, *foo++, TRUE);\n\t    while (*foo)\n\t\tadd_one_address (context, *foo++, FALSE);\n\t}\n    }\n\n    if(enable_http == -1)\n\tenable_http = krb5_config_get_bool(context, NULL, \"kdc\",\n\t\t\t\t\t   \"enable-http\", NULL);\n\n    if(request_log == NULL)\n\trequest_log = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"kdc\",\n\t\t\t\t\t     \"kdc-request-log\",\n\t\t\t\t\t     NULL);\n\n    if (krb5_config_get_string(context, NULL, \"kdc\",\n\t\t\t       \"enforce-transited-policy\", NULL))\n\tkrb5_errx(context, 1, \"enforce-transited-policy deprecated, \"\n\t\t  \"use [kdc]transited-policy instead\");\n\n    if(max_request_tcp == 0)\n\tmax_request_tcp = 64 * 1024;\n    if(max_request_udp == 0)\n\tmax_request_udp = 64 * 1024;\n\n    if (port_str == NULL)\n\tport_str = \"+\";\n\n    if(disable_des == -1)\n\tdisable_des = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t   \"disable-des\", NULL);\n    if(disable_des) {\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_CRC);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD4);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD5);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_CFB64_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_PCBC_NONE);\n    }\n\n    krb5_kdc_windc_init(context);\n\n    krb5_kdc_pkinit_config(context, config);\n\n    return config;\n}",
          "includes": [
            "include <parse_bytes.h>",
            "include <getarg.h>\n#",
            "include \"kdc_locl.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic char *config_file;",
            "tatic int require_preauth = -1;",
            "tatic char *max_request_str;",
            "tatic int disable_des = -1;",
            "tatic int builtin_hdb_flag;",
            "tatic int help_flag;",
            "tatic int version_flag;",
            "nt enable_http = -1;",
            "onst char *request_log;",
            "onst char *port_str;",
            "rb5_addresses explicit_addresses;",
            "ize_t max_request_udp;",
            "ize_t max_request_tcp;",
            "tatic struct getarg_strings addresses_str;",
            "tatic struct getargs args[] = {\n    {\n\t\"config-file\",\t'c',\targ_string,\t&config_file,\n\t\"location of config file\",\t\"file\"\n    },\n    {\n\t\"require-preauth\",\t'p',\targ_negative_flag, &require_preauth,\n\t\"don't require pa-data in as-reqs\", NULL\n    },\n    {\n\t\"max-request\",\t0,\targ_string, &max_request_str,\n\t\"max size for a kdc-request\", \"size\"\n    },\n    { \"enable-http\", 'H', arg_flag, &enable_http, \"turn on HTTP support\",\n   \t NULL },\n    {\t\"ports\",\t'P', \targ_string, rk_UNCONST(&port_str),\n\t\"ports to listen to\", \"portspec\"\n    },\n    {\n\t\"detach\",       0 ,      arg_flag, &detach_from_console,\n\t\"detach from console\", NULL\n    },\n    {\n        \"daemon-child\",       0 ,      arg_flag, &daemon_child,\n        \"private argument, do not use\", NULL\n    },\n#ifdef __APPLE__\n    {\n        \"bonjour\",       0 ,      arg_flag, &do_bonjour,\n        \"private argument, do not use\", NULL\n    },\n#endif\n    {\t\"addresses\",\t0,\targ_strings, &addresses_str,\n\t\"addresses to listen on\", \"list of addresses\" },\n    {\t\"disable-des\",\t0,\targ_flag, &disable_des,\n\t\"disable DES\", NULL },\n    {\t\"builtin-hdb\",\t0,\targ_flag,   &builtin_hdb_flag,\n\t\"list builtin hdb backends\", NULL},\n    {   \"runas-user\",\t0,\targ_string, &runas_string,\n\t\"run as this user when connected to network\", NULL\n    },\n    {   \"chroot\",\t0,\targ_string, &chroot_string,\n\t\"chroot directory to run in\", NULL\n    },\n    {\t\"testing\",\t0,\targ_flag,   &testing_flag, NULL, NULL },\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};",
            "tatic int num_args = sizeof(args) / sizeof(args[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "include <parse_bytes.h>\ninclude <getarg.h>\n#\ninclude \"kdc_locl.h\"\n#\n\ntatic char *config_file;\ntatic int require_preauth = -1;\ntatic char *max_request_str;\ntatic int disable_des = -1;\ntatic int builtin_hdb_flag;\ntatic int help_flag;\ntatic int version_flag;\nnt enable_http = -1;\nonst char *request_log;\nonst char *port_str;\nrb5_addresses explicit_addresses;\nize_t max_request_udp;\nize_t max_request_tcp;\ntatic struct getarg_strings addresses_str;\ntatic struct getargs args[] = {\n    {\n\t\"config-file\",\t'c',\targ_string,\t&config_file,\n\t\"location of config file\",\t\"file\"\n    },\n    {\n\t\"require-preauth\",\t'p',\targ_negative_flag, &require_preauth,\n\t\"don't require pa-data in as-reqs\", NULL\n    },\n    {\n\t\"max-request\",\t0,\targ_string, &max_request_str,\n\t\"max size for a kdc-request\", \"size\"\n    },\n    { \"enable-http\", 'H', arg_flag, &enable_http, \"turn on HTTP support\",\n   \t NULL },\n    {\t\"ports\",\t'P', \targ_string, rk_UNCONST(&port_str),\n\t\"ports to listen to\", \"portspec\"\n    },\n    {\n\t\"detach\",       0 ,      arg_flag, &detach_from_console,\n\t\"detach from console\", NULL\n    },\n    {\n        \"daemon-child\",       0 ,      arg_flag, &daemon_child,\n        \"private argument, do not use\", NULL\n    },\n#ifdef __APPLE__\n    {\n        \"bonjour\",       0 ,      arg_flag, &do_bonjour,\n        \"private argument, do not use\", NULL\n    },\n#endif\n    {\t\"addresses\",\t0,\targ_strings, &addresses_str,\n\t\"addresses to listen on\", \"list of addresses\" },\n    {\t\"disable-des\",\t0,\targ_flag, &disable_des,\n\t\"disable DES\", NULL },\n    {\t\"builtin-hdb\",\t0,\targ_flag,   &builtin_hdb_flag,\n\t\"list builtin hdb backends\", NULL},\n    {   \"runas-user\",\t0,\targ_string, &runas_string,\n\t\"run as this user when connected to network\", NULL\n    },\n    {   \"chroot\",\t0,\targ_string, &chroot_string,\n\t\"chroot directory to run in\", NULL\n    },\n    {\t\"testing\",\t0,\targ_flag,   &testing_flag, NULL, NULL },\n    {\t\"help\",\t\t'h',\targ_flag,   &help_flag, NULL, NULL },\n    {\t\"version\",\t'v',\targ_flag,   &version_flag, NULL, NULL }\n};\ntatic int num_args = sizeof(args) / sizeof(args[0]);\n\nrb5_kdc_configuration *\nconfigure(krb5_context context, int argc, char **argv, int *optidx)\n{\n    krb5_kdc_configuration *config;\n    krb5_error_code ret;\n    \n    const char *p;\n\n    *optidx = 0;\n\n    while (getarg(args, num_args, argc, argv, optidx))\n\twarnx(\"error at argument `%s'\", argv[*optidx]);\n\n    if (help_flag)\n\tusage (0);\n\n    if (version_flag) {\n\tprint_version(NULL);\n\texit(0);\n    }\n\n    if (builtin_hdb_flag) {\n\tchar *list;\n\tret = hdb_list_builtin(context, &list);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"listing builtin hdb backends\");\n\tprintf(\"builtin hdb backends: %s\\n\", list);\n\tfree(list);\n\texit(0);\n    }\n\n    if(detach_from_console == -1)\n\tdetach_from_console = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t\t   \"detach\", NULL);\n\n    if (detach_from_console && daemon_child == -1)\n        roken_detach_prep(argc, argv, \"--daemon-child\");\n\n    {\n\tchar **files;\n\tint aret;\n\n\tif (config_file == NULL) {\n\t    aret = asprintf(&config_file, \"%s/kdc.conf\", hdb_db_dir(context));\n\t    if (aret == -1 || config_file == NULL)\n\t\terrx(1, \"out of memory\");\n\t}\n\n\tret = krb5_prepend_config_files_default(config_file, &files);\n\tif (ret)\n\t    krb5_err(context, 1, ret, \"getting configuration files\");\n\n\tret = krb5_set_config_files(context, files);\n\tkrb5_free_config_files(files);\n\tif(ret)\n\t    krb5_err(context, 1, ret, \"reading configuration files\");\n    }\n\n    ret = krb5_kdc_get_config(context, &config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_default_config\");\n\n    kdc_openlog(context, \"kdc\", config);\n\n    ret = krb5_kdc_set_dbinfo(context, config);\n    if (ret)\n\tkrb5_err(context, 1, ret, \"krb5_kdc_set_dbinfo\");\n\n    if(max_request_str)\n\tmax_request_tcp = max_request_udp = parse_bytes(max_request_str, NULL);\n\n    if(max_request_tcp == 0){\n\tp = krb5_config_get_string (context,\n\t\t\t\t    NULL,\n\t\t\t\t    \"kdc\",\n\t\t\t\t    \"max-request\",\n\t\t\t\t    NULL);\n\tif(p)\n\t    max_request_tcp = max_request_udp = parse_bytes(p, NULL);\n    }\n\n    if(require_preauth != -1)\n\tconfig->require_preauth = require_preauth;\n\n    if(port_str == NULL){\n\tp = krb5_config_get_string(context, NULL, \"kdc\", \"ports\", NULL);\n\tif (p != NULL)\n\t    port_str = strdup(p);\n    }\n\n    explicit_addresses.len = 0;\n\n    if (addresses_str.num_strings) {\n\tint i;\n\n\tfor (i = 0; i < addresses_str.num_strings; ++i)\n\t    add_one_address (context, addresses_str.strings[i], i == 0);\n\tfree_getarg_strings (&addresses_str);\n    } else {\n\tchar **foo = krb5_config_get_strings (context, NULL,\n\t\t\t\t\t      \"kdc\", \"addresses\", NULL);\n\n\tif (foo != NULL) {\n\t    add_one_address (context, *foo++, TRUE);\n\t    while (*foo)\n\t\tadd_one_address (context, *foo++, FALSE);\n\t}\n    }\n\n    if(enable_http == -1)\n\tenable_http = krb5_config_get_bool(context, NULL, \"kdc\",\n\t\t\t\t\t   \"enable-http\", NULL);\n\n    if(request_log == NULL)\n\trequest_log = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"kdc\",\n\t\t\t\t\t     \"kdc-request-log\",\n\t\t\t\t\t     NULL);\n\n    if (krb5_config_get_string(context, NULL, \"kdc\",\n\t\t\t       \"enforce-transited-policy\", NULL))\n\tkrb5_errx(context, 1, \"enforce-transited-policy deprecated, \"\n\t\t  \"use [kdc]transited-policy instead\");\n\n    if(max_request_tcp == 0)\n\tmax_request_tcp = 64 * 1024;\n    if(max_request_udp == 0)\n\tmax_request_udp = 64 * 1024;\n\n    if (port_str == NULL)\n\tport_str = \"+\";\n\n    if(disable_des == -1)\n\tdisable_des = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t   \"kdc\",\n\t\t\t\t\t\t   \"disable-des\", NULL);\n    if(disable_des) {\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_CRC);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD4);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_MD5);\n\tkrb5_enctype_disable(context, ETYPE_DES_CBC_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_CFB64_NONE);\n\tkrb5_enctype_disable(context, ETYPE_DES_PCBC_NONE);\n    }\n\n    krb5_kdc_windc_init(context);\n\n    krb5_kdc_pkinit_config(context, config);\n\n    return config;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_kt_register(HDB) failed: %d\",",
            "et)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_kt_register(",
          "args": [
            "ontext,",
            "hdb_get_kt_ops)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_init_context failed: %d\",",
            "et)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx",
          "args": [
            ",",
            "krb5_init_context failed to parse configuration file\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb5_init_context(",
          "args": [
            "context)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etprogname(",
          "args": [
            "rgv[0])"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <cap-ng.h>\n#\ninclude <util.h>\n#\ninclude \"kdc_locl.h\"\n#\n\nnt\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_kdc_configuration *config;\n    int optidx = 0;\n\n    setprogname(argv[0]);\n\n    ret = krb5_init_context(&context);\n    if (ret == KRB5_CONFIG_BADFORMAT)\n\terrx (1, \"krb5_init_context failed to parse configuration file\");\n    else if (ret)\n\terrx (1, \"krb5_init_context failed: %d\", ret);\n\n    ret = krb5_kt_register(context, &hdb_get_kt_ops);\n    if (ret)\n\terrx (1, \"krb5_kt_register(HDB) failed: %d\", ret);\n\n    config = configure(context, argc, argv, &optidx);\n\n#ifdef HAVE_SIGACTION\n    {\n\tstruct sigaction sa;\n\n\tsa.sa_flags = 0;\n\tsa.sa_handler = sigterm;\n\tsigemptyset(&sa.sa_mask);\n\n\tsigaction(SIGINT, &sa, NULL);\n\tsigaction(SIGTERM, &sa, NULL);\n#ifdef SIGXCPU\n\tsigaction(SIGXCPU, &sa, NULL);\n#endif\n\n#ifdef SIGCHLD\n\tsa.sa_handler = sigchld;\n\tsigaction(SIGCHLD, &sa, NULL);\n#endif\n\n\tsa.sa_handler = SIG_IGN;\n#ifdef SIGPIPE\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n    }\n#else\n    signal(SIGINT, sigterm);\n    signal(SIGTERM, sigterm);\n#ifdef SIGCHLD\n    signal(SIGCHLD, sigchld);\n#endif\n#ifdef SIGXCPU\n    signal(SIGXCPU, sigterm);\n#endif\n#ifdef SIGPIPE\n    signal(SIGPIPE, SIG_IGN);\n#endif\n#endif\n    rk_pidfile(NULL);\n\n    switch_environment();\n\n    start_kdc(context, config, argv[0]);\n    krb5_free_context(context);\n    return 0;\n}"
  },
  {
    "function_name": "witch_environment(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/main.c",
    "lines": "69-111",
    "snippet": "tatic void\nswitch_environment(void)\n{\n#ifdef HAVE_GETEUID\n    if ((runas_string || chroot_string) && geteuid() != 0)\n\terrx(1, \"no running as root, can't switch user/chroot\");\n\n    if (chroot_string) {\n\tif (chroot(chroot_string))\n\t    err(1, \"chroot(%s) failed\", chroot_string);\n\tif (chdir(\"/\"))\n\t    err(1, \"chdir(/) after chroot failed\");\n    }\n\n    if (runas_string) {\n\tstruct passwd *pw;\n\n\tpw = getpwnam(runas_string);\n\tif (pw == NULL)\n\t    errx(1, \"unknown user %s\", runas_string);\n\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t    err(1, \"initgroups failed\");\n\n#ifndef HAVE_CAPNG\n\tif (setgid(pw->pw_gid) < 0)\n\t    err(1, \"setgid(%s) failed\", runas_string);\n\n\tif (setuid(pw->pw_uid) < 0)\n\t    err(1, \"setuid(%s)\", runas_string);\n#else\n\tcapng_clear (CAPNG_EFFECTIVE | CAPNG_PERMITTED);\n\tif (capng_updatev (CAPNG_ADD, CAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t                   CAP_NET_BIND_SERVICE, CAP_SETPCAP, -1) < 0)\n\t    err(1, \"capng_updateev\");\n\n\tif (capng_change_id(pw->pw_uid, pw->pw_gid,\n\t                    CAPNG_CLEAR_BOUNDING) < 0)\n\t    err(1, \"capng_change_id(%s)\", runas_string);\n#endif\n    }\n#endif\n}",
    "includes": [
      "include <cap-ng.h>\n#",
      "include <util.h>\n#",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "capng_change_id(%s)\",",
            "unas_string)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apng_change_id(",
          "args": [
            "w->pw_uid,",
            "w->pw_gid,",
            "APNG_CLEAR_BOUNDING)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "capng_updateev\")"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apng_updatev",
          "args": [
            "APNG_ADD,",
            "APNG_EFFECTIVE | CAPNG_PERMITTED,",
            "AP_NET_BIND_SERVICE,",
            "AP_SETPCAP,",
            "1)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apng_clear",
          "args": [
            "APNG_EFFECTIVE | CAPNG_PERMITTED)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "setuid(%s)\",",
            "unas_string)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etuid(",
          "args": [
            "w->pw_uid)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "setgid(%s) failed\",",
            "unas_string)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etgid(",
          "args": [
            "w->pw_gid)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "initgroups failed\")"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nitgroups(",
          "args": [
            "w->pw_name,",
            "w->pw_gid)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "unknown user %s\",",
            "unas_string)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etpwnam(",
          "args": [
            "unas_string)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "chdir(/) after chroot failed\")"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hdir(",
          "args": [
            "/\")"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr(",
          "args": [
            ",",
            "chroot(%s) failed\",",
            "hroot_string)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hroot(",
          "args": [
            "hroot_string)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrx(",
          "args": [
            ",",
            "no running as root, can't switch user/chroot\")"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eteuid(",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <cap-ng.h>\n#\ninclude <util.h>\n#\ninclude \"kdc_locl.h\"\n#\n\ntatic void\nswitch_environment(void)\n{\n#ifdef HAVE_GETEUID\n    if ((runas_string || chroot_string) && geteuid() != 0)\n\terrx(1, \"no running as root, can't switch user/chroot\");\n\n    if (chroot_string) {\n\tif (chroot(chroot_string))\n\t    err(1, \"chroot(%s) failed\", chroot_string);\n\tif (chdir(\"/\"))\n\t    err(1, \"chdir(/) after chroot failed\");\n    }\n\n    if (runas_string) {\n\tstruct passwd *pw;\n\n\tpw = getpwnam(runas_string);\n\tif (pw == NULL)\n\t    errx(1, \"unknown user %s\", runas_string);\n\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t    err(1, \"initgroups failed\");\n\n#ifndef HAVE_CAPNG\n\tif (setgid(pw->pw_gid) < 0)\n\t    err(1, \"setgid(%s) failed\", runas_string);\n\n\tif (setuid(pw->pw_uid) < 0)\n\t    err(1, \"setuid(%s)\", runas_string);\n#else\n\tcapng_clear (CAPNG_EFFECTIVE | CAPNG_PERMITTED);\n\tif (capng_updatev (CAPNG_ADD, CAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t                   CAP_NET_BIND_SERVICE, CAP_SETPCAP, -1) < 0)\n\t    err(1, \"capng_updateev\");\n\n\tif (capng_change_id(pw->pw_uid, pw->pw_gid,\n\t                    CAPNG_CLEAR_BOUNDING) < 0)\n\t    err(1, \"capng_change_id(%s)\", runas_string);\n#endif\n    }\n#endif\n}"
  },
  {
    "function_name": "igterm(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/main.c",
    "lines": "56-60",
    "snippet": "tatic RETSIGTYPE\nsigterm(int sig)\n{\n    exit_flag = sig;\n}",
    "includes": [
      "include <cap-ng.h>\n#",
      "include <util.h>\n#",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "ig_atomic_t exit_flag = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "include <cap-ng.h>\n#\ninclude <util.h>\n#\ninclude \"kdc_locl.h\"\n#\n\nig_atomic_t exit_flag = 0;\n\ntatic RETSIGTYPE\nsigterm(int sig)\n{\n    exit_flag = sig;\n}"
  },
  {
    "function_name": "igchld(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-6594/repo/kdc/main.c",
    "lines": "51-54",
    "snippet": "tatic RETSIGTYPE\nsigchld(int sig)\n{\n}",
    "includes": [
      "include <cap-ng.h>\n#",
      "include <util.h>\n#",
      "include \"kdc_locl.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include <cap-ng.h>\n#\ninclude <util.h>\n#\ninclude \"kdc_locl.h\"\n#\n\ntatic RETSIGTYPE\nsigchld(int sig)\n{\n}"
  }
]