[
  {
    "function_name": "btsnoop_read_phy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "574-578",
    "snippet": "bool btsnoop_read_phy(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t *frequency, void *data, uint16_t *size)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nbool btsnoop_read_phy(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t *frequency, void *data, uint16_t *size)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "btsnoop_read_hci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "498-572",
    "snippet": "bool btsnoop_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint32_t toread, flags;\n\tuint64_t ts;\n\tuint8_t pkt_type;\n\tssize_t len;\n\n\tif (!btsnoop || btsnoop->aborted)\n\t\treturn false;\n\n\tif (btsnoop->pklg_format)\n\t\treturn pklg_read_hci(btsnoop, tv, index, opcode, data, size);\n\n\tlen = read(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != BTSNOOP_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\ttoread = be32toh(pkt.size);\n\tif (toread > BTSNOOP_MAX_PACKET_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tflags = be32toh(pkt.flags);\n\n\tts = be64toh(pkt.ts) - 0x00E03AB44A676000ll;\n\ttv->tv_sec = (ts / 1000000ll) + 946684800ll;\n\ttv->tv_usec = ts % 1000000ll;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_HCI:\n\t\t*index = 0;\n\t\t*opcode = get_opcode_from_flags(0xff, flags);\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_UART:\n\t\tlen = read(btsnoop->fd, &pkt_type, 1);\n\t\tif (len < 0) {\n\t\t\tbtsnoop->aborted = true;\n\t\t\treturn false;\n\t\t}\n\t\ttoread--;\n\n\t\t*index = 0;\n\t\t*opcode = get_opcode_from_flags(pkt_type, flags);\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_MONITOR:\n\t\t*index = flags >> 16;\n\t\t*opcode = flags & 0xffff;\n\t\tbreak;\n\n\tdefault:\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "btsnoop->fd",
            "data",
            "toread"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode_from_flags",
          "args": [
            "pkt_type",
            "flags"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode_from_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "463-496",
          "snippet": "static uint16_t get_opcode_from_flags(uint8_t type, uint32_t flags)\n{\n\tswitch (type) {\n\tcase 0x01:\n\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\tcase 0x02:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\tcase 0x03:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_SCO_TX_PKT;\n\tcase 0x04:\n\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\tcase 0xff:\n\t\tif (flags & 0x02) {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\t\t} else {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0xffff;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstatic uint16_t get_opcode_from_flags(uint8_t type, uint32_t flags)\n{\n\tswitch (type) {\n\tcase 0x01:\n\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\tcase 0x02:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\tcase 0x03:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_SCO_TX_PKT;\n\tcase 0x04:\n\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\tcase 0xff:\n\t\tif (flags & 0x02) {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\t\t} else {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0xffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64toh",
          "args": [
            "pkt.ts"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "pkt.flags"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "pkt.size"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pklg_read_hci",
          "args": [
            "btsnoop",
            "tv",
            "index",
            "opcode",
            "data",
            "size"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "pklg_read_hci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "381-461",
          "snippet": "static bool pklg_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct pklg_pkt pkt;\n\tuint32_t toread;\n\tuint64_t ts;\n\tssize_t len;\n\n\tlen = read(btsnoop->fd, &pkt, PKLG_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != PKLG_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tif (btsnoop->pklg_v2) {\n\t\ttoread = le32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = le64toh(pkt.ts);\n\t\ttv->tv_sec = ts & 0xffffffff;\n\t\ttv->tv_usec = ts >> 32;\n\t} else {\n\t\ttoread = be32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = be64toh(pkt.ts);\n\t\ttv->tv_sec = ts >> 32;\n\t\ttv->tv_usec = ts & 0xffffffff;\n\t}\n\n\tswitch (pkt.type) {\n\tcase 0x00:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_COMMAND_PKT;\n\t\tbreak;\n\tcase 0x01:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_EVENT_PKT;\n\t\tbreak;\n\tcase 0x02:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\tbreak;\n\tcase 0x03:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\tbreak;\n\tcase 0x08:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_TX_PKT;\n\t\tbreak;\n\tcase 0x09:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\tbreak;\n\tcase 0x0b:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_VENDOR_DIAG;\n\t\tbreak;\n\tcase 0xfc:\n\t\t*index = 0xffff;\n\t\t*opcode = BTSNOOP_OPCODE_SYSTEM_NOTE;\n\t\tbreak;\n\tdefault:\n\t\t*index = 0xffff;\n\t\t*opcode = 0xffff;\n\t\tbreak;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PKLG_PKT_SIZE (sizeof(struct pklg_pkt))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define PKLG_PKT_SIZE (sizeof(struct pklg_pkt))\n\nstatic bool pklg_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct pklg_pkt pkt;\n\tuint32_t toread;\n\tuint64_t ts;\n\tssize_t len;\n\n\tlen = read(btsnoop->fd, &pkt, PKLG_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != PKLG_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tif (btsnoop->pklg_v2) {\n\t\ttoread = le32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = le64toh(pkt.ts);\n\t\ttv->tv_sec = ts & 0xffffffff;\n\t\ttv->tv_usec = ts >> 32;\n\t} else {\n\t\ttoread = be32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = be64toh(pkt.ts);\n\t\ttv->tv_sec = ts >> 32;\n\t\ttv->tv_usec = ts & 0xffffffff;\n\t}\n\n\tswitch (pkt.type) {\n\tcase 0x00:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_COMMAND_PKT;\n\t\tbreak;\n\tcase 0x01:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_EVENT_PKT;\n\t\tbreak;\n\tcase 0x02:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\tbreak;\n\tcase 0x03:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\tbreak;\n\tcase 0x08:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_TX_PKT;\n\t\tbreak;\n\tcase 0x09:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\tbreak;\n\tcase 0x0b:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_VENDOR_DIAG;\n\t\tbreak;\n\tcase 0xfc:\n\t\t*index = 0xffff;\n\t\t*opcode = BTSNOOP_OPCODE_SYSTEM_NOTE;\n\t\tbreak;\n\tdefault:\n\t\t*index = 0xffff;\n\t\t*opcode = 0xffff;\n\t\tbreak;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))\n\nbool btsnoop_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint32_t toread, flags;\n\tuint64_t ts;\n\tuint8_t pkt_type;\n\tssize_t len;\n\n\tif (!btsnoop || btsnoop->aborted)\n\t\treturn false;\n\n\tif (btsnoop->pklg_format)\n\t\treturn pklg_read_hci(btsnoop, tv, index, opcode, data, size);\n\n\tlen = read(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != BTSNOOP_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\ttoread = be32toh(pkt.size);\n\tif (toread > BTSNOOP_MAX_PACKET_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tflags = be32toh(pkt.flags);\n\n\tts = be64toh(pkt.ts) - 0x00E03AB44A676000ll;\n\ttv->tv_sec = (ts / 1000000ll) + 946684800ll;\n\ttv->tv_usec = ts % 1000000ll;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_HCI:\n\t\t*index = 0;\n\t\t*opcode = get_opcode_from_flags(0xff, flags);\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_UART:\n\t\tlen = read(btsnoop->fd, &pkt_type, 1);\n\t\tif (len < 0) {\n\t\t\tbtsnoop->aborted = true;\n\t\t\treturn false;\n\t\t}\n\t\ttoread--;\n\n\t\t*index = 0;\n\t\t*opcode = get_opcode_from_flags(pkt_type, flags);\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_MONITOR:\n\t\t*index = flags >> 16;\n\t\t*opcode = flags & 0xffff;\n\t\tbreak;\n\n\tdefault:\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}"
  },
  {
    "function_name": "get_opcode_from_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "463-496",
    "snippet": "static uint16_t get_opcode_from_flags(uint8_t type, uint32_t flags)\n{\n\tswitch (type) {\n\tcase 0x01:\n\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\tcase 0x02:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\tcase 0x03:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_SCO_TX_PKT;\n\tcase 0x04:\n\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\tcase 0xff:\n\t\tif (flags & 0x02) {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\t\t} else {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0xffff;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstatic uint16_t get_opcode_from_flags(uint8_t type, uint32_t flags)\n{\n\tswitch (type) {\n\tcase 0x01:\n\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\tcase 0x02:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\tcase 0x03:\n\t\tif (flags & 0x01)\n\t\t\treturn BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\telse\n\t\t\treturn BTSNOOP_OPCODE_SCO_TX_PKT;\n\tcase 0x04:\n\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\tcase 0xff:\n\t\tif (flags & 0x02) {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_EVENT_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_COMMAND_PKT;\n\t\t} else {\n\t\t\tif (flags & 0x01)\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\t\telse\n\t\t\t\treturn BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0xffff;\n}"
  },
  {
    "function_name": "pklg_read_hci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "381-461",
    "snippet": "static bool pklg_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct pklg_pkt pkt;\n\tuint32_t toread;\n\tuint64_t ts;\n\tssize_t len;\n\n\tlen = read(btsnoop->fd, &pkt, PKLG_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != PKLG_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tif (btsnoop->pklg_v2) {\n\t\ttoread = le32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = le64toh(pkt.ts);\n\t\ttv->tv_sec = ts & 0xffffffff;\n\t\ttv->tv_usec = ts >> 32;\n\t} else {\n\t\ttoread = be32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = be64toh(pkt.ts);\n\t\ttv->tv_sec = ts >> 32;\n\t\ttv->tv_usec = ts & 0xffffffff;\n\t}\n\n\tswitch (pkt.type) {\n\tcase 0x00:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_COMMAND_PKT;\n\t\tbreak;\n\tcase 0x01:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_EVENT_PKT;\n\t\tbreak;\n\tcase 0x02:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\tbreak;\n\tcase 0x03:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\tbreak;\n\tcase 0x08:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_TX_PKT;\n\t\tbreak;\n\tcase 0x09:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\tbreak;\n\tcase 0x0b:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_VENDOR_DIAG;\n\t\tbreak;\n\tcase 0xfc:\n\t\t*index = 0xffff;\n\t\t*opcode = BTSNOOP_OPCODE_SYSTEM_NOTE;\n\t\tbreak;\n\tdefault:\n\t\t*index = 0xffff;\n\t\t*opcode = 0xffff;\n\t\tbreak;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PKLG_PKT_SIZE (sizeof(struct pklg_pkt))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "btsnoop->fd",
            "data",
            "toread"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64toh",
          "args": [
            "pkt.ts"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "pkt.len"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64toh",
          "args": [
            "pkt.ts"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "pkt.len"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define PKLG_PKT_SIZE (sizeof(struct pklg_pkt))\n\nstatic bool pklg_read_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\t\t\tuint16_t *index, uint16_t *opcode,\n\t\t\t\t\tvoid *data, uint16_t *size)\n{\n\tstruct pklg_pkt pkt;\n\tuint32_t toread;\n\tuint64_t ts;\n\tssize_t len;\n\n\tlen = read(btsnoop->fd, &pkt, PKLG_PKT_SIZE);\n\tif (len == 0)\n\t\treturn false;\n\n\tif (len < 0 || len != PKLG_PKT_SIZE) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\tif (btsnoop->pklg_v2) {\n\t\ttoread = le32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = le64toh(pkt.ts);\n\t\ttv->tv_sec = ts & 0xffffffff;\n\t\ttv->tv_usec = ts >> 32;\n\t} else {\n\t\ttoread = be32toh(pkt.len) - (PKLG_PKT_SIZE - 4);\n\n\t\tts = be64toh(pkt.ts);\n\t\ttv->tv_sec = ts >> 32;\n\t\ttv->tv_usec = ts & 0xffffffff;\n\t}\n\n\tswitch (pkt.type) {\n\tcase 0x00:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_COMMAND_PKT;\n\t\tbreak;\n\tcase 0x01:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_EVENT_PKT;\n\t\tbreak;\n\tcase 0x02:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_TX_PKT;\n\t\tbreak;\n\tcase 0x03:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_ACL_RX_PKT;\n\t\tbreak;\n\tcase 0x08:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_TX_PKT;\n\t\tbreak;\n\tcase 0x09:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_SCO_RX_PKT;\n\t\tbreak;\n\tcase 0x0b:\n\t\t*index = 0x0000;\n\t\t*opcode = BTSNOOP_OPCODE_VENDOR_DIAG;\n\t\tbreak;\n\tcase 0xfc:\n\t\t*index = 0xffff;\n\t\t*opcode = BTSNOOP_OPCODE_SYSTEM_NOTE;\n\t\tbreak;\n\tdefault:\n\t\t*index = 0xffff;\n\t\t*opcode = 0xffff;\n\t\tbreak;\n\t}\n\n\tlen = read(btsnoop->fd, data, toread);\n\tif (len < 0) {\n\t\tbtsnoop->aborted = true;\n\t\treturn false;\n\t}\n\n\t*size = toread;\n\n\treturn true;\n}"
  },
  {
    "function_name": "btsnoop_write_phy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "361-379",
    "snippet": "bool btsnoop_write_phy(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t frequency, const void *data, uint16_t size)\n{\n\tuint32_t flags;\n\n\tif (!btsnoop)\n\t\treturn false;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_SIMULATOR:\n\t\tflags = (1 << 16) | frequency;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn btsnoop_write(btsnoop, tv, flags, 0, data, size);\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btsnoop_write",
          "args": [
            "btsnoop",
            "tv",
            "flags",
            "0",
            "data",
            "size"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "262-301",
          "snippet": "bool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))\n\nbool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nbool btsnoop_write_phy(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t frequency, const void *data, uint16_t size)\n{\n\tuint32_t flags;\n\n\tif (!btsnoop)\n\t\treturn false;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_SIMULATOR:\n\t\tflags = (1 << 16) | frequency;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn btsnoop_write(btsnoop, tv, flags, 0, data, size);\n}"
  },
  {
    "function_name": "btsnoop_write_hci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "328-359",
    "snippet": "bool btsnoop_write_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t index, uint16_t opcode, uint32_t drops,\n\t\t\tconst void *data, uint16_t size)\n{\n\tuint32_t flags;\n\n\tif (!btsnoop)\n\t\treturn false;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_HCI:\n\t\tif (btsnoop->index == 0xffff)\n\t\t\tbtsnoop->index = index;\n\n\t\tif (index != btsnoop->index)\n\t\t\treturn false;\n\n\t\tflags = get_flags_from_opcode(opcode);\n\t\tif (flags == 0xff)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_MONITOR:\n\t\tflags = (index << 16) | opcode;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn btsnoop_write(btsnoop, tv, flags, drops, data, size);\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btsnoop_write",
          "args": [
            "btsnoop",
            "tv",
            "flags",
            "drops",
            "data",
            "size"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "262-301",
          "snippet": "bool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))\n\nbool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_flags_from_opcode",
          "args": [
            "opcode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "get_flags_from_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "303-326",
          "snippet": "static uint32_t get_flags_from_opcode(uint16_t opcode)\n{\n\tswitch (opcode) {\n\tcase BTSNOOP_OPCODE_NEW_INDEX:\n\tcase BTSNOOP_OPCODE_DEL_INDEX:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_COMMAND_PKT:\n\t\treturn 0x02;\n\tcase BTSNOOP_OPCODE_EVENT_PKT:\n\t\treturn 0x03;\n\tcase BTSNOOP_OPCODE_ACL_TX_PKT:\n\t\treturn 0x00;\n\tcase BTSNOOP_OPCODE_ACL_RX_PKT:\n\t\treturn 0x01;\n\tcase BTSNOOP_OPCODE_SCO_TX_PKT:\n\tcase BTSNOOP_OPCODE_SCO_RX_PKT:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_OPEN_INDEX:\n\tcase BTSNOOP_OPCODE_CLOSE_INDEX:\n\t\tbreak;\n\t}\n\n\treturn 0xff;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstatic uint32_t get_flags_from_opcode(uint16_t opcode)\n{\n\tswitch (opcode) {\n\tcase BTSNOOP_OPCODE_NEW_INDEX:\n\tcase BTSNOOP_OPCODE_DEL_INDEX:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_COMMAND_PKT:\n\t\treturn 0x02;\n\tcase BTSNOOP_OPCODE_EVENT_PKT:\n\t\treturn 0x03;\n\tcase BTSNOOP_OPCODE_ACL_TX_PKT:\n\t\treturn 0x00;\n\tcase BTSNOOP_OPCODE_ACL_RX_PKT:\n\t\treturn 0x01;\n\tcase BTSNOOP_OPCODE_SCO_TX_PKT:\n\tcase BTSNOOP_OPCODE_SCO_RX_PKT:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_OPEN_INDEX:\n\tcase BTSNOOP_OPCODE_CLOSE_INDEX:\n\t\tbreak;\n\t}\n\n\treturn 0xff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nbool btsnoop_write_hci(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint16_t index, uint16_t opcode, uint32_t drops,\n\t\t\tconst void *data, uint16_t size)\n{\n\tuint32_t flags;\n\n\tif (!btsnoop)\n\t\treturn false;\n\n\tswitch (btsnoop->format) {\n\tcase BTSNOOP_FORMAT_HCI:\n\t\tif (btsnoop->index == 0xffff)\n\t\t\tbtsnoop->index = index;\n\n\t\tif (index != btsnoop->index)\n\t\t\treturn false;\n\n\t\tflags = get_flags_from_opcode(opcode);\n\t\tif (flags == 0xff)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase BTSNOOP_FORMAT_MONITOR:\n\t\tflags = (index << 16) | opcode;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn btsnoop_write(btsnoop, tv, flags, drops, data, size);\n}"
  },
  {
    "function_name": "get_flags_from_opcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "303-326",
    "snippet": "static uint32_t get_flags_from_opcode(uint16_t opcode)\n{\n\tswitch (opcode) {\n\tcase BTSNOOP_OPCODE_NEW_INDEX:\n\tcase BTSNOOP_OPCODE_DEL_INDEX:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_COMMAND_PKT:\n\t\treturn 0x02;\n\tcase BTSNOOP_OPCODE_EVENT_PKT:\n\t\treturn 0x03;\n\tcase BTSNOOP_OPCODE_ACL_TX_PKT:\n\t\treturn 0x00;\n\tcase BTSNOOP_OPCODE_ACL_RX_PKT:\n\t\treturn 0x01;\n\tcase BTSNOOP_OPCODE_SCO_TX_PKT:\n\tcase BTSNOOP_OPCODE_SCO_RX_PKT:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_OPEN_INDEX:\n\tcase BTSNOOP_OPCODE_CLOSE_INDEX:\n\t\tbreak;\n\t}\n\n\treturn 0xff;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstatic uint32_t get_flags_from_opcode(uint16_t opcode)\n{\n\tswitch (opcode) {\n\tcase BTSNOOP_OPCODE_NEW_INDEX:\n\tcase BTSNOOP_OPCODE_DEL_INDEX:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_COMMAND_PKT:\n\t\treturn 0x02;\n\tcase BTSNOOP_OPCODE_EVENT_PKT:\n\t\treturn 0x03;\n\tcase BTSNOOP_OPCODE_ACL_TX_PKT:\n\t\treturn 0x00;\n\tcase BTSNOOP_OPCODE_ACL_RX_PKT:\n\t\treturn 0x01;\n\tcase BTSNOOP_OPCODE_SCO_TX_PKT:\n\tcase BTSNOOP_OPCODE_SCO_RX_PKT:\n\t\tbreak;\n\tcase BTSNOOP_OPCODE_OPEN_INDEX:\n\tcase BTSNOOP_OPCODE_CLOSE_INDEX:\n\t\tbreak;\n\t}\n\n\treturn 0xff;\n}"
  },
  {
    "function_name": "btsnoop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "262-301",
    "snippet": "bool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "btsnoop->fd",
            "data",
            "size"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "notify_data_write_ccc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1324-1355",
          "snippet": "static bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htobe64",
          "args": [
            "ts + 0x00E03AB44A676000ll"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "drops"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "flags"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "size"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "size"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btsnoop_rotate",
          "args": [
            "btsnoop"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_rotate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "226-260",
          "snippet": "static bool btsnoop_rotate(struct btsnoop *btsnoop)\n{\n\tstruct btsnoop_hdr hdr;\n\tchar path[PATH_MAX];\n\tssize_t written;\n\n\tclose(btsnoop->fd);\n\n\t/* Check if max number of log files has been reached */\n\tif (btsnoop->max_count && btsnoop->cur_count >= btsnoop->max_count) {\n\t\tsnprintf(path, PATH_MAX, \"%s.%u\", btsnoop->path,\n\t\t\t\tbtsnoop->cur_count - btsnoop->max_count);\n\t\tunlink(path);\n\t}\n\n\tsnprintf(path, PATH_MAX,\"%s.%u\", btsnoop->path, btsnoop->cur_count);\n\tbtsnoop->cur_count++;\n\n\tbtsnoop->fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0)\n\t\treturn false;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstatic bool btsnoop_rotate(struct btsnoop *btsnoop)\n{\n\tstruct btsnoop_hdr hdr;\n\tchar path[PATH_MAX];\n\tssize_t written;\n\n\tclose(btsnoop->fd);\n\n\t/* Check if max number of log files has been reached */\n\tif (btsnoop->max_count && btsnoop->cur_count >= btsnoop->max_count) {\n\t\tsnprintf(path, PATH_MAX, \"%s.%u\", btsnoop->path,\n\t\t\t\tbtsnoop->cur_count - btsnoop->max_count);\n\t\tunlink(path);\n\t}\n\n\tsnprintf(path, PATH_MAX,\"%s.%u\", btsnoop->path, btsnoop->cur_count);\n\tbtsnoop->cur_count++;\n\n\tbtsnoop->fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0)\n\t\treturn false;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_PKT_SIZE (sizeof(struct btsnoop_pkt))\n\nbool btsnoop_write(struct btsnoop *btsnoop, struct timeval *tv,\n\t\t\tuint32_t flags, uint32_t drops, const void *data,\n\t\t\tuint16_t size)\n{\n\tstruct btsnoop_pkt pkt;\n\tuint64_t ts;\n\tssize_t written;\n\n\tif (!btsnoop || !tv)\n\t\treturn false;\n\n\tif (btsnoop->max_size && btsnoop->max_size <=\n\t\t\tbtsnoop->cur_size + size + BTSNOOP_PKT_SIZE)\n\t\tif (!btsnoop_rotate(btsnoop))\n\t\t\treturn false;\n\n\tts = (tv->tv_sec - 946684800ll) * 1000000ll + tv->tv_usec;\n\n\tpkt.size  = htobe32(size);\n\tpkt.len   = htobe32(size);\n\tpkt.flags = htobe32(flags);\n\tpkt.drops = htobe32(drops);\n\tpkt.ts    = htobe64(ts + 0x00E03AB44A676000ll);\n\n\twritten = write(btsnoop->fd, &pkt, BTSNOOP_PKT_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size += BTSNOOP_PKT_SIZE;\n\n\tif (data && size > 0) {\n\t\twritten = write(btsnoop->fd, data, size);\n\t\tif (written < 0)\n\t\t\treturn false;\n\t}\n\n\tbtsnoop->cur_size += size;\n\n\treturn true;\n}"
  },
  {
    "function_name": "btsnoop_rotate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "226-260",
    "snippet": "static bool btsnoop_rotate(struct btsnoop *btsnoop)\n{\n\tstruct btsnoop_hdr hdr;\n\tchar path[PATH_MAX];\n\tssize_t written;\n\n\tclose(btsnoop->fd);\n\n\t/* Check if max number of log files has been reached */\n\tif (btsnoop->max_count && btsnoop->cur_count >= btsnoop->max_count) {\n\t\tsnprintf(path, PATH_MAX, \"%s.%u\", btsnoop->path,\n\t\t\t\tbtsnoop->cur_count - btsnoop->max_count);\n\t\tunlink(path);\n\t}\n\n\tsnprintf(path, PATH_MAX,\"%s.%u\", btsnoop->path, btsnoop->cur_count);\n\tbtsnoop->cur_count++;\n\n\tbtsnoop->fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0)\n\t\treturn false;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
    ],
    "globals_used": [
      "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
      "static const uint32_t btsnoop_version = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "btsnoop->fd",
            "&hdr",
            "BTSNOOP_HDR_SIZE"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "notify_data_write_ccc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1324-1355",
          "snippet": "static bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "btsnoop->format"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "btsnoop_version"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hdr.id",
            "btsnoop_id",
            "sizeof(btsnoop_id)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "PATH_MAX",
            "\"%s.%u\"",
            "btsnoop->path",
            "btsnoop->cur_count"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "PATH_MAX",
            "\"%s.%u\"",
            "btsnoop->path",
            "btsnoop->cur_count - btsnoop->max_count"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "btsnoop->fd"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstatic bool btsnoop_rotate(struct btsnoop *btsnoop)\n{\n\tstruct btsnoop_hdr hdr;\n\tchar path[PATH_MAX];\n\tssize_t written;\n\n\tclose(btsnoop->fd);\n\n\t/* Check if max number of log files has been reached */\n\tif (btsnoop->max_count && btsnoop->cur_count >= btsnoop->max_count) {\n\t\tsnprintf(path, PATH_MAX, \"%s.%u\", btsnoop->path,\n\t\t\t\tbtsnoop->cur_count - btsnoop->max_count);\n\t\tunlink(path);\n\t}\n\n\tsnprintf(path, PATH_MAX,\"%s.%u\", btsnoop->path, btsnoop->cur_count);\n\tbtsnoop->cur_count++;\n\n\tbtsnoop->fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0)\n\t\treturn false;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0)\n\t\treturn false;\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn true;\n}"
  },
  {
    "function_name": "btsnoop_get_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "218-224",
    "snippet": "uint32_t btsnoop_get_format(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn BTSNOOP_FORMAT_INVALID;\n\n\treturn btsnoop->format;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nuint32_t btsnoop_get_format(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn BTSNOOP_FORMAT_INVALID;\n\n\treturn btsnoop->format;\n}"
  },
  {
    "function_name": "btsnoop_unref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "204-216",
    "snippet": "void btsnoop_unref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&btsnoop->ref_count, 1))\n\t\treturn;\n\n\tif (btsnoop->fd >= 0)\n\t\tclose(btsnoop->fd);\n\n\tfree(btsnoop);\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "btsnoop"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "btsnoop->fd"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_sub_and_fetch",
          "args": [
            "&btsnoop->ref_count",
            "1"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nvoid btsnoop_unref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&btsnoop->ref_count, 1))\n\t\treturn;\n\n\tif (btsnoop->fd >= 0)\n\t\tclose(btsnoop->fd);\n\n\tfree(btsnoop);\n}"
  },
  {
    "function_name": "btsnoop_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "194-202",
    "snippet": "struct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_fetch_and_add",
          "args": [
            "&btsnoop->ref_count",
            "1"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstruct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}"
  },
  {
    "function_name": "btsnoop_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "141-192",
    "snippet": "struct btsnoop *btsnoop_create(const char *path, size_t max_size,\n\t\t\t\t\tunsigned int max_count, uint32_t format)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tconst char *real_path;\n\tchar tmp[PATH_MAX];\n\tssize_t written;\n\n\tif (!max_size && max_count)\n\t\treturn NULL;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t/* If max file size is specified, always add counter to file path */\n\tif (max_size) {\n\t\tsnprintf(tmp, PATH_MAX, \"%s.0\", path);\n\t\treal_path = tmp;\n\t} else {\n\t\treal_path = path;\n\t}\n\n\tbtsnoop->fd = open(real_path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->format = format;\n\tbtsnoop->index = 0xffff;\n\tbtsnoop->path = path;\n\tbtsnoop->max_count = max_count;\n\tbtsnoop->max_size = max_size;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0) {\n\t\tclose(btsnoop->fd);\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn btsnoop_ref(btsnoop);\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
    ],
    "globals_used": [
      "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
      "static const uint32_t btsnoop_version = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btsnoop_ref",
          "args": [
            "btsnoop"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "194-202",
          "snippet": "struct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstruct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "btsnoop"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "btsnoop->fd"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "btsnoop->fd",
            "&hdr",
            "BTSNOOP_HDR_SIZE"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "notify_data_write_ccc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1324-1355",
          "snippet": "static bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic bool notify_data_write_ccc(struct notify_data *notify_data, bool enable,\n\t\t\t\t\t\tbt_att_response_func_t callback)\n{\n\tuint8_t pdu[4];\n\tunsigned int att_id;\n\n\tassert(notify_data->chrc->ccc_handle);\n\tmemset(pdu, 0, sizeof(pdu));\n\tput_le16(notify_data->chrc->ccc_handle, pdu);\n\n\tif (enable) {\n\t\t/* Try to enable notifications and/or indications based on\n\t\t * whatever the characteristic supports.\n\t\t */\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_NOTIFY)\n\t\t\tpdu[2] = 0x01;\n\n\t\tif (notify_data->chrc->properties & BT_GATT_CHRC_PROP_INDICATE)\n\t\t\tpdu[2] |= 0x02;\n\n\t\tif (!pdu[2])\n\t\t\treturn false;\n\t}\n\n\tatt_id = bt_att_send(notify_data->client->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\tpdu, sizeof(pdu), callback,\n\t\t\t\t\t\tnotify_data_ref(notify_data),\n\t\t\t\t\t\tnotify_data_unref);\n\tnotify_data->chrc->ccc_write_id = notify_data->att_id = att_id;\n\n\treturn !!att_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "btsnoop->format"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "btsnoop_version"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hdr.id",
            "btsnoop_id",
            "sizeof(btsnoop_id)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "real_path",
            "O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "PATH_MAX",
            "\"%s.0\"",
            "path"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*btsnoop)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_create(const char *path, size_t max_size,\n\t\t\t\t\tunsigned int max_count, uint32_t format)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tconst char *real_path;\n\tchar tmp[PATH_MAX];\n\tssize_t written;\n\n\tif (!max_size && max_count)\n\t\treturn NULL;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t/* If max file size is specified, always add counter to file path */\n\tif (max_size) {\n\t\tsnprintf(tmp, PATH_MAX, \"%s.0\", path);\n\t\treal_path = tmp;\n\t} else {\n\t\treal_path = path;\n\t}\n\n\tbtsnoop->fd = open(real_path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,\n\t\t\t\t\tS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->format = format;\n\tbtsnoop->index = 0xffff;\n\tbtsnoop->path = path;\n\tbtsnoop->max_count = max_count;\n\tbtsnoop->max_size = max_size;\n\n\tmemcpy(hdr.id, btsnoop_id, sizeof(btsnoop_id));\n\thdr.version = htobe32(btsnoop_version);\n\thdr.type = htobe32(btsnoop->format);\n\n\twritten = write(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (written < 0) {\n\t\tclose(btsnoop->fd);\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->cur_size = BTSNOOP_HDR_SIZE;\n\n\treturn btsnoop_ref(btsnoop);\n}"
  },
  {
    "function_name": "btsnoop_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
    "lines": "85-139",
    "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/shared/btsnoop.h\"",
      "#include <sys/stat.h>",
      "#include <arpa/inet.h>",
      "#include <limits.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <endian.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
    ],
    "globals_used": [
      "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
      "static const uint32_t btsnoop_version = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "btsnoop"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "btsnoop->fd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btsnoop_ref",
          "args": [
            "btsnoop"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "194-202",
          "snippet": "struct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\nstruct btsnoop *btsnoop_ref(struct btsnoop *btsnoop)\n{\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&btsnoop->ref_count, 1);\n\n\treturn btsnoop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "btsnoop->fd",
            "0",
            "SEEK_SET"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "hdr.type"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "hdr.version"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hdr.id",
            "btsnoop_id",
            "sizeof(btsnoop_id)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "btsnoop->fd",
            "&hdr",
            "BTSNOOP_HDR_SIZE"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*btsnoop)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
  }
]