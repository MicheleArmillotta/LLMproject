[
  {
    "function_name": "textfile_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "381-475",
    "snippet": "int textfile_foreach(const char *pathname, textfile_cb func, void *data)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *key, *value;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\toff = map;\n\n\twhile (size - (off - map) > 0) {\n\t\tend = strnpbrk(off, size - (off - map), \" \");\n\t\tif (!end) {\n\t\t\terr = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = end - off;\n\n\t\tkey = malloc(len + 1);\n\t\tif (!key) {\n\t\t\terr = -errno;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(key, 0, len + 1);\n\t\tmemcpy(key, off, len);\n\n\t\toff = end + 1;\n\n\t\tif (size - (off - map) < 0) {\n\t\t\terr = -EILSEQ;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\t\tif (!end) {\n\t\t\terr = -EILSEQ;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = end - off;\n\n\t\tvalue = malloc(len + 1);\n\t\tif (!value) {\n\t\t\terr = -errno;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(value, 0, len + 1);\n\t\tmemcpy(value, off, len);\n\n\t\tfunc(key, value, data);\n\n\t\tfree(key);\n\t\tfree(value);\n\n\t\toff = end + 1;\n\t}\n\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_UN"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "key",
            "value",
            "data"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "off",
            "len"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "len + 1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnpbrk",
          "args": [
            "off",
            "size - (off - map)",
            "\"\\r\\n\""
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "strnpbrk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "156-176",
          "snippet": "static char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key",
            "off",
            "len"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key",
            "0",
            "len + 1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "size",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_SH"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "pathname",
            "O_RDONLY"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nint textfile_foreach(const char *pathname, textfile_cb func, void *data)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *key, *value;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\toff = map;\n\n\twhile (size - (off - map) > 0) {\n\t\tend = strnpbrk(off, size - (off - map), \" \");\n\t\tif (!end) {\n\t\t\terr = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = end - off;\n\n\t\tkey = malloc(len + 1);\n\t\tif (!key) {\n\t\t\terr = -errno;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(key, 0, len + 1);\n\t\tmemcpy(key, off, len);\n\n\t\toff = end + 1;\n\n\t\tif (size - (off - map) < 0) {\n\t\t\terr = -EILSEQ;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\t\tif (!end) {\n\t\t\terr = -EILSEQ;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = end - off;\n\n\t\tvalue = malloc(len + 1);\n\t\tif (!value) {\n\t\t\terr = -errno;\n\t\t\tfree(key);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(value, 0, len + 1);\n\t\tmemcpy(value, off, len);\n\n\t\tfunc(key, value, data);\n\n\t\tfree(key);\n\t\tfree(value);\n\n\t\toff = end + 1;\n\t}\n\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "textfile_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "376-379",
    "snippet": "char *textfile_get(const char *pathname, const char *key)\n{\n\treturn read_key(pathname, key, 0);\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_key",
          "args": [
            "pathname",
            "key",
            "0"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "302-364",
          "snippet": "static char *read_key(const char *pathname, const char *key, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str = NULL;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(end - off - len);\n\tif (!str) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tmemset(str, 0, end - off - len);\n\tstrncpy(str, off + len + 1, end - off - len - 1);\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn str;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *read_key(const char *pathname, const char *key, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str = NULL;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(end - off - len);\n\tif (!str) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tmemset(str, 0, end - off - len);\n\tstrncpy(str, off + len + 1, end - off - len - 1);\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nchar *textfile_get(const char *pathname, const char *key)\n{\n\treturn read_key(pathname, key, 0);\n}"
  },
  {
    "function_name": "textfile_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "371-374",
    "snippet": "int textfile_del(const char *pathname, const char *key)\n{\n\treturn write_key(pathname, key, NULL, 0);\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_key",
          "args": [
            "pathname",
            "key",
            "NULL",
            "0"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "write_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "178-300",
          "snippet": "static int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nint textfile_del(const char *pathname, const char *key)\n{\n\treturn write_key(pathname, key, NULL, 0);\n}"
  },
  {
    "function_name": "textfile_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "366-369",
    "snippet": "int textfile_put(const char *pathname, const char *key, const char *value)\n{\n\treturn write_key(pathname, key, value, 0);\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_key",
          "args": [
            "pathname",
            "key",
            "value",
            "0"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "write_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "178-300",
          "snippet": "static int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nint textfile_put(const char *pathname, const char *key, const char *value)\n{\n\treturn write_key(pathname, key, value, 0);\n}"
  },
  {
    "function_name": "read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "302-364",
    "snippet": "static char *read_key(const char *pathname, const char *key, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str = NULL;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(end - off - len);\n\tif (!str) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tmemset(str, 0, end - off - len);\n\tstrncpy(str, off + len + 1, end - off - len - 1);\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn str;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_UN"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "str",
            "off + len + 1",
            "end - off - len - 1"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "str",
            "0",
            "end - off - len"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "end - off - len"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnpbrk",
          "args": [
            "off",
            "size - (off - map)",
            "\"\\r\\n\""
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "strnpbrk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "156-176",
          "snippet": "static char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_key",
          "args": [
            "map",
            "size",
            "key",
            "len",
            "icase"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "find_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "96-132",
          "snippet": "static inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "size",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_SH"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "pathname",
            "O_RDONLY"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *read_key(const char *pathname, const char *key, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str = NULL;\n\toff_t size; size_t len;\n\tint fd, err = 0;\n\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif (flock(fd, LOCK_SH) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tmap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tend = strnpbrk(off, size - (off - map), \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(end - off - len);\n\tif (!str) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tmemset(str, 0, end - off - len);\n\tstrncpy(str, off + len + 1, end - off - len - 1);\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tclose(fd);\n\terrno = -err;\n\n\treturn str;\n}"
  },
  {
    "function_name": "write_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "178-300",
    "snippet": "static int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdatasync",
          "args": [
            "fd"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_UN"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "str",
            "len"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "write_key_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "134-154",
          "snippet": "static inline int write_key_value(int fd, const char *key, const char *value)\n{\n\tchar *str;\n\tsize_t size;\n\tint err = 0;\n\n\tsize = strlen(key) + strlen(value) + 2;\n\n\tstr = malloc(size + 1);\n\tif (!str)\n\t\treturn ENOMEM;\n\n\tsprintf(str, \"%s %s\\n\", key, value);\n\n\tif (write(fd, str, size) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\treturn err;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic inline int write_key_value(int fd, const char *key, const char *value)\n{\n\tchar *str;\n\tsize_t size;\n\tint err = 0;\n\n\tsize = strlen(key) + strlen(value) + 2;\n\n\tstr = malloc(size + 1);\n\tif (!str)\n\t\treturn ENOMEM;\n\n\tsprintf(str, \"%s %s\\n\", key, value);\n\n\tif (write(fd, str, size) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "base",
            "SEEK_SET"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "base"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str",
            "end",
            "len"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "base",
            "SEEK_SET"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "base"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "end",
            "\"\\r\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "off + len + 1",
            "value",
            "end - off - len - 1"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnpbrk",
          "args": [
            "off",
            "size",
            "\"\\r\\n\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "strnpbrk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "156-176",
          "snippet": "static char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "size",
            "SEEK_SET"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "map",
            "size"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_key",
          "args": [
            "map",
            "size",
            "key",
            "len",
            "icase"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "find_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "96-132",
          "snippet": "static inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "size",
            "PROT_READ | PROT_WRITE",
            "MAP_PRIVATE | MAP_LOCKED",
            "fd",
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "size",
            "SEEK_SET"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "fd",
            "LOCK_EX"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "pathname",
            "O_RDWR"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int write_key(const char *pathname, const char *key, const char *value, int icase)\n{\n\tstruct stat st;\n\tchar *map, *off, *end, *str;\n\toff_t size;\n\tsize_t base;\n\tint fd, len, err = 0;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (flock(fd, LOCK_EX) < 0) {\n\t\terr = -errno;\n\t\tgoto close;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tsize = st.st_size;\n\n\tif (!size) {\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tmap = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t\tMAP_PRIVATE | MAP_LOCKED, fd, 0);\n\tif (!map || map == MAP_FAILED) {\n\t\terr = -errno;\n\t\tgoto unlock;\n\t}\n\n\tlen = strlen(key);\n\toff = find_key(map, size, key, len, icase);\n\tif (!off) {\n\t\tmunmap(map, size);\n\t\tif (value) {\n\t\t\tlseek(fd, size, SEEK_SET);\n\t\t\terr = write_key_value(fd, key, value);\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\tbase = off - map;\n\n\tend = strnpbrk(off, size, \"\\r\\n\");\n\tif (!end) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tif (value && ((ssize_t) strlen(value) == end - off - len - 1) &&\n\t\t\t!strncmp(off + len + 1, value, end - off - len - 1))\n\t\tgoto unmap;\n\n\tlen = strspn(end, \"\\r\\n\");\n\tend += len;\n\n\tlen = size - (end - map);\n\tif (!len) {\n\t\tmunmap(map, size);\n\t\tif (ftruncate(fd, base) < 0) {\n\t\t\terr = -errno;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlseek(fd, base, SEEK_SET);\n\t\tif (value)\n\t\t\terr = write_key_value(fd, key, value);\n\n\t\tgoto unlock;\n\t}\n\n\tif (len < 0 || len > size) {\n\t\terr = -EILSEQ;\n\t\tgoto unmap;\n\t}\n\n\tstr = malloc(len);\n\tif (!str) {\n\t\terr = -errno;\n\t\tgoto unmap;\n\t}\n\n\tmemcpy(str, end, len);\n\n\tmunmap(map, size);\n\tif (ftruncate(fd, base) < 0) {\n\t\terr = -errno;\n\t\tfree(str);\n\t\tgoto unlock;\n\t}\n\tlseek(fd, base, SEEK_SET);\n\tif (value)\n\t\terr = write_key_value(fd, key, value);\n\n\tif (write(fd, str, len) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\tgoto unlock;\n\nunmap:\n\tmunmap(map, size);\n\nunlock:\n\tflock(fd, LOCK_UN);\n\nclose:\n\tfdatasync(fd);\n\n\tclose(fd);\n\terrno = -err;\n\n\treturn err;\n}"
  },
  {
    "function_name": "strnpbrk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "156-176",
    "snippet": "static char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *strnpbrk(const char *s, ssize_t len, const char *accept)\n{\n\tconst char *p = s;\n\tconst char *end;\n\n\tend = s + len - 1;\n\n\twhile (p <= end && *p) {\n\t\tconst char *a = accept;\n\n\t\twhile (*a) {\n\t\t\tif (*p == *a)\n\t\t\t\treturn (char *) p;\n\t\t\ta++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "write_key_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "134-154",
    "snippet": "static inline int write_key_value(int fd, const char *key, const char *value)\n{\n\tchar *str;\n\tsize_t size;\n\tint err = 0;\n\n\tsize = strlen(key) + strlen(value) + 2;\n\n\tstr = malloc(size + 1);\n\tif (!str)\n\t\treturn ENOMEM;\n\n\tsprintf(str, \"%s %s\\n\", key, value);\n\n\tif (write(fd, str, size) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\treturn err;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "str",
            "size"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "write_key_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "134-154",
          "snippet": "static inline int write_key_value(int fd, const char *key, const char *value)\n{\n\tchar *str;\n\tsize_t size;\n\tint err = 0;\n\n\tsize = strlen(key) + strlen(value) + 2;\n\n\tstr = malloc(size + 1);\n\tif (!str)\n\t\treturn ENOMEM;\n\n\tsprintf(str, \"%s %s\\n\", key, value);\n\n\tif (write(fd, str, size) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%s %s\\n\"",
            "key",
            "value"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size + 1"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic inline int write_key_value(int fd, const char *key, const char *value)\n{\n\tchar *str;\n\tsize_t size;\n\tint err = 0;\n\n\tsize = strlen(key) + strlen(value) + 2;\n\n\tstr = malloc(size + 1);\n\tif (!str)\n\t\treturn ENOMEM;\n\n\tsprintf(str, \"%s %s\\n\", key, value);\n\n\tif (write(fd, str, size) < 0)\n\t\terr = -errno;\n\n\tfree(str);\n\n\treturn err;\n}"
  },
  {
    "function_name": "find_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "96-132",
    "snippet": "static inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "ptr + 1",
            "*key",
            "ptrlen - 1"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "ptr + 1",
            "toupper(*key)",
            "ptrlen - 1"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*key"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "ptr + 1",
            "tolower(*key)",
            "ptrlen - 1"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*key"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "key",
            "len"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "ptr",
            "key",
            "len"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic inline char *find_key(char *map, size_t size, const char *key, size_t len, int icase)\n{\n\tchar *ptr = map;\n\tsize_t ptrlen = size;\n\n\twhile (ptrlen > len + 1) {\n\t\tint cmp = (icase) ? strncasecmp(ptr, key, len) : strncmp(ptr, key, len);\n\t\tif (cmp == 0) {\n\t\t\tif (ptr == map && *(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\n\t\t\tif ((*(ptr - 1) == '\\r' || *(ptr - 1) == '\\n') &&\n\t\t\t\t\t\t\t*(ptr + len) == ' ')\n\t\t\t\treturn ptr;\n\t\t}\n\n\t\tif (icase) {\n\t\t\tchar *p1 = memchr(ptr + 1, tolower(*key), ptrlen - 1);\n\t\t\tchar *p2 = memchr(ptr + 1, toupper(*key), ptrlen - 1);\n\n\t\t\tif (!p1)\n\t\t\t\tptr = p2;\n\t\t\telse if (!p2)\n\t\t\t\tptr = p1;\n\t\t\telse\n\t\t\t\tptr = (p1 < p2) ? p1 : p2;\n\t\t} else\n\t\t\tptr = memchr(ptr + 1, *key, ptrlen - 1);\n\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\n\t\tptrlen = size - (ptr - map);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "create_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "91-94",
    "snippet": "int create_name(char *buf, size_t size, const char *path, const char *address, const char *name)\n{\n\treturn snprintf(buf, size, \"%s/%s/%s\", path, address, name);\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%s/%s/%s\"",
            "path",
            "address",
            "name"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nint create_name(char *buf, size_t size, const char *path, const char *address, const char *name)\n{\n\treturn snprintf(buf, size, \"%s/%s/%s\", path, address, name);\n}"
  },
  {
    "function_name": "create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "76-89",
    "snippet": "int create_file(const char *filename, const mode_t mode)\n{\n\tint fd;\n\n\tcreate_dirs(filename, S_IRUSR | S_IWUSR | S_IXUSR);\n\n\tfd = open(filename, O_RDWR | O_CREAT, mode);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tclose(fd);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDWR | O_CREAT",
            "mode"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_dirs",
          "args": [
            "filename",
            "S_IRUSR | S_IWUSR | S_IXUSR"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "create_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
          "lines": "42-74",
          "snippet": "static int create_dirs(const char *filename, const mode_t mode)\n{\n\tstruct stat st;\n\tchar dir[PATH_MAX + 1], *prev, *next;\n\tint err;\n\n\terr = stat(filename, &st);\n\tif (!err && S_ISREG(st.st_mode))\n\t\treturn 0;\n\n\tmemset(dir, 0, PATH_MAX + 1);\n\tstrcat(dir, \"/\");\n\n\tprev = strchr(filename, '/');\n\n\twhile (prev) {\n\t\tnext = strchr(prev + 1, '/');\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (next - prev == 1) {\n\t\t\tprev = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrncat(dir, prev + 1, next - prev);\n\t\tmkdir(dir, mode);\n\n\t\tprev = next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"textfile.h\"",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int create_dirs(const char *filename, const mode_t mode)\n{\n\tstruct stat st;\n\tchar dir[PATH_MAX + 1], *prev, *next;\n\tint err;\n\n\terr = stat(filename, &st);\n\tif (!err && S_ISREG(st.st_mode))\n\t\treturn 0;\n\n\tmemset(dir, 0, PATH_MAX + 1);\n\tstrcat(dir, \"/\");\n\n\tprev = strchr(filename, '/');\n\n\twhile (prev) {\n\t\tnext = strchr(prev + 1, '/');\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (next - prev == 1) {\n\t\t\tprev = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrncat(dir, prev + 1, next - prev);\n\t\tmkdir(dir, mode);\n\n\t\tprev = next;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nint create_file(const char *filename, const mode_t mode)\n{\n\tint fd;\n\n\tcreate_dirs(filename, S_IRUSR | S_IWUSR | S_IXUSR);\n\n\tfd = open(filename, O_RDWR | O_CREAT, mode);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tclose(fd);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "create_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/textfile.c",
    "lines": "42-74",
    "snippet": "static int create_dirs(const char *filename, const mode_t mode)\n{\n\tstruct stat st;\n\tchar dir[PATH_MAX + 1], *prev, *next;\n\tint err;\n\n\terr = stat(filename, &st);\n\tif (!err && S_ISREG(st.st_mode))\n\t\treturn 0;\n\n\tmemset(dir, 0, PATH_MAX + 1);\n\tstrcat(dir, \"/\");\n\n\tprev = strchr(filename, '/');\n\n\twhile (prev) {\n\t\tnext = strchr(prev + 1, '/');\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (next - prev == 1) {\n\t\t\tprev = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrncat(dir, prev + 1, next - prev);\n\t\tmkdir(dir, mode);\n\n\t\tprev = next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"textfile.h\"",
      "#include <sys/param.h>",
      "#include <sys/mman.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "mode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "dir",
            "prev + 1",
            "next - prev"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "prev + 1",
            "'/'"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "filename",
            "'/'"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dir",
            "\"/\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dir",
            "0",
            "PATH_MAX + 1"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&st"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "find_service_with_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/device.c",
          "lines": "298-311",
          "snippet": "static GSList *find_service_with_state(GSList *list,\n\t\t\t\t\t\tbtd_service_state_t state)\n{\n\tGSList *l;\n\n\tfor (l = list; l != NULL; l = g_slist_next(l)) {\n\t\tstruct btd_service *service = l->data;\n\n\t\tif (btd_service_get_state(service) == state)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"eir.h\"",
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"agent.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"sdp-client.h\"",
            "#include \"uuid-helper.h\"",
            "#include \"error.h\"",
            "#include \"dbus-common.h\"",
            "#include \"service.h\"",
            "#include \"profile.h\"",
            "#include \"gatt-client.h\"",
            "#include \"device.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"gatt-database.h\"",
            "#include \"adapter.h\"",
            "#include \"hcid.h\"",
            "#include \"attrib/att.h\"",
            "#include \"lib/mgmt.h\"",
            "#include \"btio/btio.h\"",
            "#include \"src/shared/ad.h\"",
            "#include \"src/shared/gatt-server.h\"",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"log.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <dbus/dbus.h>",
            "#include <glib.h>",
            "#include <time.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdbool.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eir.h\"\n#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"agent.h\"\n#include \"attrib/gatt.h\"\n#include \"sdp-client.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"service.h\"\n#include \"profile.h\"\n#include \"gatt-client.h\"\n#include \"device.h\"\n#include \"attrib/gattrib.h\"\n#include \"gatt-database.h\"\n#include \"adapter.h\"\n#include \"hcid.h\"\n#include \"attrib/att.h\"\n#include \"lib/mgmt.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/ad.h\"\n#include \"src/shared/gatt-server.h\"\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/util.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <time.h>\n#include <dirent.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GSList *find_service_with_state(GSList *list,\n\t\t\t\t\t\tbtd_service_state_t state)\n{\n\tGSList *l;\n\n\tfor (l = list; l != NULL; l = g_slist_next(l)) {\n\t\tstruct btd_service *service = l->data;\n\n\t\tif (btd_service_get_state(service) == state)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"textfile.h\"\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int create_dirs(const char *filename, const mode_t mode)\n{\n\tstruct stat st;\n\tchar dir[PATH_MAX + 1], *prev, *next;\n\tint err;\n\n\terr = stat(filename, &st);\n\tif (!err && S_ISREG(st.st_mode))\n\t\treturn 0;\n\n\tmemset(dir, 0, PATH_MAX + 1);\n\tstrcat(dir, \"/\");\n\n\tprev = strchr(filename, '/');\n\n\twhile (prev) {\n\t\tnext = strchr(prev + 1, '/');\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (next - prev == 1) {\n\t\t\tprev = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstrncat(dir, prev + 1, next - prev);\n\t\tmkdir(dir, mode);\n\n\t\tprev = next;\n\t}\n\n\treturn 0;\n}"
  }
]