[
  {
    "function_name": "handle_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "1072-1119",
    "snippet": "void handle_request(int sk, uint8_t *data, int len)\n{\n\tstruct sockaddr_l2 sa;\n\tsocklen_t size;\n\tsdp_req_t req;\n\n\tsize = sizeof(sa);\n\tif (getpeername(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\terror(\"getpeername: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (sa.l2_family == AF_BLUETOOTH) {\n\t\tstruct l2cap_options lo;\n\n\t\tmemset(&lo, 0, sizeof(lo));\n\t\tsize = sizeof(lo);\n\n\t\tif (getsockopt(sk, SOL_L2CAP, L2CAP_OPTIONS, &lo, &size) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.bdaddr, &sa.l2_bdaddr);\n\t\treq.mtu = lo.omtu;\n\t\treq.local = 0;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsize = sizeof(sa);\n\n\t\tif (getsockname(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\t\terror(\"getsockname: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.device, &sa.l2_bdaddr);\n\t} else {\n\t\tbacpy(&req.device, BDADDR_ANY);\n\t\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\t\treq.mtu = 2048;\n\t\treq.local = 1;\n\t}\n\n\treq.sock = sk;\n\treq.buf  = data;\n\treq.len  = len;\n\n\tprocess_request(&req);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_request",
          "args": [
            "&req"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "process_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "968-1054",
          "snippet": "static void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.bdaddr",
            "BDADDR_LOCAL"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.device",
            "BDADDR_ANY"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.device",
            "&sa.l2_bdaddr"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"getsockname: %s\"",
            "strerror(errno)"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "124-128",
          "snippet": "DBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sk",
            "(struct sockaddr *) &sa",
            "&size"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof(sa)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.bdaddr",
            "&sa.l2_bdaddr"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sk",
            "SOL_L2CAP",
            "L2CAP_OPTIONS",
            "&lo",
            "&size"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lo",
            "0",
            "sizeof(lo)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sk",
            "(struct sockaddr *) &sa",
            "&size"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nvoid handle_request(int sk, uint8_t *data, int len)\n{\n\tstruct sockaddr_l2 sa;\n\tsocklen_t size;\n\tsdp_req_t req;\n\n\tsize = sizeof(sa);\n\tif (getpeername(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\terror(\"getpeername: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (sa.l2_family == AF_BLUETOOTH) {\n\t\tstruct l2cap_options lo;\n\n\t\tmemset(&lo, 0, sizeof(lo));\n\t\tsize = sizeof(lo);\n\n\t\tif (getsockopt(sk, SOL_L2CAP, L2CAP_OPTIONS, &lo, &size) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.bdaddr, &sa.l2_bdaddr);\n\t\treq.mtu = lo.omtu;\n\t\treq.local = 0;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsize = sizeof(sa);\n\n\t\tif (getsockname(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\t\terror(\"getsockname: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.device, &sa.l2_bdaddr);\n\t} else {\n\t\tbacpy(&req.device, BDADDR_ANY);\n\t\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\t\treq.mtu = 2048;\n\t\treq.local = 1;\n\t}\n\n\treq.sock = sk;\n\treq.buf  = data;\n\treq.len  = len;\n\n\tprocess_request(&req);\n}"
  },
  {
    "function_name": "handle_internal_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "1056-1070",
    "snippet": "void handle_internal_request(int sk, int mtu, void *data, int len)\n{\n\tsdp_req_t req;\n\n\tbacpy(&req.device, BDADDR_ANY);\n\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\treq.local = 0;\n\treq.sock = sk;\n\treq.mtu = mtu;\n\treq.flags = 0;\n\treq.buf = data;\n\treq.len = len;\n\n\tprocess_request(&req);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_request",
          "args": [
            "&req"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "process_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "968-1054",
          "snippet": "static void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.bdaddr",
            "BDADDR_LOCAL"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&req.device",
            "BDADDR_ANY"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nvoid handle_internal_request(int sk, int mtu, void *data, int len)\n{\n\tsdp_req_t req;\n\n\tbacpy(&req.device, BDADDR_ANY);\n\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\treq.local = 0;\n\treq.sock = sk;\n\treq.mtu = mtu;\n\treq.flags = 0;\n\treq.buf = data;\n\treq.len = len;\n\n\tprocess_request(&req);\n}"
  },
  {
    "function_name": "process_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "968-1054",
    "snippet": "static void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "req->buf"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Bytes Sent : %d\"",
            "rsp.data_size"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"send: %s (%d)\"",
            "strerror(errno)",
            "errno"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/log.c",
          "lines": "199-213",
          "snippet": "void btd_error(uint16_t index, const char *format, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, format);\n\tvsyslog(LOG_ERR, format, ap);\n\tva_end(ap);\n\n\tif (logging_fd < 0)\n\t\treturn;\n\n\tva_start(ap, format);\n\tlogging_log(index, LOG_ERR, format, ap);\n\tva_end(ap);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/hci.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <syslog.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int logging_fd = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"src/shared/util.h\"\n#include \"lib/hci.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <syslog.h>\n#include <errno.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int logging_fd = -1;\n\nvoid btd_error(uint16_t index, const char *format, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, format);\n\tvsyslog(LOG_ERR, format, ap);\n\tva_end(ap);\n\n\tif (logging_fd < 0)\n\t\treturn;\n\n\tva_start(ap, format);\n\tlogging_log(index, LOG_ERR, format, ap);\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "req->sock",
            "rsp.data",
            "rsp.data_size",
            "0"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_gw_send_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "783-810",
          "snippet": "bool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "rsp.data_size"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Sending rsp. status %d\"",
            "status"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_be16",
          "args": [
            "status",
            "rsp.data"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "put_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "164-167",
          "snippet": "static inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unknown PDU ID : 0x%x received\"",
            "reqhdr->pdu_id"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "124-128",
          "snippet": "DBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "service_remove_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "service_remove_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "927-953",
          "snippet": "int service_remove_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = get_be32(p);\n\tsdp_record_t *rec;\n\tint status = 0;\n\n\t/* extract service record handle */\n\n\trec = sdp_record_find(handle);\n\tif (rec) {\n\t\tsdp_svcdb_collect(rec);\n\t\tstatus = sdp_record_remove(handle);\n\t\tsdp_record_free(rec);\n\t\tif (status == 0)\n\t\t\tupdate_db_timestamp();\n\t} else {\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\t\tSDPDBG(\"Could not find record : 0x%x\", handle);\n\t}\n\n\tp = rsp->data;\n\tput_be16(status, p);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn status;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nint service_remove_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = get_be32(p);\n\tsdp_record_t *rec;\n\tint status = 0;\n\n\t/* extract service record handle */\n\n\trec = sdp_record_find(handle);\n\tif (rec) {\n\t\tsdp_svcdb_collect(rec);\n\t\tstatus = sdp_record_remove(handle);\n\t\tsdp_record_free(rec);\n\t\tif (status == 0)\n\t\t\tupdate_db_timestamp();\n\t} else {\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\t\tSDPDBG(\"Could not find record : 0x%x\", handle);\n\t}\n\n\tp = rsp->data;\n\tput_be16(status, p);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Service removal request\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_update_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "service_update_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "885-922",
          "snippet": "int service_update_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tsdp_record_t *orec, *nrec;\n\tint status = 0, scanned = 0;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = get_be32(p);\n\n\tSDPDBG(\"Svc Rec Handle: 0x%x\", handle);\n\n\tp += sizeof(uint32_t);\n\tbufsize -= sizeof(uint32_t);\n\n\torec = sdp_record_find(handle);\n\n\tSDPDBG(\"SvcRecOld: %p\", orec);\n\n\tif (!orec) {\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\t\tgoto done;\n\t}\n\n\tnrec = extract_pdu_server(BDADDR_ANY, p, bufsize, handle, &scanned);\n\tif (!nrec) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tassert(nrec == orec);\n\n\tupdate_db_timestamp();\n\ndone:\n\tp = rsp->data;\n\tput_be16(status, p);\n\trsp->data_size = sizeof(uint16_t);\n\treturn status;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nint service_update_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tsdp_record_t *orec, *nrec;\n\tint status = 0, scanned = 0;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle = get_be32(p);\n\n\tSDPDBG(\"Svc Rec Handle: 0x%x\", handle);\n\n\tp += sizeof(uint32_t);\n\tbufsize -= sizeof(uint32_t);\n\n\torec = sdp_record_find(handle);\n\n\tSDPDBG(\"SvcRecOld: %p\", orec);\n\n\tif (!orec) {\n\t\tstatus = SDP_INVALID_RECORD_HANDLE;\n\t\tgoto done;\n\t}\n\n\tnrec = extract_pdu_server(BDADDR_ANY, p, bufsize, handle, &scanned);\n\tif (!nrec) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tassert(nrec == orec);\n\n\tupdate_db_timestamp();\n\ndone:\n\tp = rsp->data;\n\tput_be16(status, p);\n\trsp->data_size = sizeof(uint16_t);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Service update request\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_register_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "service_register_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "816-880",
          "snippet": "int service_register_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tint scanned = 0;\n\tsdp_data_t *handle;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tsdp_record_t *rec;\n\n\treq->flags = *p++;\n\tif (req->flags & SDP_DEVICE_RECORD) {\n\t\tbacpy(&req->device, (bdaddr_t *) p);\n\t\tp += sizeof(bdaddr_t);\n\t\tbufsize -= sizeof(bdaddr_t);\n\t}\n\n\t/* save image of PDU: we need it when clients request this attribute */\n\trec = extract_pdu_server(&req->device, p, bufsize, 0xffffffff, &scanned);\n\tif (!rec)\n\t\tgoto invalid;\n\n\tif (rec->handle == 0xffffffff) {\n\t\trec->handle = sdp_next_handle();\n\t\tif (rec->handle < 0x10000) {\n\t\t\tsdp_record_free(rec);\n\t\t\tgoto invalid;\n\t\t}\n\t} else {\n\t\tif (sdp_record_find(rec->handle)) {\n\t\t\t/* extract_pdu_server will add the record handle\n\t\t\t * if it is missing. So instead of failing, skip\n\t\t\t * the record adding to avoid duplication. */\n\t\t\tgoto success;\n\t\t}\n\t}\n\n\tsdp_record_add(&req->device, rec);\n\tif (!(req->flags & SDP_RECORD_PERSIST))\n\t\tsdp_svcdb_set_collectable(rec, req->sock);\n\n\thandle = sdp_data_alloc(SDP_UINT32, &rec->handle);\n\tsdp_attr_replace(rec, SDP_ATTR_RECORD_HANDLE, handle);\n\nsuccess:\n\t/* if the browse group descriptor is NULL,\n\t * ensure that the record belongs to the ROOT group */\n\tif (sdp_data_get(rec, SDP_ATTR_BROWSE_GRP_LIST) == NULL) {\n\t\tuuid_t uuid;\n\t\tsdp_uuid16_create(&uuid, PUBLIC_BROWSE_GROUP);\n\t\tsdp_pattern_add_uuid(rec, &uuid);\n\t}\n\n\tupdate_db_timestamp();\n\n\t/* Build a rsp buffer */\n\tput_be32(rec->handle, rsp->data);\n\trsp->data_size = sizeof(uint32_t);\n\n\treturn 0;\n\ninvalid:\n\tput_be16(SDP_INVALID_SYNTAX, rsp->data);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nint service_register_req(sdp_req_t *req, sdp_buf_t *rsp)\n{\n\tint scanned = 0;\n\tsdp_data_t *handle;\n\tuint8_t *p = req->buf + sizeof(sdp_pdu_hdr_t);\n\tint bufsize = req->len - sizeof(sdp_pdu_hdr_t);\n\tsdp_record_t *rec;\n\n\treq->flags = *p++;\n\tif (req->flags & SDP_DEVICE_RECORD) {\n\t\tbacpy(&req->device, (bdaddr_t *) p);\n\t\tp += sizeof(bdaddr_t);\n\t\tbufsize -= sizeof(bdaddr_t);\n\t}\n\n\t/* save image of PDU: we need it when clients request this attribute */\n\trec = extract_pdu_server(&req->device, p, bufsize, 0xffffffff, &scanned);\n\tif (!rec)\n\t\tgoto invalid;\n\n\tif (rec->handle == 0xffffffff) {\n\t\trec->handle = sdp_next_handle();\n\t\tif (rec->handle < 0x10000) {\n\t\t\tsdp_record_free(rec);\n\t\t\tgoto invalid;\n\t\t}\n\t} else {\n\t\tif (sdp_record_find(rec->handle)) {\n\t\t\t/* extract_pdu_server will add the record handle\n\t\t\t * if it is missing. So instead of failing, skip\n\t\t\t * the record adding to avoid duplication. */\n\t\t\tgoto success;\n\t\t}\n\t}\n\n\tsdp_record_add(&req->device, rec);\n\tif (!(req->flags & SDP_RECORD_PERSIST))\n\t\tsdp_svcdb_set_collectable(rec, req->sock);\n\n\thandle = sdp_data_alloc(SDP_UINT32, &rec->handle);\n\tsdp_attr_replace(rec, SDP_ATTR_RECORD_HANDLE, handle);\n\nsuccess:\n\t/* if the browse group descriptor is NULL,\n\t * ensure that the record belongs to the ROOT group */\n\tif (sdp_data_get(rec, SDP_ATTR_BROWSE_GRP_LIST) == NULL) {\n\t\tuuid_t uuid;\n\t\tsdp_uuid16_create(&uuid, PUBLIC_BROWSE_GROUP);\n\t\tsdp_pattern_add_uuid(rec, &uuid);\n\t}\n\n\tupdate_db_timestamp();\n\n\t/* Build a rsp buffer */\n\tput_be32(rec->handle, rsp->data);\n\trsp->data_size = sizeof(uint32_t);\n\n\treturn 0;\n\ninvalid:\n\tput_be16(SDP_INVALID_SYNTAX, rsp->data);\n\trsp->data_size = sizeof(uint16_t);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Service register request\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_search_attr_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "service_search_attr_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "786-961",
          "snippet": "static int service_search_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, plen, totscanned;\n\tuint8_t *pdata, *pResponse = NULL;\n\tunsigned int max;\n\tint scanned, rsp_count = 0;\n\tsdp_list_t *pattern = NULL, *seq = NULL, *svcList;\n\tsdp_cont_state_t *cstate = NULL;\n\tshort cstate_size = 0;\n\tuint8_t dtd = 0;\n\tsdp_buf_t tmpbuf;\n\tsize_t data_left;\n\n\ttmpbuf.data = NULL;\n\tpdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tdata_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\ttotscanned = scanned;\n\n\tSDPDBG(\"Bytes scanned: %d\", scanned);\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tSDPDBG(\"Max Attr expected: %d\", max);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\ttotscanned += scanned + sizeof(uint16_t) + 1;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tif (plen < totscanned || plen != totscanned + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tsvcList = sdp_get_record_list();\n\n\ttmpbuf.data = malloc(USHRT_MAX);\n\ttmpbuf.data_size = 0;\n\ttmpbuf.buf_size = USHRT_MAX;\n\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax = MIN(max, req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* no continuation state -> create new response */\n\t\tsdp_list_t *p;\n\t\tfor (p = svcList; p; p = p->next) {\n\t\t\tsdp_record_t *rec = p->data;\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tstatus = extract_attrs(rec, seq, &tmpbuf);\n\n\t\t\t\tSDPDBG(\"Response count : %d\", rsp_count);\n\t\t\t\tSDPDBG(\"Local PDU size : %d\", tmpbuf.data_size);\n\t\t\t\tif (status) {\n\t\t\t\t\tSDPDBG(\"Extract attr from record returns err\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (buf->data_size + tmpbuf.data_size < buf->buf_size) {\n\t\t\t\t\t/* to be sure no relocations */\n\t\t\t\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\t\t\t\ttmpbuf.data_size = 0;\n\t\t\t\t\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Relocation needed\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSDPDBG(\"Net PDU size : %d\", buf->data_size);\n\t\t\t}\n\t\t}\n\t\tif (buf->data_size > max) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tbuf->data_size = max;\n\t\t\tnewState.cStateValue.maxBytesSent = max;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t} else {\n\t\t/* continuation State exists -> get from cache */\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\tif (pCache && cstate->cStateValue.maxBytesSent < pCache->data_size) {\n\t\t\tuint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\tSDPDBG(\"Non-null continuation state, but null cache buffer\");\n\t\t}\n\t}\n\n\tif (!rsp_count && !cstate) {\n\t\t/* found nothing */\n\t\tbuf->data_size = 0;\n\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\tsdp_set_cstate_pdu(buf, NULL);\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\n\tif (!status) {\n\t\t/* set attribute list byte count */\n\t\tput_be16(buf->data_size - cstate_size, buf->data);\n\t\tbuf->data_size += sizeof(uint16_t);\n\t}\n\ndone:\n\tfree(cstate);\n\tfree(tmpbuf.data);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\treturn status;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_ATTRID\t0xff",
            "#define SDP_TYPE_UUID\t0xfe",
            "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_search_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, plen, totscanned;\n\tuint8_t *pdata, *pResponse = NULL;\n\tunsigned int max;\n\tint scanned, rsp_count = 0;\n\tsdp_list_t *pattern = NULL, *seq = NULL, *svcList;\n\tsdp_cont_state_t *cstate = NULL;\n\tshort cstate_size = 0;\n\tuint8_t dtd = 0;\n\tsdp_buf_t tmpbuf;\n\tsize_t data_left;\n\n\ttmpbuf.data = NULL;\n\tpdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tdata_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\ttotscanned = scanned;\n\n\tSDPDBG(\"Bytes scanned: %d\", scanned);\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tSDPDBG(\"Max Attr expected: %d\", max);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\ttotscanned += scanned + sizeof(uint16_t) + 1;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tif (plen < totscanned || plen != totscanned + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tsvcList = sdp_get_record_list();\n\n\ttmpbuf.data = malloc(USHRT_MAX);\n\ttmpbuf.data_size = 0;\n\ttmpbuf.buf_size = USHRT_MAX;\n\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax = MIN(max, req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* no continuation state -> create new response */\n\t\tsdp_list_t *p;\n\t\tfor (p = svcList; p; p = p->next) {\n\t\t\tsdp_record_t *rec = p->data;\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tstatus = extract_attrs(rec, seq, &tmpbuf);\n\n\t\t\t\tSDPDBG(\"Response count : %d\", rsp_count);\n\t\t\t\tSDPDBG(\"Local PDU size : %d\", tmpbuf.data_size);\n\t\t\t\tif (status) {\n\t\t\t\t\tSDPDBG(\"Extract attr from record returns err\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (buf->data_size + tmpbuf.data_size < buf->buf_size) {\n\t\t\t\t\t/* to be sure no relocations */\n\t\t\t\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\t\t\t\ttmpbuf.data_size = 0;\n\t\t\t\t\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Relocation needed\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSDPDBG(\"Net PDU size : %d\", buf->data_size);\n\t\t\t}\n\t\t}\n\t\tif (buf->data_size > max) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tbuf->data_size = max;\n\t\t\tnewState.cStateValue.maxBytesSent = max;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t} else {\n\t\t/* continuation State exists -> get from cache */\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\tif (pCache && cstate->cStateValue.maxBytesSent < pCache->data_size) {\n\t\t\tuint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\tSDPDBG(\"Non-null continuation state, but null cache buffer\");\n\t\t}\n\t}\n\n\tif (!rsp_count && !cstate) {\n\t\t/* found nothing */\n\t\tbuf->data_size = 0;\n\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\tsdp_set_cstate_pdu(buf, NULL);\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\n\tif (!status) {\n\t\t/* set attribute list byte count */\n\t\tput_be16(buf->data_size - cstate_size, buf->data);\n\t\tbuf->data_size += sizeof(uint16_t);\n\t}\n\ndone:\n\tfree(cstate);\n\tfree(tmpbuf.data);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Got a svc srch attr req\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_attr_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "service_attr_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "633-781",
          "snippet": "static int service_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pResponse = NULL;\n\tshort cstate_size = 0;\n\tsdp_list_t *seq = NULL;\n\tuint8_t dtd = 0;\n\tint scanned = 0;\n\tunsigned int max_rsp_size;\n\tint status = 0, plen, mlen;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle;\n\n\tif (data_left < sizeof(uint32_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\thandle = get_be32(pdata);\n\n\tpdata += sizeof(uint32_t);\n\tdata_left -= sizeof(uint32_t);\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax_rsp_size = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint32_t) + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists, attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\tSDPDBG(\"max_rsp_size : %d\", max_rsp_size);\n\n\t/*\n\t * Check that max_rsp_size is within valid range\n\t * a minimum size of 0x0007 has to be used for data field\n\t */\n\tif (max_rsp_size < 0x0007) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax_rsp_size = MIN(max_rsp_size, req->mtu - sizeof(sdp_pdu_hdr_t) -\n\t\t\tsizeof(uint32_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate) {\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\n\t\tSDPDBG(\"Obtained cached rsp : %p\", pCache);\n\n\t\tif (pCache) {\n\t\t\tshort sent = MIN(max_rsp_size, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\n\t\t\tSDPDBG(\"Response size : %d sending now : %d bytes sent so far : %d\",\n\t\t\t\tpCache->data_size, sent, cstate->cStateValue.maxBytesSent);\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\terror(\"NULL cache buffer and non-NULL continuation state\");\n\t\t}\n\t} else {\n\t\tsdp_record_t *rec = sdp_record_find(handle);\n\t\tstatus = extract_attrs(rec, seq, buf);\n\t\tif (buf->data_size > max_rsp_size) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tSDPDBG(\"Creating continuation state of size : %d\", buf->data_size);\n\t\t\tbuf->data_size = max_rsp_size;\n\t\t\tnewState.cStateValue.maxBytesSent = max_rsp_size;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else {\n\t\t\tif (buf->data_size == 0)\n\t\t\t\tsdp_append_to_buf(buf, NULL, 0);\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\ndone:\n\tfree(cstate);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\tif (status)\n\t\treturn status;\n\n\t/* set attribute list byte count */\n\tput_be16(buf->data_size - cstate_size, buf->data);\n\tbuf->data_size += sizeof(uint16_t);\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_ATTRID\t0xff",
            "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pResponse = NULL;\n\tshort cstate_size = 0;\n\tsdp_list_t *seq = NULL;\n\tuint8_t dtd = 0;\n\tint scanned = 0;\n\tunsigned int max_rsp_size;\n\tint status = 0, plen, mlen;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle;\n\n\tif (data_left < sizeof(uint32_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\thandle = get_be32(pdata);\n\n\tpdata += sizeof(uint32_t);\n\tdata_left -= sizeof(uint32_t);\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax_rsp_size = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint32_t) + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists, attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\tSDPDBG(\"max_rsp_size : %d\", max_rsp_size);\n\n\t/*\n\t * Check that max_rsp_size is within valid range\n\t * a minimum size of 0x0007 has to be used for data field\n\t */\n\tif (max_rsp_size < 0x0007) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax_rsp_size = MIN(max_rsp_size, req->mtu - sizeof(sdp_pdu_hdr_t) -\n\t\t\tsizeof(uint32_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate) {\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\n\t\tSDPDBG(\"Obtained cached rsp : %p\", pCache);\n\n\t\tif (pCache) {\n\t\t\tshort sent = MIN(max_rsp_size, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\n\t\t\tSDPDBG(\"Response size : %d sending now : %d bytes sent so far : %d\",\n\t\t\t\tpCache->data_size, sent, cstate->cStateValue.maxBytesSent);\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\terror(\"NULL cache buffer and non-NULL continuation state\");\n\t\t}\n\t} else {\n\t\tsdp_record_t *rec = sdp_record_find(handle);\n\t\tstatus = extract_attrs(rec, seq, buf);\n\t\tif (buf->data_size > max_rsp_size) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tSDPDBG(\"Creating continuation state of size : %d\", buf->data_size);\n\t\t\tbuf->data_size = max_rsp_size;\n\t\t\tnewState.cStateValue.maxBytesSent = max_rsp_size;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else {\n\t\t\tif (buf->data_size == 0)\n\t\t\t\tsdp_append_to_buf(buf, NULL, 0);\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\ndone:\n\tfree(cstate);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\tif (status)\n\t\treturn status;\n\n\t/* set attribute list byte count */\n\tput_be16(buf->data_size - cstate_size, buf->data);\n\tbuf->data_size += sizeof(uint16_t);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Got a svc attr req\""
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_search_req",
          "args": [
            "req",
            "&rsp"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "service_search_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "362-553",
          "snippet": "static int service_search_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, i, plen, mlen, mtu, scanned;\n\tsdp_list_t *pattern = NULL;\n\tuint16_t expected, actual, rsp_count = 0;\n\tuint8_t dtd;\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pCacheBuffer = NULL;\n\tint handleSize = 0;\n\tuint32_t cStateId = 0;\n\tuint8_t *pTotalRecordCount, *pCurrentRecordCount;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)(pdata+sizeof(uint16_t))) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\texpected = get_be16(pdata);\n\n\tSDPDBG(\"Expected count: %d\", expected);\n\tSDPDBG(\"Bytes scanned : %d\", scanned);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmtu = req->mtu - sizeof(sdp_pdu_hdr_t) - sizeof(uint16_t) - sizeof(uint16_t) - SDP_CONT_STATE_SIZE;\n\tactual = MIN(expected, mtu >> 2);\n\n\t/* make space in the rsp buffer for total and current record counts */\n\tpdata = buf->data;\n\n\t/* total service record count = 0 */\n\tpTotalRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\t/* current service record count = 0 */\n\tpCurrentRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* for every record in the DB, do a pattern search */\n\t\tsdp_list_t *list = sdp_get_record_list();\n\n\t\thandleSize = 0;\n\t\tfor (; list && rsp_count < expected; list = list->next) {\n\t\t\tsdp_record_t *rec = list->data;\n\n\t\t\tSDPDBG(\"Checking svcRec : 0x%x\", rec->handle);\n\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tput_be32(rec->handle, pdata);\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t}\n\n\t\tSDPDBG(\"Match count: %d\", rsp_count);\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(rsp_count, pCurrentRecordCount);\n\n\t\tif (rsp_count > actual) {\n\t\t\t/* cache the rsp and generate a continuation state */\n\t\t\tcStateId = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * subtract handleSize since we now send only\n\t\t\t * a subset of handles\n\t\t\t */\n\t\t\tbuf->data_size -= handleSize;\n\t\t} else {\n\t\t\t/* NULL continuation state */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* under both the conditions below, the rsp buffer is not built yet */\n\tif (cstate || cStateId > 0) {\n\t\tshort lastIndex = 0;\n\n\t\tif (cstate) {\n\t\t\t/*\n\t\t\t * Get the previous sdp_cont_state_t and obtain\n\t\t\t * the cached rsp\n\t\t\t */\n\t\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\t\tif (pCache) {\n\t\t\t\tpCacheBuffer = pCache->data;\n\t\t\t\t/* get the rsp_count from the cached buffer */\n\t\t\t\trsp_count = get_be16(pCacheBuffer);\n\n\t\t\t\t/* get index of the last sdp_record_t sent */\n\t\t\t\tlastIndex = cstate->cStateValue.lastIndexSent;\n\t\t\t} else {\n\t\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tpCacheBuffer = buf->data;\n\t\t\tlastIndex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set the local buffer pointer to after the\n\t\t * current record count and increment the cached\n\t\t * buffer pointer to beyond the counters\n\t\t */\n\t\tpdata = pCurrentRecordCount + sizeof(uint16_t);\n\n\t\t/* increment beyond the totalCount and the currentCount */\n\t\tpCacheBuffer += 2 * sizeof(uint16_t);\n\n\t\tif (cstate) {\n\t\t\thandleSize = 0;\n\t\t\tfor (i = lastIndex; (i - lastIndex) < actual && i < rsp_count; i++) {\n\t\t\t\tmemcpy(pdata, pCacheBuffer + i * sizeof(uint32_t), sizeof(uint32_t));\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t} else {\n\t\t\thandleSize = actual << 2;\n\t\t\ti = actual;\n\t\t}\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(i - lastIndex, pCurrentRecordCount);\n\n\t\tif (i == rsp_count) {\n\t\t\t/* set \"null\" continuationState */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's more: set lastIndexSent to\n\t\t\t * the new value and move on\n\t\t\t */\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tSDPDBG(\"Setting non-NULL sdp_cstate_t\");\n\n\t\t\tif (cstate)\n\t\t\t\tmemcpy(&newState, cstate, sizeof(sdp_cont_state_t));\n\t\t\telse {\n\t\t\t\tmemset(&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\t\tnewState.timestamp = cStateId;\n\t\t\t}\n\t\t\tnewState.cStateValue.lastIndexSent = i;\n\t\t\tsdp_set_cstate_pdu(buf, &newState);\n\t\t}\n\t}\n\ndone:\n\tfree(cstate);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\n\treturn status;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_UUID\t0xfe",
            "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_UUID\t0xfe\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_search_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, i, plen, mlen, mtu, scanned;\n\tsdp_list_t *pattern = NULL;\n\tuint16_t expected, actual, rsp_count = 0;\n\tuint8_t dtd;\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pCacheBuffer = NULL;\n\tint handleSize = 0;\n\tuint32_t cStateId = 0;\n\tuint8_t *pTotalRecordCount, *pCurrentRecordCount;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)(pdata+sizeof(uint16_t))) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\texpected = get_be16(pdata);\n\n\tSDPDBG(\"Expected count: %d\", expected);\n\tSDPDBG(\"Bytes scanned : %d\", scanned);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmtu = req->mtu - sizeof(sdp_pdu_hdr_t) - sizeof(uint16_t) - sizeof(uint16_t) - SDP_CONT_STATE_SIZE;\n\tactual = MIN(expected, mtu >> 2);\n\n\t/* make space in the rsp buffer for total and current record counts */\n\tpdata = buf->data;\n\n\t/* total service record count = 0 */\n\tpTotalRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\t/* current service record count = 0 */\n\tpCurrentRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* for every record in the DB, do a pattern search */\n\t\tsdp_list_t *list = sdp_get_record_list();\n\n\t\thandleSize = 0;\n\t\tfor (; list && rsp_count < expected; list = list->next) {\n\t\t\tsdp_record_t *rec = list->data;\n\n\t\t\tSDPDBG(\"Checking svcRec : 0x%x\", rec->handle);\n\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tput_be32(rec->handle, pdata);\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t}\n\n\t\tSDPDBG(\"Match count: %d\", rsp_count);\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(rsp_count, pCurrentRecordCount);\n\n\t\tif (rsp_count > actual) {\n\t\t\t/* cache the rsp and generate a continuation state */\n\t\t\tcStateId = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * subtract handleSize since we now send only\n\t\t\t * a subset of handles\n\t\t\t */\n\t\t\tbuf->data_size -= handleSize;\n\t\t} else {\n\t\t\t/* NULL continuation state */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* under both the conditions below, the rsp buffer is not built yet */\n\tif (cstate || cStateId > 0) {\n\t\tshort lastIndex = 0;\n\n\t\tif (cstate) {\n\t\t\t/*\n\t\t\t * Get the previous sdp_cont_state_t and obtain\n\t\t\t * the cached rsp\n\t\t\t */\n\t\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\t\tif (pCache) {\n\t\t\t\tpCacheBuffer = pCache->data;\n\t\t\t\t/* get the rsp_count from the cached buffer */\n\t\t\t\trsp_count = get_be16(pCacheBuffer);\n\n\t\t\t\t/* get index of the last sdp_record_t sent */\n\t\t\t\tlastIndex = cstate->cStateValue.lastIndexSent;\n\t\t\t} else {\n\t\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tpCacheBuffer = buf->data;\n\t\t\tlastIndex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set the local buffer pointer to after the\n\t\t * current record count and increment the cached\n\t\t * buffer pointer to beyond the counters\n\t\t */\n\t\tpdata = pCurrentRecordCount + sizeof(uint16_t);\n\n\t\t/* increment beyond the totalCount and the currentCount */\n\t\tpCacheBuffer += 2 * sizeof(uint16_t);\n\n\t\tif (cstate) {\n\t\t\thandleSize = 0;\n\t\t\tfor (i = lastIndex; (i - lastIndex) < actual && i < rsp_count; i++) {\n\t\t\t\tmemcpy(pdata, pCacheBuffer + i * sizeof(uint32_t), sizeof(uint32_t));\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t} else {\n\t\t\thandleSize = actual << 2;\n\t\t\ti = actual;\n\t\t}\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(i - lastIndex, pCurrentRecordCount);\n\n\t\tif (i == rsp_count) {\n\t\t\t/* set \"null\" continuationState */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's more: set lastIndexSent to\n\t\t\t * the new value and move on\n\t\t\t */\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tSDPDBG(\"Setting non-NULL sdp_cstate_t\");\n\n\t\t\tif (cstate)\n\t\t\t\tmemcpy(&newState, cstate, sizeof(sdp_cont_state_t));\n\t\t\telse {\n\t\t\t\tmemset(&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\t\tnewState.timestamp = cStateId;\n\t\t\t}\n\t\t\tnewState.cStateValue.lastIndexSent = i;\n\t\t\tsdp_set_cstate_pdu(buf, &newState);\n\t\t}\n\t}\n\ndone:\n\tfree(cstate);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Got a svc srch req\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "reqhdr->plen"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "USHRT_MAX"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "USHRT_MAX"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void process_request(sdp_req_t *req)\n{\n\tsdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *)req->buf;\n\tsdp_pdu_hdr_t *rsphdr;\n\tsdp_buf_t rsp;\n\tuint8_t *buf = malloc(USHRT_MAX);\n\tint status = SDP_INVALID_SYNTAX;\n\n\tmemset(buf, 0, USHRT_MAX);\n\trsp.data = buf + sizeof(sdp_pdu_hdr_t);\n\trsp.data_size = 0;\n\trsp.buf_size = USHRT_MAX - sizeof(sdp_pdu_hdr_t);\n\trsphdr = (sdp_pdu_hdr_t *)buf;\n\n\tif (ntohs(reqhdr->plen) != req->len - sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto send_rsp;\n\t}\n\tswitch (reqhdr->pdu_id) {\n\tcase SDP_SVC_SEARCH_REQ:\n\t\tSDPDBG(\"Got a svc srch req\");\n\t\tstatus = service_search_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_RSP;\n\t\tbreak;\n\tcase SDP_SVC_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc attr req\");\n\t\tstatus = service_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_ATTR_RSP;\n\t\tbreak;\n\tcase SDP_SVC_SEARCH_ATTR_REQ:\n\t\tSDPDBG(\"Got a svc srch attr req\");\n\t\tstatus = service_search_attr_req(req, &rsp);\n\t\trsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;\n\t\tbreak;\n\t/* Following requests are allowed only for local connections */\n\tcase SDP_SVC_REGISTER_REQ:\n\t\tSDPDBG(\"Service register request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_register_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REGISTER_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_UPDATE_REQ:\n\t\tSDPDBG(\"Service update request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_update_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_UPDATE_RSP;\n\t\t}\n\t\tbreak;\n\tcase SDP_SVC_REMOVE_REQ:\n\t\tSDPDBG(\"Service removal request\");\n\t\tif (req->local) {\n\t\t\tstatus = service_remove_req(req, &rsp);\n\t\t\trsphdr->pdu_id = SDP_SVC_REMOVE_RSP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown PDU ID : 0x%x received\", reqhdr->pdu_id);\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tbreak;\n\t}\n\nsend_rsp:\n\tif (status) {\n\t\trsphdr->pdu_id = SDP_ERROR_RSP;\n\t\tput_be16(status, rsp.data);\n\t\trsp.data_size = sizeof(uint16_t);\n\t}\n\n\tSDPDBG(\"Sending rsp. status %d\", status);\n\n\trsphdr->tid  = reqhdr->tid;\n\trsphdr->plen = htons(rsp.data_size);\n\n\t/* point back to the real buffer start and set the real rsp length */\n\trsp.data_size += sizeof(sdp_pdu_hdr_t);\n\trsp.data = buf;\n\n\t/* stream the rsp PDU */\n\tif (send(req->sock, rsp.data, rsp.data_size, 0) < 0)\n\t\terror(\"send: %s (%d)\", strerror(errno), errno);\n\n\tSDPDBG(\"Bytes Sent : %d\", rsp.data_size);\n\n\tfree(rsp.data);\n\tfree(req->buf);\n}"
  },
  {
    "function_name": "service_search_attr_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "786-961",
    "snippet": "static int service_search_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, plen, totscanned;\n\tuint8_t *pdata, *pResponse = NULL;\n\tunsigned int max;\n\tint scanned, rsp_count = 0;\n\tsdp_list_t *pattern = NULL, *seq = NULL, *svcList;\n\tsdp_cont_state_t *cstate = NULL;\n\tshort cstate_size = 0;\n\tuint8_t dtd = 0;\n\tsdp_buf_t tmpbuf;\n\tsize_t data_left;\n\n\ttmpbuf.data = NULL;\n\tpdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tdata_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\ttotscanned = scanned;\n\n\tSDPDBG(\"Bytes scanned: %d\", scanned);\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tSDPDBG(\"Max Attr expected: %d\", max);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\ttotscanned += scanned + sizeof(uint16_t) + 1;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tif (plen < totscanned || plen != totscanned + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tsvcList = sdp_get_record_list();\n\n\ttmpbuf.data = malloc(USHRT_MAX);\n\ttmpbuf.data_size = 0;\n\ttmpbuf.buf_size = USHRT_MAX;\n\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax = MIN(max, req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* no continuation state -> create new response */\n\t\tsdp_list_t *p;\n\t\tfor (p = svcList; p; p = p->next) {\n\t\t\tsdp_record_t *rec = p->data;\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tstatus = extract_attrs(rec, seq, &tmpbuf);\n\n\t\t\t\tSDPDBG(\"Response count : %d\", rsp_count);\n\t\t\t\tSDPDBG(\"Local PDU size : %d\", tmpbuf.data_size);\n\t\t\t\tif (status) {\n\t\t\t\t\tSDPDBG(\"Extract attr from record returns err\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (buf->data_size + tmpbuf.data_size < buf->buf_size) {\n\t\t\t\t\t/* to be sure no relocations */\n\t\t\t\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\t\t\t\ttmpbuf.data_size = 0;\n\t\t\t\t\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Relocation needed\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSDPDBG(\"Net PDU size : %d\", buf->data_size);\n\t\t\t}\n\t\t}\n\t\tif (buf->data_size > max) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tbuf->data_size = max;\n\t\t\tnewState.cStateValue.maxBytesSent = max;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t} else {\n\t\t/* continuation State exists -> get from cache */\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\tif (pCache && cstate->cStateValue.maxBytesSent < pCache->data_size) {\n\t\t\tuint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\tSDPDBG(\"Non-null continuation state, but null cache buffer\");\n\t\t}\n\t}\n\n\tif (!rsp_count && !cstate) {\n\t\t/* found nothing */\n\t\tbuf->data_size = 0;\n\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\tsdp_set_cstate_pdu(buf, NULL);\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\n\tif (!status) {\n\t\t/* set attribute list byte count */\n\t\tput_be16(buf->data_size - cstate_size, buf->data);\n\t\tbuf->data_size += sizeof(uint16_t);\n\t}\n\ndone:\n\tfree(cstate);\n\tfree(tmpbuf.data);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\treturn status;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SDP_TYPE_ATTRID\t0xff",
      "#define SDP_TYPE_UUID\t0xfe",
      "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sdp_list_free",
          "args": [
            "seq",
            "free"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_free",
          "args": [
            "pattern",
            "free"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmpbuf.data"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_be16",
          "args": [
            "buf->data_size - cstate_size",
            "buf->data"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "put_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "164-167",
          "snippet": "static inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_set_cstate_pdu",
          "args": [
            "buf",
            "NULL"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_set_cstate_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "262-281",
          "snippet": "static int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_append_to_buf",
          "args": [
            "buf",
            "tmpbuf.data",
            "tmpbuf.data_size"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Non-null continuation state, but null cache buffer\""
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf->data",
            "pResponse + cstate->cStateValue.maxBytesSent",
            "sent"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "max",
            "pCache->data_size - cstate->cStateValue.maxBytesSent"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_get_cached_rsp",
          "args": [
            "cstate"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_cached_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "69-77",
          "snippet": "static sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_cstate_alloc_buf",
          "args": [
            "buf"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_alloc_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "79-93",
          "snippet": "static uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&newState",
            "0",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Net PDU size : %d\"",
            "buf->data_size"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Relocation needed\""
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuf.data",
            "0",
            "USHRT_MAX"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_append_to_buf",
          "args": [
            "buf",
            "tmpbuf.data",
            "tmpbuf.data_size"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Extract attr from record returns err\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Local PDU size : %d\"",
            "tmpbuf.data_size"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Response count : %d\"",
            "rsp_count"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attrs",
          "args": [
            "rec",
            "seq",
            "&tmpbuf"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "extract_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "562-625",
          "snippet": "static int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_check_access",
          "args": [
            "rec->handle",
            "&req->device"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_check_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "277-295",
          "snippet": "int sdp_check_access(uint32_t handle, bdaddr_t *device)\n{\n\tsdp_list_t *p = access_locate(handle);\n\tsdp_access_t *a;\n\n\tif (!p)\n\t\treturn 1;\n\n\ta = p->data;\n\tif (!a)\n\t\treturn 1;\n\n\tif (bacmp(&a->device, device) &&\n\t\t\tbacmp(&a->device, BDADDR_ANY) &&\n\t\t\tbacmp(device, BDADDR_ANY))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nint sdp_check_access(uint32_t handle, bdaddr_t *device)\n{\n\tsdp_list_t *p = access_locate(handle);\n\tsdp_access_t *a;\n\n\tif (!p)\n\t\treturn 1;\n\n\ta = p->data;\n\tif (!a)\n\t\treturn 1;\n\n\tif (bacmp(&a->device, device) &&\n\t\t\tbacmp(&a->device, BDADDR_ANY) &&\n\t\t\tbacmp(device, BDADDR_ANY))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_match_uuid",
          "args": [
            "pattern",
            "rec->pattern"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_match_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "329-355",
          "snippet": "static int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "max",
            "req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuf.data",
            "0",
            "USHRT_MAX"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "USHRT_MAX"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_get_record_list",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_record_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "272-275",
          "snippet": "sdp_list_t *sdp_get_record_list(void)\n{\n\treturn service_db;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_list_t *service_db;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic sdp_list_t *service_db;\n\nsdp_list_t *sdp_get_record_list(void)\n{\n\treturn service_db;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_cstate_get",
          "args": [
            "pdata",
            "data_left",
            "&cstate"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "283-316",
          "snippet": "static int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "((sdp_pdu_hdr_t *)(req->buf))->plen"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_des",
          "args": [
            "pdata",
            "data_left",
            "&seq",
            "&dtd",
            "SDP_TYPE_ATTRID"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "extract_des",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "113-260",
          "snippet": "static int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_ATTRID\t0xff",
            "#define SDP_TYPE_UUID\t0xfe"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n\nstatic int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Max Attr expected: %d\"",
            "max"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_be16",
          "args": [
            "pdata"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "get_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "134-137",
          "snippet": "static inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Bytes scanned: %d\"",
            "scanned"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_search_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, plen, totscanned;\n\tuint8_t *pdata, *pResponse = NULL;\n\tunsigned int max;\n\tint scanned, rsp_count = 0;\n\tsdp_list_t *pattern = NULL, *seq = NULL, *svcList;\n\tsdp_cont_state_t *cstate = NULL;\n\tshort cstate_size = 0;\n\tuint8_t dtd = 0;\n\tsdp_buf_t tmpbuf;\n\tsize_t data_left;\n\n\ttmpbuf.data = NULL;\n\tpdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tdata_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\ttotscanned = scanned;\n\n\tSDPDBG(\"Bytes scanned: %d\", scanned);\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tSDPDBG(\"Max Attr expected: %d\", max);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\ttotscanned += scanned + sizeof(uint16_t) + 1;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tif (plen < totscanned || plen != totscanned + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tsvcList = sdp_get_record_list();\n\n\ttmpbuf.data = malloc(USHRT_MAX);\n\ttmpbuf.data_size = 0;\n\ttmpbuf.buf_size = USHRT_MAX;\n\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax = MIN(max, req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* no continuation state -> create new response */\n\t\tsdp_list_t *p;\n\t\tfor (p = svcList; p; p = p->next) {\n\t\t\tsdp_record_t *rec = p->data;\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tstatus = extract_attrs(rec, seq, &tmpbuf);\n\n\t\t\t\tSDPDBG(\"Response count : %d\", rsp_count);\n\t\t\t\tSDPDBG(\"Local PDU size : %d\", tmpbuf.data_size);\n\t\t\t\tif (status) {\n\t\t\t\t\tSDPDBG(\"Extract attr from record returns err\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (buf->data_size + tmpbuf.data_size < buf->buf_size) {\n\t\t\t\t\t/* to be sure no relocations */\n\t\t\t\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\t\t\t\ttmpbuf.data_size = 0;\n\t\t\t\t\tmemset(tmpbuf.data, 0, USHRT_MAX);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Relocation needed\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSDPDBG(\"Net PDU size : %d\", buf->data_size);\n\t\t\t}\n\t\t}\n\t\tif (buf->data_size > max) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tbuf->data_size = max;\n\t\t\tnewState.cStateValue.maxBytesSent = max;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t} else {\n\t\t/* continuation State exists -> get from cache */\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\tif (pCache && cstate->cStateValue.maxBytesSent < pCache->data_size) {\n\t\t\tuint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\tSDPDBG(\"Non-null continuation state, but null cache buffer\");\n\t\t}\n\t}\n\n\tif (!rsp_count && !cstate) {\n\t\t/* found nothing */\n\t\tbuf->data_size = 0;\n\t\tsdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);\n\t\tsdp_set_cstate_pdu(buf, NULL);\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\n\tif (!status) {\n\t\t/* set attribute list byte count */\n\t\tput_be16(buf->data_size - cstate_size, buf->data);\n\t\tbuf->data_size += sizeof(uint16_t);\n\t}\n\ndone:\n\tfree(cstate);\n\tfree(tmpbuf.data);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\treturn status;\n}"
  },
  {
    "function_name": "service_attr_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "633-781",
    "snippet": "static int service_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pResponse = NULL;\n\tshort cstate_size = 0;\n\tsdp_list_t *seq = NULL;\n\tuint8_t dtd = 0;\n\tint scanned = 0;\n\tunsigned int max_rsp_size;\n\tint status = 0, plen, mlen;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle;\n\n\tif (data_left < sizeof(uint32_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\thandle = get_be32(pdata);\n\n\tpdata += sizeof(uint32_t);\n\tdata_left -= sizeof(uint32_t);\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax_rsp_size = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint32_t) + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists, attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\tSDPDBG(\"max_rsp_size : %d\", max_rsp_size);\n\n\t/*\n\t * Check that max_rsp_size is within valid range\n\t * a minimum size of 0x0007 has to be used for data field\n\t */\n\tif (max_rsp_size < 0x0007) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax_rsp_size = MIN(max_rsp_size, req->mtu - sizeof(sdp_pdu_hdr_t) -\n\t\t\tsizeof(uint32_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate) {\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\n\t\tSDPDBG(\"Obtained cached rsp : %p\", pCache);\n\n\t\tif (pCache) {\n\t\t\tshort sent = MIN(max_rsp_size, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\n\t\t\tSDPDBG(\"Response size : %d sending now : %d bytes sent so far : %d\",\n\t\t\t\tpCache->data_size, sent, cstate->cStateValue.maxBytesSent);\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\terror(\"NULL cache buffer and non-NULL continuation state\");\n\t\t}\n\t} else {\n\t\tsdp_record_t *rec = sdp_record_find(handle);\n\t\tstatus = extract_attrs(rec, seq, buf);\n\t\tif (buf->data_size > max_rsp_size) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tSDPDBG(\"Creating continuation state of size : %d\", buf->data_size);\n\t\t\tbuf->data_size = max_rsp_size;\n\t\t\tnewState.cStateValue.maxBytesSent = max_rsp_size;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else {\n\t\t\tif (buf->data_size == 0)\n\t\t\t\tsdp_append_to_buf(buf, NULL, 0);\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\ndone:\n\tfree(cstate);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\tif (status)\n\t\treturn status;\n\n\t/* set attribute list byte count */\n\tput_be16(buf->data_size - cstate_size, buf->data);\n\tbuf->data_size += sizeof(uint16_t);\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SDP_TYPE_ATTRID\t0xff",
      "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_be16",
          "args": [
            "buf->data_size - cstate_size",
            "buf->data"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "put_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "164-167",
          "snippet": "static inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_list_free",
          "args": [
            "seq",
            "free"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cstate"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_set_cstate_pdu",
          "args": [
            "buf",
            "NULL"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_set_cstate_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "262-281",
          "snippet": "static int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_append_to_buf",
          "args": [
            "buf",
            "NULL",
            "0"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Creating continuation state of size : %d\"",
            "buf->data_size"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_cstate_alloc_buf",
          "args": [
            "buf"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_alloc_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "79-93",
          "snippet": "static uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&newState",
            "0",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attrs",
          "args": [
            "rec",
            "seq",
            "buf"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "extract_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "562-625",
          "snippet": "static int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_record_find",
          "args": [
            "handle"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_record_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "227-237",
          "snippet": "sdp_record_t *sdp_record_find(uint32_t handle)\n{\n\tsdp_list_t *p = record_locate(handle);\n\n\tif (!p) {\n\t\tSDPDBG(\"Couldn't find record for : 0x%x\", handle);\n\t\treturn 0;\n\t}\n\n\treturn p->data;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nsdp_record_t *sdp_record_find(uint32_t handle)\n{\n\tsdp_list_t *p = record_locate(handle);\n\n\tif (!p) {\n\t\tSDPDBG(\"Couldn't find record for : 0x%x\", handle);\n\t\treturn 0;\n\t}\n\n\treturn p->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"NULL cache buffer and non-NULL continuation state\""
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Response size : %d sending now : %d bytes sent so far : %d\"",
            "pCache->data_size",
            "sent",
            "cstate->cStateValue.maxBytesSent"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf->data",
            "pResponse + cstate->cStateValue.maxBytesSent",
            "sent"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "max_rsp_size",
            "pCache->data_size - cstate->cStateValue.maxBytesSent"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Obtained cached rsp : %p\"",
            "pCache"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_get_cached_rsp",
          "args": [
            "cstate"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_cached_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "69-77",
          "snippet": "static sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "max_rsp_size",
            "req->mtu - sizeof(sdp_pdu_hdr_t) -\n\t\t\tsizeof(uint32_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"max_rsp_size : %d\"",
            "max_rsp_size"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"SvcRecHandle : 0x%x\"",
            "handle"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_cstate_get",
          "args": [
            "pdata",
            "data_left",
            "&cstate"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "283-316",
          "snippet": "static int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "((sdp_pdu_hdr_t *)(req->buf))->plen"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_des",
          "args": [
            "pdata",
            "data_left",
            "&seq",
            "&dtd",
            "SDP_TYPE_ATTRID"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "extract_des",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "113-260",
          "snippet": "static int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_ATTRID\t0xff",
            "#define SDP_TYPE_UUID\t0xfe"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n\nstatic int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_be16",
          "args": [
            "pdata"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "get_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "134-137",
          "snippet": "static inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_be32",
          "args": [
            "pdata"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "get_be32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "144-147",
          "snippet": "static inline uint32_t get_be32(const void *ptr)\n{\n\treturn be32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint32_t get_be32(const void *ptr)\n{\n\treturn be32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_attr_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pResponse = NULL;\n\tshort cstate_size = 0;\n\tsdp_list_t *seq = NULL;\n\tuint8_t dtd = 0;\n\tint scanned = 0;\n\tunsigned int max_rsp_size;\n\tint status = 0, plen, mlen;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\tuint32_t handle;\n\n\tif (data_left < sizeof(uint32_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\thandle = get_be32(pdata);\n\n\tpdata += sizeof(uint32_t);\n\tdata_left -= sizeof(uint32_t);\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmax_rsp_size = get_be16(pdata);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\tif (data_left < sizeof(sdp_pdu_hdr_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/* extract the attribute list */\n\tscanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint32_t) + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)pdata) {\n\t\tstatus = SDP_INVALID_PDU_SIZE;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * if continuation state exists, attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tSDPDBG(\"SvcRecHandle : 0x%x\", handle);\n\tSDPDBG(\"max_rsp_size : %d\", max_rsp_size);\n\n\t/*\n\t * Check that max_rsp_size is within valid range\n\t * a minimum size of 0x0007 has to be used for data field\n\t */\n\tif (max_rsp_size < 0x0007) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Calculate Attribute size according to MTU\n\t * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))\n\t */\n\tmax_rsp_size = MIN(max_rsp_size, req->mtu - sizeof(sdp_pdu_hdr_t) -\n\t\t\tsizeof(uint32_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));\n\n\t/* pull header for AttributeList byte count */\n\tbuf->data += sizeof(uint16_t);\n\tbuf->buf_size -= sizeof(uint16_t);\n\n\tif (cstate) {\n\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\n\t\tSDPDBG(\"Obtained cached rsp : %p\", pCache);\n\n\t\tif (pCache) {\n\t\t\tshort sent = MIN(max_rsp_size, pCache->data_size - cstate->cStateValue.maxBytesSent);\n\t\t\tpResponse = pCache->data;\n\t\t\tmemcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);\n\t\t\tbuf->data_size += sent;\n\t\t\tcstate->cStateValue.maxBytesSent += sent;\n\n\t\t\tSDPDBG(\"Response size : %d sending now : %d bytes sent so far : %d\",\n\t\t\t\tpCache->data_size, sent, cstate->cStateValue.maxBytesSent);\n\t\t\tif (cstate->cStateValue.maxBytesSent == pCache->data_size)\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t\telse\n\t\t\t\tcstate_size = sdp_set_cstate_pdu(buf, cstate);\n\t\t} else {\n\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\terror(\"NULL cache buffer and non-NULL continuation state\");\n\t\t}\n\t} else {\n\t\tsdp_record_t *rec = sdp_record_find(handle);\n\t\tstatus = extract_attrs(rec, seq, buf);\n\t\tif (buf->data_size > max_rsp_size) {\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tmemset((char *)&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\tnewState.timestamp = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * Reset the buffer size to the maximum expected and\n\t\t\t * set the sdp_cont_state_t\n\t\t\t */\n\t\t\tSDPDBG(\"Creating continuation state of size : %d\", buf->data_size);\n\t\t\tbuf->data_size = max_rsp_size;\n\t\t\tnewState.cStateValue.maxBytesSent = max_rsp_size;\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, &newState);\n\t\t} else {\n\t\t\tif (buf->data_size == 0)\n\t\t\t\tsdp_append_to_buf(buf, NULL, 0);\n\t\t\tcstate_size = sdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* push header */\n\tbuf->data -= sizeof(uint16_t);\n\tbuf->buf_size += sizeof(uint16_t);\n\ndone:\n\tfree(cstate);\n\tif (seq)\n\t\tsdp_list_free(seq, free);\n\tif (status)\n\t\treturn status;\n\n\t/* set attribute list byte count */\n\tput_be16(buf->data_size - cstate_size, buf->data);\n\tbuf->data_size += sizeof(uint16_t);\n\treturn 0;\n}"
  },
  {
    "function_name": "extract_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "562-625",
    "snippet": "static int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pdu.data"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Expect uint16_t or uint32_t\""
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unexpected data type : 0x%x\"",
            "aid->dtd"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "124-128",
          "snippet": "DBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_append_to_pdu",
          "args": [
            "buf",
            "data"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_data_get",
          "args": [
            "rec",
            "high"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_append_to_pdu",
          "args": [
            "buf",
            "data"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_data_get",
          "args": [
            "rec",
            "attr"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf->data",
            "pdu.data",
            "pdu.data_size"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"High id : 0x%x\"",
            "high"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Low id : 0x%x\"",
            "low"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"attr range : 0x%x\"",
            "range"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_append_to_pdu",
          "args": [
            "buf",
            "a"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_data_get",
          "args": [
            "rec",
            "attr"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"AttrDataType : %d\"",
            "aid->dtd"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_gen_record_pdu",
          "args": [
            "rec",
            "&pdu"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Entries in attr seq : %d\"",
            "sdp_list_len(seq)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_len",
          "args": [
            "seq"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Attribute sequence is NULL\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int extract_attrs(sdp_record_t *rec, sdp_list_t *seq, sdp_buf_t *buf)\n{\n\tsdp_buf_t pdu;\n\n\tif (!rec)\n\t\treturn SDP_INVALID_RECORD_HANDLE;\n\n\tif (seq == NULL) {\n\t\tSDPDBG(\"Attribute sequence is NULL\");\n\t\treturn 0;\n\t}\n\n\tSDPDBG(\"Entries in attr seq : %d\", sdp_list_len(seq));\n\n\tsdp_gen_record_pdu(rec, &pdu);\n\n\tfor (; seq; seq = seq->next) {\n\t\tstruct attrid *aid = seq->data;\n\n\t\tSDPDBG(\"AttrDataType : %d\", aid->dtd);\n\n\t\tif (aid->dtd == SDP_UINT16) {\n\t\t\tuint16_t attr = aid->uint16;\n\t\t\tsdp_data_t *a = sdp_data_get(rec, attr);\n\t\t\tif (a)\n\t\t\t\tsdp_append_to_pdu(buf, a);\n\t\t} else if (aid->dtd == SDP_UINT32) {\n\t\t\tuint32_t range = aid->uint32;\n\t\t\tuint16_t attr;\n\t\t\tuint16_t low = (0xffff0000 & range) >> 16;\n\t\t\tuint16_t high = 0x0000ffff & range;\n\t\t\tsdp_data_t *data;\n\n\t\t\tSDPDBG(\"attr range : 0x%x\", range);\n\t\t\tSDPDBG(\"Low id : 0x%x\", low);\n\t\t\tSDPDBG(\"High id : 0x%x\", high);\n\n\t\t\tif (low == 0x0000 && high == 0xffff && pdu.data_size <= buf->buf_size) {\n\t\t\t\t/* copy it */\n\t\t\t\tmemcpy(buf->data, pdu.data, pdu.data_size);\n\t\t\t\tbuf->data_size = pdu.data_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* (else) sub-range of attributes */\n\t\t\tfor (attr = low; attr < high; attr++) {\n\t\t\t\tdata = sdp_data_get(rec, attr);\n\t\t\t\tif (data)\n\t\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t\t}\n\t\t\tdata = sdp_data_get(rec, high);\n\t\t\tif (data)\n\t\t\t\tsdp_append_to_pdu(buf, data);\n\t\t} else {\n\t\t\terror(\"Unexpected data type : 0x%x\", aid->dtd);\n\t\t\terror(\"Expect uint16_t or uint32_t\");\n\t\t\tfree(pdu.data);\n\t\t\treturn SDP_INVALID_SYNTAX;\n\t\t}\n\t}\n\n\tfree(pdu.data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "service_search_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "362-553",
    "snippet": "static int service_search_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, i, plen, mlen, mtu, scanned;\n\tsdp_list_t *pattern = NULL;\n\tuint16_t expected, actual, rsp_count = 0;\n\tuint8_t dtd;\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pCacheBuffer = NULL;\n\tint handleSize = 0;\n\tuint32_t cStateId = 0;\n\tuint8_t *pTotalRecordCount, *pCurrentRecordCount;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)(pdata+sizeof(uint16_t))) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\texpected = get_be16(pdata);\n\n\tSDPDBG(\"Expected count: %d\", expected);\n\tSDPDBG(\"Bytes scanned : %d\", scanned);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmtu = req->mtu - sizeof(sdp_pdu_hdr_t) - sizeof(uint16_t) - sizeof(uint16_t) - SDP_CONT_STATE_SIZE;\n\tactual = MIN(expected, mtu >> 2);\n\n\t/* make space in the rsp buffer for total and current record counts */\n\tpdata = buf->data;\n\n\t/* total service record count = 0 */\n\tpTotalRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\t/* current service record count = 0 */\n\tpCurrentRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* for every record in the DB, do a pattern search */\n\t\tsdp_list_t *list = sdp_get_record_list();\n\n\t\thandleSize = 0;\n\t\tfor (; list && rsp_count < expected; list = list->next) {\n\t\t\tsdp_record_t *rec = list->data;\n\n\t\t\tSDPDBG(\"Checking svcRec : 0x%x\", rec->handle);\n\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tput_be32(rec->handle, pdata);\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t}\n\n\t\tSDPDBG(\"Match count: %d\", rsp_count);\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(rsp_count, pCurrentRecordCount);\n\n\t\tif (rsp_count > actual) {\n\t\t\t/* cache the rsp and generate a continuation state */\n\t\t\tcStateId = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * subtract handleSize since we now send only\n\t\t\t * a subset of handles\n\t\t\t */\n\t\t\tbuf->data_size -= handleSize;\n\t\t} else {\n\t\t\t/* NULL continuation state */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* under both the conditions below, the rsp buffer is not built yet */\n\tif (cstate || cStateId > 0) {\n\t\tshort lastIndex = 0;\n\n\t\tif (cstate) {\n\t\t\t/*\n\t\t\t * Get the previous sdp_cont_state_t and obtain\n\t\t\t * the cached rsp\n\t\t\t */\n\t\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\t\tif (pCache) {\n\t\t\t\tpCacheBuffer = pCache->data;\n\t\t\t\t/* get the rsp_count from the cached buffer */\n\t\t\t\trsp_count = get_be16(pCacheBuffer);\n\n\t\t\t\t/* get index of the last sdp_record_t sent */\n\t\t\t\tlastIndex = cstate->cStateValue.lastIndexSent;\n\t\t\t} else {\n\t\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tpCacheBuffer = buf->data;\n\t\t\tlastIndex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set the local buffer pointer to after the\n\t\t * current record count and increment the cached\n\t\t * buffer pointer to beyond the counters\n\t\t */\n\t\tpdata = pCurrentRecordCount + sizeof(uint16_t);\n\n\t\t/* increment beyond the totalCount and the currentCount */\n\t\tpCacheBuffer += 2 * sizeof(uint16_t);\n\n\t\tif (cstate) {\n\t\t\thandleSize = 0;\n\t\t\tfor (i = lastIndex; (i - lastIndex) < actual && i < rsp_count; i++) {\n\t\t\t\tmemcpy(pdata, pCacheBuffer + i * sizeof(uint32_t), sizeof(uint32_t));\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t} else {\n\t\t\thandleSize = actual << 2;\n\t\t\ti = actual;\n\t\t}\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(i - lastIndex, pCurrentRecordCount);\n\n\t\tif (i == rsp_count) {\n\t\t\t/* set \"null\" continuationState */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's more: set lastIndexSent to\n\t\t\t * the new value and move on\n\t\t\t */\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tSDPDBG(\"Setting non-NULL sdp_cstate_t\");\n\n\t\t\tif (cstate)\n\t\t\t\tmemcpy(&newState, cstate, sizeof(sdp_cont_state_t));\n\t\t\telse {\n\t\t\t\tmemset(&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\t\tnewState.timestamp = cStateId;\n\t\t\t}\n\t\t\tnewState.cStateValue.lastIndexSent = i;\n\t\t\tsdp_set_cstate_pdu(buf, &newState);\n\t\t}\n\t}\n\ndone:\n\tfree(cstate);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\n\treturn status;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SDP_TYPE_UUID\t0xfe",
      "#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sdp_list_free",
          "args": [
            "pattern",
            "free"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cstate"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_set_cstate_pdu",
          "args": [
            "buf",
            "&newState"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_set_cstate_pdu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "262-281",
          "snippet": "static int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&newState",
            "0",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newState",
            "cstate",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Setting non-NULL sdp_cstate_t\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_be16",
          "args": [
            "i - lastIndex",
            "pCurrentRecordCount"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "put_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "164-167",
          "snippet": "static inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pdata",
            "pCacheBuffer + i * sizeof(uint32_t)",
            "sizeof(uint32_t)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_be16",
          "args": [
            "pCacheBuffer"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "get_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "134-137",
          "snippet": "static inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_get_cached_rsp",
          "args": [
            "cstate"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_cached_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "69-77",
          "snippet": "static sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_cstate_alloc_buf",
          "args": [
            "buf"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_alloc_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "79-93",
          "snippet": "static uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_cstate_list_t *cstates;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Match count: %d\"",
            "rsp_count"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_be32",
          "args": [
            "rec->handle",
            "pdata"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "put_be32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "174-177",
          "snippet": "static inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_check_access",
          "args": [
            "rec->handle",
            "&req->device"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_check_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "277-295",
          "snippet": "int sdp_check_access(uint32_t handle, bdaddr_t *device)\n{\n\tsdp_list_t *p = access_locate(handle);\n\tsdp_access_t *a;\n\n\tif (!p)\n\t\treturn 1;\n\n\ta = p->data;\n\tif (!a)\n\t\treturn 1;\n\n\tif (bacmp(&a->device, device) &&\n\t\t\tbacmp(&a->device, BDADDR_ANY) &&\n\t\t\tbacmp(device, BDADDR_ANY))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nint sdp_check_access(uint32_t handle, bdaddr_t *device)\n{\n\tsdp_list_t *p = access_locate(handle);\n\tsdp_access_t *a;\n\n\tif (!p)\n\t\treturn 1;\n\n\ta = p->data;\n\tif (!a)\n\t\treturn 1;\n\n\tif (bacmp(&a->device, device) &&\n\t\t\tbacmp(&a->device, BDADDR_ANY) &&\n\t\t\tbacmp(device, BDADDR_ANY))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_match_uuid",
          "args": [
            "pattern",
            "rec->pattern"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_match_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "329-355",
          "snippet": "static int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Checking svcRec : 0x%x\"",
            "rec->handle"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_get_record_list",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_record_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "272-275",
          "snippet": "sdp_list_t *sdp_get_record_list(void)\n{\n\treturn service_db;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_list_t *service_db;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic sdp_list_t *service_db;\n\nsdp_list_t *sdp_get_record_list(void)\n{\n\treturn service_db;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "expected",
            "mtu >> 2"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_cstate_get",
          "args": [
            "pdata",
            "data_left",
            "&cstate"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_cstate_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "283-316",
          "snippet": "static int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Bytes scanned : %d\"",
            "scanned"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Expected count: %d\"",
            "expected"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "((sdp_pdu_hdr_t *)(req->buf))->plen"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_des",
          "args": [
            "pdata",
            "data_left",
            "&pattern",
            "&dtd",
            "SDP_TYPE_UUID"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "extract_des",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "113-260",
          "snippet": "static int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SDP_TYPE_ATTRID\t0xff",
            "#define SDP_TYPE_UUID\t0xfe"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n\nstatic int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_UUID\t0xfe\n#define SDP_CONT_STATE_SIZE (sizeof(uint8_t) + sizeof(sdp_cont_state_t))\n\nstatic int service_search_req(sdp_req_t *req, sdp_buf_t *buf)\n{\n\tint status = 0, i, plen, mlen, mtu, scanned;\n\tsdp_list_t *pattern = NULL;\n\tuint16_t expected, actual, rsp_count = 0;\n\tuint8_t dtd;\n\tsdp_cont_state_t *cstate = NULL;\n\tuint8_t *pCacheBuffer = NULL;\n\tint handleSize = 0;\n\tuint32_t cStateId = 0;\n\tuint8_t *pTotalRecordCount, *pCurrentRecordCount;\n\tuint8_t *pdata = req->buf + sizeof(sdp_pdu_hdr_t);\n\tsize_t data_left = req->len - sizeof(sdp_pdu_hdr_t);\n\n\tscanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);\n\n\tif (scanned == -1) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\tpdata += scanned;\n\tdata_left -= scanned;\n\n\tplen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);\n\tmlen = scanned + sizeof(uint16_t) + 1;\n\t/* ensure we don't read past buffer */\n\tif (plen < mlen || plen != mlen + *(uint8_t *)(pdata+sizeof(uint16_t))) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tif (data_left < sizeof(uint16_t)) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\texpected = get_be16(pdata);\n\n\tSDPDBG(\"Expected count: %d\", expected);\n\tSDPDBG(\"Bytes scanned : %d\", scanned);\n\n\tpdata += sizeof(uint16_t);\n\tdata_left -= sizeof(uint16_t);\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get rsp remainder from cache, else send error\n\t */\n\tif (sdp_cstate_get(pdata, data_left, &cstate) < 0) {\n\t\tstatus = SDP_INVALID_SYNTAX;\n\t\tgoto done;\n\t}\n\n\tmtu = req->mtu - sizeof(sdp_pdu_hdr_t) - sizeof(uint16_t) - sizeof(uint16_t) - SDP_CONT_STATE_SIZE;\n\tactual = MIN(expected, mtu >> 2);\n\n\t/* make space in the rsp buffer for total and current record counts */\n\tpdata = buf->data;\n\n\t/* total service record count = 0 */\n\tpTotalRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\t/* current service record count = 0 */\n\tpCurrentRecordCount = pdata;\n\tput_be16(0, pdata);\n\tpdata += sizeof(uint16_t);\n\tbuf->data_size += sizeof(uint16_t);\n\n\tif (cstate == NULL) {\n\t\t/* for every record in the DB, do a pattern search */\n\t\tsdp_list_t *list = sdp_get_record_list();\n\n\t\thandleSize = 0;\n\t\tfor (; list && rsp_count < expected; list = list->next) {\n\t\t\tsdp_record_t *rec = list->data;\n\n\t\t\tSDPDBG(\"Checking svcRec : 0x%x\", rec->handle);\n\n\t\t\tif (sdp_match_uuid(pattern, rec->pattern) > 0 &&\n\t\t\t\t\tsdp_check_access(rec->handle, &req->device)) {\n\t\t\t\trsp_count++;\n\t\t\t\tput_be32(rec->handle, pdata);\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t}\n\n\t\tSDPDBG(\"Match count: %d\", rsp_count);\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(rsp_count, pCurrentRecordCount);\n\n\t\tif (rsp_count > actual) {\n\t\t\t/* cache the rsp and generate a continuation state */\n\t\t\tcStateId = sdp_cstate_alloc_buf(buf);\n\t\t\t/*\n\t\t\t * subtract handleSize since we now send only\n\t\t\t * a subset of handles\n\t\t\t */\n\t\t\tbuf->data_size -= handleSize;\n\t\t} else {\n\t\t\t/* NULL continuation state */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t}\n\t}\n\n\t/* under both the conditions below, the rsp buffer is not built yet */\n\tif (cstate || cStateId > 0) {\n\t\tshort lastIndex = 0;\n\n\t\tif (cstate) {\n\t\t\t/*\n\t\t\t * Get the previous sdp_cont_state_t and obtain\n\t\t\t * the cached rsp\n\t\t\t */\n\t\t\tsdp_buf_t *pCache = sdp_get_cached_rsp(cstate);\n\t\t\tif (pCache) {\n\t\t\t\tpCacheBuffer = pCache->data;\n\t\t\t\t/* get the rsp_count from the cached buffer */\n\t\t\t\trsp_count = get_be16(pCacheBuffer);\n\n\t\t\t\t/* get index of the last sdp_record_t sent */\n\t\t\t\tlastIndex = cstate->cStateValue.lastIndexSent;\n\t\t\t} else {\n\t\t\t\tstatus = SDP_INVALID_CSTATE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tpCacheBuffer = buf->data;\n\t\t\tlastIndex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set the local buffer pointer to after the\n\t\t * current record count and increment the cached\n\t\t * buffer pointer to beyond the counters\n\t\t */\n\t\tpdata = pCurrentRecordCount + sizeof(uint16_t);\n\n\t\t/* increment beyond the totalCount and the currentCount */\n\t\tpCacheBuffer += 2 * sizeof(uint16_t);\n\n\t\tif (cstate) {\n\t\t\thandleSize = 0;\n\t\t\tfor (i = lastIndex; (i - lastIndex) < actual && i < rsp_count; i++) {\n\t\t\t\tmemcpy(pdata, pCacheBuffer + i * sizeof(uint32_t), sizeof(uint32_t));\n\t\t\t\tpdata += sizeof(uint32_t);\n\t\t\t\thandleSize += sizeof(uint32_t);\n\t\t\t}\n\t\t} else {\n\t\t\thandleSize = actual << 2;\n\t\t\ti = actual;\n\t\t}\n\n\t\tbuf->data_size += handleSize;\n\t\tput_be16(rsp_count, pTotalRecordCount);\n\t\tput_be16(i - lastIndex, pCurrentRecordCount);\n\n\t\tif (i == rsp_count) {\n\t\t\t/* set \"null\" continuationState */\n\t\t\tsdp_set_cstate_pdu(buf, NULL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's more: set lastIndexSent to\n\t\t\t * the new value and move on\n\t\t\t */\n\t\t\tsdp_cont_state_t newState;\n\n\t\t\tSDPDBG(\"Setting non-NULL sdp_cstate_t\");\n\n\t\t\tif (cstate)\n\t\t\t\tmemcpy(&newState, cstate, sizeof(sdp_cont_state_t));\n\t\t\telse {\n\t\t\t\tmemset(&newState, 0, sizeof(sdp_cont_state_t));\n\t\t\t\tnewState.timestamp = cStateId;\n\t\t\t}\n\t\t\tnewState.cStateValue.lastIndexSent = i;\n\t\t\tsdp_set_cstate_pdu(buf, &newState);\n\t\t}\n\t}\n\ndone:\n\tfree(cstate);\n\tif (pattern)\n\t\tsdp_list_free(pattern, free);\n\n\treturn status;\n}"
  },
  {
    "function_name": "sdp_match_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "329-355",
    "snippet": "static int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_free",
          "args": [
            "uuid128"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_find",
          "args": [
            "pattern",
            "uuid128",
            "sdp_uuid128_cmp"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_uuid_to_uuid128",
          "args": [
            "(uuid_t *)data"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_len",
          "args": [
            "search"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_len",
          "args": [
            "pattern"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_match_uuid(sdp_list_t *search, sdp_list_t *pattern)\n{\n\t/*\n\t * The target is a sorted list, so we need not look\n\t * at all elements to confirm existence of an element\n\t * from the search pattern\n\t */\n\tint patlen = sdp_list_len(pattern);\n\n\tif (patlen < sdp_list_len(search))\n\t\treturn -1;\n\tfor (; search; search = search->next) {\n\t\tuuid_t *uuid128;\n\t\tvoid *data = search->data;\n\t\tsdp_list_t *list;\n\t\tif (data == NULL)\n\t\t\treturn -1;\n\n\t\t/* create 128-bit form of the search UUID */\n\t\tuuid128 = sdp_uuid_to_uuid128((uuid_t *)data);\n\t\tlist = sdp_list_find(pattern, uuid128, sdp_uuid128_cmp);\n\t\tbt_free(uuid128);\n\t\tif (!list)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "sdp_cstate_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "283-316",
    "snippet": "static int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Bytes sent : %d\"",
            "(*cstate)->cStateValue.maxBytesSent"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Cstate TS : 0x%x\"",
            "(*cstate)->timestamp"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*cstate",
            "buffer",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Continuation State size : %d\"",
            "cStateSize"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_cstate_get(uint8_t *buffer, size_t len,\n\t\t\t\t\t\tsdp_cont_state_t **cstate)\n{\n\tuint8_t cStateSize = *buffer;\n\n\tSDPDBG(\"Continuation State size : %d\", cStateSize);\n\n\tif (cStateSize == 0) {\n\t\t*cstate = NULL;\n\t\treturn 0;\n\t}\n\n\tbuffer++;\n\tlen--;\n\n\tif (len < sizeof(sdp_cont_state_t))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check if continuation state exists, if yes attempt\n\t * to get response remainder from cache, else send error\n\t */\n\n\t*cstate = malloc(sizeof(sdp_cont_state_t));\n\tif (!(*cstate))\n\t\treturn -ENOMEM;\n\n\tmemcpy(*cstate, buffer, sizeof(sdp_cont_state_t));\n\n\tSDPDBG(\"Cstate TS : 0x%x\", (*cstate)->timestamp);\n\tSDPDBG(\"Bytes sent : %d\", (*cstate)->cStateValue.maxBytesSent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sdp_set_cstate_pdu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "262-281",
    "snippet": "static int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pdata",
            "cstate",
            "sizeof(sdp_cont_state_t)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Non null sdp_cstate_t id : 0x%x\"",
            "cstate->timestamp"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int sdp_set_cstate_pdu(sdp_buf_t *buf, sdp_cont_state_t *cstate)\n{\n\tuint8_t *pdata = buf->data + buf->data_size;\n\tint length = 0;\n\n\tif (cstate) {\n\t\tSDPDBG(\"Non null sdp_cstate_t id : 0x%x\", cstate->timestamp);\n\t\t*pdata = sizeof(sdp_cont_state_t);\n\t\tpdata += sizeof(uint8_t);\n\t\tlength += sizeof(uint8_t);\n\t\tmemcpy(pdata, cstate, sizeof(sdp_cont_state_t));\n\t\tlength += sizeof(sdp_cont_state_t);\n\t} else {\n\t\t/* set \"null\" continuation state */\n\t\t*pdata = 0;\n\t\tlength += sizeof(uint8_t);\n\t}\n\tbuf->data_size += length;\n\treturn length;\n}"
  },
  {
    "function_name": "extract_des",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "113-260",
    "snippet": "static int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SDP_TYPE_ATTRID\t0xff",
      "#define SDP_TYPE_UUID\t0xfe"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sdp_list_free",
          "args": [
            "pSeq",
            "free"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pElem"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"No of elements : %d\"",
            "numberOfElements"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_list_append",
          "args": [
            "pSeq",
            "pElem"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_uuid_extract",
          "args": [
            "p",
            "bufsize",
            "puuid",
            "&localSeqLength"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(uuid_t)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_be32",
          "args": [
            "tmp",
            "pElem"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "put_be32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "174-177",
          "snippet": "static inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp",
            "p",
            "sizeof(tmp)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_be32",
          "args": [
            "p"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "get_be32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "144-147",
          "snippet": "static inline uint32_t get_be32(const void *ptr)\n{\n\treturn be32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint32_t get_be32(const void *ptr)\n{\n\treturn be32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected end of buffer\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_be16",
          "args": [
            "tmp",
            "pElem"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "put_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "164-167",
          "snippet": "static inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be16(uint16_t val, const void *ptr)\n{\n\tput_unaligned(cpu_to_be16(val), (uint16_t *) ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp",
            "p",
            "sizeof(tmp)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_be16",
          "args": [
            "p"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "get_be16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "134-137",
          "snippet": "static inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint16_t get_be16(const void *ptr)\n{\n\treturn be16_to_cpu(get_unaligned((const uint16_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected end of buffer\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected Data type (expected 0x%02x)\"",
            "expectedType"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected Data type (expected 0x%02x or 0x%02x)\"",
            "SDP_UINT16",
            "SDP_UINT32"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected Data type (expected UUID_ANY)\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Data type: 0x%02x\"",
            "dataType"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"->Unexpected end of buffer\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Data size : %d\"",
            "data_size"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unknown seq type\""
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SDPDBG",
          "args": [
            "\"Seq type : %d\"",
            "seqType"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_extract_seqtype",
          "args": [
            "buf",
            "len",
            "&seqType",
            "&data_size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\n#define SDP_TYPE_ATTRID\t0xff\n#define SDP_TYPE_UUID\t0xfe\n\nstatic int extract_des(uint8_t *buf, int len, sdp_list_t **svcReqSeq, uint8_t *pDataType, uint8_t expectedType)\n{\n\tuint8_t seqType;\n\tint scanned, data_size = 0;\n\tshort numberOfElements = 0;\n\tint seqlen = 0;\n\tsdp_list_t *pSeq = NULL;\n\tuint8_t dataType;\n\tint status = 0;\n\tconst uint8_t *p;\n\tsize_t bufsize;\n\n\tscanned = sdp_extract_seqtype(buf, len, &seqType, &data_size);\n\n\tSDPDBG(\"Seq type : %d\", seqType);\n\tif (!scanned || (seqType != SDP_SEQ8 && seqType != SDP_SEQ16)) {\n\t\terror(\"Unknown seq type\");\n\t\treturn -1;\n\t}\n\tp = buf + scanned;\n\tbufsize = len - scanned;\n\n\tSDPDBG(\"Data size : %d\", data_size);\n\n\tfor (;;) {\n\t\tchar *pElem = NULL;\n\t\tint localSeqLength = 0;\n\t\tuuid_t *puuid;\n\n\t\tif (bufsize < sizeof(uint8_t)) {\n\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdataType = *p;\n\n\t\tSDPDBG(\"Data type: 0x%02x\", dataType);\n\n\t\tif (expectedType == SDP_TYPE_UUID) {\n\t\t\tif (dataType != SDP_UUID16 && dataType != SDP_UUID32 && dataType != SDP_UUID128) {\n\t\t\t\tSDPDBG(\"->Unexpected Data type (expected UUID_ANY)\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (expectedType == SDP_TYPE_ATTRID &&\n\t\t\t\t(dataType != SDP_UINT16 && dataType != SDP_UINT32)) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x or 0x%02x)\",\n\t\t\t\t\t\t\t\tSDP_UINT16, SDP_UINT32);\n\t\t\tgoto failed;\n\t\t} else if (expectedType != SDP_TYPE_ATTRID && dataType != expectedType) {\n\t\t\tSDPDBG(\"->Unexpected Data type (expected 0x%02x)\", expectedType);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tswitch (dataType) {\n\t\tcase SDP_UINT16:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < sizeof(uint16_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint16 = get_be16(p);\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint16_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint16_t));\n\t\t\t\tput_be16(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint16_t);\n\t\t\tseqlen += sizeof(uint16_t);\n\t\t\tbufsize -= sizeof(uint16_t);\n\t\t\tbreak;\n\t\tcase SDP_UINT32:\n\t\t\tp += sizeof(uint8_t);\n\t\t\tseqlen += sizeof(uint8_t);\n\t\t\tbufsize -= sizeof(uint8_t);\n\t\t\tif (bufsize < (int)sizeof(uint32_t)) {\n\t\t\t\tSDPDBG(\"->Unexpected end of buffer\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (expectedType == SDP_TYPE_ATTRID) {\n\t\t\t\tstruct attrid *aid;\n\t\t\t\taid = malloc(sizeof(struct attrid));\n\t\t\t\taid->dtd = dataType;\n\t\t\t\taid->uint32 = get_be32(p);\n\n\t\t\t\tpElem = (char *) aid;\n\t\t\t} else {\n\t\t\t\tuint32_t tmp;\n\n\t\t\t\tmemcpy(&tmp, p, sizeof(tmp));\n\n\t\t\t\tpElem = malloc(sizeof(uint32_t));\n\t\t\t\tput_be32(tmp, pElem);\n\t\t\t}\n\t\t\tp += sizeof(uint32_t);\n\t\t\tseqlen += sizeof(uint32_t);\n\t\t\tbufsize -= sizeof(uint32_t);\n\t\t\tbreak;\n\t\tcase SDP_UUID16:\n\t\tcase SDP_UUID32:\n\t\tcase SDP_UUID128:\n\t\t\tpuuid = malloc(sizeof(uuid_t));\n\t\t\tstatus = sdp_uuid_extract(p, bufsize, puuid, &localSeqLength);\n\t\t\tif (status < 0) {\n\t\t\t\tfree(puuid);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tpElem = (char *) puuid;\n\t\t\tseqlen += localSeqLength;\n\t\t\tp += localSeqLength;\n\t\t\tbufsize -= localSeqLength;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == 0) {\n\t\t\tpSeq = sdp_list_append(pSeq, pElem);\n\t\t\tnumberOfElements++;\n\t\t\tSDPDBG(\"No of elements : %d\", numberOfElements);\n\n\t\t\tif (seqlen == data_size)\n\t\t\t\tbreak;\n\t\t\telse if (seqlen > data_size || seqlen > len)\n\t\t\t\tgoto failed;\n\t\t} else\n\t\t\tfree(pElem);\n\t}\n\t*svcReqSeq = pSeq;\n\tscanned += seqlen;\n\t*pDataType = dataType;\n\treturn scanned;\n\nfailed:\n\tsdp_list_free(pSeq, free);\n\treturn -1;\n}"
  },
  {
    "function_name": "sdp_cstate_alloc_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "79-93",
    "snippet": "static uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sdp_cstate_list_t *cstates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sdp_get_time",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_get_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "290-300",
          "snippet": "uint32_t sdp_get_time(void)\n{\n\t/*\n\t * To handle failure in gettimeofday, so an old\n\t * value is returned and service does not fail\n\t */\n\tstatic struct timeval tm;\n\n\tgettimeofday(&tm, NULL);\n\treturn (uint32_t) tm.tv_sec;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nuint32_t sdp_get_time(void)\n{\n\t/*\n\t * To handle failure in gettimeofday, so an old\n\t * value is returned and service does not fail\n\t */\n\tstatic struct timeval tm;\n\n\tgettimeofday(&tm, NULL);\n\treturn (uint32_t) tm.tv_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)cstate",
            "0",
            "sizeof(sdp_cstate_list_t)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "buf->data",
            "buf->data_size"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "buf->data_size"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic uint32_t sdp_cstate_alloc_buf(sdp_buf_t *buf)\n{\n\tsdp_cstate_list_t *cstate = malloc(sizeof(sdp_cstate_list_t));\n\tuint8_t *data = malloc(buf->data_size);\n\n\tmemcpy(data, buf->data, buf->data_size);\n\tmemset((char *)cstate, 0, sizeof(sdp_cstate_list_t));\n\tcstate->buf.data = data;\n\tcstate->buf.data_size = buf->data_size;\n\tcstate->buf.buf_size = buf->data_size;\n\tcstate->timestamp = sdp_get_time();\n\tcstate->next = cstates;\n\tcstates = cstate;\n\treturn cstate->timestamp;\n}"
  },
  {
    "function_name": "sdp_get_cached_rsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
    "lines": "69-77",
    "snippet": "static sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"sdpd.h\"",
      "#include \"src/shared/util.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <stdbool.h>",
      "#include <limits.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static sdp_cstate_list_t *cstates;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_cstate_list_t *cstates;\n\nstatic sdp_buf_t *sdp_get_cached_rsp(sdp_cont_state_t *cstate)\n{\n\tsdp_cstate_list_t *p;\n\n\tfor (p = cstates; p; p = p->next)\n\t\tif (p->timestamp == cstate->timestamp)\n\t\t\treturn &p->buf;\n\treturn 0;\n}"
  }
]