[
  {
    "function_name": "stop_sdp_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
    "lines": "263-277",
    "snippet": "void stop_sdp_server(void)\n{\n\tinfo(\"Stopping SDP server\");\n\n\tsdp_svcdb_reset();\n\n\tif (unix_id > 0)\n\t\tg_source_remove(unix_id);\n\n\tif (l2cap_id > 0)\n\t\tg_source_remove(l2cap_id);\n\n\tl2cap_id = unix_id = 0;\n\tl2cap_sock = unix_sock = -1;\n}",
    "includes": [
      "#include \"sdpd.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <sys/un.h>",
      "#include <sys/stat.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static guint l2cap_id = 0, unix_id = 0;",
      "static int l2cap_sock = -1, unix_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "l2cap_id"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "unix_id"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sdp_svcdb_reset",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_svcdb_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "88-95",
          "snippet": "void sdp_svcdb_reset(void)\n{\n\tsdp_list_free(service_db, (sdp_free_func_t) sdp_record_free);\n\tservice_db = NULL;\n\n\tsdp_list_free(access_db, access_free);\n\taccess_db = NULL;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_list_t *service_db;",
            "static sdp_list_t *access_db;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic sdp_list_t *service_db;\nstatic sdp_list_t *access_db;\n\nvoid sdp_svcdb_reset(void)\n{\n\tsdp_list_free(service_db, (sdp_free_func_t) sdp_record_free);\n\tservice_db = NULL;\n\n\tsdp_list_free(access_db, access_free);\n\taccess_db = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"Stopping SDP server\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "store_device_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/device.c",
          "lines": "475-487",
          "snippet": "static void store_device_info(struct btd_device *device)\n{\n\tif (device->temporary || device->store_id > 0)\n\t\treturn;\n\n\tif (device_address_is_private(device)) {\n\t\tDBG(\"Can't store info for private addressed device %s\",\n\t\t\t\t\t\t\t\tdevice->path);\n\t\treturn;\n\t}\n\n\tdevice->store_id = g_idle_add(store_device_info_cb, device);\n}",
          "includes": [
            "#include \"eir.h\"",
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"agent.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"sdp-client.h\"",
            "#include \"uuid-helper.h\"",
            "#include \"error.h\"",
            "#include \"dbus-common.h\"",
            "#include \"service.h\"",
            "#include \"profile.h\"",
            "#include \"gatt-client.h\"",
            "#include \"device.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"gatt-database.h\"",
            "#include \"adapter.h\"",
            "#include \"hcid.h\"",
            "#include \"attrib/att.h\"",
            "#include \"lib/mgmt.h\"",
            "#include \"btio/btio.h\"",
            "#include \"src/shared/ad.h\"",
            "#include \"src/shared/gatt-server.h\"",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"log.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <dbus/dbus.h>",
            "#include <glib.h>",
            "#include <time.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdbool.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void gatt_client_init(struct btd_device *device);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"eir.h\"\n#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"agent.h\"\n#include \"attrib/gatt.h\"\n#include \"sdp-client.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"service.h\"\n#include \"profile.h\"\n#include \"gatt-client.h\"\n#include \"device.h\"\n#include \"attrib/gattrib.h\"\n#include \"gatt-database.h\"\n#include \"adapter.h\"\n#include \"hcid.h\"\n#include \"attrib/att.h\"\n#include \"lib/mgmt.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/ad.h\"\n#include \"src/shared/gatt-server.h\"\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/util.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <time.h>\n#include <dirent.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void gatt_client_init(struct btd_device *device);\n\nstatic void store_device_info(struct btd_device *device)\n{\n\tif (device->temporary || device->store_id > 0)\n\t\treturn;\n\n\tif (device_address_is_private(device)) {\n\t\tDBG(\"Can't store info for private addressed device %s\",\n\t\t\t\t\t\t\t\tdevice->path);\n\t\treturn;\n\t}\n\n\tdevice->store_id = g_idle_add(store_device_info_cb, device);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic guint l2cap_id = 0, unix_id = 0;\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nvoid stop_sdp_server(void)\n{\n\tinfo(\"Stopping SDP server\");\n\n\tsdp_svcdb_reset();\n\n\tif (unix_id > 0)\n\t\tg_source_remove(unix_id);\n\n\tif (l2cap_id > 0)\n\t\tg_source_remove(l2cap_id);\n\n\tl2cap_id = unix_id = 0;\n\tl2cap_sock = unix_sock = -1;\n}"
  },
  {
    "function_name": "start_sdp_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
    "lines": "230-261",
    "snippet": "int start_sdp_server(uint16_t mtu, uint32_t flags)\n{\n\tint compat = flags & SDP_SERVER_COMPAT;\n\tint master = flags & SDP_SERVER_MASTER;\n\tGIOChannel *io;\n\n\tinfo(\"Starting SDP server\");\n\n\tif (init_server(mtu, master, compat) < 0) {\n\t\terror(\"Server initialization failed\");\n\t\treturn -1;\n\t}\n\n\tio = g_io_channel_unix_new(l2cap_sock);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tl2cap_id = g_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_accept_event, &l2cap_sock);\n\tg_io_channel_unref(io);\n\n\tif (compat && unix_sock > fileno(stderr)) {\n\t\tio = g_io_channel_unix_new(unix_sock);\n\t\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\t\tunix_id = g_io_add_watch(io,\n\t\t\t\t\tG_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_accept_event, &unix_sock);\n\t\tg_io_channel_unref(io);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sdpd.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <sys/un.h>",
      "#include <sys/stat.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static guint l2cap_id = 0, unix_id = 0;",
      "static int l2cap_sock = -1, unix_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_io_channel_unref",
          "args": [
            "io"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_add_watch",
          "args": [
            "io",
            "G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL",
            "io_accept_event",
            "&unix_sock"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_set_close_on_unref",
          "args": [
            "io",
            "TRUE"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_new",
          "args": [
            "unix_sock"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unref",
          "args": [
            "io"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_add_watch",
          "args": [
            "io",
            "G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL",
            "io_accept_event",
            "&l2cap_sock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_set_close_on_unref",
          "args": [
            "io",
            "TRUE"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_new",
          "args": [
            "l2cap_sock"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Server initialization failed\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_server",
          "args": [
            "mtu",
            "master",
            "compat"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "init_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
          "lines": "56-148",
          "snippet": "static int init_server(uint16_t mtu, int master, int compat)\n{\n\tstruct l2cap_options opts;\n\tstruct sockaddr_l2 l2addr;\n\tstruct sockaddr_un unaddr;\n\tsocklen_t optlen;\n\n\t/* Register the public browse group root */\n\tregister_public_browse_group();\n\n\t/* Register the SDP server's service record */\n\tregister_server_service();\n\n\t/* Create L2CAP socket */\n\tl2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (l2cap_sock < 0) {\n\t\terror(\"opening L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&l2addr, 0, sizeof(l2addr));\n\tl2addr.l2_family = AF_BLUETOOTH;\n\tbacpy(&l2addr.l2_bdaddr, BDADDR_ANY);\n\tl2addr.l2_psm = htobs(SDP_PSM);\n\n\tif (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n\t\terror(\"binding L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (master) {\n\t\tint opt = L2CAP_LM_MASTER;\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (mtu > 0) {\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\toptlen = sizeof(opts);\n\n\t\tif (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\topts.omtu = mtu;\n\t\topts.imtu = mtu;\n\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (listen(l2cap_sock, 5) < 0) {\n\t\terror(\"listen: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (!compat) {\n\t\tunix_sock = -1;\n\t\treturn 0;\n\t}\n\n\t/* Create local Unix socket */\n\tunix_sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (unix_sock < 0) {\n\t\terror(\"opening UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&unaddr, 0, sizeof(unaddr));\n\tunaddr.sun_family = AF_UNIX;\n\tstrcpy(unaddr.sun_path, SDP_UNIX_PATH);\n\n\tunlink(unaddr.sun_path);\n\n\tif (bind(unix_sock, (struct sockaddr *) &unaddr, sizeof(unaddr)) < 0) {\n\t\terror(\"binding UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (listen(unix_sock, 5) < 0) {\n\t\terror(\"listen UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tchmod(SDP_UNIX_PATH, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sdpd.h\"",
            "#include \"log.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <sys/un.h>",
            "#include <sys/stat.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int l2cap_sock = -1, unix_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nstatic int init_server(uint16_t mtu, int master, int compat)\n{\n\tstruct l2cap_options opts;\n\tstruct sockaddr_l2 l2addr;\n\tstruct sockaddr_un unaddr;\n\tsocklen_t optlen;\n\n\t/* Register the public browse group root */\n\tregister_public_browse_group();\n\n\t/* Register the SDP server's service record */\n\tregister_server_service();\n\n\t/* Create L2CAP socket */\n\tl2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (l2cap_sock < 0) {\n\t\terror(\"opening L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&l2addr, 0, sizeof(l2addr));\n\tl2addr.l2_family = AF_BLUETOOTH;\n\tbacpy(&l2addr.l2_bdaddr, BDADDR_ANY);\n\tl2addr.l2_psm = htobs(SDP_PSM);\n\n\tif (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n\t\terror(\"binding L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (master) {\n\t\tint opt = L2CAP_LM_MASTER;\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (mtu > 0) {\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\toptlen = sizeof(opts);\n\n\t\tif (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\topts.omtu = mtu;\n\t\topts.imtu = mtu;\n\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (listen(l2cap_sock, 5) < 0) {\n\t\terror(\"listen: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (!compat) {\n\t\tunix_sock = -1;\n\t\treturn 0;\n\t}\n\n\t/* Create local Unix socket */\n\tunix_sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (unix_sock < 0) {\n\t\terror(\"opening UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&unaddr, 0, sizeof(unaddr));\n\tunaddr.sun_family = AF_UNIX;\n\tstrcpy(unaddr.sun_path, SDP_UNIX_PATH);\n\n\tunlink(unaddr.sun_path);\n\n\tif (bind(unix_sock, (struct sockaddr *) &unaddr, sizeof(unaddr)) < 0) {\n\t\terror(\"binding UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (listen(unix_sock, 5) < 0) {\n\t\terror(\"listen UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tchmod(SDP_UNIX_PATH, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"Starting SDP server\""
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "store_device_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/device.c",
          "lines": "475-487",
          "snippet": "static void store_device_info(struct btd_device *device)\n{\n\tif (device->temporary || device->store_id > 0)\n\t\treturn;\n\n\tif (device_address_is_private(device)) {\n\t\tDBG(\"Can't store info for private addressed device %s\",\n\t\t\t\t\t\t\t\tdevice->path);\n\t\treturn;\n\t}\n\n\tdevice->store_id = g_idle_add(store_device_info_cb, device);\n}",
          "includes": [
            "#include \"eir.h\"",
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"agent.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"sdp-client.h\"",
            "#include \"uuid-helper.h\"",
            "#include \"error.h\"",
            "#include \"dbus-common.h\"",
            "#include \"service.h\"",
            "#include \"profile.h\"",
            "#include \"gatt-client.h\"",
            "#include \"device.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"gatt-database.h\"",
            "#include \"adapter.h\"",
            "#include \"hcid.h\"",
            "#include \"attrib/att.h\"",
            "#include \"lib/mgmt.h\"",
            "#include \"btio/btio.h\"",
            "#include \"src/shared/ad.h\"",
            "#include \"src/shared/gatt-server.h\"",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"log.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <dbus/dbus.h>",
            "#include <glib.h>",
            "#include <time.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <stdbool.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void gatt_client_init(struct btd_device *device);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"eir.h\"\n#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"agent.h\"\n#include \"attrib/gatt.h\"\n#include \"sdp-client.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"service.h\"\n#include \"profile.h\"\n#include \"gatt-client.h\"\n#include \"device.h\"\n#include \"attrib/gattrib.h\"\n#include \"gatt-database.h\"\n#include \"adapter.h\"\n#include \"hcid.h\"\n#include \"attrib/att.h\"\n#include \"lib/mgmt.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/ad.h\"\n#include \"src/shared/gatt-server.h\"\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/util.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <time.h>\n#include <dirent.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void gatt_client_init(struct btd_device *device);\n\nstatic void store_device_info(struct btd_device *device)\n{\n\tif (device->temporary || device->store_id > 0)\n\t\treturn;\n\n\tif (device_address_is_private(device)) {\n\t\tDBG(\"Can't store info for private addressed device %s\",\n\t\t\t\t\t\t\t\tdevice->path);\n\t\treturn;\n\t}\n\n\tdevice->store_id = g_idle_add(store_device_info_cb, device);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic guint l2cap_id = 0, unix_id = 0;\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nint start_sdp_server(uint16_t mtu, uint32_t flags)\n{\n\tint compat = flags & SDP_SERVER_COMPAT;\n\tint master = flags & SDP_SERVER_MASTER;\n\tGIOChannel *io;\n\n\tinfo(\"Starting SDP server\");\n\n\tif (init_server(mtu, master, compat) < 0) {\n\t\terror(\"Server initialization failed\");\n\t\treturn -1;\n\t}\n\n\tio = g_io_channel_unix_new(l2cap_sock);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tl2cap_id = g_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_accept_event, &l2cap_sock);\n\tg_io_channel_unref(io);\n\n\tif (compat && unix_sock > fileno(stderr)) {\n\t\tio = g_io_channel_unix_new(unix_sock);\n\t\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\t\tunix_id = g_io_add_watch(io,\n\t\t\t\t\tG_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_accept_event, &unix_sock);\n\t\tg_io_channel_unref(io);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "io_accept_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
    "lines": "193-228",
    "snippet": "static gboolean io_accept_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tGIOChannel *io;\n\tint nsk;\n\n\tif (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL))\n\t\treturn FALSE;\n\n\tif (data == &l2cap_sock) {\n\t\tstruct sockaddr_l2 addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(l2cap_sock, (struct sockaddr *) &addr, &len);\n\t} else if (data == &unix_sock) {\n\t\tstruct sockaddr_un addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(unix_sock, (struct sockaddr *) &addr, &len);\n\t} else\n\t\treturn FALSE;\n\n\tif (nsk < 0) {\n\t\terror(\"Can't accept connection: %s\", strerror(errno));\n\t\treturn TRUE;\n\t}\n\n\tio = g_io_channel_unix_new(nsk);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tg_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_session_event, data);\n\n\tg_io_channel_unref(io);\n\n\treturn TRUE;\n}",
    "includes": [
      "#include \"sdpd.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <sys/un.h>",
      "#include <sys/stat.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int l2cap_sock = -1, unix_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_io_channel_unref",
          "args": [
            "io"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_add_watch",
          "args": [
            "io",
            "G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL",
            "io_session_event",
            "data"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_set_close_on_unref",
          "args": [
            "io",
            "TRUE"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_new",
          "args": [
            "nsk"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Can't accept connection: %s\"",
            "strerror(errno)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "124-128",
          "snippet": "DBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "unix_sock",
            "(struct sockaddr *) &addr",
            "&len"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "io_accept_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
          "lines": "193-228",
          "snippet": "static gboolean io_accept_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tGIOChannel *io;\n\tint nsk;\n\n\tif (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL))\n\t\treturn FALSE;\n\n\tif (data == &l2cap_sock) {\n\t\tstruct sockaddr_l2 addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(l2cap_sock, (struct sockaddr *) &addr, &len);\n\t} else if (data == &unix_sock) {\n\t\tstruct sockaddr_un addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(unix_sock, (struct sockaddr *) &addr, &len);\n\t} else\n\t\treturn FALSE;\n\n\tif (nsk < 0) {\n\t\terror(\"Can't accept connection: %s\", strerror(errno));\n\t\treturn TRUE;\n\t}\n\n\tio = g_io_channel_unix_new(nsk);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tg_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_session_event, data);\n\n\tg_io_channel_unref(io);\n\n\treturn TRUE;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nstatic gboolean io_accept_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tGIOChannel *io;\n\tint nsk;\n\n\tif (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL))\n\t\treturn FALSE;\n\n\tif (data == &l2cap_sock) {\n\t\tstruct sockaddr_l2 addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(l2cap_sock, (struct sockaddr *) &addr, &len);\n\t} else if (data == &unix_sock) {\n\t\tstruct sockaddr_un addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(unix_sock, (struct sockaddr *) &addr, &len);\n\t} else\n\t\treturn FALSE;\n\n\tif (nsk < 0) {\n\t\terror(\"Can't accept connection: %s\", strerror(errno));\n\t\treturn TRUE;\n\t}\n\n\tio = g_io_channel_unix_new(nsk);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tg_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_session_event, data);\n\n\tg_io_channel_unref(io);\n\n\treturn TRUE;\n}"
  },
  {
    "function_name": "io_session_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
    "lines": "150-191",
    "snippet": "static gboolean io_session_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tsdp_pdu_hdr_t hdr;\n\tuint8_t *buf;\n\tint sk, len, size;\n\n\tif (cond & G_IO_NVAL)\n\t\treturn FALSE;\n\n\tsk = g_io_channel_unix_get_fd(chan);\n\n\tif (cond & (G_IO_HUP | G_IO_ERR)) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\treturn FALSE;\n\t}\n\n\tlen = recv(sk, &hdr, sizeof(sdp_pdu_hdr_t), MSG_PEEK);\n\tif (len < 0 || (unsigned int) len < sizeof(sdp_pdu_hdr_t)) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\treturn FALSE;\n\t}\n\n\tsize = sizeof(sdp_pdu_hdr_t) + ntohs(hdr.plen);\n\tbuf = malloc(size);\n\tif (!buf)\n\t\treturn TRUE;\n\n\tlen = recv(sk, buf, size, 0);\n\t/* Check here only that the received message is not empty.\n\t * Incorrect length of message should be processed later\n\t * inside handle_request() in order to produce ErrorResponse.\n\t */\n\tif (len <= 0) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\tfree(buf);\n\t\treturn FALSE;\n\t}\n\n\thandle_request(sk, buf, len);\n\n\treturn TRUE;\n}",
    "includes": [
      "#include \"sdpd.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <sys/un.h>",
      "#include <sys/stat.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_request",
          "args": [
            "sk",
            "buf",
            "len"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "handle_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-request.c",
          "lines": "1072-1119",
          "snippet": "void handle_request(int sk, uint8_t *data, int len)\n{\n\tstruct sockaddr_l2 sa;\n\tsocklen_t size;\n\tsdp_req_t req;\n\n\tsize = sizeof(sa);\n\tif (getpeername(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\terror(\"getpeername: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (sa.l2_family == AF_BLUETOOTH) {\n\t\tstruct l2cap_options lo;\n\n\t\tmemset(&lo, 0, sizeof(lo));\n\t\tsize = sizeof(lo);\n\n\t\tif (getsockopt(sk, SOL_L2CAP, L2CAP_OPTIONS, &lo, &size) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.bdaddr, &sa.l2_bdaddr);\n\t\treq.mtu = lo.omtu;\n\t\treq.local = 0;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsize = sizeof(sa);\n\n\t\tif (getsockname(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\t\terror(\"getsockname: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.device, &sa.l2_bdaddr);\n\t} else {\n\t\tbacpy(&req.device, BDADDR_ANY);\n\t\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\t\treq.mtu = 2048;\n\t\treq.local = 1;\n\t}\n\n\treq.sock = sk;\n\treq.buf  = data;\n\treq.len  = len;\n\n\tprocess_request(&req);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nvoid handle_request(int sk, uint8_t *data, int len)\n{\n\tstruct sockaddr_l2 sa;\n\tsocklen_t size;\n\tsdp_req_t req;\n\n\tsize = sizeof(sa);\n\tif (getpeername(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\terror(\"getpeername: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\tif (sa.l2_family == AF_BLUETOOTH) {\n\t\tstruct l2cap_options lo;\n\n\t\tmemset(&lo, 0, sizeof(lo));\n\t\tsize = sizeof(lo);\n\n\t\tif (getsockopt(sk, SOL_L2CAP, L2CAP_OPTIONS, &lo, &size) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.bdaddr, &sa.l2_bdaddr);\n\t\treq.mtu = lo.omtu;\n\t\treq.local = 0;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsize = sizeof(sa);\n\n\t\tif (getsockname(sk, (struct sockaddr *) &sa, &size) < 0) {\n\t\t\terror(\"getsockname: %s\", strerror(errno));\n\t\t\treturn;\n\t\t}\n\n\t\tbacpy(&req.device, &sa.l2_bdaddr);\n\t} else {\n\t\tbacpy(&req.device, BDADDR_ANY);\n\t\tbacpy(&req.bdaddr, BDADDR_LOCAL);\n\t\treq.mtu = 2048;\n\t\treq.local = 1;\n\t}\n\n\treq.sock = sk;\n\treq.buf  = data;\n\treq.len  = len;\n\n\tprocess_request(&req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "gatt_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "123-150",
          "snippet": "static void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic void gatt_server_free(struct gatt_server *server)\n{\n\tg_list_free_full(server->database, attrib_free);\n\n\tif (server->l2cap_io != NULL) {\n\t\tg_io_channel_shutdown(server->l2cap_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->l2cap_io);\n\t}\n\n\tif (server->le_io != NULL) {\n\t\tg_io_channel_shutdown(server->le_io, FALSE, NULL);\n\t\tg_io_channel_unref(server->le_io);\n\t}\n\n\tg_slist_free_full(server->clients, (GDestroyNotify) channel_free);\n\n\tif (server->gatt_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter,\n\t\t\t\t\tserver->gatt_sdp_handle);\n\n\tif (server->gap_sdp_handle > 0)\n\t\tadapter_service_remove(server->adapter, server->gap_sdp_handle);\n\n\tif (server->adapter != NULL)\n\t\tbtd_adapter_unref(server->adapter);\n\n\tg_free(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sdp_svcdb_collect_all",
          "args": [
            "sk"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "sdp_svcdb_collect_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-database.c",
          "lines": "107-131",
          "snippet": "void sdp_svcdb_collect_all(int sock)\n{\n\tsdp_list_t *p, *q;\n\n\tfor (p = socket_index, q = 0; p; ) {\n\t\tsdp_indexed_t *item = p->data;\n\t\tif (item->sock == sock) {\n\t\t\tsdp_list_t *next = p->next;\n\t\t\tsdp_record_remove(item->record->handle);\n\t\t\tsdp_record_free(item->record);\n\t\t\tfree(item);\n\t\t\tif (q)\n\t\t\t\tq->next = next;\n\t\t\telse\n\t\t\t\tsocket_index = next;\n\t\t\tfree(p);\n\t\t\tp = next;\n\t\t} else if (item->sock > sock)\n\t\t\treturn;\n\t\telse {\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_list_t *socket_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic sdp_list_t *socket_index;\n\nvoid sdp_svcdb_collect_all(int sock)\n{\n\tsdp_list_t *p, *q;\n\n\tfor (p = socket_index, q = 0; p; ) {\n\t\tsdp_indexed_t *item = p->data;\n\t\tif (item->sock == sock) {\n\t\t\tsdp_list_t *next = p->next;\n\t\t\tsdp_record_remove(item->record->handle);\n\t\t\tsdp_record_free(item->record);\n\t\t\tfree(item);\n\t\t\tif (q)\n\t\t\t\tq->next = next;\n\t\t\telse\n\t\t\t\tsocket_index = next;\n\t\t\tfree(p);\n\t\t\tp = next;\n\t\t} else if (item->sock > sock)\n\t\t\treturn;\n\t\telse {\n\t\t\tq = p;\n\t\t\tp = p->next;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "sk",
            "buf",
            "size",
            "0"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "btd_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.c",
          "lines": "41-55",
          "snippet": "void *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/util.h\"",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdbool.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/util.h\"\n#include <string.h>\n#include <limits.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid *btd_malloc(size_t size)\n{\n\tif (__builtin_expect(!!size, 1)) {\n\t\tvoid *ptr;\n\n\t\tptr = malloc(size);\n\t\tif (ptr)\n\t\t\treturn ptr;\n\n\t\tfprintf(stderr, \"failed to allocate %zu bytes\\n\", size);\n\t\tabort();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "hdr.plen"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "sk",
            "&hdr",
            "sizeof(sdp_pdu_hdr_t)",
            "MSG_PEEK"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_get_fd",
          "args": [
            "chan"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic gboolean io_session_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tsdp_pdu_hdr_t hdr;\n\tuint8_t *buf;\n\tint sk, len, size;\n\n\tif (cond & G_IO_NVAL)\n\t\treturn FALSE;\n\n\tsk = g_io_channel_unix_get_fd(chan);\n\n\tif (cond & (G_IO_HUP | G_IO_ERR)) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\treturn FALSE;\n\t}\n\n\tlen = recv(sk, &hdr, sizeof(sdp_pdu_hdr_t), MSG_PEEK);\n\tif (len < 0 || (unsigned int) len < sizeof(sdp_pdu_hdr_t)) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\treturn FALSE;\n\t}\n\n\tsize = sizeof(sdp_pdu_hdr_t) + ntohs(hdr.plen);\n\tbuf = malloc(size);\n\tif (!buf)\n\t\treturn TRUE;\n\n\tlen = recv(sk, buf, size, 0);\n\t/* Check here only that the received message is not empty.\n\t * Incorrect length of message should be processed later\n\t * inside handle_request() in order to produce ErrorResponse.\n\t */\n\tif (len <= 0) {\n\t\tsdp_svcdb_collect_all(sk);\n\t\tfree(buf);\n\t\treturn FALSE;\n\t}\n\n\thandle_request(sk, buf, len);\n\n\treturn TRUE;\n}"
  },
  {
    "function_name": "init_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
    "lines": "56-148",
    "snippet": "static int init_server(uint16_t mtu, int master, int compat)\n{\n\tstruct l2cap_options opts;\n\tstruct sockaddr_l2 l2addr;\n\tstruct sockaddr_un unaddr;\n\tsocklen_t optlen;\n\n\t/* Register the public browse group root */\n\tregister_public_browse_group();\n\n\t/* Register the SDP server's service record */\n\tregister_server_service();\n\n\t/* Create L2CAP socket */\n\tl2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (l2cap_sock < 0) {\n\t\terror(\"opening L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&l2addr, 0, sizeof(l2addr));\n\tl2addr.l2_family = AF_BLUETOOTH;\n\tbacpy(&l2addr.l2_bdaddr, BDADDR_ANY);\n\tl2addr.l2_psm = htobs(SDP_PSM);\n\n\tif (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n\t\terror(\"binding L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (master) {\n\t\tint opt = L2CAP_LM_MASTER;\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (mtu > 0) {\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\toptlen = sizeof(opts);\n\n\t\tif (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\topts.omtu = mtu;\n\t\topts.imtu = mtu;\n\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (listen(l2cap_sock, 5) < 0) {\n\t\terror(\"listen: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (!compat) {\n\t\tunix_sock = -1;\n\t\treturn 0;\n\t}\n\n\t/* Create local Unix socket */\n\tunix_sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (unix_sock < 0) {\n\t\terror(\"opening UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&unaddr, 0, sizeof(unaddr));\n\tunaddr.sun_family = AF_UNIX;\n\tstrcpy(unaddr.sun_path, SDP_UNIX_PATH);\n\n\tunlink(unaddr.sun_path);\n\n\tif (bind(unix_sock, (struct sockaddr *) &unaddr, sizeof(unaddr)) < 0) {\n\t\terror(\"binding UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (listen(unix_sock, 5) < 0) {\n\t\terror(\"listen UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tchmod(SDP_UNIX_PATH, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sdpd.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp_lib.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/l2cap.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <sys/un.h>",
      "#include <sys/stat.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int l2cap_sock = -1, unix_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "SDP_UNIX_PATH",
            "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"listen UNIX socket: %s\"",
            "strerror(errno)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "124-128",
          "snippet": "DBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_failed(DBusMessage *msg, const char *str)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE\n\t\t\t\t\t\".Failed\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "unix_sock",
            "5"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "unix_sock",
            "(struct sockaddr *) &unaddr",
            "sizeof(unaddr)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "unaddr.sun_path"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "unaddr.sun_path",
            "SDP_UNIX_PATH"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&unaddr",
            "0",
            "sizeof(unaddr)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "l2cap_sock",
            "5"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "l2cap_sock",
            "SOL_L2CAP",
            "L2CAP_OPTIONS",
            "&opts",
            "sizeof(opts)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "l2cap_sock",
            "SOL_L2CAP",
            "L2CAP_OPTIONS",
            "&opts",
            "&optlen"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&opts",
            "0",
            "sizeof(opts)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "l2cap_sock",
            "SOL_L2CAP",
            "L2CAP_LM",
            "&opt",
            "sizeof(opt)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "l2cap_sock",
            "(struct sockaddr *) &l2addr",
            "sizeof(l2addr)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobs",
          "args": [
            "SDP_PSM"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bacpy",
          "args": [
            "&l2addr.l2_bdaddr",
            "BDADDR_ANY"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&l2addr",
            "0",
            "sizeof(l2addr)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_BLUETOOTH",
            "SOCK_SEQPACKET",
            "BTPROTO_L2CAP"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_server_service",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "register_server_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "357-405",
          "snippet": "void register_server_service(void)\n{\n\tsdp_list_t *classIDList;\n\tuuid_t classID;\n\tvoid **versions, **versionDTDs;\n\tuint8_t dtd;\n\tsdp_data_t *pData;\n\tint i;\n\n\tserver = sdp_record_alloc();\n\tserver->pattern = NULL;\n\n\t/* Force the record to be SDP_SERVER_RECORD_HANDLE */\n\tserver->handle = SDP_SERVER_RECORD_HANDLE;\n\n\tsdp_record_add(BDADDR_ANY, server);\n\tsdp_attr_add(server, SDP_ATTR_RECORD_HANDLE,\n\t\t\t\tsdp_data_alloc(SDP_UINT32, &server->handle));\n\n\tsdp_uuid16_create(&classID, SDP_SERVER_SVCLASS_ID);\n\tclassIDList = sdp_list_append(0, &classID);\n\tsdp_set_service_classes(server, classIDList);\n\tsdp_list_free(classIDList, 0);\n\n\t/*\n\t * Set the version numbers supported, these are passed as arguments\n\t * to the server on command line. Now defaults to 1.0\n\t * Build the version number sequence first\n\t */\n\tversions = malloc(sdpServerVnumEntries * sizeof(void *));\n\tversionDTDs = malloc(sdpServerVnumEntries * sizeof(void *));\n\tdtd = SDP_UINT16;\n\tfor (i = 0; i < sdpServerVnumEntries; i++) {\n\t\tuint16_t *version = malloc(sizeof(uint16_t));\n\t\t*version = sdpVnumArray[i].major;\n\t\t*version = (*version << 8);\n\t\t*version |= sdpVnumArray[i].minor;\n\t\tversions[i] = version;\n\t\tversionDTDs[i] = &dtd;\n\t}\n\tpData = sdp_seq_alloc(versionDTDs, versions, sdpServerVnumEntries);\n\tfor (i = 0; i < sdpServerVnumEntries; i++)\n\t\tfree(versions[i]);\n\tfree(versions);\n\tfree(versionDTDs);\n\tsdp_attr_add(server, SDP_ATTR_VERSION_NUM_LIST, pData);\n\n\tupdate_db_timestamp();\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sdp_record_t *server = NULL;",
            "static sdp_version_t sdpVnumArray[1] = {\n\t{ 1, 0 }\n};",
            "static const int sdpServerVnumEntries = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nstatic sdp_record_t *server = NULL;\nstatic sdp_version_t sdpVnumArray[1] = {\n\t{ 1, 0 }\n};\nstatic const int sdpServerVnumEntries = 1;\n\nvoid register_server_service(void)\n{\n\tsdp_list_t *classIDList;\n\tuuid_t classID;\n\tvoid **versions, **versionDTDs;\n\tuint8_t dtd;\n\tsdp_data_t *pData;\n\tint i;\n\n\tserver = sdp_record_alloc();\n\tserver->pattern = NULL;\n\n\t/* Force the record to be SDP_SERVER_RECORD_HANDLE */\n\tserver->handle = SDP_SERVER_RECORD_HANDLE;\n\n\tsdp_record_add(BDADDR_ANY, server);\n\tsdp_attr_add(server, SDP_ATTR_RECORD_HANDLE,\n\t\t\t\tsdp_data_alloc(SDP_UINT32, &server->handle));\n\n\tsdp_uuid16_create(&classID, SDP_SERVER_SVCLASS_ID);\n\tclassIDList = sdp_list_append(0, &classID);\n\tsdp_set_service_classes(server, classIDList);\n\tsdp_list_free(classIDList, 0);\n\n\t/*\n\t * Set the version numbers supported, these are passed as arguments\n\t * to the server on command line. Now defaults to 1.0\n\t * Build the version number sequence first\n\t */\n\tversions = malloc(sdpServerVnumEntries * sizeof(void *));\n\tversionDTDs = malloc(sdpServerVnumEntries * sizeof(void *));\n\tdtd = SDP_UINT16;\n\tfor (i = 0; i < sdpServerVnumEntries; i++) {\n\t\tuint16_t *version = malloc(sizeof(uint16_t));\n\t\t*version = sdpVnumArray[i].major;\n\t\t*version = (*version << 8);\n\t\t*version |= sdpVnumArray[i].minor;\n\t\tversions[i] = version;\n\t\tversionDTDs[i] = &dtd;\n\t}\n\tpData = sdp_seq_alloc(versionDTDs, versions, sdpServerVnumEntries);\n\tfor (i = 0; i < sdpServerVnumEntries; i++)\n\t\tfree(versions[i]);\n\tfree(versions);\n\tfree(versionDTDs);\n\tsdp_attr_add(server, SDP_ATTR_VERSION_NUM_LIST, pData);\n\n\tupdate_db_timestamp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_public_browse_group",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "register_public_browse_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-service.c",
          "lines": "328-349",
          "snippet": "void register_public_browse_group(void)\n{\n\tsdp_list_t *browselist;\n\tuuid_t bgscid, pbgid;\n\tsdp_data_t *sdpdata;\n\tsdp_record_t *browse = sdp_record_alloc();\n\n\tbrowse->handle = SDP_SERVER_RECORD_HANDLE + 1;\n\n\tsdp_record_add(BDADDR_ANY, browse);\n\tsdpdata = sdp_data_alloc(SDP_UINT32, &browse->handle);\n\tsdp_attr_add(browse, SDP_ATTR_RECORD_HANDLE, sdpdata);\n\n\tsdp_uuid16_create(&bgscid, BROWSE_GRP_DESC_SVCLASS_ID);\n\tbrowselist = sdp_list_append(0, &bgscid);\n\tsdp_set_service_classes(browse, browselist);\n\tsdp_list_free(browselist, 0);\n\n\tsdp_uuid16_create(&pbgid, PUBLIC_BROWSE_GROUP);\n\tsdp_attr_add_new(browse, SDP_ATTR_GROUP_ID,\n\t\t\t\tSDP_UUID16, &pbgid.value.uuid16);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"sdpd.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <stdbool.h>",
            "#include <sys/time.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"sdpd.h\"\n#include \"src/shared/util.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <stdbool.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <config.h>\n\nvoid register_public_browse_group(void)\n{\n\tsdp_list_t *browselist;\n\tuuid_t bgscid, pbgid;\n\tsdp_data_t *sdpdata;\n\tsdp_record_t *browse = sdp_record_alloc();\n\n\tbrowse->handle = SDP_SERVER_RECORD_HANDLE + 1;\n\n\tsdp_record_add(BDADDR_ANY, browse);\n\tsdpdata = sdp_data_alloc(SDP_UINT32, &browse->handle);\n\tsdp_attr_add(browse, SDP_ATTR_RECORD_HANDLE, sdpdata);\n\n\tsdp_uuid16_create(&bgscid, BROWSE_GRP_DESC_SVCLASS_ID);\n\tbrowselist = sdp_list_append(0, &bgscid);\n\tsdp_set_service_classes(browse, browselist);\n\tsdp_list_free(browselist, 0);\n\n\tsdp_uuid16_create(&pbgid, PUBLIC_BROWSE_GROUP);\n\tsdp_attr_add_new(browse, SDP_ATTR_GROUP_ID,\n\t\t\t\tSDP_UUID16, &pbgid.value.uuid16);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nstatic int init_server(uint16_t mtu, int master, int compat)\n{\n\tstruct l2cap_options opts;\n\tstruct sockaddr_l2 l2addr;\n\tstruct sockaddr_un unaddr;\n\tsocklen_t optlen;\n\n\t/* Register the public browse group root */\n\tregister_public_browse_group();\n\n\t/* Register the SDP server's service record */\n\tregister_server_service();\n\n\t/* Create L2CAP socket */\n\tl2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);\n\tif (l2cap_sock < 0) {\n\t\terror(\"opening L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&l2addr, 0, sizeof(l2addr));\n\tl2addr.l2_family = AF_BLUETOOTH;\n\tbacpy(&l2addr.l2_bdaddr, BDADDR_ANY);\n\tl2addr.l2_psm = htobs(SDP_PSM);\n\n\tif (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {\n\t\terror(\"binding L2CAP socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (master) {\n\t\tint opt = L2CAP_LM_MASTER;\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (mtu > 0) {\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\toptlen = sizeof(opts);\n\n\t\tif (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {\n\t\t\terror(\"getsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\topts.omtu = mtu;\n\t\topts.imtu = mtu;\n\n\t\tif (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {\n\t\t\terror(\"setsockopt: %s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (listen(l2cap_sock, 5) < 0) {\n\t\terror(\"listen: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (!compat) {\n\t\tunix_sock = -1;\n\t\treturn 0;\n\t}\n\n\t/* Create local Unix socket */\n\tunix_sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (unix_sock < 0) {\n\t\terror(\"opening UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&unaddr, 0, sizeof(unaddr));\n\tunaddr.sun_family = AF_UNIX;\n\tstrcpy(unaddr.sun_path, SDP_UNIX_PATH);\n\n\tunlink(unaddr.sun_path);\n\n\tif (bind(unix_sock, (struct sockaddr *) &unaddr, sizeof(unaddr)) < 0) {\n\t\terror(\"binding UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (listen(unix_sock, 5) < 0) {\n\t\terror(\"listen UNIX socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tchmod(SDP_UNIX_PATH, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n\n\treturn 0;\n}"
  }
]