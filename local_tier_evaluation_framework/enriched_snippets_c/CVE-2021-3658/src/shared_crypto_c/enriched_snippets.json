[
  {
    "function_name": "bt_crypto_h6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "683-690",
    "snippet": "bool bt_crypto_h6(struct bt_crypto *crypto, const uint8_t w[16],\n\t\t\t\tconst uint8_t keyid[4], uint8_t res[16])\n{\n\tif (!aes_cmac(crypto, w, keyid, 4, res))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aes_cmac",
          "args": [
            "crypto",
            "w",
            "keyid",
            "4",
            "res"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "aes_cmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "571-604",
          "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CMAC_MSG_MAX\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_h6(struct bt_crypto *crypto, const uint8_t w[16],\n\t\t\t\tconst uint8_t keyid[4], uint8_t res[16])\n{\n\tif (!aes_cmac(crypto, w, keyid, 4, res))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_g2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "665-681",
    "snippet": "bool bt_crypto_g2(struct bt_crypto *crypto, uint8_t u[32], uint8_t v[32],\n\t\t\t\tuint8_t x[16], uint8_t y[16], uint32_t *val)\n{\n\tuint8_t m[80], tmp[16];\n\n\tmemcpy(&m[0], y, 16);\n\tmemcpy(&m[16], v, 32);\n\tmemcpy(&m[48], u, 32);\n\n\tif (!aes_cmac(crypto, x, m, sizeof(m), tmp))\n\t\treturn false;\n\n\t*val = get_le32(tmp);\n\t*val %= 1000000;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_le32",
          "args": [
            "tmp"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "get_le32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "139-142",
          "snippet": "static inline uint32_t get_le32(const void *ptr)\n{\n\treturn le32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline uint32_t get_le32(const void *ptr)\n{\n\treturn le32_to_cpu(get_unaligned((const uint32_t *) ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "aes_cmac",
          "args": [
            "crypto",
            "x",
            "m",
            "sizeof(m)",
            "tmp"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "aes_cmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "571-604",
          "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CMAC_MSG_MAX\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[48]",
            "u",
            "32"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[16]",
            "v",
            "32"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[0]",
            "y",
            "16"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_g2(struct bt_crypto *crypto, uint8_t u[32], uint8_t v[32],\n\t\t\t\tuint8_t x[16], uint8_t y[16], uint32_t *val)\n{\n\tuint8_t m[80], tmp[16];\n\n\tmemcpy(&m[0], y, 16);\n\tmemcpy(&m[16], v, 32);\n\tmemcpy(&m[48], u, 32);\n\n\tif (!aes_cmac(crypto, x, m, sizeof(m), tmp))\n\t\treturn false;\n\n\t*val = get_le32(tmp);\n\t*val %= 1000000;\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_f6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "649-663",
    "snippet": "bool bt_crypto_f6(struct bt_crypto *crypto, uint8_t w[16], uint8_t n1[16],\n\t\t\tuint8_t n2[16], uint8_t r[16], uint8_t io_cap[3],\n\t\t\tuint8_t a1[7], uint8_t a2[7], uint8_t res[16])\n{\n\tuint8_t m[65];\n\n\tmemcpy(&m[0], a2, 7);\n\tmemcpy(&m[7], a1, 7);\n\tmemcpy(&m[14], io_cap, 3);\n\tmemcpy(&m[17], r, 16);\n\tmemcpy(&m[33], n2, 16);\n\tmemcpy(&m[49], n1, 16);\n\n\treturn aes_cmac(crypto, w, m, sizeof(m), res);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aes_cmac",
          "args": [
            "crypto",
            "w",
            "m",
            "sizeof(m)",
            "res"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "aes_cmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "571-604",
          "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CMAC_MSG_MAX\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[49]",
            "n1",
            "16"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[33]",
            "n2",
            "16"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[17]",
            "r",
            "16"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[14]",
            "io_cap",
            "3"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[7]",
            "a1",
            "7"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[0]",
            "a2",
            "7"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_f6(struct bt_crypto *crypto, uint8_t w[16], uint8_t n1[16],\n\t\t\tuint8_t n2[16], uint8_t r[16], uint8_t io_cap[3],\n\t\t\tuint8_t a1[7], uint8_t a2[7], uint8_t res[16])\n{\n\tuint8_t m[65];\n\n\tmemcpy(&m[0], a2, 7);\n\tmemcpy(&m[7], a1, 7);\n\tmemcpy(&m[14], io_cap, 3);\n\tmemcpy(&m[17], r, 16);\n\tmemcpy(&m[33], n2, 16);\n\tmemcpy(&m[49], n1, 16);\n\n\treturn aes_cmac(crypto, w, m, sizeof(m), res);\n}"
  },
  {
    "function_name": "bt_crypto_f5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "621-647",
    "snippet": "bool bt_crypto_f5(struct bt_crypto *crypto, uint8_t w[32], uint8_t n1[16],\n\t\t\t\tuint8_t n2[16], uint8_t a1[7], uint8_t a2[7],\n\t\t\t\tuint8_t mackey[16], uint8_t ltk[16])\n{\n\tuint8_t btle[4] = { 0x65, 0x6c, 0x74, 0x62 };\n\tuint8_t salt[16] = { 0xbe, 0x83, 0x60, 0x5a, 0xdb, 0x0b, 0x37, 0x60,\n\t\t\t     0x38, 0xa5, 0xf5, 0xaa, 0x91, 0x83, 0x88, 0x6c };\n\tuint8_t length[2] = { 0x00, 0x01 };\n\tuint8_t m[53], t[16];\n\n\tif (!aes_cmac(crypto, salt, w, 32, t))\n\t\treturn false;\n\n\tmemcpy(&m[0], length, 2);\n\tmemcpy(&m[2], a2, 7);\n\tmemcpy(&m[9], a1, 7);\n\tmemcpy(&m[16], n2, 16);\n\tmemcpy(&m[32], n1, 16);\n\tmemcpy(&m[48], btle, 4);\n\n\tm[52] = 0; /* Counter */\n\tif (!aes_cmac(crypto, t, m, sizeof(m), mackey))\n\t\treturn false;\n\n\tm[52] = 1; /* Counter */\n\treturn aes_cmac(crypto, t, m, sizeof(m), ltk);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aes_cmac",
          "args": [
            "crypto",
            "t",
            "m",
            "sizeof(m)",
            "ltk"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "aes_cmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "571-604",
          "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CMAC_MSG_MAX\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[48]",
            "btle",
            "4"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[32]",
            "n1",
            "16"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[16]",
            "n2",
            "16"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[9]",
            "a1",
            "7"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[2]",
            "a2",
            "7"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[0]",
            "length",
            "2"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_f5(struct bt_crypto *crypto, uint8_t w[32], uint8_t n1[16],\n\t\t\t\tuint8_t n2[16], uint8_t a1[7], uint8_t a2[7],\n\t\t\t\tuint8_t mackey[16], uint8_t ltk[16])\n{\n\tuint8_t btle[4] = { 0x65, 0x6c, 0x74, 0x62 };\n\tuint8_t salt[16] = { 0xbe, 0x83, 0x60, 0x5a, 0xdb, 0x0b, 0x37, 0x60,\n\t\t\t     0x38, 0xa5, 0xf5, 0xaa, 0x91, 0x83, 0x88, 0x6c };\n\tuint8_t length[2] = { 0x00, 0x01 };\n\tuint8_t m[53], t[16];\n\n\tif (!aes_cmac(crypto, salt, w, 32, t))\n\t\treturn false;\n\n\tmemcpy(&m[0], length, 2);\n\tmemcpy(&m[2], a2, 7);\n\tmemcpy(&m[9], a1, 7);\n\tmemcpy(&m[16], n2, 16);\n\tmemcpy(&m[32], n1, 16);\n\tmemcpy(&m[48], btle, 4);\n\n\tm[52] = 0; /* Counter */\n\tif (!aes_cmac(crypto, t, m, sizeof(m), mackey))\n\t\treturn false;\n\n\tm[52] = 1; /* Counter */\n\treturn aes_cmac(crypto, t, m, sizeof(m), ltk);\n}"
  },
  {
    "function_name": "bt_crypto_f4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "606-619",
    "snippet": "bool bt_crypto_f4(struct bt_crypto *crypto, uint8_t u[32], uint8_t v[32],\n\t\t\t\tuint8_t x[16], uint8_t z, uint8_t res[16])\n{\n\tuint8_t m[65];\n\n\tif (!crypto)\n\t\treturn false;\n\n\tm[0] = z;\n\tmemcpy(&m[1], v, 32);\n\tmemcpy(&m[33], u, 32);\n\n\treturn aes_cmac(crypto, x, m, sizeof(m), res);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aes_cmac",
          "args": [
            "crypto",
            "x",
            "m",
            "sizeof(m)",
            "res"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "aes_cmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "571-604",
          "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CMAC_MSG_MAX\t80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[33]",
            "u",
            "32"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&m[1]",
            "v",
            "32"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_f4(struct bt_crypto *crypto, uint8_t u[32], uint8_t v[32],\n\t\t\t\tuint8_t x[16], uint8_t z, uint8_t res[16])\n{\n\tuint8_t m[65];\n\n\tif (!crypto)\n\t\treturn false;\n\n\tm[0] = z;\n\tmemcpy(&m[1], v, 32);\n\tmemcpy(&m[33], u, 32);\n\n\treturn aes_cmac(crypto, x, m, sizeof(m), res);\n}"
  },
  {
    "function_name": "aes_cmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "571-604",
    "snippet": "static bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CMAC_MSG_MAX\t80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_buf",
          "args": [
            "out",
            "res",
            "16"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "swap_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "258-264",
          "snippet": "static inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "out",
            "16"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "msg_msb",
            "msg_len",
            "0"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_gw_send_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "783-810",
          "snippet": "bool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alg_new",
          "args": [
            "crypto->cmac_aes",
            "key_msb",
            "16"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "alg_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "210-217",
          "snippet": "static int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SOL_ALG\t\t279",
            "#define ALG_SET_KEY                     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_SET_KEY                     1\n\nstatic int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define CMAC_MSG_MAX\t80\n\nstatic bool aes_cmac(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t *msg, size_t msg_len, uint8_t res[16])\n{\n\tuint8_t key_msb[16], out[16], msg_msb[CMAC_MSG_MAX];\n\tssize_t len;\n\tint fd;\n\n\tif (msg_len > CMAC_MSG_MAX)\n\t\treturn false;\n\n\tswap_buf(key, key_msb, 16);\n\tfd = alg_new(crypto->cmac_aes, key_msb, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\tswap_buf(msg, msg_msb, msg_len);\n\tlen = send(fd, msg_msb, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tswap_buf(out, res, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_s1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "561-569",
    "snippet": "bool bt_crypto_s1(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\tconst uint8_t r1[16], const uint8_t r2[16],\n\t\t\tuint8_t res[16])\n{\n\tmemcpy(res, r2, 8);\n\tmemcpy(res + 8, r1, 8);\n\n\treturn bt_crypto_e(crypto, k, res, res);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_crypto_e",
          "args": [
            "crypto",
            "k",
            "res",
            "res"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "bt_crypto_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "339-370",
          "snippet": "bool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res + 8",
            "r1",
            "8"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "r2",
            "8"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_s1(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\tconst uint8_t r1[16], const uint8_t r2[16],\n\t\t\tuint8_t res[16])\n{\n\tmemcpy(res, r2, 8);\n\tmemcpy(res + 8, r1, 8);\n\n\treturn bt_crypto_e(crypto, k, res, res);\n}"
  },
  {
    "function_name": "bt_crypto_c1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "497-528",
    "snippet": "bool bt_crypto_c1(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\tconst uint8_t r[16], const uint8_t pres[7],\n\t\t\tconst uint8_t preq[7], uint8_t iat,\n\t\t\tconst uint8_t ia[6], uint8_t rat,\n\t\t\tconst uint8_t ra[6], uint8_t res[16])\n{\n\tuint8_t p1[16], p2[16];\n\n\t/* p1 = pres || preq || _rat || _iat */\n\tp1[0] = iat;\n\tp1[1] = rat;\n\tmemcpy(p1 + 2, preq, 7);\n\tmemcpy(p1 + 9, pres, 7);\n\n\t/* p2 = padding || ia || ra */\n\tmemcpy(p2, ra, 6);\n\tmemcpy(p2 + 6, ia, 6);\n\tmemset(p2 + 12, 0, 4);\n\n\t/* res = r XOR p1 */\n\tu128_xor(r, p1, res);\n\n\t/* res = e(k, res) */\n\tif (!bt_crypto_e(crypto, k, res, res))\n\t\treturn false;\n\n\t/* res = res XOR p2 */\n\tu128_xor(res, p2, res);\n\n\t/* res = e(k, res) */\n\treturn bt_crypto_e(crypto, k, res, res);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_crypto_e",
          "args": [
            "crypto",
            "k",
            "res",
            "res"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "bt_crypto_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "339-370",
          "snippet": "bool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u128_xor",
          "args": [
            "res",
            "p2",
            "res"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "u128_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "431-443",
          "snippet": "static inline void u128_xor(const uint8_t p[16], const uint8_t q[16],\n\t\t\t\t\t\t\t\tuint8_t r[16])\n{\n\tu128 pp, qq, rr;\n\n\tmemcpy(&pp, p, 16);\n\tmemcpy(&qq, q, 16);\n\n\trr.a = pp.a ^ qq.a;\n\trr.b = pp.b ^ qq.b;\n\n\tmemcpy(r, &rr, 16);\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void u128_xor(const uint8_t p[16], const uint8_t q[16],\n\t\t\t\t\t\t\t\tuint8_t r[16])\n{\n\tu128 pp, qq, rr;\n\n\tmemcpy(&pp, p, 16);\n\tmemcpy(&qq, q, 16);\n\n\trr.a = pp.a ^ qq.a;\n\trr.b = pp.b ^ qq.b;\n\n\tmemcpy(r, &rr, 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p2 + 12",
            "0",
            "4"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p2 + 6",
            "ia",
            "6"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p2",
            "ra",
            "6"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p1 + 9",
            "pres",
            "7"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p1 + 2",
            "preq",
            "7"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_c1(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\tconst uint8_t r[16], const uint8_t pres[7],\n\t\t\tconst uint8_t preq[7], uint8_t iat,\n\t\t\tconst uint8_t ia[6], uint8_t rat,\n\t\t\tconst uint8_t ra[6], uint8_t res[16])\n{\n\tuint8_t p1[16], p2[16];\n\n\t/* p1 = pres || preq || _rat || _iat */\n\tp1[0] = iat;\n\tp1[1] = rat;\n\tmemcpy(p1 + 2, preq, 7);\n\tmemcpy(p1 + 9, pres, 7);\n\n\t/* p2 = padding || ia || ra */\n\tmemcpy(p2, ra, 6);\n\tmemcpy(p2 + 6, ia, 6);\n\tmemset(p2 + 12, 0, 4);\n\n\t/* res = r XOR p1 */\n\tu128_xor(r, p1, res);\n\n\t/* res = e(k, res) */\n\tif (!bt_crypto_e(crypto, k, res, res))\n\t\treturn false;\n\n\t/* res = res XOR p2 */\n\tu128_xor(res, p2, res);\n\n\t/* res = e(k, res) */\n\treturn bt_crypto_e(crypto, k, res, res);\n}"
  },
  {
    "function_name": "u128_xor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "431-443",
    "snippet": "static inline void u128_xor(const uint8_t p[16], const uint8_t q[16],\n\t\t\t\t\t\t\t\tuint8_t r[16])\n{\n\tu128 pp, qq, rr;\n\n\tmemcpy(&pp, p, 16);\n\tmemcpy(&qq, q, 16);\n\n\trr.a = pp.a ^ qq.a;\n\trr.b = pp.b ^ qq.b;\n\n\tmemcpy(r, &rr, 16);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "&rr",
            "16"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&qq",
            "q",
            "16"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pp",
            "p",
            "16"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void u128_xor(const uint8_t p[16], const uint8_t q[16],\n\t\t\t\t\t\t\t\tuint8_t r[16])\n{\n\tu128 pp, qq, rr;\n\n\tmemcpy(&pp, p, 16);\n\tmemcpy(&qq, q, 16);\n\n\trr.a = pp.a ^ qq.a;\n\trr.b = pp.b ^ qq.b;\n\n\tmemcpy(r, &rr, 16);\n}"
  },
  {
    "function_name": "bt_crypto_ah",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "404-425",
    "snippet": "bool bt_crypto_ah(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\t\t\tconst uint8_t r[3], uint8_t hash[3])\n{\n\tuint8_t rp[16];\n\tuint8_t encrypted[16];\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* r' = padding || r */\n\tmemcpy(rp, r, 3);\n\tmemset(rp + 3, 0, 13);\n\n\t/* e(k, r') */\n\tif (!bt_crypto_e(crypto, k, rp, encrypted))\n\t\treturn false;\n\n\t/* ah(k, r) = e(k, r') mod 2^24 */\n\tmemcpy(hash, encrypted, 3);\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash",
            "encrypted",
            "3"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_crypto_e",
          "args": [
            "crypto",
            "k",
            "rp",
            "encrypted"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "bt_crypto_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "339-370",
          "snippet": "bool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rp + 3",
            "0",
            "13"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rp",
            "r",
            "3"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_ah(struct bt_crypto *crypto, const uint8_t k[16],\n\t\t\t\t\tconst uint8_t r[3], uint8_t hash[3])\n{\n\tuint8_t rp[16];\n\tuint8_t encrypted[16];\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* r' = padding || r */\n\tmemcpy(rp, r, 3);\n\tmemset(rp + 3, 0, 13);\n\n\t/* e(k, r') */\n\tif (!bt_crypto_e(crypto, k, rp, encrypted))\n\t\treturn false;\n\n\t/* ah(k, r) = e(k, r') mod 2^24 */\n\tmemcpy(hash, encrypted, 3);\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_e",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "339-370",
    "snippet": "bool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_buf",
          "args": [
            "out",
            "encrypted",
            "16"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "swap_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "258-264",
          "snippet": "static inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "alg_encrypt",
          "args": [
            "fd",
            "in",
            "16",
            "out",
            "16"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "alg_encrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "219-256",
          "snippet": "static bool alg_encrypt(int fd, const void *inbuf, size_t inlen,\n\t\t\t\t\t\tvoid *outbuf, size_t outlen)\n{\n\t__u32 alg_op = ALG_OP_ENCRYPT;\n\tchar cbuf[CMSG_SPACE(sizeof(alg_op))];\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tssize_t len;\n\n\tmemset(cbuf, 0, sizeof(cbuf));\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_ALG;\n\tcmsg->cmsg_type = ALG_SET_OP;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(alg_op));\n\tmemcpy(CMSG_DATA(cmsg), &alg_op, sizeof(alg_op));\n\n\tiov.iov_base = (void *) inbuf;\n\tiov.iov_len = inlen;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tlen = sendmsg(fd, &msg, 0);\n\tif (len < 0)\n\t\treturn false;\n\n\tlen = read(fd, outbuf, outlen);\n\tif (len < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SOL_ALG\t\t279",
            "#define ALG_OP_ENCRYPT                  1",
            "#define ALG_SET_OP                      3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_OP_ENCRYPT                  1\n#define ALG_SET_OP                      3\n\nstatic bool alg_encrypt(int fd, const void *inbuf, size_t inlen,\n\t\t\t\t\t\tvoid *outbuf, size_t outlen)\n{\n\t__u32 alg_op = ALG_OP_ENCRYPT;\n\tchar cbuf[CMSG_SPACE(sizeof(alg_op))];\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tssize_t len;\n\n\tmemset(cbuf, 0, sizeof(cbuf));\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_ALG;\n\tcmsg->cmsg_type = ALG_SET_OP;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(alg_op));\n\tmemcpy(CMSG_DATA(cmsg), &alg_op, sizeof(alg_op));\n\n\tiov.iov_base = (void *) inbuf;\n\tiov.iov_len = inlen;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tlen = sendmsg(fd, &msg, 0);\n\tif (len < 0)\n\t\treturn false;\n\n\tlen = read(fd, outbuf, outlen);\n\tif (len < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alg_new",
          "args": [
            "crypto->ecb_aes",
            "tmp",
            "16"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "alg_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "210-217",
          "snippet": "static int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SOL_ALG\t\t279",
            "#define ALG_SET_KEY                     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_SET_KEY                     1\n\nstatic int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_e(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\tconst uint8_t plaintext[16], uint8_t encrypted[16])\n{\n\tuint8_t tmp[16], in[16], out[16];\n\tint fd;\n\n\tif (!crypto)\n\t\treturn false;\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->ecb_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\n\t/* Most significant octet of plaintextData corresponds to in[0] */\n\tswap_buf(plaintext, in, 16);\n\n\tif (!alg_encrypt(fd, in, 16, out, 16)) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\t/* Most significant octet of encryptedData corresponds to out[0] */\n\tswap_buf(out, encrypted, 16);\n\n\tclose(fd);\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_sign_att",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "266-325",
    "snippet": "bool bt_crypto_sign_att(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\t\tconst uint8_t *m, uint16_t m_len,\n\t\t\t\tuint32_t sign_cnt, uint8_t signature[12])\n{\n\tint fd;\n\tint len;\n\tuint8_t tmp[16], out[16];\n\tuint16_t msg_len = m_len + sizeof(uint32_t);\n\tuint8_t msg[msg_len];\n\tuint8_t msg_s[msg_len];\n\n\tif (!crypto)\n\t\treturn false;\n\n\tmemset(msg, 0, msg_len);\n\tmemcpy(msg, m, m_len);\n\n\t/* Add sign_counter to the message */\n\tput_le32(sign_cnt, msg + m_len);\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->cmac_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\t/* Swap msg before signing */\n\tswap_buf(msg, msg_s, msg_len);\n\n\tlen = send(fd, msg_s, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tclose(fd);\n\n\t/*\n\t * As to BT spec. 4.1 Vol[3], Part C, chapter 10.4.1 sign counter should\n\t * be placed in the signature\n\t */\n\tput_be32(sign_cnt, out + 8);\n\n\t/*\n\t * The most significant octet of hash corresponds to out[0]  - swap it.\n\t * Then truncate in most significant bit first order to a length of\n\t * 12 octets\n\t */\n\tswap_buf(out, tmp, 16);\n\tmemcpy(signature, tmp + 4, 12);\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "signature",
            "tmp + 4",
            "12"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_buf",
          "args": [
            "out",
            "tmp",
            "16"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "swap_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "258-264",
          "snippet": "static inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_be32",
          "args": [
            "sign_cnt",
            "out + 8"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "put_be32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "174-177",
          "snippet": "static inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_be32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_be32(val), (uint32_t *) dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "out",
            "16"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "msg_s",
            "msg_len",
            "0"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_gw_send_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "783-810",
          "snippet": "bool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_gw_send_info(struct hfp_gw *hfp, const char *format, ...)\n{\n\tva_list ap;\n\tchar *fmt;\n\tint len;\n\n\tif (!hfp || !format)\n\t\treturn false;\n\n\tif (asprintf(&fmt, \"\\r\\n%s\\r\\n\", format) < 0)\n\t\treturn false;\n\n\tva_start(ap, format);\n\tlen = ringbuf_vprintf(hfp->write_buf, fmt, ap);\n\tva_end(ap);\n\n\tfree(fmt);\n\n\tif (len < 0)\n\t\treturn false;\n\n\tif (hfp->result_pending)\n\t\treturn true;\n\n\twakeup_writer(hfp);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alg_new",
          "args": [
            "crypto->cmac_aes",
            "tmp",
            "16"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "alg_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "210-217",
          "snippet": "static int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SOL_ALG\t\t279",
            "#define ALG_SET_KEY                     1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_SET_KEY                     1\n\nstatic int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_le32",
          "args": [
            "sign_cnt",
            "msg + m_len"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "put_le32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/util.h",
          "lines": "169-172",
          "snippet": "static inline void put_le32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_le32(val), (uint32_t *) dst);\n}",
          "includes": [
            "#include <string.h>",
            "#include <byteswap.h>",
            "#include <alloca.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <byteswap.h>\n#include <alloca.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nstatic inline void put_le32(uint32_t val, void *dst)\n{\n\tput_unaligned(cpu_to_le32(val), (uint32_t *) dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "msg",
            "m",
            "m_len"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "msg_len"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_sign_att(struct bt_crypto *crypto, const uint8_t key[16],\n\t\t\t\tconst uint8_t *m, uint16_t m_len,\n\t\t\t\tuint32_t sign_cnt, uint8_t signature[12])\n{\n\tint fd;\n\tint len;\n\tuint8_t tmp[16], out[16];\n\tuint16_t msg_len = m_len + sizeof(uint32_t);\n\tuint8_t msg[msg_len];\n\tuint8_t msg_s[msg_len];\n\n\tif (!crypto)\n\t\treturn false;\n\n\tmemset(msg, 0, msg_len);\n\tmemcpy(msg, m, m_len);\n\n\t/* Add sign_counter to the message */\n\tput_le32(sign_cnt, msg + m_len);\n\n\t/* The most significant octet of key corresponds to key[0] */\n\tswap_buf(key, tmp, 16);\n\n\tfd = alg_new(crypto->cmac_aes, tmp, 16);\n\tif (fd < 0)\n\t\treturn false;\n\n\t/* Swap msg before signing */\n\tswap_buf(msg, msg_s, msg_len);\n\n\tlen = send(fd, msg_s, msg_len, 0);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tlen = read(fd, out, 16);\n\tif (len < 0) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tclose(fd);\n\n\t/*\n\t * As to BT spec. 4.1 Vol[3], Part C, chapter 10.4.1 sign counter should\n\t * be placed in the signature\n\t */\n\tput_be32(sign_cnt, out + 8);\n\n\t/*\n\t * The most significant octet of hash corresponds to out[0]  - swap it.\n\t * Then truncate in most significant bit first order to a length of\n\t * 12 octets\n\t */\n\tswap_buf(out, tmp, 16);\n\tmemcpy(signature, tmp + 4, 12);\n\n\treturn true;\n}"
  },
  {
    "function_name": "swap_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "258-264",
    "snippet": "static inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic inline void swap_buf(const uint8_t *src, uint8_t *dst, uint16_t len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdst[len - 1 - i] = src[i];\n}"
  },
  {
    "function_name": "alg_encrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "219-256",
    "snippet": "static bool alg_encrypt(int fd, const void *inbuf, size_t inlen,\n\t\t\t\t\t\tvoid *outbuf, size_t outlen)\n{\n\t__u32 alg_op = ALG_OP_ENCRYPT;\n\tchar cbuf[CMSG_SPACE(sizeof(alg_op))];\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tssize_t len;\n\n\tmemset(cbuf, 0, sizeof(cbuf));\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_ALG;\n\tcmsg->cmsg_type = ALG_SET_OP;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(alg_op));\n\tmemcpy(CMSG_DATA(cmsg), &alg_op, sizeof(alg_op));\n\n\tiov.iov_base = (void *) inbuf;\n\tiov.iov_len = inlen;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tlen = sendmsg(fd, &msg, 0);\n\tif (len < 0)\n\t\treturn false;\n\n\tlen = read(fd, outbuf, outlen);\n\tif (len < 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SOL_ALG\t\t279",
      "#define ALG_OP_ENCRYPT                  1",
      "#define ALG_SET_OP                      3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "outbuf",
            "outlen"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "fd",
            "&msg",
            "0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CMSG_DATA(cmsg)",
            "&alg_op",
            "sizeof(alg_op)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(alg_op)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cbuf",
            "0",
            "sizeof(cbuf)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(alg_op)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_OP_ENCRYPT                  1\n#define ALG_SET_OP                      3\n\nstatic bool alg_encrypt(int fd, const void *inbuf, size_t inlen,\n\t\t\t\t\t\tvoid *outbuf, size_t outlen)\n{\n\t__u32 alg_op = ALG_OP_ENCRYPT;\n\tchar cbuf[CMSG_SPACE(sizeof(alg_op))];\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tssize_t len;\n\n\tmemset(cbuf, 0, sizeof(cbuf));\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_ALG;\n\tcmsg->cmsg_type = ALG_SET_OP;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(alg_op));\n\tmemcpy(CMSG_DATA(cmsg), &alg_op, sizeof(alg_op));\n\n\tiov.iov_base = (void *) inbuf;\n\tiov.iov_len = inlen;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tlen = sendmsg(fd, &msg, 0);\n\tif (len < 0)\n\t\treturn false;\n\n\tlen = read(fd, outbuf, outlen);\n\tif (len < 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "alg_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "210-217",
    "snippet": "static int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SOL_ALG\t\t279",
      "#define ALG_SET_KEY                     1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "fd",
            "NULL",
            "0"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "io_accept_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/sdpd-server.c",
          "lines": "193-228",
          "snippet": "static gboolean io_accept_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tGIOChannel *io;\n\tint nsk;\n\n\tif (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL))\n\t\treturn FALSE;\n\n\tif (data == &l2cap_sock) {\n\t\tstruct sockaddr_l2 addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(l2cap_sock, (struct sockaddr *) &addr, &len);\n\t} else if (data == &unix_sock) {\n\t\tstruct sockaddr_un addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(unix_sock, (struct sockaddr *) &addr, &len);\n\t} else\n\t\treturn FALSE;\n\n\tif (nsk < 0) {\n\t\terror(\"Can't accept connection: %s\", strerror(errno));\n\t\treturn TRUE;\n\t}\n\n\tio = g_io_channel_unix_new(nsk);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tg_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_session_event, data);\n\n\tg_io_channel_unref(io);\n\n\treturn TRUE;\n}",
          "includes": [
            "#include \"sdpd.h\"",
            "#include \"log.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <glib.h>",
            "#include <sys/un.h>",
            "#include <sys/stat.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int l2cap_sock = -1, unix_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sdpd.h\"\n#include \"log.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int l2cap_sock = -1, unix_sock = -1;\n\nstatic gboolean io_accept_event(GIOChannel *chan, GIOCondition cond, gpointer data)\n{\n\tGIOChannel *io;\n\tint nsk;\n\n\tif (cond & (G_IO_HUP | G_IO_ERR | G_IO_NVAL))\n\t\treturn FALSE;\n\n\tif (data == &l2cap_sock) {\n\t\tstruct sockaddr_l2 addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(l2cap_sock, (struct sockaddr *) &addr, &len);\n\t} else if (data == &unix_sock) {\n\t\tstruct sockaddr_un addr;\n\t\tsocklen_t len = sizeof(addr);\n\n\t\tnsk = accept(unix_sock, (struct sockaddr *) &addr, &len);\n\t} else\n\t\treturn FALSE;\n\n\tif (nsk < 0) {\n\t\terror(\"Can't accept connection: %s\", strerror(errno));\n\t\treturn TRUE;\n\t}\n\n\tio = g_io_channel_unix_new(nsk);\n\tg_io_channel_set_close_on_unref(io, TRUE);\n\n\tg_io_add_watch(io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,\n\t\t\t\t\tio_session_event, data);\n\n\tg_io_channel_unref(io);\n\n\treturn TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_ALG",
            "ALG_SET_KEY",
            "keyval",
            "keylen"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define SOL_ALG\t\t279\n#define ALG_SET_KEY                     1\n\nstatic int alg_new(int fd, const void *keyval, socklen_t keylen)\n{\n\tif (setsockopt(fd, SOL_ALG, ALG_SET_KEY, keyval, keylen) < 0)\n\t\treturn -1;\n\n\t/* FIXME: This should use accept4() with SOCK_CLOEXEC */\n\treturn accept(fd, NULL, 0);\n}"
  },
  {
    "function_name": "bt_crypto_random_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "195-208",
    "snippet": "bool bt_crypto_random_bytes(struct bt_crypto *crypto,\n\t\t\t\t\tvoid *buf, uint8_t num_bytes)\n{\n\tssize_t len;\n\n\tif (!crypto)\n\t\treturn false;\n\n\tlen = read(crypto->urandom, buf, num_bytes);\n\tif (len < num_bytes)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "crypto->urandom",
            "buf",
            "num_bytes"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool bt_crypto_random_bytes(struct bt_crypto *crypto,\n\t\t\t\t\tvoid *buf, uint8_t num_bytes)\n{\n\tssize_t len;\n\n\tif (!crypto)\n\t\treturn false;\n\n\tlen = read(crypto->urandom, buf, num_bytes);\n\tif (len < num_bytes)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "bt_crypto_unref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "180-193",
    "snippet": "void bt_crypto_unref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&crypto->ref_count, 1))\n\t\treturn;\n\n\tclose(crypto->urandom);\n\tclose(crypto->ecb_aes);\n\tclose(crypto->cmac_aes);\n\n\tfree(crypto);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "crypto"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "crypto->cmac_aes"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_sub_and_fetch",
          "args": [
            "&crypto->ref_count",
            "1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid bt_crypto_unref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&crypto->ref_count, 1))\n\t\treturn;\n\n\tclose(crypto->urandom);\n\tclose(crypto->ecb_aes);\n\tclose(crypto->cmac_aes);\n\n\tfree(crypto);\n}"
  },
  {
    "function_name": "bt_crypto_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "170-178",
    "snippet": "struct bt_crypto *bt_crypto_ref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&crypto->ref_count, 1);\n\n\treturn crypto;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_fetch_and_add",
          "args": [
            "&crypto->ref_count",
            "1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstruct bt_crypto *bt_crypto_ref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&crypto->ref_count, 1);\n\n\treturn crypto;\n}"
  },
  {
    "function_name": "bt_crypto_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "140-168",
    "snippet": "struct bt_crypto *bt_crypto_new(void)\n{\n\tstruct bt_crypto *crypto;\n\n\tcrypto = new0(struct bt_crypto, 1);\n\n\tcrypto->ecb_aes = ecb_aes_setup();\n\tif (crypto->ecb_aes < 0) {\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\tcrypto->urandom = urandom_setup();\n\tif (crypto->urandom < 0) {\n\t\tclose(crypto->ecb_aes);\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\tcrypto->cmac_aes = cmac_aes_setup();\n\tif (crypto->cmac_aes < 0) {\n\t\tclose(crypto->urandom);\n\t\tclose(crypto->ecb_aes);\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\treturn bt_crypto_ref(crypto);\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_crypto_ref",
          "args": [
            "crypto"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "bt_crypto_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "170-178",
          "snippet": "struct bt_crypto *bt_crypto_ref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&crypto->ref_count, 1);\n\n\treturn crypto;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstruct bt_crypto *bt_crypto_ref(struct bt_crypto *crypto)\n{\n\tif (!crypto)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&crypto->ref_count, 1);\n\n\treturn crypto;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "crypto"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "crypto->ecb_aes"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmac_aes_setup",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "cmac_aes_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "118-138",
          "snippet": "static int cmac_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"hash\");\n\tstrcpy((char *) salg.salg_name, \"cmac(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define AF_ALG\t\tPF_ALG",
            "#define PF_ALG\t\t38\t/* Algorithm sockets.  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define AF_ALG\t\tPF_ALG\n#define PF_ALG\t\t38\t/* Algorithm sockets.  */\n\nstatic int cmac_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"hash\");\n\tstrcpy((char *) salg.salg_name, \"cmac(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "urandom_setup",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "urandom_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "85-94",
          "snippet": "static int urandom_setup(void)\n{\n\tint fd;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int urandom_setup(void)\n{\n\tint fd;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecb_aes_setup",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ecb_aes_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
          "lines": "96-116",
          "snippet": "static int ecb_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"skcipher\");\n\tstrcpy((char *) salg.salg_name, \"ecb(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/if_alg.h>",
            "#include <linux/types.h>",
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/util.h\"",
            "#include <sys/socket.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define AF_ALG\t\tPF_ALG",
            "#define PF_ALG\t\t38\t/* Algorithm sockets.  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define AF_ALG\t\tPF_ALG\n#define PF_ALG\t\t38\t/* Algorithm sockets.  */\n\nstatic int ecb_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"skcipher\");\n\tstrcpy((char *) salg.salg_name, \"ecb(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new0",
          "args": [
            "structbt_crypto",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstruct bt_crypto *bt_crypto_new(void)\n{\n\tstruct bt_crypto *crypto;\n\n\tcrypto = new0(struct bt_crypto, 1);\n\n\tcrypto->ecb_aes = ecb_aes_setup();\n\tif (crypto->ecb_aes < 0) {\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\tcrypto->urandom = urandom_setup();\n\tif (crypto->urandom < 0) {\n\t\tclose(crypto->ecb_aes);\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\tcrypto->cmac_aes = cmac_aes_setup();\n\tif (crypto->cmac_aes < 0) {\n\t\tclose(crypto->urandom);\n\t\tclose(crypto->ecb_aes);\n\t\tfree(crypto);\n\t\treturn NULL;\n\t}\n\n\treturn bt_crypto_ref(crypto);\n}"
  },
  {
    "function_name": "cmac_aes_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "118-138",
    "snippet": "static int cmac_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"hash\");\n\tstrcpy((char *) salg.salg_name, \"cmac(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define AF_ALG\t\tPF_ALG",
      "#define PF_ALG\t\t38\t/* Algorithm sockets.  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "(struct sockaddr *) &salg",
            "sizeof(salg)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *) salg.salg_name",
            "\"cmac(aes)\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *) salg.salg_type",
            "\"hash\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&salg",
            "0",
            "sizeof(salg)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_ALG",
            "SOCK_SEQPACKET | SOCK_CLOEXEC",
            "0"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define AF_ALG\t\tPF_ALG\n#define PF_ALG\t\t38\t/* Algorithm sockets.  */\n\nstatic int cmac_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"hash\");\n\tstrcpy((char *) salg.salg_name, \"cmac(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "ecb_aes_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "96-116",
    "snippet": "static int ecb_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"skcipher\");\n\tstrcpy((char *) salg.salg_name, \"ecb(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define AF_ALG\t\tPF_ALG",
      "#define PF_ALG\t\t38\t/* Algorithm sockets.  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "(struct sockaddr *) &salg",
            "sizeof(salg)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *) salg.salg_name",
            "\"ecb(aes)\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *) salg.salg_type",
            "\"skcipher\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&salg",
            "0",
            "sizeof(salg)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_ALG",
            "SOCK_SEQPACKET | SOCK_CLOEXEC",
            "0"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define AF_ALG\t\tPF_ALG\n#define PF_ALG\t\t38\t/* Algorithm sockets.  */\n\nstatic int ecb_aes_setup(void)\n{\n\tstruct sockaddr_alg salg;\n\tint fd;\n\n\tfd = socket(PF_ALG, SOCK_SEQPACKET | SOCK_CLOEXEC, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&salg, 0, sizeof(salg));\n\tsalg.salg_family = AF_ALG;\n\tstrcpy((char *) salg.salg_type, \"skcipher\");\n\tstrcpy((char *) salg.salg_name, \"ecb(aes)\");\n\n\tif (bind(fd, (struct sockaddr *) &salg, sizeof(salg)) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "urandom_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/crypto.c",
    "lines": "85-94",
    "snippet": "static int urandom_setup(void)\n{\n\tint fd;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/if_alg.h>",
      "#include <linux/types.h>",
      "#include \"src/shared/crypto.h\"",
      "#include \"src/shared/util.h\"",
      "#include <sys/socket.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/if_alg.h>\n#include <linux/types.h>\n#include \"src/shared/crypto.h\"\n#include \"src/shared/util.h\"\n#include <sys/socket.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int urandom_setup(void)\n{\n\tint fd;\n\n\tfd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\n\treturn fd;\n}"
  }
]