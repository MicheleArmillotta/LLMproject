[
  {
    "function_name": "rfkill_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/rfkill.c",
    "lines": "167-174",
    "snippet": "void rfkill_exit(void)\n{\n\tif (watch == 0)\n\t\treturn;\n\n\tg_source_remove(watch);\n\twatch = 0;\n}",
    "includes": [
      "#include \"hcid.h\"",
      "#include \"adapter.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static guint watch = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_source_remove",
          "args": [
            "watch"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hcid.h\"\n#include \"adapter.h\"\n#include \"log.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <config.h>\n\nstatic guint watch = 0;\n\nvoid rfkill_exit(void)\n{\n\tif (watch == 0)\n\t\treturn;\n\n\tg_source_remove(watch);\n\twatch = 0;\n}"
  },
  {
    "function_name": "rfkill_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/rfkill.c",
    "lines": "146-165",
    "snippet": "void rfkill_init(void)\n{\n\tint fd;\n\tGIOChannel *channel;\n\n\tfd = open(\"/dev/rfkill\", O_RDWR);\n\tif (fd < 0) {\n\t\terror(\"Failed to open RFKILL control device\");\n\t\treturn;\n\t}\n\n\tchannel = g_io_channel_unix_new(fd);\n\tg_io_channel_set_close_on_unref(channel, TRUE);\n\n\twatch = g_io_add_watch(channel,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,\n\t\t\t\trfkill_event, NULL);\n\n\tg_io_channel_unref(channel);\n}",
    "includes": [
      "#include \"hcid.h\"",
      "#include \"adapter.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static guint watch = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_io_channel_unref",
          "args": [
            "channel"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_add_watch",
          "args": [
            "channel",
            "G_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR",
            "rfkill_event",
            "NULL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_set_close_on_unref",
          "args": [
            "channel",
            "TRUE"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_new",
          "args": [
            "fd"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Failed to open RFKILL control device\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "btd_error_not_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/error.c",
          "lines": "118-122",
          "snippet": "DBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}",
          "includes": [
            "#include \"error.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error.h\"\n#include \"gdbus/gdbus.h\"\n#include <config.h>\n\nDBusMessage *btd_error_not_ready(DBusMessage *msg)\n{\n\treturn g_dbus_create_error(msg, ERROR_INTERFACE \".NotReady\",\n\t\t\t\t\t\"Resource Not Ready\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/rfkill\"",
            "O_RDWR"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hcid.h\"\n#include \"adapter.h\"\n#include \"log.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <config.h>\n\nstatic guint watch = 0;\n\nvoid rfkill_init(void)\n{\n\tint fd;\n\tGIOChannel *channel;\n\n\tfd = open(\"/dev/rfkill\", O_RDWR);\n\tif (fd < 0) {\n\t\terror(\"Failed to open RFKILL control device\");\n\t\treturn;\n\t}\n\n\tchannel = g_io_channel_unix_new(fd);\n\tg_io_channel_set_close_on_unref(channel, TRUE);\n\n\twatch = g_io_add_watch(channel,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,\n\t\t\t\trfkill_event, NULL);\n\n\tg_io_channel_unref(channel);\n}"
  },
  {
    "function_name": "rfkill_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/rfkill.c",
    "lines": "69-142",
    "snippet": "static gboolean rfkill_event(GIOChannel *chan,\n\t\t\t\tGIOCondition cond, gpointer data)\n{\n\tunsigned char buf[32];\n\tstruct rfkill_event *event = (void *) buf;\n\tstruct btd_adapter *adapter;\n\tchar sysname[PATH_MAX];\n\tssize_t len;\n\tint fd, id;\n\n\tif (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))\n\t\treturn FALSE;\n\n\tfd = g_io_channel_unix_get_fd(chan);\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tlen = read(fd, buf, sizeof(buf));\n\tif (len < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t}\n\n\tif (len != sizeof(struct rfkill_event))\n\t\treturn TRUE;\n\n\tDBG(\"RFKILL event idx %u type %u op %u soft %u hard %u\",\n\t\t\t\t\tevent->idx, event->type, event->op,\n\t\t\t\t\t\tevent->soft, event->hard);\n\n\tif (event->soft || event->hard)\n\t\treturn TRUE;\n\n\tif (event->op != RFKILL_OP_CHANGE)\n\t\treturn TRUE;\n\n\tif (event->type != RFKILL_TYPE_BLUETOOTH &&\n\t\t\t\t\tevent->type != RFKILL_TYPE_ALL)\n\t\treturn TRUE;\n\n\tsnprintf(sysname, sizeof(sysname) - 1,\n\t\t\t\"/sys/class/rfkill/rfkill%u/name\", event->idx);\n\n\tfd = open(sysname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn TRUE;\n\n\tmemset(sysname, 0, sizeof(sysname));\n\n\tif (read(fd, sysname, sizeof(sysname) - 1) < 4) {\n\t\tclose(fd);\n\t\treturn TRUE;\n\t}\n\n\tclose(fd);\n\n\tif (g_str_has_prefix(sysname, \"hci\") == FALSE)\n\t\treturn TRUE;\n\n\tid = atoi(sysname + 3);\n\tif (id < 0)\n\t\treturn TRUE;\n\n\tadapter = adapter_find_by_id(id);\n\tif (!adapter)\n\t\treturn TRUE;\n\n\tDBG(\"RFKILL unblock for hci%d\", id);\n\n\tbtd_adapter_restore_powered(adapter);\n\n\treturn TRUE;\n}",
    "includes": [
      "#include \"hcid.h\"",
      "#include \"adapter.h\"",
      "#include \"log.h\"",
      "#include \"lib/sdp.h\"",
      "#include \"lib/bluetooth.h\"",
      "#include <glib.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <errno.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btd_adapter_restore_powered",
          "args": [
            "adapter"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "btd_adapter_restore_powered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/adapter.c",
          "lines": "6642-6650",
          "snippet": "int btd_adapter_restore_powered(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_POWERED)\n\t\treturn 0;\n\n\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x01);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"eir.h\"",
            "#include \"advertising.h\"",
            "#include \"gatt-database.h\"",
            "#include \"attrib-server.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"storage.h\"",
            "#include \"agent.h\"",
            "#include \"uuid-helper.h\"",
            "#include \"error.h\"",
            "#include \"dbus-common.h\"",
            "#include \"profile.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"sdpd.h\"",
            "#include \"hcid.h\"",
            "#include \"btio/btio.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/mgmt.h\"",
            "#include \"textfile.h\"",
            "#include \"log.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include \"lib/mgmt.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"bluetooth/sdp_lib.h\"",
            "#include \"bluetooth/sdp.h\"",
            "#include \"bluetooth/hci_lib.h\"",
            "#include \"bluetooth/hci.h\"",
            "#include \"bluetooth/bluetooth.h\"",
            "#include <dbus/dbus.h>",
            "#include <glib.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/ioctl.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <inttypes.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void trigger_pairable_timeout(struct btd_adapter *adapter);",
            "static void adapter_start(struct btd_adapter *adapter);",
            "static void adapter_stop(struct btd_adapter *adapter);",
            "static void trigger_passive_scanning(struct btd_adapter *adapter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"eir.h\"\n#include \"advertising.h\"\n#include \"gatt-database.h\"\n#include \"attrib-server.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"storage.h\"\n#include \"agent.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"profile.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"sdpd.h\"\n#include \"hcid.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/mgmt.h\"\n#include \"textfile.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/mgmt.h\"\n#include \"lib/uuid.h\"\n#include \"bluetooth/sdp_lib.h\"\n#include \"bluetooth/sdp.h\"\n#include \"bluetooth/hci_lib.h\"\n#include \"bluetooth/hci.h\"\n#include \"bluetooth/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter);\nstatic void adapter_start(struct btd_adapter *adapter);\nstatic void adapter_stop(struct btd_adapter *adapter);\nstatic void trigger_passive_scanning(struct btd_adapter *adapter);\n\nint btd_adapter_restore_powered(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_POWERED)\n\t\treturn 0;\n\n\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x01);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"RFKILL unblock for hci%d\"",
            "id"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adapter_find_by_id",
          "args": [
            "id"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "adapter_find_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/adapter.c",
          "lines": "8013-8023",
          "snippet": "struct btd_adapter *adapter_find_by_id(int id)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, GINT_TO_POINTER(id),\n\t\t\t\t\t\t\tadapter_id_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}",
          "includes": [
            "#include \"eir.h\"",
            "#include \"advertising.h\"",
            "#include \"gatt-database.h\"",
            "#include \"attrib-server.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"storage.h\"",
            "#include \"agent.h\"",
            "#include \"uuid-helper.h\"",
            "#include \"error.h\"",
            "#include \"dbus-common.h\"",
            "#include \"profile.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"sdpd.h\"",
            "#include \"hcid.h\"",
            "#include \"btio/btio.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/mgmt.h\"",
            "#include \"textfile.h\"",
            "#include \"log.h\"",
            "#include \"gdbus/gdbus.h\"",
            "#include \"lib/mgmt.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"bluetooth/sdp_lib.h\"",
            "#include \"bluetooth/sdp.h\"",
            "#include \"bluetooth/hci_lib.h\"",
            "#include \"bluetooth/hci.h\"",
            "#include \"bluetooth/bluetooth.h\"",
            "#include <dbus/dbus.h>",
            "#include <glib.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/ioctl.h>",
            "#include <stdbool.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <inttypes.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static GSList *adapters = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"eir.h\"\n#include \"advertising.h\"\n#include \"gatt-database.h\"\n#include \"attrib-server.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"storage.h\"\n#include \"agent.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"profile.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"sdpd.h\"\n#include \"hcid.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/mgmt.h\"\n#include \"textfile.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/mgmt.h\"\n#include \"lib/uuid.h\"\n#include \"bluetooth/sdp_lib.h\"\n#include \"bluetooth/sdp.h\"\n#include \"bluetooth/hci_lib.h\"\n#include \"bluetooth/hci.h\"\n#include \"bluetooth/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic GSList *adapters = NULL;\n\nstruct btd_adapter *adapter_find_by_id(int id)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, GINT_TO_POINTER(id),\n\t\t\t\t\t\t\tadapter_id_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "sysname + 3"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_str_has_prefix",
          "args": [
            "sysname",
            "\"hci\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "sysname",
            "sizeof(sysname) - 1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "read_device_ccc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/attrib-server.c",
          "lines": "763-795",
          "snippet": "static int read_device_ccc(struct btd_device *device, uint16_t handle,\n\t\t\t\tuint16_t *value)\n{\n\tchar *filename;\n\tGKeyFile *key_file;\n\tchar group[6];\n\tchar *str;\n\tunsigned int config;\n\tint err = 0;\n\n\tfilename = btd_device_get_storage_path(device, \"ccc\");\n\tif (!filename) {\n\t\twarn(\"Unable to get ccc storage path for device\");\n\t\treturn -ENOENT;\n\t}\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\n\tstr = g_key_file_get_string(key_file, group, \"Value\", NULL);\n\tif (!str || sscanf(str, \"%04X\", &config) != 1)\n\t\terr = -ENOENT;\n\telse\n\t\t*value = config;\n\n\tg_free(str);\n\tg_free(filename);\n\tg_key_file_free(key_file);\n\n\treturn err;\n}",
          "includes": [
            "#include \"attrib-server.h\"",
            "#include \"storage.h\"",
            "#include \"textfile.h\"",
            "#include \"attrib/att-database.h\"",
            "#include \"attrib/gatt.h\"",
            "#include \"attrib/att.h\"",
            "#include \"attrib/gattrib.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"device.h\"",
            "#include \"adapter.h\"",
            "#include \"backtrace.h\"",
            "#include \"log.h\"",
            "#include \"btio/btio.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/sdp_lib.h\"",
            "#include \"lib/sdp.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include <sys/stat.h>",
            "#include <glib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "#include <errno.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"attrib-server.h\"\n#include \"storage.h\"\n#include \"textfile.h\"\n#include \"attrib/att-database.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"src/shared/util.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"backtrace.h\"\n#include \"log.h\"\n#include \"btio/btio.h\"\n#include \"lib/uuid.h\"\n#include \"lib/sdp_lib.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <sys/stat.h>\n#include <glib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <errno.h>\n#include <config.h>\n\nstatic int read_device_ccc(struct btd_device *device, uint16_t handle,\n\t\t\t\tuint16_t *value)\n{\n\tchar *filename;\n\tGKeyFile *key_file;\n\tchar group[6];\n\tchar *str;\n\tunsigned int config;\n\tint err = 0;\n\n\tfilename = btd_device_get_storage_path(device, \"ccc\");\n\tif (!filename) {\n\t\twarn(\"Unable to get ccc storage path for device\");\n\t\treturn -ENOENT;\n\t}\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\n\tstr = g_key_file_get_string(key_file, group, \"Value\", NULL);\n\tif (!str || sscanf(str, \"%04X\", &config) != 1)\n\t\terr = -ENOENT;\n\telse\n\t\t*value = config;\n\n\tg_free(str);\n\tg_free(filename);\n\tg_key_file_free(key_file);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sysname",
            "0",
            "sizeof(sysname)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "sysname",
            "O_RDONLY"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sysname",
            "sizeof(sysname) - 1",
            "\"/sys/class/rfkill/rfkill%u/name\"",
            "event->idx"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"RFKILL event idx %u type %u op %u soft %u hard %u\"",
            "event->idx",
            "event->type",
            "event->op",
            "event->soft",
            "event->hard"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_io_channel_unix_get_fd",
          "args": [
            "chan"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hcid.h\"\n#include \"adapter.h\"\n#include \"log.h\"\n#include \"lib/sdp.h\"\n#include \"lib/bluetooth.h\"\n#include <glib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <config.h>\n\nstatic gboolean rfkill_event(GIOChannel *chan,\n\t\t\t\tGIOCondition cond, gpointer data)\n{\n\tunsigned char buf[32];\n\tstruct rfkill_event *event = (void *) buf;\n\tstruct btd_adapter *adapter;\n\tchar sysname[PATH_MAX];\n\tssize_t len;\n\tint fd, id;\n\n\tif (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))\n\t\treturn FALSE;\n\n\tfd = g_io_channel_unix_get_fd(chan);\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tlen = read(fd, buf, sizeof(buf));\n\tif (len < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t}\n\n\tif (len != sizeof(struct rfkill_event))\n\t\treturn TRUE;\n\n\tDBG(\"RFKILL event idx %u type %u op %u soft %u hard %u\",\n\t\t\t\t\tevent->idx, event->type, event->op,\n\t\t\t\t\t\tevent->soft, event->hard);\n\n\tif (event->soft || event->hard)\n\t\treturn TRUE;\n\n\tif (event->op != RFKILL_OP_CHANGE)\n\t\treturn TRUE;\n\n\tif (event->type != RFKILL_TYPE_BLUETOOTH &&\n\t\t\t\t\tevent->type != RFKILL_TYPE_ALL)\n\t\treturn TRUE;\n\n\tsnprintf(sysname, sizeof(sysname) - 1,\n\t\t\t\"/sys/class/rfkill/rfkill%u/name\", event->idx);\n\n\tfd = open(sysname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn TRUE;\n\n\tmemset(sysname, 0, sizeof(sysname));\n\n\tif (read(fd, sysname, sizeof(sysname) - 1) < 4) {\n\t\tclose(fd);\n\t\treturn TRUE;\n\t}\n\n\tclose(fd);\n\n\tif (g_str_has_prefix(sysname, \"hci\") == FALSE)\n\t\treturn TRUE;\n\n\tid = atoi(sysname + 3);\n\tif (id < 0)\n\t\treturn TRUE;\n\n\tadapter = adapter_find_by_id(id);\n\tif (!adapter)\n\t\treturn TRUE;\n\n\tDBG(\"RFKILL unblock for hci%d\", id);\n\n\tbtd_adapter_restore_powered(adapter);\n\n\treturn TRUE;\n}"
  }
]