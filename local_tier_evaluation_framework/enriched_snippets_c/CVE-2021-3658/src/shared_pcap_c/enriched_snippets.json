[
  {
    "function_name": "pcap_read_ppi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "181-233",
    "snippet": "bool pcap_read_ppi(struct pcap *pcap, struct timeval *tv, uint32_t *type,\n\t\t\t\t\tvoid *data, uint32_t size,\n\t\t\t\t\tuint32_t *offset, uint32_t *len)\n{\n\tstruct pcap_pkt pkt;\n\tstruct pcap_ppi ppi;\n\tuint16_t pph_len;\n\tuint32_t toread;\n\tssize_t bytes_read;\n\n\tif (!pcap)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, &pkt, PCAP_PKT_SIZE);\n\tif (bytes_read != PCAP_PKT_SIZE)\n\t\treturn false;\n\n\tif (pkt.incl_len > size)\n\t\ttoread = size;\n\telse\n\t\ttoread = pkt.incl_len;\n\n\tbytes_read = read(pcap->fd, &ppi, PCAP_PPI_SIZE);\n\tif (bytes_read != PCAP_PPI_SIZE)\n\t\treturn false;\n\n\tif (ppi.flags)\n\t\treturn false;\n\n\tpph_len = le16_to_cpu(ppi.len);\n\tif (pph_len < PCAP_PPI_SIZE)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, data, toread - PCAP_PPI_SIZE);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tif (tv) {\n\t\ttv->tv_sec = pkt.ts_sec;\n\t\ttv->tv_usec = pkt.ts_usec;\n\t}\n\n\tif (type)\n\t\t*type = le32_to_cpu(ppi.dlt);\n\n\tif (offset)\n\t\t*offset = pph_len - PCAP_PPI_SIZE;\n\n\tif (len)\n\t\t*len = toread - pph_len;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCAP_PPI_SIZE (sizeof(struct pcap_ppi))",
      "#define PCAP_PKT_SIZE (sizeof(struct pcap_pkt))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ppi.dlt"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pcap->fd",
            "data",
            "toread - PCAP_PPI_SIZE"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ppi.len"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define PCAP_PPI_SIZE (sizeof(struct pcap_ppi))\n#define PCAP_PKT_SIZE (sizeof(struct pcap_pkt))\n\nbool pcap_read_ppi(struct pcap *pcap, struct timeval *tv, uint32_t *type,\n\t\t\t\t\tvoid *data, uint32_t size,\n\t\t\t\t\tuint32_t *offset, uint32_t *len)\n{\n\tstruct pcap_pkt pkt;\n\tstruct pcap_ppi ppi;\n\tuint16_t pph_len;\n\tuint32_t toread;\n\tssize_t bytes_read;\n\n\tif (!pcap)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, &pkt, PCAP_PKT_SIZE);\n\tif (bytes_read != PCAP_PKT_SIZE)\n\t\treturn false;\n\n\tif (pkt.incl_len > size)\n\t\ttoread = size;\n\telse\n\t\ttoread = pkt.incl_len;\n\n\tbytes_read = read(pcap->fd, &ppi, PCAP_PPI_SIZE);\n\tif (bytes_read != PCAP_PPI_SIZE)\n\t\treturn false;\n\n\tif (ppi.flags)\n\t\treturn false;\n\n\tpph_len = le16_to_cpu(ppi.len);\n\tif (pph_len < PCAP_PPI_SIZE)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, data, toread - PCAP_PPI_SIZE);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tif (tv) {\n\t\ttv->tv_sec = pkt.ts_sec;\n\t\ttv->tv_usec = pkt.ts_usec;\n\t}\n\n\tif (type)\n\t\t*type = le32_to_cpu(ppi.dlt);\n\n\tif (offset)\n\t\t*offset = pph_len - PCAP_PPI_SIZE;\n\n\tif (len)\n\t\t*len = toread - pph_len;\n\n\treturn true;\n}"
  },
  {
    "function_name": "pcap_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "147-179",
    "snippet": "bool pcap_read(struct pcap *pcap, struct timeval *tv,\n\t\t\t\tvoid *data, uint32_t size, uint32_t *len)\n{\n\tstruct pcap_pkt pkt;\n\tuint32_t toread;\n\tssize_t bytes_read;\n\n\tif (!pcap)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, &pkt, PCAP_PKT_SIZE);\n\tif (bytes_read != PCAP_PKT_SIZE)\n\t\treturn false;\n\n\tif (pkt.incl_len > size)\n\t\ttoread = size;\n\telse\n\t\ttoread = pkt.incl_len;\n\n\tbytes_read = read(pcap->fd, data, toread);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tif (tv) {\n\t\ttv->tv_sec = pkt.ts_sec;\n\t\ttv->tv_usec = pkt.ts_usec;\n\t}\n\n\tif (len)\n\t\t*len = toread;\n\n\treturn true;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCAP_PKT_SIZE (sizeof(struct pcap_pkt))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pcap->fd",
            "data",
            "toread"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define PCAP_PKT_SIZE (sizeof(struct pcap_pkt))\n\nbool pcap_read(struct pcap *pcap, struct timeval *tv,\n\t\t\t\tvoid *data, uint32_t size, uint32_t *len)\n{\n\tstruct pcap_pkt pkt;\n\tuint32_t toread;\n\tssize_t bytes_read;\n\n\tif (!pcap)\n\t\treturn false;\n\n\tbytes_read = read(pcap->fd, &pkt, PCAP_PKT_SIZE);\n\tif (bytes_read != PCAP_PKT_SIZE)\n\t\treturn false;\n\n\tif (pkt.incl_len > size)\n\t\ttoread = size;\n\telse\n\t\ttoread = pkt.incl_len;\n\n\tbytes_read = read(pcap->fd, data, toread);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tif (tv) {\n\t\ttv->tv_sec = pkt.ts_sec;\n\t\ttv->tv_usec = pkt.ts_usec;\n\t}\n\n\tif (len)\n\t\t*len = toread;\n\n\treturn true;\n}"
  },
  {
    "function_name": "pcap_get_snaplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "139-145",
    "snippet": "uint32_t pcap_get_snaplen(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn 0;\n\n\treturn pcap->snaplen;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nuint32_t pcap_get_snaplen(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn 0;\n\n\treturn pcap->snaplen;\n}"
  },
  {
    "function_name": "pcap_get_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "131-137",
    "snippet": "uint32_t pcap_get_type(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn PCAP_TYPE_INVALID;\n\n\treturn pcap->type;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nuint32_t pcap_get_type(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn PCAP_TYPE_INVALID;\n\n\treturn pcap->type;\n}"
  },
  {
    "function_name": "pcap_unref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "117-129",
    "snippet": "void pcap_unref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&pcap->ref_count, 1))\n\t\treturn;\n\n\tif (pcap->fd >= 0)\n\t\tclose(pcap->fd);\n\n\tfree(pcap);\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pcap"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pcap->fd"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_sub_and_fetch",
          "args": [
            "&pcap->ref_count",
            "1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid pcap_unref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&pcap->ref_count, 1))\n\t\treturn;\n\n\tif (pcap->fd >= 0)\n\t\tclose(pcap->fd);\n\n\tfree(pcap);\n}"
  },
  {
    "function_name": "pcap_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "107-115",
    "snippet": "struct pcap *pcap_ref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&pcap->ref_count, 1);\n\n\treturn pcap;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_fetch_and_add",
          "args": [
            "&pcap->ref_count",
            "1"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstruct pcap *pcap_ref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&pcap->ref_count, 1);\n\n\treturn pcap;\n}"
  },
  {
    "function_name": "pcap_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
    "lines": "69-105",
    "snippet": "struct pcap *pcap_open(const char *path)\n{\n\tstruct pcap *pcap;\n\tstruct pcap_hdr hdr;\n\tssize_t len;\n\n\tpcap = calloc(1, sizeof(*pcap));\n\tif (!pcap)\n\t\treturn NULL;\n\n\tpcap->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (pcap->fd < 0) {\n\t\tfree(pcap);\n\t\treturn NULL;\n\t}\n\n\tlen = read(pcap->fd, &hdr, PCAP_HDR_SIZE);\n\tif (len < 0 || len != PCAP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (hdr.magic_number != 0xa1b2c3d4)\n\t\tgoto failed;\n\n\tif (hdr.version_major != 2 || hdr.version_minor != 4)\n\t\tgoto failed;\n\n\tpcap->snaplen = hdr.snaplen;\n\tpcap->type = hdr.network;\n\n\treturn pcap_ref(pcap);\n\nfailed:\n\tclose(pcap->fd);\n\tfree(pcap);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/shared/pcap.h\"",
      "#include \"src/shared/util.h\"",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCAP_HDR_SIZE (sizeof(struct pcap_hdr))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pcap"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "bt_att_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/att.c",
          "lines": "956-985",
          "snippet": "static void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}",
          "includes": [
            "#include \"src/shared/crypto.h\"",
            "#include \"src/shared/att.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/l2cap.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/timeout.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/io.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/crypto.h\"\n#include \"src/shared/att.h\"\n#include \"lib/uuid.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/timeout.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/io.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tif (att->pending_req)\n\t\tdestroy_att_send_op(att->pending_req);\n\n\tif (att->pending_ind)\n\t\tdestroy_att_send_op(att->pending_ind);\n\n\tio_destroy(att->io);\n\tbt_crypto_unref(att->crypto);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tfree(att->buf);\n\n\tfree(att);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pcap->fd"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "hfp_context_close_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/hfp.c",
          "lines": "334-347",
          "snippet": "bool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}",
          "includes": [
            "#include \"src/shared/hfp.h\"",
            "#include \"src/shared/io.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/ringbuf.h\"",
            "#include \"src/shared/util.h\"",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/hfp.h\"\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/ringbuf.h\"\n#include \"src/shared/util.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <config.h>\n\nbool hfp_context_close_container(struct hfp_context *context)\n{\n\tskip_whitespace(context);\n\n\t/* The list shall be followed by a right parenthesis (\")\" V250 5.7.3.1*/\n\tif (context->data[context->offset] != ')')\n\t\treturn false;\n\n\tcontext->offset++;\n\n\tnext_field(context);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcap_ref",
          "args": [
            "pcap"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "pcap_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/pcap.c",
          "lines": "107-115",
          "snippet": "struct pcap *pcap_ref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&pcap->ref_count, 1);\n\n\treturn pcap;\n}",
          "includes": [
            "#include \"src/shared/pcap.h\"",
            "#include \"src/shared/util.h\"",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstruct pcap *pcap_ref(struct pcap *pcap)\n{\n\tif (!pcap)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&pcap->ref_count, 1);\n\n\treturn pcap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pcap->fd",
            "&hdr",
            "PCAP_HDR_SIZE"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "notify_client_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/gatt-client.c",
          "lines": "1221-1250",
          "snippet": "static void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <assert.h>",
            "#include \"src/shared/gatt-client.h\"",
            "#include \"src/shared/gatt-db.h\"",
            "#include \"src/shared/queue.h\"",
            "#include \"src/shared/util.h\"",
            "#include \"src/shared/gatt-helpers.h\"",
            "#include \"lib/uuid.h\"",
            "#include \"lib/bluetooth.h\"",
            "#include \"src/shared/att.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <assert.h>\n#include \"src/shared/gatt-client.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"lib/uuid.h\"\n#include \"lib/bluetooth.h\"\n#include \"src/shared/att.h\"\n#include <config.h>\n\nstatic void notify_client_ready(struct bt_gatt_client *client, bool success,\n\t\t\t\t\t\t\tuint8_t att_ecode)\n{\n\tconst struct queue_entry *entry;\n\n\tif (client->ready)\n\t\treturn;\n\n\tbt_gatt_client_ref(client);\n\tclient->ready = success;\n\n\tfor (entry = queue_get_entries(client->ready_cbs); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct ready_cb *ready = entry->data;\n\n\t\tready->callback(success, att_ecode, ready->data);\n\t}\n\n\tqueue_remove_all(client->ready_cbs, NULL, NULL, ready_destroy);\n\n\t/* Notify clones */\n\tfor (entry = queue_get_entries(client->clones); entry;\n\t\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_gatt_client *clone = entry->data;\n\n\t\tnotify_client_ready(clone, success, att_ecode);\n\t}\n\n\tbt_gatt_client_unref(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "btsnoop_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/shared/btsnoop.c",
          "lines": "85-139",
          "snippet": "struct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/shared/btsnoop.h\"",
            "#include <sys/stat.h>",
            "#include <arpa/inet.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <endian.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))"
          ],
          "globals_used": [
            "static const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };",
            "static const uint32_t btsnoop_version = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/shared/btsnoop.h\"\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <endian.h>\n#include <config.h>\n\n#define BTSNOOP_HDR_SIZE (sizeof(struct btsnoop_hdr))\n\nstatic const uint8_t btsnoop_id[] = { 0x62, 0x74, 0x73, 0x6e,\n\t\t\t\t      0x6f, 0x6f, 0x70, 0x00 };\nstatic const uint32_t btsnoop_version = 1;\n\nstruct btsnoop *btsnoop_open(const char *path, unsigned long flags)\n{\n\tstruct btsnoop *btsnoop;\n\tstruct btsnoop_hdr hdr;\n\tssize_t len;\n\n\tbtsnoop = calloc(1, sizeof(*btsnoop));\n\tif (!btsnoop)\n\t\treturn NULL;\n\n\tbtsnoop->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (btsnoop->fd < 0) {\n\t\tfree(btsnoop);\n\t\treturn NULL;\n\t}\n\n\tbtsnoop->flags = flags;\n\n\tlen = read(btsnoop->fd, &hdr, BTSNOOP_HDR_SIZE);\n\tif (len < 0 || len != BTSNOOP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (!memcmp(hdr.id, btsnoop_id, sizeof(btsnoop_id))) {\n\t\t/* Check for BTSnoop version 1 format */\n\t\tif (be32toh(hdr.version) != btsnoop_version)\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = be32toh(hdr.type);\n\t\tbtsnoop->index = 0xffff;\n\t} else {\n\t\tif (!(btsnoop->flags & BTSNOOP_FLAG_PKLG_SUPPORT))\n\t\t\tgoto failed;\n\n\t\t/* Check for Apple Packet Logger format */\n\t\tif (hdr.id[0] != 0x00 ||\n\t\t\t\t(hdr.id[1] != 0x00 && hdr.id[1] != 0x01))\n\t\t\tgoto failed;\n\n\t\tbtsnoop->format = BTSNOOP_FORMAT_MONITOR;\n\t\tbtsnoop->index = 0xffff;\n\t\tbtsnoop->pklg_format = true;\n\t\tbtsnoop->pklg_v2 = (hdr.id[1] == 0x01);\n\n\t\t/* Apple Packet Logger format has no header */\n\t\tlseek(btsnoop->fd, 0, SEEK_SET);\n\t}\n\n\treturn btsnoop_ref(btsnoop);\n\nfailed:\n\tclose(btsnoop->fd);\n\tfree(btsnoop);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*pcap)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/shared/pcap.h\"\n#include \"src/shared/util.h\"\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define PCAP_HDR_SIZE (sizeof(struct pcap_hdr))\n\nstruct pcap *pcap_open(const char *path)\n{\n\tstruct pcap *pcap;\n\tstruct pcap_hdr hdr;\n\tssize_t len;\n\n\tpcap = calloc(1, sizeof(*pcap));\n\tif (!pcap)\n\t\treturn NULL;\n\n\tpcap->fd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (pcap->fd < 0) {\n\t\tfree(pcap);\n\t\treturn NULL;\n\t}\n\n\tlen = read(pcap->fd, &hdr, PCAP_HDR_SIZE);\n\tif (len < 0 || len != PCAP_HDR_SIZE)\n\t\tgoto failed;\n\n\tif (hdr.magic_number != 0xa1b2c3d4)\n\t\tgoto failed;\n\n\tif (hdr.version_major != 2 || hdr.version_minor != 4)\n\t\tgoto failed;\n\n\tpcap->snaplen = hdr.snaplen;\n\tpcap->type = hdr.network;\n\n\treturn pcap_ref(pcap);\n\nfailed:\n\tclose(pcap->fd);\n\tfree(pcap);\n\n\treturn NULL;\n}"
  }
]