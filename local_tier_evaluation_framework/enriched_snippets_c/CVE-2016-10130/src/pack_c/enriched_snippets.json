[
  {
    "function_name": "git_pack_entry_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1367-1401",
    "snippet": "int git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&e->sha1",
            "&found_oid"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_open",
          "args": [
            "p"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1009-1088",
          "snippet": "static int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find_offset",
          "args": [
            "&offset",
            "&found_oid",
            "p",
            "short_oid",
            "len"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1263-1365",
          "snippet": "static int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"bad object found in packfile\""
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "short_oid",
            "&p->bad_object_sha1[i]"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_pack_entry_find(\n\t\tstruct git_pack_entry *e,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len)\n{\n\tgit_off_t offset;\n\tgit_oid found_oid;\n\tint error;\n\n\tassert(p);\n\n\tif (len == GIT_OID_HEXSZ && p->num_bad_objects) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (git_oid__cmp(short_oid, &p->bad_object_sha1[i]) == 0)\n\t\t\t\treturn packfile_error(\"bad object found in packfile\");\n\t}\n\n\terror = pack_entry_find_offset(&offset, &found_oid, p, short_oid, len);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* we found a unique entry in the index;\n\t * make sure the packfile backing the index\n\t * still exists on disk */\n\tif (p->mwf.fd == -1 && (error = packfile_open(p)) < 0)\n\t\treturn error;\n\n\te->offset = offset;\n\te->p = p;\n\n\tgit_oid_cpy(&e->sha1, &found_oid);\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_entry_find_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1263-1365",
    "snippet": "static int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"found lo=%d %s\\n\"",
            "lo",
            "hex_sha1"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "hex_sha1",
            "found_oid"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "found_oid",
            "current"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"packfile index is corrupt\""
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nth_packed_object_offset",
          "args": [
            "p",
            "pos"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "nth_packed_object_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1176-1198",
          "snippet": "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_map.data;\n\tconst unsigned char *end = index + p->index_map.len;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + 24 * n)));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += 8 + p->num_objects * (20 + 4);\n\t\toff = ntohl(*((uint32_t *)(index + 4 * n)));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += p->num_objects * 4 + (off & 0x7fffffff) * 8;\n\n\t\t/* Make sure we're not being sent out of bounds */\n\t\tif (index >= end - 8)\n\t\t\treturn -1;\n\n\t\treturn (((uint64_t)ntohl(*((uint32_t *)(index + 0)))) << 32) |\n\t\t\t\t\tntohl(*((uint32_t *)(index + 4)));\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_map.data;\n\tconst unsigned char *end = index + p->index_map.len;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + 24 * n)));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += 8 + p->num_objects * (20 + 4);\n\t\toff = ntohl(*((uint32_t *)(index + 4 * n)));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += p->num_objects * 4 + (off & 0x7fffffff) * 8;\n\n\t\t/* Make sure we're not being sent out of bounds */\n\t\tif (index >= end - 8)\n\t\t\treturn -1;\n\n\t\treturn (((uint64_t)ntohl(*((uint32_t *)(index + 0)))) << 32) |\n\t\t\t\t\tntohl(*((uint32_t *)(index + 4)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_ambiguous",
          "args": [
            "\"found multiple offsets for pack entry\""
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_ambiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1234-1238",
          "snippet": "int git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_ambiguous(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Ambiguous SHA1 prefix - %s\", message);\n\treturn GIT_EAMBIGUOUS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"failed to find offset for pack entry\"",
            "short_oid",
            "len"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_ncmp",
          "args": [
            "short_oid",
            "(const git_oid *)next",
            "len"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_ncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "189-210",
          "snippet": "int git_oid_ncmp(const git_oid *oid_a, const git_oid *oid_b, size_t len)\n{\n\tconst unsigned char *a = oid_a->id;\n\tconst unsigned char *b = oid_b->id;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\twhile (len > 1) {\n\t\tif (*a != *b)\n\t\t\treturn 1;\n\t\ta++;\n\t\tb++;\n\t\tlen -= 2;\n\t};\n\n\tif (len)\n\t\tif ((*a ^ *b) & 0xf0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_ncmp(const git_oid *oid_a, const git_oid *oid_b, size_t len)\n{\n\tconst unsigned char *a = oid_a->id;\n\tconst unsigned char *b = oid_b->id;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\twhile (len > 1) {\n\t\tif (*a != *b)\n\t\t\treturn 1;\n\t\ta++;\n\t\tb++;\n\t\tlen -= 2;\n\t};\n\n\tif (len)\n\t\tif ((*a ^ *b) & 0xf0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sha1_position",
          "args": [
            "index",
            "stride",
            "lo",
            "hi",
            "short_oid->id"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sha1_lookup.c",
          "lines": "228-249",
          "snippet": "int sha1_position(const void *table,\n\t\t\tsize_t stride,\n\t\t\tunsigned lo, unsigned hi,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = table;\n\n\tdo {\n\t\tunsigned mi = (lo + hi) / 2;\n\t\tint cmp = git_oid__hashcmp(base + mi * stride, key);\n\n\t\tif (!cmp)\n\t\t\treturn mi;\n\n\t\tif (cmp > 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t} while (lo < hi);\n\n\treturn -((int)lo)-1;\n}",
          "includes": [
            "#include \"oid.h\"",
            "#include \"common.h\"",
            "#include \"sha1_lookup.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oid.h\"\n#include \"common.h\"\n#include \"sha1_lookup.h\"\n#include <stdio.h>\n\nint sha1_position(const void *table,\n\t\t\tsize_t stride,\n\t\t\tunsigned lo, unsigned hi,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = table;\n\n\tdo {\n\t\tunsigned mi = (lo + hi) / 2;\n\t\tint cmp = git_oid__hashcmp(base + mi * stride, key);\n\n\t\tif (!cmp)\n\t\t\treturn mi;\n\n\t\tif (cmp > 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t} while (lo < hi);\n\n\treturn -((int)lo)-1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sha1_entry_pos",
          "args": [
            "index",
            "stride",
            "0",
            "lo",
            "hi",
            "p->num_objects",
            "short_oid->id"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_entry_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sha1_lookup.c",
          "lines": "76-226",
          "snippet": "int sha1_entry_pos(const void *table,\n\t\t\tsize_t elem_size,\n\t\t\tsize_t key_offset,\n\t\t\tunsigned lo, unsigned hi, unsigned nr,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = (const unsigned char*)table;\n\tconst unsigned char *hi_key, *lo_key;\n\tunsigned ofs_0;\n\n\tif (!nr || lo >= hi)\n\t\treturn -1;\n\n\tif (nr == hi)\n\t\thi_key = NULL;\n\telse\n\t\thi_key = base + elem_size * hi + key_offset;\n\tlo_key = base + elem_size * lo + key_offset;\n\n\tofs_0 = 0;\n\tdo {\n\t\tint cmp;\n\t\tunsigned ofs, mi, range;\n\t\tunsigned lov, hiv, kyv;\n\t\tconst unsigned char *mi_key;\n\n\t\trange = hi - lo;\n\t\tif (hi_key) {\n\t\t\tfor (ofs = ofs_0; ofs < 20; ofs++)\n\t\t\t\tif (lo_key[ofs] != hi_key[ofs])\n\t\t\t\t\tbreak;\n\t\t\tofs_0 = ofs;\n\t\t\t/*\n\t\t\t * byte 0 thru (ofs-1) are the same between\n\t\t\t * lo and hi; ofs is the first byte that is\n\t\t\t * different.\n\t\t\t *\n\t\t\t * If ofs==20, then no bytes are different,\n\t\t\t * meaning we have entries with duplicate\n\t\t\t * keys. We know that we are in a solid run\n\t\t\t * of this entry (because the entries are\n\t\t\t * sorted, and our lo and hi are the same,\n\t\t\t * there can be nothing but this single key\n\t\t\t * in between). So we can stop the search.\n\t\t\t * Either one of these entries is it (and\n\t\t\t * we do not care which), or we do not have\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Furthermore, we know that one of our\n\t\t\t * endpoints must be the edge of the run of\n\t\t\t * duplicates. For example, given this\n\t\t\t * sequence:\n\t\t\t *\n\t\t\t *     idx 0 1 2 3 4 5\n\t\t\t *     key A C C C C D\n\t\t\t *\n\t\t\t * If we are searching for \"B\", we might\n\t\t\t * hit the duplicate run at lo=1, hi=3\n\t\t\t * (e.g., by first mi=3, then mi=0). But we\n\t\t\t * can never have lo > 1, because B < C.\n\t\t\t * That is, if our key is less than the\n\t\t\t * run, we know that \"lo\" is the edge, but\n\t\t\t * we can say nothing of \"hi\". Similarly,\n\t\t\t * if our key is greater than the run, we\n\t\t\t * know that \"hi\" is the edge, but we can\n\t\t\t * say nothing of \"lo\".\n\t\t\t *\n\t\t\t * Therefore if we do not find it, we also\n\t\t\t * know where it would go if it did exist:\n\t\t\t * just on the far side of the edge that we\n\t\t\t * know about.\n\t\t\t */\n\t\t\tif (ofs == 20) {\n\t\t\t\tmi = lo;\n\t\t\t\tmi_key = base + elem_size * mi + key_offset;\n\t\t\t\tcmp = memcmp(mi_key, key, 20);\n\t\t\t\tif (!cmp)\n\t\t\t\t\treturn mi;\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\treturn -1 - hi;\n\t\t\t\telse\n\t\t\t\t\treturn -1 - lo;\n\t\t\t}\n\n\t\t\thiv = hi_key[ofs_0];\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv = (hiv << 8) | hi_key[ofs_0+1];\n\t\t} else {\n\t\t\thiv = 256;\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv <<= 8;\n\t\t}\n\t\tlov = lo_key[ofs_0];\n\t\tkyv = key[ofs_0];\n\t\tif (ofs_0 < 19) {\n\t\t\tlov = (lov << 8) | lo_key[ofs_0+1];\n\t\t\tkyv = (kyv << 8) | key[ofs_0+1];\n\t\t}\n\t\tassert(lov < hiv);\n\n\t\tif (kyv < lov)\n\t\t\treturn -1 - lo;\n\t\tif (hiv < kyv)\n\t\t\treturn -1 - hi;\n\n\t\t/*\n\t\t * Even if we know the target is much closer to 'hi'\n\t\t * than 'lo', if we pick too precisely and overshoot\n\t\t * (e.g. when we know 'mi' is closer to 'hi' than to\n\t\t * 'lo', pick 'mi' that is higher than the target), we\n\t\t * end up narrowing the search space by a smaller\n\t\t * amount (i.e. the distance between 'mi' and 'hi')\n\t\t * than what we would have (i.e. about half of 'lo'\n\t\t * and 'hi'). Hedge our bets to pick 'mi' less\n\t\t * aggressively, i.e. make 'mi' a bit closer to the\n\t\t * middle than we would otherwise pick.\n\t\t */\n\t\tkyv = (kyv * 6 + lov + hiv) / 8;\n\t\tif (lov < hiv - 1) {\n\t\t\tif (kyv == lov)\n\t\t\t\tkyv++;\n\t\t\telse if (kyv == hiv)\n\t\t\t\tkyv--;\n\t\t}\n\t\tmi = (range - 1) * (kyv - lov) / (hiv - lov) + lo;\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t\tprintf(\"lo %u hi %u rg %u mi %u \", lo, hi, range, mi);\n\t\tprintf(\"ofs %u lov %x, hiv %x, kyv %x\\n\",\n\t\t\t\tofs_0, lov, hiv, kyv);\n#endif\n\n\t\tif (!(lo <= mi && mi < hi)) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Assertion failure. Binary search invariant is false\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmi_key = base + elem_size * mi + key_offset;\n\t\tcmp = memcmp(mi_key + ofs_0, key + ofs_0, 20 - ofs_0);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp > 0) {\n\t\t\thi = mi;\n\t\t\thi_key = mi_key;\n\t\t} else {\n\t\t\tlo = mi + 1;\n\t\t\tlo_key = mi_key + elem_size;\n\t\t}\n\t} while (lo < hi);\n\treturn -((int)lo)-1;\n}",
          "includes": [
            "#include \"oid.h\"",
            "#include \"common.h\"",
            "#include \"sha1_lookup.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oid.h\"\n#include \"common.h\"\n#include \"sha1_lookup.h\"\n#include <stdio.h>\n\nint sha1_entry_pos(const void *table,\n\t\t\tsize_t elem_size,\n\t\t\tsize_t key_offset,\n\t\t\tunsigned lo, unsigned hi, unsigned nr,\n\t\t\tconst unsigned char *key)\n{\n\tconst unsigned char *base = (const unsigned char*)table;\n\tconst unsigned char *hi_key, *lo_key;\n\tunsigned ofs_0;\n\n\tif (!nr || lo >= hi)\n\t\treturn -1;\n\n\tif (nr == hi)\n\t\thi_key = NULL;\n\telse\n\t\thi_key = base + elem_size * hi + key_offset;\n\tlo_key = base + elem_size * lo + key_offset;\n\n\tofs_0 = 0;\n\tdo {\n\t\tint cmp;\n\t\tunsigned ofs, mi, range;\n\t\tunsigned lov, hiv, kyv;\n\t\tconst unsigned char *mi_key;\n\n\t\trange = hi - lo;\n\t\tif (hi_key) {\n\t\t\tfor (ofs = ofs_0; ofs < 20; ofs++)\n\t\t\t\tif (lo_key[ofs] != hi_key[ofs])\n\t\t\t\t\tbreak;\n\t\t\tofs_0 = ofs;\n\t\t\t/*\n\t\t\t * byte 0 thru (ofs-1) are the same between\n\t\t\t * lo and hi; ofs is the first byte that is\n\t\t\t * different.\n\t\t\t *\n\t\t\t * If ofs==20, then no bytes are different,\n\t\t\t * meaning we have entries with duplicate\n\t\t\t * keys. We know that we are in a solid run\n\t\t\t * of this entry (because the entries are\n\t\t\t * sorted, and our lo and hi are the same,\n\t\t\t * there can be nothing but this single key\n\t\t\t * in between). So we can stop the search.\n\t\t\t * Either one of these entries is it (and\n\t\t\t * we do not care which), or we do not have\n\t\t\t * it.\n\t\t\t *\n\t\t\t * Furthermore, we know that one of our\n\t\t\t * endpoints must be the edge of the run of\n\t\t\t * duplicates. For example, given this\n\t\t\t * sequence:\n\t\t\t *\n\t\t\t *     idx 0 1 2 3 4 5\n\t\t\t *     key A C C C C D\n\t\t\t *\n\t\t\t * If we are searching for \"B\", we might\n\t\t\t * hit the duplicate run at lo=1, hi=3\n\t\t\t * (e.g., by first mi=3, then mi=0). But we\n\t\t\t * can never have lo > 1, because B < C.\n\t\t\t * That is, if our key is less than the\n\t\t\t * run, we know that \"lo\" is the edge, but\n\t\t\t * we can say nothing of \"hi\". Similarly,\n\t\t\t * if our key is greater than the run, we\n\t\t\t * know that \"hi\" is the edge, but we can\n\t\t\t * say nothing of \"lo\".\n\t\t\t *\n\t\t\t * Therefore if we do not find it, we also\n\t\t\t * know where it would go if it did exist:\n\t\t\t * just on the far side of the edge that we\n\t\t\t * know about.\n\t\t\t */\n\t\t\tif (ofs == 20) {\n\t\t\t\tmi = lo;\n\t\t\t\tmi_key = base + elem_size * mi + key_offset;\n\t\t\t\tcmp = memcmp(mi_key, key, 20);\n\t\t\t\tif (!cmp)\n\t\t\t\t\treturn mi;\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\treturn -1 - hi;\n\t\t\t\telse\n\t\t\t\t\treturn -1 - lo;\n\t\t\t}\n\n\t\t\thiv = hi_key[ofs_0];\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv = (hiv << 8) | hi_key[ofs_0+1];\n\t\t} else {\n\t\t\thiv = 256;\n\t\t\tif (ofs_0 < 19)\n\t\t\t\thiv <<= 8;\n\t\t}\n\t\tlov = lo_key[ofs_0];\n\t\tkyv = key[ofs_0];\n\t\tif (ofs_0 < 19) {\n\t\t\tlov = (lov << 8) | lo_key[ofs_0+1];\n\t\t\tkyv = (kyv << 8) | key[ofs_0+1];\n\t\t}\n\t\tassert(lov < hiv);\n\n\t\tif (kyv < lov)\n\t\t\treturn -1 - lo;\n\t\tif (hiv < kyv)\n\t\t\treturn -1 - hi;\n\n\t\t/*\n\t\t * Even if we know the target is much closer to 'hi'\n\t\t * than 'lo', if we pick too precisely and overshoot\n\t\t * (e.g. when we know 'mi' is closer to 'hi' than to\n\t\t * 'lo', pick 'mi' that is higher than the target), we\n\t\t * end up narrowing the search space by a smaller\n\t\t * amount (i.e. the distance between 'mi' and 'hi')\n\t\t * than what we would have (i.e. about half of 'lo'\n\t\t * and 'hi'). Hedge our bets to pick 'mi' less\n\t\t * aggressively, i.e. make 'mi' a bit closer to the\n\t\t * middle than we would otherwise pick.\n\t\t */\n\t\tkyv = (kyv * 6 + lov + hiv) / 8;\n\t\tif (lov < hiv - 1) {\n\t\t\tif (kyv == lov)\n\t\t\t\tkyv++;\n\t\t\telse if (kyv == hiv)\n\t\t\t\tkyv--;\n\t\t}\n\t\tmi = (range - 1) * (kyv - lov) / (hiv - lov) + lo;\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t\tprintf(\"lo %u hi %u rg %u mi %u \", lo, hi, range, mi);\n\t\tprintf(\"ofs %u lov %x, hiv %x, kyv %x\\n\",\n\t\t\t\tofs_0, lov, hiv, kyv);\n#endif\n\n\t\tif (!(lo <= mi && mi < hi)) {\n\t\t\tgiterr_set(GITERR_INVALID, \"Assertion failure. Binary search invariant is false\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmi_key = base + elem_size * mi + key_offset;\n\t\tcmp = memcmp(mi_key + ofs_0, key + ofs_0, 20 - ofs_0);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp > 0) {\n\t\t\thi = mi;\n\t\t\thi_key = mi_key;\n\t\t} else {\n\t\t\tlo = mi + 1;\n\t\t\tlo_key = mi_key + elem_size;\n\t\t}\n\t} while (lo < hi);\n\treturn -((int)lo)-1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "level1_ofs[(int)short_oid->id[0] - 1]"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "level1_ofs[(int)short_oid->id[0]]"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p->index_map.data"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_index_open",
          "args": [
            "p"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "pack_index_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "320-353",
          "snippet": "static int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_pack_foreach_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1204-1261",
    "snippet": "int git_pack_foreach_entry(\n\tstruct git_pack_file *p,\n\tgit_odb_foreach_cb cb,\n\tvoid *data)\n{\n\tconst unsigned char *index = p->index_map.data, *current;\n\tuint32_t i;\n\tint error = 0;\n\n\tif (index == NULL) {\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\n\tif (p->oids == NULL) {\n\t\tgit_vector offsets, oids;\n\n\t\tif ((error = git_vector_init(&oids, p->num_objects, NULL)))\n\t\t\treturn error;\n\n\t\tif ((error = git_vector_init(&offsets, p->num_objects, git__memcmp4)))\n\t\t\treturn error;\n\n\t\tif (p->index_version > 1) {\n\t\t\tconst unsigned char *off = index + 24 * p->num_objects;\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&off[4 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&index[5 * (current - off)]);\n\t\t} else {\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&index[24 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&current[4]);\n\t\t}\n\n\t\tgit_vector_free(&offsets);\n\t\tp->oids = (git_oid **)git_vector_detach(NULL, NULL, &oids);\n\t}\n\n\tfor (i = 0; i < p->num_objects; i++)\n\t\tif ((error = cb(p->oids[i], data)) != 0)\n\t\t\treturn giterr_set_after_callback(error);\n\n\treturn error;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "p->oids[i]",
            "data"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_load__cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "193-226",
          "snippet": "static int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_detach",
          "args": [
            "NULL",
            "NULL",
            "&oids"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "110-124",
          "snippet": "void **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid **git_vector_detach(size_t *size, size_t *asize, git_vector *v)\n{\n\tvoid **data = v->contents;\n\n\tif (size)\n\t\t*size = v->length;\n\tif (asize)\n\t\t*asize = v->_alloc_size;\n\n\tv->_alloc_size = 0;\n\tv->length   = 0;\n\tv->contents = NULL;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&offsets"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&oids",
            "(void*)&current[4]"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&offsets",
            "i",
            "current"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&offsets"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&offsets",
            "i",
            "current"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&offsets",
            "p->num_objects",
            "git__memcmp4"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p->index_map.data"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_index_open",
          "args": [
            "p"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "pack_index_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "320-353",
          "snippet": "static int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_pack_foreach_entry(\n\tstruct git_pack_file *p,\n\tgit_odb_foreach_cb cb,\n\tvoid *data)\n{\n\tconst unsigned char *index = p->index_map.data, *current;\n\tuint32_t i;\n\tint error = 0;\n\n\tif (index == NULL) {\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\n\tif (p->oids == NULL) {\n\t\tgit_vector offsets, oids;\n\n\t\tif ((error = git_vector_init(&oids, p->num_objects, NULL)))\n\t\t\treturn error;\n\n\t\tif ((error = git_vector_init(&offsets, p->num_objects, git__memcmp4)))\n\t\t\treturn error;\n\n\t\tif (p->index_version > 1) {\n\t\t\tconst unsigned char *off = index + 24 * p->num_objects;\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&off[4 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&index[5 * (current - off)]);\n\t\t} else {\n\t\t\tfor (i = 0; i < p->num_objects; i++)\n\t\t\t\tgit_vector_insert(&offsets, (void*)&index[24 * i]);\n\t\t\tgit_vector_sort(&offsets);\n\t\t\tgit_vector_foreach(&offsets, i, current)\n\t\t\t\tgit_vector_insert(&oids, (void*)&current[4]);\n\t\t}\n\n\t\tgit_vector_free(&offsets);\n\t\tp->oids = (git_oid **)git_vector_detach(NULL, NULL, &oids);\n\t}\n\n\tfor (i = 0; i < p->num_objects; i++)\n\t\tif ((error = cb(p->oids[i], data)) != 0)\n\t\t\treturn giterr_set_after_callback(error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git__memcmp4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1200-1202",
    "snippet": "static int git__memcmp4(const void *a, const void *b) {\n\treturn memcmp(a, b, 4);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a",
            "b",
            "4"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int git__memcmp4(const void *a, const void *b) {\n\treturn memcmp(a, b, 4);\n}"
  },
  {
    "function_name": "nth_packed_object_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1176-1198",
    "snippet": "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_map.data;\n\tconst unsigned char *end = index + p->index_map.len;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + 24 * n)));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += 8 + p->num_objects * (20 + 4);\n\t\toff = ntohl(*((uint32_t *)(index + 4 * n)));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += p->num_objects * 4 + (off & 0x7fffffff) * 8;\n\n\t\t/* Make sure we're not being sent out of bounds */\n\t\tif (index >= end - 8)\n\t\t\treturn -1;\n\n\t\treturn (((uint64_t)ntohl(*((uint32_t *)(index + 0)))) << 32) |\n\t\t\t\t\tntohl(*((uint32_t *)(index + 4)));\n\t}\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*((uint32_t *)(index + 4))"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*((uint32_t *)(index + 0))"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*((uint32_t *)(index + 4 * n))"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*((uint32_t *)(index + 24 * n))"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_map.data;\n\tconst unsigned char *end = index + p->index_map.len;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + 24 * n)));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += 8 + p->num_objects * (20 + 4);\n\t\toff = ntohl(*((uint32_t *)(index + 4 * n)));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += p->num_objects * 4 + (off & 0x7fffffff) * 8;\n\n\t\t/* Make sure we're not being sent out of bounds */\n\t\tif (index >= end - 8)\n\t\t\treturn -1;\n\n\t\treturn (((uint64_t)ntohl(*((uint32_t *)(index + 0)))) << 32) |\n\t\t\t\t\tntohl(*((uint32_t *)(index + 4)));\n\t}\n}"
  },
  {
    "function_name": "git_packfile_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1107-1168",
    "snippet": "int git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "p"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_init",
          "args": [
            "&p->bases"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "94-111",
          "snippet": "static int cache_init(git_pack_cache *cache)\n{\n\tcache->entries = git_offmap_alloc();\n\tGITERR_CHECK_ALLOC(cache->entries);\n\n\tcache->memory_limit = GIT_PACK_CACHE_MEMORY_LIMIT;\n\n\tif (git_mutex_init(&cache->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize pack cache mutex\");\n\n\t\tgit__free(cache->entries);\n\t\tcache->entries = NULL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int cache_init(git_pack_cache *cache)\n{\n\tcache->entries = git_offmap_alloc();\n\tGITERR_CHECK_ALLOC(cache->entries);\n\n\tcache->memory_limit = GIT_PACK_CACHE_MEMORY_LIMIT;\n\n\tif (git_mutex_init(&cache->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize pack cache mutex\");\n\n\t\tgit__free(cache->entries);\n\t\tcache->entries = NULL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to initialize packfile mutex\""
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_init",
          "args": [
            "&p->lock"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "140-141",
          "snippet": "GIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"packfile not found\"",
            "NULL",
            "0"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "p->pack_name",
            "&st"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p->pack_name + root_len",
            "\".pack\"",
            "sizeof(\".pack\")"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "p->pack_name"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p->pack_name + root_len",
            "\".keep\"",
            "sizeof(\".keep\")"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "path",
            "\".idx\""
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p->pack_name",
            "path",
            "path_len + 1"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "p"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloc_len"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "2"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "sizeof(*p)",
            "path_len"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_alloc(struct git_pack_file **pack_out, const char *path)\n{\n\tstruct stat st;\n\tstruct git_pack_file *p;\n\tsize_t path_len = path ? strlen(path) : 0, alloc_len;\n\n\t*pack_out = NULL;\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*p), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 2);\n\n\tp = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(p);\n\n\tmemcpy(p->pack_name, path, path_len + 1);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tif (git__suffixcmp(path, \".idx\") == 0) {\n\t\tsize_t root_len = path_len - strlen(\".idx\");\n\n\t\tmemcpy(p->pack_name + root_len, \".keep\", sizeof(\".keep\"));\n\t\tif (git_path_exists(p->pack_name) == true)\n\t\t\tp->pack_keep = 1;\n\n\t\tmemcpy(p->pack_name + root_len, \".pack\", sizeof(\".pack\"));\n\t}\n\n\tif (p_stat(p->pack_name, &st) < 0 || !S_ISREG(st.st_mode)) {\n\t\tgit__free(p);\n\t\treturn git_odb__error_notfound(\"packfile not found\", NULL, 0);\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->mwf.fd = -1;\n\tp->mwf.size = st.st_size;\n\tp->pack_local = 1;\n\tp->mtime = (git_time_t)st.st_mtime;\n\tp->index_version = -1;\n\n\tif (git_mutex_init(&p->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize packfile mutex\");\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\tif (cache_init(&p->bases) < 0) {\n\t\tgit__free(p);\n\t\treturn -1;\n\t}\n\n\t*pack_out = p;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_packfile__name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1090-1105",
    "snippet": "int git_packfile__name(char **out, const char *path)\n{\n\tsize_t path_len;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tpath_len = strlen(path);\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tif (git_buf_printf(&buf, \"%.*s.pack\", (int)(path_len - strlen(\".idx\")), path) < 0)\n\t\treturn -1;\n\n\t*out = git_buf_detach(&buf);\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&buf"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"%.*s.pack\"",
            "(int)(path_len - strlen(\".idx\"))",
            "path"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"invalid packfile path\"",
            "NULL",
            "0"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".idx\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nint git_packfile__name(char **out, const char *path)\n{\n\tsize_t path_len;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tpath_len = strlen(path);\n\n\tif (path_len < strlen(\".idx\"))\n\t\treturn git_odb__error_notfound(\"invalid packfile path\", NULL, 0);\n\n\tif (git_buf_printf(&buf, \"%.*s.pack\", (int)(path_len - strlen(\".idx\")), path) < 0)\n\t\treturn -1;\n\n\t*out = git_buf_detach(&buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "packfile_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "1009-1088",
    "snippet": "static int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "p->mwf.fd"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Invalid packfile '%s'\"",
            "p->pack_name"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&sha1",
            "(git_oid *)idx_sha1"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "p->mwf.fd",
            "sha1.id",
            "GIT_OID_RAWSZ"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lseek",
          "args": [
            "p->mwf.fd",
            "p->mwf.size - GIT_OID_RAWSZ",
            "SEEK_SET"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr.hdr_entries"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_version_ok",
          "args": [
            "hdr.hdr_version"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "PACK_SIGNATURE"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "p->pack_fd",
            "F_SETFD",
            "fd_flag"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "p->mwf.fd",
            "F_GETFD",
            "0"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mwindow_file_register",
          "args": [
            "&p->mwf"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_file_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "375-395",
          "snippet": "int git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nint git_mwindow_file_register(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tint ret;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn -1;\n\t}\n\n\tif (ctl->windowfiles.length == 0 &&\n\t    git_vector_init(&ctl->windowfiles, 8, NULL) < 0) {\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\treturn -1;\n\t}\n\n\tret = git_vector_insert(&ctl->windowfiles, mwf);\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fstat",
          "args": [
            "p->mwf.fd",
            "&st"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "p_fstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "401-415",
          "snippet": "int p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "p->pack_name"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"failed to get lock for open\""
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&p->lock"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__error_notfound",
          "args": [
            "\"failed to open packfile\"",
            "NULL",
            "0"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1220-1232",
          "snippet": "int git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__error_notfound(\n\tconst char *message, const git_oid *oid, size_t oid_len)\n{\n\tif (oid != NULL) {\n\t\tchar oid_str[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_tostr(oid_str, oid_len+1, oid);\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s (%.*s)\",\n\t\t\tmessage, oid_len, oid_str);\n\t} else\n\t\tgiterr_set(GITERR_ODB, \"Object not found - %s\", message);\n\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_index_open",
          "args": [
            "p"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "pack_index_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "320-353",
          "snippet": "static int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "git_packfile_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "988-1007",
    "snippet": "void git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "p"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_free",
          "args": [
            "&p->bases.lock"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "104-108",
          "snippet": "int git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_index_free",
          "args": [
            "p"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "pack_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "202-212",
          "snippet": "static void pack_index_free(struct git_pack_file *p)\n{\n\tif (p->oids) {\n\t\tgit__free(p->oids);\n\t\tp->oids = NULL;\n\t}\n\tif (p->index_map.data) {\n\t\tgit_futils_mmap_free(&p->index_map);\n\t\tp->index_map.data = NULL;\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic void pack_index_free(struct git_pack_file *p)\n{\n\tif (p->oids) {\n\t\tgit__free(p->oids);\n\t\tp->oids = NULL;\n\t}\n\tif (p->index_map.data) {\n\t\tgit_futils_mmap_free(&p->index_map);\n\t\tp->index_map.data = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "p->mwf.fd"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_free_all_locked",
          "args": [
            "&p->mwf"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_free_all_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "140-172",
          "snippet": "void git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nvoid git_mwindow_free_all_locked(git_mwindow_file *mwf)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tsize_t i;\n\n\t/*\n\t * Remove these windows from the global list\n\t */\n\tfor (i = 0; i < ctl->windowfiles.length; ++i){\n\t\tif (git_vector_get(&ctl->windowfiles, i) == mwf) {\n\t\t\tgit_vector_remove(&ctl->windowfiles, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctl->windowfiles.length == 0) {\n\t\tgit_vector_free(&ctl->windowfiles);\n\t\tctl->windowfiles.contents = NULL;\n\t}\n\n\twhile (mwf->windows) {\n\t\tgit_mwindow *w = mwf->windows;\n\t\tassert(w->inuse_cnt == 0);\n\n\t\tctl->mapped -= w->window_map.len;\n\t\tctl->open_windows--;\n\n\t\tgit_futils_mmap_free(&w->window_map);\n\n\t\tmwf->windows = w->next;\n\t\tgit__free(w);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_free",
          "args": [
            "&p->bases"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "79-92",
          "snippet": "static void cache_free(git_pack_cache *cache)\n{\n\tkhiter_t k;\n\n\tif (cache->entries) {\n\t\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\t\tif (kh_exist(cache->entries, k))\n\t\t\t\tfree_cache_object(kh_value(cache->entries, k));\n\t\t}\n\n\t\tgit_offmap_free(cache->entries);\n\t\tcache->entries = NULL;\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void cache_free(git_pack_cache *cache)\n{\n\tkhiter_t k;\n\n\tif (cache->entries) {\n\t\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\t\tif (kh_exist(cache->entries, k))\n\t\t\t\tfree_cache_object(kh_value(cache->entries, k));\n\t\t}\n\n\t\tgit_offmap_free(cache->entries);\n\t\tcache->entries = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nvoid git_packfile_free(struct git_pack_file *p)\n{\n\tif (!p)\n\t\treturn;\n\n\tcache_free(&p->bases);\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mwindow_free_all_locked(&p->mwf);\n\t\tp_close(p->mwf.fd);\n\t}\n\n\tpack_index_free(p);\n\n\tgit__free(p->bad_object_sha1);\n\n\tgit_mutex_free(&p->lock);\n\tgit_mutex_free(&p->bases.lock);\n\tgit__free(p);\n}"
  },
  {
    "function_name": "get_delta_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "913-980",
    "snippet": "git_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"base entry delta is not in the same pack\""
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_entry_find_offset",
          "args": [
            "&base_offset",
            "&unused",
            "p",
            "(git_oid *)base_info",
            "GIT_OID_HEXSZ"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "pack_entry_find_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1263-1365",
          "snippet": "static int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int pack_entry_find_offset(\n\tgit_off_t *offset_out,\n\tgit_oid *found_oid,\n\tstruct git_pack_file *p,\n\tconst git_oid *short_oid,\n\tsize_t len)\n{\n\tconst uint32_t *level1_ofs = p->index_map.data;\n\tconst unsigned char *index = p->index_map.data;\n\tunsigned hi, lo, stride;\n\tint pos, found = 0;\n\tgit_off_t offset;\n\tconst unsigned char *current = 0;\n\n\t*offset_out = 0;\n\n\tif (p->index_version == -1) {\n\t\tint error;\n\n\t\tif ((error = pack_index_open(p)) < 0)\n\t\t\treturn error;\n\t\tassert(p->index_map.data);\n\n\t\tindex = p->index_map.data;\n\t\tlevel1_ofs = p->index_map.data;\n\t}\n\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[(int)short_oid->id[0]]);\n\tlo = ((short_oid->id[0] == 0x0) ? 0 : ntohl(level1_ofs[(int)short_oid->id[0] - 1]));\n\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n#ifdef INDEX_DEBUG_LOOKUP\n\tprintf(\"%02x%02x%02x... lo %u hi %u nr %d\\n\",\n\t\tshort_oid->id[0], short_oid->id[1], short_oid->id[2], lo, hi, p->num_objects);\n#endif\n\n#ifdef GIT_USE_LOOKUP\n\tpos = sha1_entry_pos(index, stride, 0, lo, hi, p->num_objects, short_oid->id);\n#else\n\tpos = sha1_position(index, stride, lo, hi, short_oid->id);\n#endif\n\n\tif (pos >= 0) {\n\t\t/* An object matching exactly the oid was found */\n\t\tfound = 1;\n\t\tcurrent = index + pos * stride;\n\t} else {\n\t\t/* No object was found */\n\t\t/* pos refers to the object with the \"closest\" oid to short_oid */\n\t\tpos = - 1 - pos;\n\t\tif (pos < (int)p->num_objects) {\n\t\t\tcurrent = index + pos * stride;\n\n\t\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)current, len))\n\t\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && len != GIT_OID_HEXSZ && pos + 1 < (int)p->num_objects) {\n\t\t/* Check for ambiguousity */\n\t\tconst unsigned char *next = current + stride;\n\n\t\tif (!git_oid_ncmp(short_oid, (const git_oid *)next, len)) {\n\t\t\tfound = 2;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn git_odb__error_notfound(\"failed to find offset for pack entry\", short_oid, len);\n\tif (found > 1)\n\t\treturn git_odb__error_ambiguous(\"found multiple offsets for pack entry\");\n\n\tif ((offset = nth_packed_object_offset(p, pos)) < 0) {\n\t\tgiterr_set(GITERR_ODB, \"packfile index is corrupt\");\n\t\treturn -1;\n\t}\n\n\t*offset_out = offset;\n\tgit_oid_fromraw(found_oid, current);\n\n#ifdef INDEX_DEBUG_LOOKUP\n\t{\n\t\tunsigned char hex_sha1[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_fmt(hex_sha1, found_oid);\n\t\thex_sha1[GIT_OID_HEXSZ] = '\\0';\n\t\tprintf(\"found lo=%d %s\\n\", lo, hex_sha1);\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "p->idx_cache",
            "k"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "p->idx_cache"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_get",
          "args": [
            "oid",
            "p->idx_cache",
            "&oid"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&oid",
            "base_info"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSB",
          "args": [
            "base_offset",
            "7"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_window_open",
          "args": [
            "p",
            "w_curs",
            "*curpos",
            "&left"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "pack_window_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "355-378",
          "snippet": "static unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\ngit_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}"
  },
  {
    "function_name": "packfile_unpack_compressed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "846-907",
    "snippet": "static int packfile_unpack_compressed(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tsize_t size,\n\tgit_otype type)\n{\n\tsize_t buf_size;\n\tint st;\n\tz_stream stream;\n\tunsigned char *buffer, *in;\n\n\tGITERR_CHECK_ALLOC_ADD(&buf_size, size, 1);\n\tbuffer = git__calloc(1, buf_size);\n\tGITERR_CHECK_ALLOC(buffer);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = (uInt)buf_size;\n\tstream.zalloc = use_git_alloc;\n\tstream.zfree = use_git_free;\n\n\tst = inflateInit(&stream);\n\tif (st != Z_OK) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init zlib stream on unpack\");\n\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tin = pack_window_open(p, w_curs, *curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = inflate(&stream, Z_FINISH);\n\t\tgit_mwindow_close(w_curs);\n\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\n\t\tif (st == Z_BUF_ERROR && in == NULL) {\n\t\t\tinflateEnd(&stream);\n\t\t\tgit__free(buffer);\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\t*curpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\n\tinflateEnd(&stream);\n\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"error inflating zlib stream\");\n\t\treturn -1;\n\t}\n\n\tobj->type = type;\n\tobj->len = size;\n\tobj->data = buffer;\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"error inflating zlib stream\""
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buffer"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "&stream"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "&stream"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "w_curs"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "&stream",
            "Z_FINISH"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_window_open",
          "args": [
            "p",
            "w_curs",
            "*curpos",
            "&stream.avail_in"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "pack_window_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "355-378",
          "snippet": "static unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }"
        }
      },
      {
        "call_info": {
          "callee": "inflateInit",
          "args": [
            "&stream"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stream",
            "0",
            "sizeof(stream)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "buffer"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "buf_size"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&buf_size",
            "size",
            "1"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_unpack_compressed(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tsize_t size,\n\tgit_otype type)\n{\n\tsize_t buf_size;\n\tint st;\n\tz_stream stream;\n\tunsigned char *buffer, *in;\n\n\tGITERR_CHECK_ALLOC_ADD(&buf_size, size, 1);\n\tbuffer = git__calloc(1, buf_size);\n\tGITERR_CHECK_ALLOC(buffer);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = (uInt)buf_size;\n\tstream.zalloc = use_git_alloc;\n\tstream.zfree = use_git_free;\n\n\tst = inflateInit(&stream);\n\tif (st != Z_OK) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init zlib stream on unpack\");\n\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tin = pack_window_open(p, w_curs, *curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = inflate(&stream, Z_FINISH);\n\t\tgit_mwindow_close(w_curs);\n\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\n\t\tif (st == Z_BUF_ERROR && in == NULL) {\n\t\t\tinflateEnd(&stream);\n\t\t\tgit__free(buffer);\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\t*curpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\n\tinflateEnd(&stream);\n\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"error inflating zlib stream\");\n\t\treturn -1;\n\t}\n\n\tobj->type = type;\n\tobj->len = size;\n\tobj->data = buffer;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_packfile_stream_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "841-844",
    "snippet": "void git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inflateEnd",
          "args": [
            "&obj->zstream"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nvoid git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}"
  },
  {
    "function_name": "git_packfile_stream_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "801-839",
    "snippet": "ssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"error reading from the zlib stream\""
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&obj->mw"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflate",
          "args": [
            "&obj->zstream",
            "Z_SYNC_FLUSH"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "inflate_disk_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_loose.c",
          "lines": "348-386",
          "snippet": "static int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/types.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"filebuf.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/types.h\"\n#include \"git2/odb_backend.h\"\n#include \"filebuf.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int inflate_disk_obj(git_rawobj *out, git_buf *obj)\n{\n\tunsigned char head[64], *buf;\n\tz_stream zs;\n\tobj_hdr hdr;\n\tsize_t used;\n\n\t/*\n\t * check for a pack-like loose object\n\t */\n\tif (!is_zlib_compressed_data((unsigned char *)obj->ptr))\n\t\treturn inflate_packlike_loose_disk_obj(out, obj);\n\n\t/*\n\t * inflate the initial part of the io buffer in order\n\t * to parse the object header (type and size).\n\t */\n\tif (start_inflate(&zs, obj, head, sizeof(head)) < Z_OK ||\n\t\t(used = get_object_header(&hdr, head)) == 0 ||\n\t\t!git_object_typeisloose(hdr.type))\n\t{\n\t\tgiterr_set(GITERR_ODB, \"Failed to inflate disk object.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * allocate a buffer and inflate the object data into it\n\t * (including the initial sequence in the head buffer).\n\t */\n\tif ((buf = inflate_tail(&zs, head, used, &hdr)) == NULL)\n\t\treturn -1;\n\tbuf[hdr.size] = '\\0';\n\n\tout->data = buf;\n\tout->len = hdr.size;\n\tout->type = hdr.type;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_window_open",
          "args": [
            "obj->p",
            "&obj->mw",
            "obj->curpos",
            "&obj->zstream.avail_in"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "pack_window_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "355-378",
          "snippet": "static unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}"
  },
  {
    "function_name": "git_packfile_stream_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "781-799",
    "snippet": "int git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ZLIB",
            "\"failed to init packfile stream\""
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inflateInit",
          "args": [
            "&obj->zstream"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "obj",
            "0",
            "sizeof(git_packfile_stream)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "use_git_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "775-779",
    "snippet": "static void use_git_free(void *opaq, void *ptr)\n{\n\tGIT_UNUSED(opaq);\n\tgit__free(ptr);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ptr"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "opaq"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void use_git_free(void *opaq, void *ptr)\n{\n\tGIT_UNUSED(opaq);\n\tgit__free(ptr);\n}"
  },
  {
    "function_name": "use_git_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "769-773",
    "snippet": "static void *use_git_alloc(void *opaq, unsigned int count, unsigned int size)\n{\n\tGIT_UNUSED(opaq);\n\treturn git__calloc(count, size);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "count",
            "size"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "opaq"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void *use_git_alloc(void *opaq, unsigned int count, unsigned int size)\n{\n\tGIT_UNUSED(opaq);\n\treturn git__calloc(count, size);\n}"
  },
  {
    "function_name": "git_packfile_unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "627-767",
    "snippet": "int git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define SMALL_STACK_SIZE 64"
    ],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_array_clear",
          "args": [
            "chain"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "obj->data"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_dec",
          "args": [
            "&cached->refcount"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "182-185",
          "snippet": "GIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__delta_apply",
          "args": [
            "obj",
            "base.data",
            "base.len",
            "delta.data",
            "delta.len"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "git__delta_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
          "lines": "83-166",
          "snippet": "int git__delta_apply(\n\tgit_rawobj *out,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t/* Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\tout->data = res_dp;\n\tout->len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base.\n\t\t\t */\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)\t\tlen = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/* cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings.\n\t\t\t */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(out->data);\n\tout->data = NULL;\n\tgiterr_set(GITERR_INVALID, \"Failed to apply delta\");\n\treturn -1;\n}",
          "includes": [
            "#include \"delta-apply.h\"",
            "#include \"git2/odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nint git__delta_apply(\n\tgit_rawobj *out,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t/* Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\tout->data = res_dp;\n\tout->len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base.\n\t\t\t */\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)\t\tlen = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/* cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings.\n\t\t\t */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(out->data);\n\tout->data = NULL;\n\tgiterr_set(GITERR_INVALID, \"Failed to apply delta\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w_curs"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_unpack_compressed",
          "args": [
            "&delta",
            "p",
            "&w_curs",
            "&curpos",
            "elem->size",
            "elem->type"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_unpack_compressed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "846-907",
          "snippet": "static int packfile_unpack_compressed(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tsize_t size,\n\tgit_otype type)\n{\n\tsize_t buf_size;\n\tint st;\n\tz_stream stream;\n\tunsigned char *buffer, *in;\n\n\tGITERR_CHECK_ALLOC_ADD(&buf_size, size, 1);\n\tbuffer = git__calloc(1, buf_size);\n\tGITERR_CHECK_ALLOC(buffer);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = (uInt)buf_size;\n\tstream.zalloc = use_git_alloc;\n\tstream.zfree = use_git_free;\n\n\tst = inflateInit(&stream);\n\tif (st != Z_OK) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init zlib stream on unpack\");\n\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tin = pack_window_open(p, w_curs, *curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = inflate(&stream, Z_FINISH);\n\t\tgit_mwindow_close(w_curs);\n\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\n\t\tif (st == Z_BUF_ERROR && in == NULL) {\n\t\t\tinflateEnd(&stream);\n\t\t\tgit__free(buffer);\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\t*curpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\n\tinflateEnd(&stream);\n\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"error inflating zlib stream\");\n\t\treturn -1;\n\t}\n\n\tobj->type = type;\n\tobj->len = size;\n\tobj->data = buffer;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_unpack_compressed(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tsize_t size,\n\tgit_otype type)\n{\n\tsize_t buf_size;\n\tint st;\n\tz_stream stream;\n\tunsigned char *buffer, *in;\n\n\tGITERR_CHECK_ALLOC_ADD(&buf_size, size, 1);\n\tbuffer = git__calloc(1, buf_size);\n\tGITERR_CHECK_ALLOC(buffer);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = (uInt)buf_size;\n\tstream.zalloc = use_git_alloc;\n\tstream.zfree = use_git_free;\n\n\tst = inflateInit(&stream);\n\tif (st != Z_OK) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init zlib stream on unpack\");\n\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tin = pack_window_open(p, w_curs, *curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = inflate(&stream, Z_FINISH);\n\t\tgit_mwindow_close(w_curs);\n\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\n\t\tif (st == Z_BUF_ERROR && in == NULL) {\n\t\t\tinflateEnd(&stream);\n\t\t\tgit__free(buffer);\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\t*curpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\n\tinflateEnd(&stream);\n\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tgit__free(buffer);\n\t\tgiterr_set(GITERR_ZLIB, \"error inflating zlib stream\");\n\t\treturn -1;\n\t}\n\n\tobj->type = type;\n\tobj->len = size;\n\tobj->data = buffer;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_add",
          "args": [
            "&cached",
            "&p->bases",
            "obj",
            "elem->base_key"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "152-194",
          "snippet": "static int cache_add(\n\t\tgit_pack_cache_entry **cached_out,\n\t\tgit_pack_cache *cache,\n\t\tgit_rawobj *base,\n\t\tgit_off_t offset)\n{\n\tgit_pack_cache_entry *entry;\n\tint error, exists = 0;\n\tkhiter_t k;\n\n\tif (base->len > GIT_PACK_CACHE_SIZE_LIMIT)\n\t\treturn -1;\n\n\tentry = new_cache_object(base);\n\tif (entry) {\n\t\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to lock cache\");\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Add it to the cache if nobody else has */\n\t\texists = kh_get(off, cache->entries, offset) != kh_end(cache->entries);\n\t\tif (!exists) {\n\t\t\twhile (cache->memory_used + base->len > cache->memory_limit)\n\t\t\t\tfree_lowest_entry(cache);\n\n\t\t\tk = kh_put(off, cache->entries, offset, &error);\n\t\t\tassert(error != 0);\n\t\t\tkh_value(cache->entries, k) = entry;\n\t\t\tcache->memory_used += entry->raw.len;\n\n\t\t\t*cached_out = entry;\n\t\t}\n\t\tgit_mutex_unlock(&cache->lock);\n\t\t/* Somebody beat us to adding it into the cache */\n\t\tif (exists) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int cache_add(\n\t\tgit_pack_cache_entry **cached_out,\n\t\tgit_pack_cache *cache,\n\t\tgit_rawobj *base,\n\t\tgit_off_t offset)\n{\n\tgit_pack_cache_entry *entry;\n\tint error, exists = 0;\n\tkhiter_t k;\n\n\tif (base->len > GIT_PACK_CACHE_SIZE_LIMIT)\n\t\treturn -1;\n\n\tentry = new_cache_object(base);\n\tif (entry) {\n\t\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to lock cache\");\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Add it to the cache if nobody else has */\n\t\texists = kh_get(off, cache->entries, offset) != kh_end(cache->entries);\n\t\tif (!exists) {\n\t\t\twhile (cache->memory_used + base->len > cache->memory_limit)\n\t\t\t\tfree_lowest_entry(cache);\n\n\t\t\tk = kh_put(off, cache->entries, offset, &error);\n\t\t\tassert(error != 0);\n\t\t\tkh_value(cache->entries, k) = entry;\n\t\t\tcache->memory_used += entry->raw.len;\n\n\t\t\t*cached_out = entry;\n\t\t}\n\t\tgit_mutex_unlock(&cache->lock);\n\t\t/* Somebody beat us to adding it into the cache */\n\t\tif (exists) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "obj->data",
            "data",
            "obj->len + 1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "obj->data"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloclen"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "obj->len",
            "1"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"invalid packfile type in header\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "obj",
            "&cached->raw",
            "sizeof(git_rawobj)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_dependency_chain",
          "args": [
            "&chain",
            "&cached",
            "obj_offset",
            "small_stack",
            "&stack_size",
            "p",
            "*obj_offset"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "pack_dependency_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "538-625",
          "snippet": "static int pack_dependency_chain(git_dependency_chain *chain_out,\n\t\t\t\t git_pack_cache_entry **cached_out, git_off_t *cached_off,\n\t\t\t\t struct pack_chain_elem *small_stack, size_t *stack_sz,\n\t\t\t\t struct git_pack_file *p, git_off_t obj_offset)\n{\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = obj_offset, base_offset;\n\tint error = 0, use_heap = 0;\n\tsize_t size, elem_pos;\n\tgit_otype type;\n\n\telem_pos = 0;\n\twhile (true) {\n\t\tstruct pack_chain_elem *elem;\n\t\tgit_pack_cache_entry *cached = NULL;\n\n\t\t/* if we have a base cached, we can stop here instead */\n\t\tif ((cached = cache_get(&p->bases, obj_offset)) != NULL) {\n\t\t\t*cached_out = cached;\n\t\t\t*cached_off = obj_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if we run out of space on the small stack, use the array */\n\t\tif (elem_pos == SMALL_STACK_SIZE) {\n\t\t\tgit_array_init_to_size(chain, elem_pos);\n\t\t\tGITERR_CHECK_ARRAY(chain);\n\t\t\tmemcpy(chain.ptr, small_stack, elem_pos * sizeof(struct pack_chain_elem));\n\t\t\tchain.size = elem_pos;\n\t\t\tuse_heap = 1;\n\t\t}\n\n\t\tcurpos = obj_offset;\n\t\tif (!use_heap) {\n\t\t\telem = &small_stack[elem_pos];\n\t\t} else {\n\t\t\telem = git_array_alloc(chain);\n\t\t\tif (!elem) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\telem->base_key = obj_offset;\n\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\telem->offset = curpos;\n\t\telem->size = size;\n\t\telem->type = type;\n\t\telem->base_key = obj_offset;\n\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (base_offset == 0) {\n\t\t\terror = packfile_error(\"delta offset is zero\");\n\t\t\tgoto on_error;\n\t\t}\n\t\tif (base_offset < 0) { /* must actually be an error code */\n\t\t\terror = (int)base_offset;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* we need to pass the pos *after* the delta-base bit */\n\t\telem->offset = curpos;\n\n\t\t/* go through the loop again, but with the new object */\n\t\tobj_offset = base_offset;\n\t\telem_pos++;\n\t}\n\n\t\n\t*stack_sz = elem_pos + 1;\n\t*chain_out = chain;\n\treturn error;\n\non_error:\n\tgit_array_clear(chain);\n\treturn error;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define SMALL_STACK_SIZE 64"
          ],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nstatic int pack_dependency_chain(git_dependency_chain *chain_out,\n\t\t\t\t git_pack_cache_entry **cached_out, git_off_t *cached_off,\n\t\t\t\t struct pack_chain_elem *small_stack, size_t *stack_sz,\n\t\t\t\t struct git_pack_file *p, git_off_t obj_offset)\n{\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = obj_offset, base_offset;\n\tint error = 0, use_heap = 0;\n\tsize_t size, elem_pos;\n\tgit_otype type;\n\n\telem_pos = 0;\n\twhile (true) {\n\t\tstruct pack_chain_elem *elem;\n\t\tgit_pack_cache_entry *cached = NULL;\n\n\t\t/* if we have a base cached, we can stop here instead */\n\t\tif ((cached = cache_get(&p->bases, obj_offset)) != NULL) {\n\t\t\t*cached_out = cached;\n\t\t\t*cached_off = obj_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if we run out of space on the small stack, use the array */\n\t\tif (elem_pos == SMALL_STACK_SIZE) {\n\t\t\tgit_array_init_to_size(chain, elem_pos);\n\t\t\tGITERR_CHECK_ARRAY(chain);\n\t\t\tmemcpy(chain.ptr, small_stack, elem_pos * sizeof(struct pack_chain_elem));\n\t\t\tchain.size = elem_pos;\n\t\t\tuse_heap = 1;\n\t\t}\n\n\t\tcurpos = obj_offset;\n\t\tif (!use_heap) {\n\t\t\telem = &small_stack[elem_pos];\n\t\t} else {\n\t\t\telem = git_array_alloc(chain);\n\t\t\tif (!elem) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\telem->base_key = obj_offset;\n\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\telem->offset = curpos;\n\t\telem->size = size;\n\t\telem->type = type;\n\t\telem->base_key = obj_offset;\n\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (base_offset == 0) {\n\t\t\terror = packfile_error(\"delta offset is zero\");\n\t\t\tgoto on_error;\n\t\t}\n\t\tif (base_offset < 0) { /* must actually be an error code */\n\t\t\terror = (int)base_offset;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* we need to pass the pos *after* the delta-base bit */\n\t\telem->offset = curpos;\n\n\t\t/* go through the loop again, but with the new object */\n\t\tobj_offset = base_offset;\n\t\telem_pos++;\n\t}\n\n\t\n\t*stack_sz = elem_pos + 1;\n\t*chain_out = chain;\n\treturn error;\n\non_error:\n\tgit_array_clear(chain);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nint git_packfile_unpack(\n\tgit_rawobj *obj,\n\tstruct git_pack_file *p,\n\tgit_off_t *obj_offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = *obj_offset;\n\tint error, free_base = 0;\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tstruct pack_chain_elem *elem = NULL, *stack;\n\tgit_pack_cache_entry *cached = NULL;\n\tstruct pack_chain_elem small_stack[SMALL_STACK_SIZE];\n\tsize_t stack_size = 0, elem_pos, alloclen;\n\tgit_otype base_type;\n\n\t/*\n\t * TODO: optionally check the CRC on the packfile\n\t */\n\n\terror = pack_dependency_chain(&chain, &cached, obj_offset, small_stack, &stack_size, p, *obj_offset);\n\tif (error < 0)\n\t\treturn error;\n\n\tobj->data = NULL;\n\tobj->len = 0;\n\tobj->type = GIT_OBJ_BAD;\n\n\t/* let's point to the right stack */\n\tstack = chain.ptr ? chain.ptr : small_stack;\n\n\telem_pos = stack_size;\n\tif (cached) {\n\t\tmemcpy(obj, &cached->raw, sizeof(git_rawobj));\n\t\tbase_type = obj->type;\n\t\telem_pos--;\t/* stack_size includes the base, which isn't actually there */\n\t} else {\n\t\telem = &stack[--elem_pos];\n\t\tbase_type = elem->type;\n\t}\n\n\tswitch (base_type) {\n\tcase GIT_OBJ_COMMIT:\n\tcase GIT_OBJ_TREE:\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TAG:\n\t\tif (!cached) {\n\t\t\tcurpos = elem->offset;\n\t\t\terror = packfile_unpack_compressed(obj, p, &w_curs, &curpos, elem->size, elem->type);\n\t\t\tgit_mwindow_close(&w_curs);\n\t\t\tbase_type = elem->type;\n\t\t}\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase GIT_OBJ_OFS_DELTA:\n\tcase GIT_OBJ_REF_DELTA:\n\t\terror = packfile_error(\"dependency chain ends in a delta\");\n\t\tgoto cleanup;\n\tdefault:\n\t\terror = packfile_error(\"invalid packfile type in header\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Finding the object we want a cached base element is\n\t * problematic, as we need to make sure we don't accidentally\n\t * give the caller the cached object, which it would then feel\n\t * free to free, so we need to copy the data.\n\t */\n\tif (cached && stack_size == 1) {\n\t\tvoid *data = obj->data;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, obj->len, 1);\n\t\tobj->data = git__malloc(alloclen);\n\t\tGITERR_CHECK_ALLOC(obj->data);\n\n\t\tmemcpy(obj->data, data, obj->len + 1);\n\t\tgit_atomic_dec(&cached->refcount);\n\t\tgoto cleanup;\n\t}\n\n\t/* we now apply each consecutive delta until we run out */\n\twhile (elem_pos > 0 && !error) {\n\t\tgit_rawobj base, delta;\n\n\t\t/*\n\t\t * We can now try to add the base to the cache, as\n\t\t * long as it's not already the cached one.\n\t\t */\n\t\tif (!cached)\n\t\t\tfree_base = !!cache_add(&cached, &p->bases, obj, elem->base_key);\n\n\t\telem = &stack[elem_pos - 1];\n\t\tcurpos = elem->offset;\n\t\terror = packfile_unpack_compressed(&delta, p, &w_curs, &curpos, elem->size, elem->type);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\t/* the current object becomes the new base, on which we apply the delta */\n\t\tbase = *obj;\n\t\tobj->data = NULL;\n\t\tobj->len = 0;\n\t\tobj->type = GIT_OBJ_BAD;\n\n\t\terror = git__delta_apply(obj, base.data, base.len, delta.data, delta.len);\n\t\tobj->type = base_type;\n\t\t/*\n\t\t * We usually don't want to free the base at this\n\t\t * point, as we put it into the cache in the previous\n\t\t * iteration. free_base lets us know that we got the\n\t\t * base object directly from the packfile, so we can free it.\n\t\t */\n\t\tgit__free(delta.data);\n\t\tif (free_base) {\n\t\t\tfree_base = 0;\n\t\t\tgit__free(base.data);\n\t\t}\n\n\t\tif (cached) {\n\t\t\tgit_atomic_dec(&cached->refcount);\n\t\t\tcached = NULL;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\telem_pos--;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit__free(obj->data);\n\n\tif (elem)\n\t\t*obj_offset = curpos;\n\n\tgit_array_clear(chain);\n\treturn error;\n}"
  },
  {
    "function_name": "pack_dependency_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "538-625",
    "snippet": "static int pack_dependency_chain(git_dependency_chain *chain_out,\n\t\t\t\t git_pack_cache_entry **cached_out, git_off_t *cached_off,\n\t\t\t\t struct pack_chain_elem *small_stack, size_t *stack_sz,\n\t\t\t\t struct git_pack_file *p, git_off_t obj_offset)\n{\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = obj_offset, base_offset;\n\tint error = 0, use_heap = 0;\n\tsize_t size, elem_pos;\n\tgit_otype type;\n\n\telem_pos = 0;\n\twhile (true) {\n\t\tstruct pack_chain_elem *elem;\n\t\tgit_pack_cache_entry *cached = NULL;\n\n\t\t/* if we have a base cached, we can stop here instead */\n\t\tif ((cached = cache_get(&p->bases, obj_offset)) != NULL) {\n\t\t\t*cached_out = cached;\n\t\t\t*cached_off = obj_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if we run out of space on the small stack, use the array */\n\t\tif (elem_pos == SMALL_STACK_SIZE) {\n\t\t\tgit_array_init_to_size(chain, elem_pos);\n\t\t\tGITERR_CHECK_ARRAY(chain);\n\t\t\tmemcpy(chain.ptr, small_stack, elem_pos * sizeof(struct pack_chain_elem));\n\t\t\tchain.size = elem_pos;\n\t\t\tuse_heap = 1;\n\t\t}\n\n\t\tcurpos = obj_offset;\n\t\tif (!use_heap) {\n\t\t\telem = &small_stack[elem_pos];\n\t\t} else {\n\t\t\telem = git_array_alloc(chain);\n\t\t\tif (!elem) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\telem->base_key = obj_offset;\n\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\telem->offset = curpos;\n\t\telem->size = size;\n\t\telem->type = type;\n\t\telem->base_key = obj_offset;\n\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (base_offset == 0) {\n\t\t\terror = packfile_error(\"delta offset is zero\");\n\t\t\tgoto on_error;\n\t\t}\n\t\tif (base_offset < 0) { /* must actually be an error code */\n\t\t\terror = (int)base_offset;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* we need to pass the pos *after* the delta-base bit */\n\t\telem->offset = curpos;\n\n\t\t/* go through the loop again, but with the new object */\n\t\tobj_offset = base_offset;\n\t\telem_pos++;\n\t}\n\n\t\n\t*stack_sz = elem_pos + 1;\n\t*chain_out = chain;\n\treturn error;\n\non_error:\n\tgit_array_clear(chain);\n\treturn error;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define SMALL_STACK_SIZE 64"
    ],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_array_clear",
          "args": [
            "chain"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"delta offset is zero\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w_curs"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_delta_base",
          "args": [
            "p",
            "&w_curs",
            "&curpos",
            "type",
            "obj_offset"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "get_delta_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "913-980",
          "snippet": "git_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\ngit_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack_header",
          "args": [
            "&size",
            "&type",
            "&p->mwf",
            "&w_curs",
            "&curpos"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "449-481",
          "snippet": "int git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "chain"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "chain.ptr",
            "small_stack",
            "elem_pos * sizeof(struct pack_chain_elem)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ARRAY",
          "args": [
            "chain"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_init_to_size",
          "args": [
            "chain",
            "elem_pos"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_get",
          "args": [
            "&p->bases",
            "obj_offset"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "cache_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "113-130",
          "snippet": "static git_pack_cache_entry *cache_get(git_pack_cache *cache, git_off_t offset)\n{\n\tkhiter_t k;\n\tgit_pack_cache_entry *entry = NULL;\n\n\tif (git_mutex_lock(&cache->lock) < 0)\n\t\treturn NULL;\n\n\tk = kh_get(off, cache->entries, offset);\n\tif (k != kh_end(cache->entries)) { /* found it */\n\t\tentry = kh_value(cache->entries, k);\n\t\tgit_atomic_inc(&entry->refcount);\n\t\tentry->last_usage = cache->use_ctr++;\n\t}\n\tgit_mutex_unlock(&cache->lock);\n\n\treturn entry;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic git_pack_cache_entry *cache_get(git_pack_cache *cache, git_off_t offset)\n{\n\tkhiter_t k;\n\tgit_pack_cache_entry *entry = NULL;\n\n\tif (git_mutex_lock(&cache->lock) < 0)\n\t\treturn NULL;\n\n\tk = kh_get(off, cache->entries, offset);\n\tif (k != kh_end(cache->entries)) { /* found it */\n\t\tentry = kh_value(cache->entries, k);\n\t\tgit_atomic_inc(&entry->refcount);\n\t\tentry->last_usage = cache->use_ctr++;\n\t}\n\tgit_mutex_unlock(&cache->lock);\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\n#define SMALL_STACK_SIZE 64\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nstatic int pack_dependency_chain(git_dependency_chain *chain_out,\n\t\t\t\t git_pack_cache_entry **cached_out, git_off_t *cached_off,\n\t\t\t\t struct pack_chain_elem *small_stack, size_t *stack_sz,\n\t\t\t\t struct git_pack_file *p, git_off_t obj_offset)\n{\n\tgit_dependency_chain chain = GIT_ARRAY_INIT;\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = obj_offset, base_offset;\n\tint error = 0, use_heap = 0;\n\tsize_t size, elem_pos;\n\tgit_otype type;\n\n\telem_pos = 0;\n\twhile (true) {\n\t\tstruct pack_chain_elem *elem;\n\t\tgit_pack_cache_entry *cached = NULL;\n\n\t\t/* if we have a base cached, we can stop here instead */\n\t\tif ((cached = cache_get(&p->bases, obj_offset)) != NULL) {\n\t\t\t*cached_out = cached;\n\t\t\t*cached_off = obj_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if we run out of space on the small stack, use the array */\n\t\tif (elem_pos == SMALL_STACK_SIZE) {\n\t\t\tgit_array_init_to_size(chain, elem_pos);\n\t\t\tGITERR_CHECK_ARRAY(chain);\n\t\t\tmemcpy(chain.ptr, small_stack, elem_pos * sizeof(struct pack_chain_elem));\n\t\t\tchain.size = elem_pos;\n\t\t\tuse_heap = 1;\n\t\t}\n\n\t\tcurpos = obj_offset;\n\t\tif (!use_heap) {\n\t\t\telem = &small_stack[elem_pos];\n\t\t} else {\n\t\t\telem = git_array_alloc(chain);\n\t\t\tif (!elem) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\n\t\telem->base_key = obj_offset;\n\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\n\t\tif (error < 0)\n\t\t\tgoto on_error;\n\n\t\telem->offset = curpos;\n\t\telem->size = size;\n\t\telem->type = type;\n\t\telem->base_key = obj_offset;\n\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\tgit_mwindow_close(&w_curs);\n\n\t\tif (base_offset == 0) {\n\t\t\terror = packfile_error(\"delta offset is zero\");\n\t\t\tgoto on_error;\n\t\t}\n\t\tif (base_offset < 0) { /* must actually be an error code */\n\t\t\terror = (int)base_offset;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* we need to pass the pos *after* the delta-base bit */\n\t\telem->offset = curpos;\n\n\t\t/* go through the loop again, but with the new object */\n\t\tobj_offset = base_offset;\n\t\telem_pos++;\n\t}\n\n\t\n\t*stack_sz = elem_pos + 1;\n\t*chain_out = chain;\n\treturn error;\n\non_error:\n\tgit_array_clear(chain);\n\treturn error;\n}"
  },
  {
    "function_name": "git_packfile_resolve_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "483-528",
    "snippet": "int git_packfile_resolve_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tstruct git_pack_file *p,\n\t\tgit_off_t offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = offset;\n\tsize_t size;\n\tgit_otype type;\n\tgit_off_t base_offset;\n\tint error;\n\n\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tsize_t base_size;\n\t\tgit_packfile_stream stream;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, offset);\n\t\tgit_mwindow_close(&w_curs);\n\t\tif ((error = git_packfile_stream_open(&stream, p, curpos)) < 0)\n\t\t\treturn error;\n\t\terror = git__delta_read_header_fromstream(&base_size, size_p, &stream);\n\t\tgit_packfile_stream_free(&stream);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\t*size_p = size;\n\n\twhile (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tcurpos = base_offset;\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, base_offset);\n\t\tgit_mwindow_close(&w_curs);\n\t}\n\t*type_p = type;\n\n\treturn error;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "&w_curs"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_delta_base",
          "args": [
            "p",
            "&w_curs",
            "&curpos",
            "type",
            "base_offset"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "get_delta_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "913-980",
          "snippet": "git_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\ngit_off_t get_delta_base(\n\tstruct git_pack_file *p,\n\tgit_mwindow **w_curs,\n\tgit_off_t *curpos,\n\tgit_otype type,\n\tgit_off_t delta_obj_offset)\n{\n\tunsigned int left = 0;\n\tunsigned char *base_info;\n\tgit_off_t base_offset;\n\tgit_oid unused;\n\n\tbase_info = pack_window_open(p, w_curs, *curpos, &left);\n\t/* Assumption: the only reason this would fail is because the file is too small */\n\tif (base_info == NULL)\n\t\treturn GIT_EBUFS;\n\t/* pack_window_open() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window. Its actually the hash size\n\t * that is assured. An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == GIT_OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tif (left <= used)\n\t\t\t\treturn GIT_EBUFS;\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0; /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0; /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == GIT_OBJ_REF_DELTA) {\n\t\t/* If we have the cooperative cache, search in it first */\n\t\tif (p->has_cache) {\n\t\t\tkhiter_t k;\n\t\t\tgit_oid oid;\n\n\t\t\tgit_oid_fromraw(&oid, base_info);\n\t\t\tk = kh_get(oid, p->idx_cache, &oid);\n\t\t\tif (k != kh_end(p->idx_cache)) {\n\t\t\t\t*curpos += 20;\n\t\t\t\treturn ((struct git_pack_entry *)kh_value(p->idx_cache, k))->offset;\n\t\t\t} else {\n\t\t\t\t/* If we're building an index, don't try to find the pack\n\t\t\t\t * entry; we just haven't seen it yet.  We'll make\n\t\t\t\t * progress again in the next loop.\n\t\t\t\t */\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t\t}\n\t\t}\n\n\t\t/* The base entry _must_ be in the same pack */\n\t\tif (pack_entry_find_offset(&base_offset, &unused, p, (git_oid *)base_info, GIT_OID_HEXSZ) < 0)\n\t\t\treturn packfile_error(\"base entry delta is not in the same pack\");\n\t\t*curpos += 20;\n\t} else\n\t\treturn 0;\n\n\treturn base_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_unpack_header",
          "args": [
            "&size",
            "&type",
            "&p->mwf",
            "&w_curs",
            "&curpos"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_unpack_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "449-481",
          "snippet": "int git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_free",
          "args": [
            "&stream"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "841-844",
          "snippet": "void git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nvoid git_packfile_stream_free(git_packfile_stream *obj)\n{\n\tinflateEnd(&obj->zstream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__delta_read_header_fromstream",
          "args": [
            "&base_size",
            "size_p",
            "&stream"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git__delta_read_header_fromstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
          "lines": "53-81",
          "snippet": "int git__delta_read_header_fromstream(size_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\n\t\tif (read == 0)\n\t\t\tbreak;\n\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\n\t\tlen += read;\n\t}\n\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"delta-apply.h\"",
            "#include \"git2/odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define DELTA_HEADER_BUFFER_LEN 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\n#define DELTA_HEADER_BUFFER_LEN 16\n\nint git__delta_read_header_fromstream(size_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\n\t\tif (read == 0)\n\t\t\tbreak;\n\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\n\t\tlen += read;\n\t}\n\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_open",
          "args": [
            "&stream",
            "p",
            "curpos"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "781-799",
          "snippet": "int git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_stream_open(git_packfile_stream *obj, struct git_pack_file *p, git_off_t curpos)\n{\n\tint st;\n\n\tmemset(obj, 0, sizeof(git_packfile_stream));\n\tobj->curpos = curpos;\n\tobj->p = p;\n\tobj->zstream.zalloc = use_git_alloc;\n\tobj->zstream.zfree = use_git_free;\n\tobj->zstream.next_in = Z_NULL;\n\tobj->zstream.next_out = Z_NULL;\n\tst = inflateInit(&obj->zstream);\n\tif (st != Z_OK) {\n\t\tgiterr_set(GITERR_ZLIB, \"failed to init packfile stream\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nint git_packfile_resolve_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tstruct git_pack_file *p,\n\t\tgit_off_t offset)\n{\n\tgit_mwindow *w_curs = NULL;\n\tgit_off_t curpos = offset;\n\tsize_t size;\n\tgit_otype type;\n\tgit_off_t base_offset;\n\tint error;\n\n\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tsize_t base_size;\n\t\tgit_packfile_stream stream;\n\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, offset);\n\t\tgit_mwindow_close(&w_curs);\n\t\tif ((error = git_packfile_stream_open(&stream, p, curpos)) < 0)\n\t\t\treturn error;\n\t\terror = git__delta_read_header_fromstream(&base_size, size_p, &stream);\n\t\tgit_packfile_stream_free(&stream);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\t*size_p = size;\n\n\twhile (type == GIT_OBJ_OFS_DELTA || type == GIT_OBJ_REF_DELTA) {\n\t\tcurpos = base_offset;\n\t\terror = git_packfile_unpack_header(&size, &type, &p->mwf, &w_curs, &curpos);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (type != GIT_OBJ_OFS_DELTA && type != GIT_OBJ_REF_DELTA)\n\t\t\tbreak;\n\t\tbase_offset = get_delta_base(p, &w_curs, &curpos, type, base_offset);\n\t\tgit_mwindow_close(&w_curs);\n\t}\n\t*type_p = type;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_packfile_unpack_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "449-481",
    "snippet": "int git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"header length is zero\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_close",
          "args": [
            "w_curs"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "416-429",
          "snippet": "void git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nvoid git_mwindow_close(git_mwindow **window)\n{\n\tgit_mwindow *w = *window;\n\tif (w) {\n\t\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\t\treturn;\n\t\t}\n\n\t\tw->inuse_cnt--;\n\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t*window = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_unpack_header1",
          "args": [
            "&used",
            "size_p",
            "type_p",
            "base",
            "left"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_unpack_header1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "412-447",
          "snippet": "static int packfile_unpack_header1(\n\t\tunsigned long *usedp,\n\t\tsize_t *sizep,\n\t\tgit_otype *type,\n\t\tconst unsigned char *buf,\n\t\tunsigned long len)\n{\n\tunsigned shift;\n\tunsigned long size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used) {\n\t\t\tgiterr_set(GITERR_ODB, \"buffer too small\");\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\tif (bitsizeof(long) <= shift) {\n\t\t\t*usedp = 0;\n\t\t\tgiterr_set(GITERR_ODB, \"packfile corrupted\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tc = buf[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\n\t*sizep = (size_t)size;\n\t*usedp = used;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_unpack_header1(\n\t\tunsigned long *usedp,\n\t\tsize_t *sizep,\n\t\tgit_otype *type,\n\t\tconst unsigned char *buf,\n\t\tunsigned long len)\n{\n\tunsigned shift;\n\tunsigned long size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used) {\n\t\t\tgiterr_set(GITERR_ODB, \"buffer too small\");\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\tif (bitsizeof(long) <= shift) {\n\t\t\t*usedp = 0;\n\t\t\tgiterr_set(GITERR_ODB, \"packfile corrupted\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tc = buf[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\n\t*sizep = (size_t)size;\n\t*usedp = used;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "mwf",
            "w_curs",
            "*curpos",
            "20",
            "&left"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nint git_packfile_unpack_header(\n\t\tsize_t *size_p,\n\t\tgit_otype *type_p,\n\t\tgit_mwindow_file *mwf,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tint ret;\n\n\t/* pack_window_open() assures us we have [base, base + 20) available\n\t * as a range that we can look at at. (Its actually the hash\n\t * size that is assured.) With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n/*\tbase = pack_window_open(p, w_curs, *curpos, &left); */\n\tbase = git_mwindow_open(mwf, w_curs, *curpos, 20, &left);\n\tif (base == NULL)\n\t\treturn GIT_EBUFS;\n\n\tret = packfile_unpack_header1(&used, size_p, type_p, base, left);\n\tgit_mwindow_close(w_curs);\n\tif (ret == GIT_EBUFS)\n\t\treturn ret;\n\telse if (ret < 0)\n\t\treturn packfile_error(\"header length is zero\");\n\n\t*curpos += used;\n\treturn 0;\n}"
  },
  {
    "function_name": "packfile_unpack_header1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "412-447",
    "snippet": "static int packfile_unpack_header1(\n\t\tunsigned long *usedp,\n\t\tsize_t *sizep,\n\t\tgit_otype *type,\n\t\tconst unsigned char *buf,\n\t\tunsigned long len)\n{\n\tunsigned shift;\n\tunsigned long size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used) {\n\t\t\tgiterr_set(GITERR_ODB, \"buffer too small\");\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\tif (bitsizeof(long) <= shift) {\n\t\t\t*usedp = 0;\n\t\t\tgiterr_set(GITERR_ODB, \"packfile corrupted\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tc = buf[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\n\t*sizep = (size_t)size;\n\t*usedp = used;\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);",
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"packfile corrupted\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitsizeof",
          "args": [
            "long"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_unpack_header1(\n\t\tunsigned long *usedp,\n\t\tsize_t *sizep,\n\t\tgit_otype *type,\n\t\tconst unsigned char *buf,\n\t\tunsigned long len)\n{\n\tunsigned shift;\n\tunsigned long size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used) {\n\t\t\tgiterr_set(GITERR_ODB, \"buffer too small\");\n\t\t\treturn GIT_EBUFS;\n\t\t}\n\n\t\tif (bitsizeof(long) <= shift) {\n\t\t\t*usedp = 0;\n\t\t\tgiterr_set(GITERR_ODB, \"packfile corrupted\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tc = buf[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\n\t*sizep = (size_t)size;\n\t*usedp = used;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_packfile__object_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "388-409",
    "snippet": "size_t git_packfile__object_header(unsigned char *hdr, size_t size, git_otype type)\n{\n\tunsigned char *hdr_base;\n\tunsigned char c;\n\n\tassert(type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA);\n\n\t/* TODO: add support for chunked objects; see git.git 6c0d19b1 */\n\n\tc = (unsigned char)((type << 4) | (size & 15));\n\tsize >>= 4;\n\thdr_base = hdr;\n\n\twhile (size) {\n\t\t*hdr++ = c | 0x80;\n\t\tc = size & 0x7f;\n\t\tsize >>= 7;\n\t}\n\t*hdr++ = c;\n\n\treturn (hdr - hdr_base);\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_unpack_compressed(\n\t\tgit_rawobj *obj,\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_curs,\n\t\tgit_off_t *curpos,\n\t\tsize_t size,\n\t\tgit_otype type);\n\nsize_t git_packfile__object_header(unsigned char *hdr, size_t size, git_otype type)\n{\n\tunsigned char *hdr_base;\n\tunsigned char c;\n\n\tassert(type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA);\n\n\t/* TODO: add support for chunked objects; see git.git 6c0d19b1 */\n\n\tc = (unsigned char)((type << 4) | (size & 15));\n\tsize >>= 4;\n\thdr_base = hdr;\n\n\twhile (size) {\n\t\t*hdr++ = c | 0x80;\n\t\tc = size & 0x7f;\n\t\tsize >>= 7;\n\t}\n\t*hdr++ = c;\n\n\treturn (hdr - hdr_base);\n}"
  },
  {
    "function_name": "pack_window_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "355-378",
    "snippet": "static unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mwindow_open",
          "args": [
            "&p->mwf",
            "w_cursor",
            "offset",
            "20",
            "left"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_mwindow_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/mwindow.c",
          "lines": "318-373",
          "snippet": "unsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}",
          "includes": [
            "#include \"pack.h\"",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"map.h\"",
            "#include \"fileops.h\"",
            "#include \"vector.h\"",
            "#include \"mwindow.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_mwindow_ctl mem_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pack.h\"\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"map.h\"\n#include \"fileops.h\"\n#include \"vector.h\"\n#include \"mwindow.h\"\n#include \"common.h\"\n\nstatic git_mwindow_ctl mem_ctl;\n\nunsigned char *git_mwindow_open(\n\tgit_mwindow_file *mwf,\n\tgit_mwindow **cursor,\n\tgit_off_t offset,\n\tsize_t extra,\n\tunsigned int *left)\n{\n\tgit_mwindow_ctl *ctl = &mem_ctl;\n\tgit_mwindow *w = *cursor;\n\n\tif (git_mutex_lock(&git__mwindow_mutex)) {\n\t\tgiterr_set(GITERR_THREAD, \"unable to lock mwindow mutex\");\n\t\treturn NULL;\n\t}\n\n\tif (!w || !(git_mwindow_contains(w, offset) && git_mwindow_contains(w, offset + extra))) {\n\t\tif (w) {\n\t\t\tw->inuse_cnt--;\n\t\t}\n\n\t\tfor (w = mwf->windows; w; w = w->next) {\n\t\t\tif (git_mwindow_contains(w, offset) &&\n\t\t\t\tgit_mwindow_contains(w, offset + extra))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there isn't a suitable window, we need to create a new\n\t\t * one.\n\t\t */\n\t\tif (!w) {\n\t\t\tw = new_window(mwf, mwf->fd, mwf->size, offset);\n\t\t\tif (w == NULL) {\n\t\t\t\tgit_mutex_unlock(&git__mwindow_mutex);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tw->next = mwf->windows;\n\t\t\tmwf->windows = w;\n\t\t}\n\t}\n\n\t/* If we changed w, store it in the cursor */\n\tif (w != *cursor) {\n\t\tw->last_used = ctl->used_ctr++;\n\t\tw->inuse_cnt++;\n\t\t*cursor = w;\n\t}\n\n\toffset -= w->offset;\n\n\tif (left)\n\t\t*left = (unsigned int)(w->window_map.len - offset);\n\n\tgit_mutex_unlock(&git__mwindow_mutex);\n\treturn (unsigned char *) w->window_map.data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packfile_open",
          "args": [
            "p"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "1009-1088",
          "snippet": "static int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int packfile_open(struct git_pack_file *p)\n{\n\tstruct stat st;\n\tstruct git_pack_header hdr;\n\tgit_oid sha1;\n\tunsigned char *idx_sha1;\n\n\tif (p->index_version == -1 && pack_index_open(p) < 0)\n\t\treturn git_odb__error_notfound(\"failed to open packfile\", NULL, 0);\n\n\t/* if mwf opened by another thread, return now */\n\tif (git_mutex_lock(&p->lock) < 0)\n\t\treturn packfile_error(\"failed to get lock for open\");\n\n\tif (p->mwf.fd >= 0) {\n\t\tgit_mutex_unlock(&p->lock);\n\t\treturn 0;\n\t}\n\n\t/* TODO: open with noatime */\n\tp->mwf.fd = git_futils_open_ro(p->pack_name);\n\tif (p->mwf.fd < 0)\n\t\tgoto cleanup;\n\n\tif (p_fstat(p->mwf.fd, &st) < 0 ||\n\t\tgit_mwindow_file_register(&p->mwf) < 0)\n\t\tgoto cleanup;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->mwf.size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\tgoto cleanup;\n\t\tp->mwf.size = (git_off_t)st.st_size;\n\t} else if (p->mwf.size != st.st_size)\n\t\tgoto cleanup;\n\n#if 0\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->mwf.fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\tgoto cleanup;\n\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\tgoto cleanup;\n#endif\n\n\t/* Verify we recognize this pack file format. */\n\tif (p_read(p->mwf.fd, &hdr, sizeof(hdr)) < 0 ||\n\t\thdr.hdr_signature != htonl(PACK_SIGNATURE) ||\n\t\t!pack_version_ok(hdr.hdr_version))\n\t\tgoto cleanup;\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries) ||\n\t\tp_lseek(p->mwf.fd, p->mwf.size - GIT_OID_RAWSZ, SEEK_SET) == -1 ||\n\t\tp_read(p->mwf.fd, sha1.id, GIT_OID_RAWSZ) < 0)\n\t\tgoto cleanup;\n\n\tidx_sha1 = ((unsigned char *)p->index_map.data) + p->index_map.len - 40;\n\n\tif (git_oid__cmp(&sha1, (git_oid *)idx_sha1) != 0)\n\t\tgoto cleanup;\n\n\tgit_mutex_unlock(&p->lock);\n\treturn 0;\n\ncleanup:\n\tgiterr_set(GITERR_OS, \"Invalid packfile '%s'\", p->pack_name);\n\n\tif (p->mwf.fd >= 0)\n\t\tp_close(p->mwf.fd);\n\tp->mwf.fd = -1;\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic unsigned char *pack_window_open(\n\t\tstruct git_pack_file *p,\n\t\tgit_mwindow **w_cursor,\n\t\tgit_off_t offset,\n\t\tunsigned int *left)\n{\n\tif (p->mwf.fd == -1 && packfile_open(p) < 0)\n\t\treturn NULL;\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the pack_window_contains function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t *\n\t * Don't allow a negative offset, as that means we've wrapped\n\t * around.\n\t */\n\tif (offset > (p->mwf.size - 20))\n\t\treturn NULL;\n\tif (offset < 0)\n\t\treturn NULL;\n\n\treturn git_mwindow_open(&p->mwf, w_cursor, offset, 20, left);\n }"
  },
  {
    "function_name": "pack_index_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "320-353",
    "snippet": "static int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&p->lock"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&idx_name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_index_check",
          "args": [
            "idx_name.ptr",
            "p"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "pack_index_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "214-318",
          "snippet": "static int pack_index_check(const char *path, struct git_pack_file *p)\n{\n\tstruct git_pack_idx_header *hdr;\n\tuint32_t version, nr, i, *index;\n\tvoid *idx_map;\n\tsize_t idx_size;\n\tstruct stat st;\n\tint error;\n\t/* TODO: properly open the file without access time using O_NOATIME */\n\tgit_file fd = git_futils_open_ro(path);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (p_fstat(fd, &st) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"Unable to stat pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (!S_ISREG(st.st_mode) ||\n\t\t!git__is_sizet(st.st_size) ||\n\t\t(idx_size = (size_t)st.st_size) < 4 * 256 + 20 + 20)\n\t{\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_ODB, \"Invalid pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\terror = git_futils_mmap_ro(&p->index_map, fd, 0, idx_size);\n\n\tp_close(fd);\n\n\tif (error < 0)\n\t\treturn error;\n\n\thdr = idx_map = p->index_map.data;\n\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\n\t\tif (version < 2 || version > 2) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"unsupported index version\");\n\t\t}\n\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\n\tif (version > 1)\n\t\tindex += 2; /* skip index header */\n\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is non-monotonic\");\n\t\t}\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 24-byte entries * nr (20-byte sha1 + 4-byte offset)\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t */\n\t\tif (idx_size != 4*256 + nr * 24 + 20 + 20) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is corrupted\");\n\t\t}\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t * - 8 bytes of header\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 20-byte sha1 entry * nr\n\t\t * - 4-byte crc entry * nr\n\t\t * - 4-byte offset entry * nr\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tunsigned long min_size = 8 + 4*256 + nr*(20 + 4 + 4) + 20 + 20;\n\t\tunsigned long max_size = min_size;\n\n\t\tif (nr)\n\t\t\tmax_size += (nr - 1)*8;\n\n\t\tif (idx_size < min_size || idx_size > max_size) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"wrong index size\");\n\t\t}\n\t}\n\n\tp->num_objects = nr;\n\tp->index_version = version;\n\treturn 0;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\n\nstatic int pack_index_check(const char *path, struct git_pack_file *p)\n{\n\tstruct git_pack_idx_header *hdr;\n\tuint32_t version, nr, i, *index;\n\tvoid *idx_map;\n\tsize_t idx_size;\n\tstruct stat st;\n\tint error;\n\t/* TODO: properly open the file without access time using O_NOATIME */\n\tgit_file fd = git_futils_open_ro(path);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (p_fstat(fd, &st) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"Unable to stat pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (!S_ISREG(st.st_mode) ||\n\t\t!git__is_sizet(st.st_size) ||\n\t\t(idx_size = (size_t)st.st_size) < 4 * 256 + 20 + 20)\n\t{\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_ODB, \"Invalid pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\terror = git_futils_mmap_ro(&p->index_map, fd, 0, idx_size);\n\n\tp_close(fd);\n\n\tif (error < 0)\n\t\treturn error;\n\n\thdr = idx_map = p->index_map.data;\n\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\n\t\tif (version < 2 || version > 2) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"unsupported index version\");\n\t\t}\n\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\n\tif (version > 1)\n\t\tindex += 2; /* skip index header */\n\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is non-monotonic\");\n\t\t}\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 24-byte entries * nr (20-byte sha1 + 4-byte offset)\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t */\n\t\tif (idx_size != 4*256 + nr * 24 + 20 + 20) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is corrupted\");\n\t\t}\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t * - 8 bytes of header\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 20-byte sha1 entry * nr\n\t\t * - 4-byte crc entry * nr\n\t\t * - 4-byte offset entry * nr\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tunsigned long min_size = 8 + 4*256 + nr*(20 + 4 + 4) + 20 + 20;\n\t\tunsigned long max_size = min_size;\n\n\t\tif (nr)\n\t\t\tmax_size += (nr - 1)*8;\n\n\t\tif (idx_size < min_size || idx_size > max_size) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"wrong index size\");\n\t\t}\n\t}\n\n\tp->num_objects = nr;\n\tp->index_version = version;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&p->lock"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&idx_name"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&idx_name",
            "\".idx\""
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&idx_name",
            "p->pack_name",
            "name_len - strlen(\".pack\")"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".pack\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "&idx_name",
            "name_len"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name_len > strlen(\".pack\")"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".pack\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p->pack_name"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic int pack_index_open(struct git_pack_file *p)\n{\n\tint error = 0;\n\tsize_t name_len;\n\tgit_buf idx_name = GIT_BUF_INIT;\n\n\tif (p->index_version > -1)\n\t\treturn 0;\n\n\tname_len = strlen(p->pack_name);\n\tassert(name_len > strlen(\".pack\")); /* checked by git_pack_file alloc */\n\n\tgit_buf_grow(&idx_name, name_len);\n\tgit_buf_put(&idx_name, p->pack_name, name_len - strlen(\".pack\"));\n\tgit_buf_puts(&idx_name, \".idx\");\n\tif (git_buf_oom(&idx_name)) {\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tif ((error = git_mutex_lock(&p->lock)) < 0) {\n\t\tgit_buf_free(&idx_name);\n\t\treturn error;\n\t}\n\n\tif (p->index_version == -1)\n\t\terror = pack_index_check(idx_name.ptr, p);\n\n\tgit_buf_free(&idx_name);\n\n\tgit_mutex_unlock(&p->lock);\n\n\treturn error;\n}"
  },
  {
    "function_name": "pack_index_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "214-318",
    "snippet": "static int pack_index_check(const char *path, struct git_pack_file *p)\n{\n\tstruct git_pack_idx_header *hdr;\n\tuint32_t version, nr, i, *index;\n\tvoid *idx_map;\n\tsize_t idx_size;\n\tstruct stat st;\n\tint error;\n\t/* TODO: properly open the file without access time using O_NOATIME */\n\tgit_file fd = git_futils_open_ro(path);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (p_fstat(fd, &st) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"Unable to stat pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (!S_ISREG(st.st_mode) ||\n\t\t!git__is_sizet(st.st_size) ||\n\t\t(idx_size = (size_t)st.st_size) < 4 * 256 + 20 + 20)\n\t{\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_ODB, \"Invalid pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\terror = git_futils_mmap_ro(&p->index_map, fd, 0, idx_size);\n\n\tp_close(fd);\n\n\tif (error < 0)\n\t\treturn error;\n\n\thdr = idx_map = p->index_map.data;\n\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\n\t\tif (version < 2 || version > 2) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"unsupported index version\");\n\t\t}\n\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\n\tif (version > 1)\n\t\tindex += 2; /* skip index header */\n\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is non-monotonic\");\n\t\t}\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 24-byte entries * nr (20-byte sha1 + 4-byte offset)\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t */\n\t\tif (idx_size != 4*256 + nr * 24 + 20 + 20) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is corrupted\");\n\t\t}\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t * - 8 bytes of header\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 20-byte sha1 entry * nr\n\t\t * - 4-byte crc entry * nr\n\t\t * - 4-byte offset entry * nr\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tunsigned long min_size = 8 + 4*256 + nr*(20 + 4 + 4) + 20 + 20;\n\t\tunsigned long max_size = min_size;\n\n\t\tif (nr)\n\t\t\tmax_size += (nr - 1)*8;\n\n\t\tif (idx_size < min_size || idx_size > max_size) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"wrong index size\");\n\t\t}\n\t}\n\n\tp->num_objects = nr;\n\tp->index_version = version;\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);",
      "static git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "packfile_error",
          "args": [
            "\"wrong index size\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "46-50",
          "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_free",
          "args": [
            "&p->index_map"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "294-297",
          "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "index[i]"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->idx_version"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "PACK_IDX_SIGNATURE"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_ro",
          "args": [
            "&p->index_map",
            "fd",
            "0",
            "idx_size"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "269-272",
          "snippet": "int git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"Invalid pack index '%s'\"",
            "path"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "st.st_size"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "p_fstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "401-415",
          "snippet": "int p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "path"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic git_off_t nth_packed_object_offset(const struct git_pack_file *p, uint32_t n);\n\nstatic int pack_index_check(const char *path, struct git_pack_file *p)\n{\n\tstruct git_pack_idx_header *hdr;\n\tuint32_t version, nr, i, *index;\n\tvoid *idx_map;\n\tsize_t idx_size;\n\tstruct stat st;\n\tint error;\n\t/* TODO: properly open the file without access time using O_NOATIME */\n\tgit_file fd = git_futils_open_ro(path);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (p_fstat(fd, &st) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"Unable to stat pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (!S_ISREG(st.st_mode) ||\n\t\t!git__is_sizet(st.st_size) ||\n\t\t(idx_size = (size_t)st.st_size) < 4 * 256 + 20 + 20)\n\t{\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_ODB, \"Invalid pack index '%s'\", path);\n\t\treturn -1;\n\t}\n\n\terror = git_futils_mmap_ro(&p->index_map, fd, 0, idx_size);\n\n\tp_close(fd);\n\n\tif (error < 0)\n\t\treturn error;\n\n\thdr = idx_map = p->index_map.data;\n\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\n\t\tif (version < 2 || version > 2) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"unsupported index version\");\n\t\t}\n\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\n\tif (version > 1)\n\t\tindex += 2; /* skip index header */\n\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is non-monotonic\");\n\t\t}\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 24-byte entries * nr (20-byte sha1 + 4-byte offset)\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t */\n\t\tif (idx_size != 4*256 + nr * 24 + 20 + 20) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"index is corrupted\");\n\t\t}\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t * - 8 bytes of header\n\t\t * - 256 index entries 4 bytes each\n\t\t * - 20-byte sha1 entry * nr\n\t\t * - 4-byte crc entry * nr\n\t\t * - 4-byte offset entry * nr\n\t\t * - 20-byte SHA1 of the packfile\n\t\t * - 20-byte SHA1 file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tunsigned long min_size = 8 + 4*256 + nr*(20 + 4 + 4) + 20 + 20;\n\t\tunsigned long max_size = min_size;\n\n\t\tif (nr)\n\t\t\tmax_size += (nr - 1)*8;\n\n\t\tif (idx_size < min_size || idx_size > max_size) {\n\t\t\tgit_futils_mmap_free(&p->index_map);\n\t\t\treturn packfile_error(\"wrong index size\");\n\t\t}\n\t}\n\n\tp->num_objects = nr;\n\tp->index_version = version;\n\treturn 0;\n}"
  },
  {
    "function_name": "pack_index_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "202-212",
    "snippet": "static void pack_index_free(struct git_pack_file *p)\n{\n\tif (p->oids) {\n\t\tgit__free(p->oids);\n\t\tp->oids = NULL;\n\t}\n\tif (p->index_map.data) {\n\t\tgit_futils_mmap_free(&p->index_map);\n\t\tp->index_map.data = NULL;\n\t}\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int packfile_open(struct git_pack_file *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_mmap_free",
          "args": [
            "&p->index_map"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "294-297",
          "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "p->oids"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\n\nstatic void pack_index_free(struct git_pack_file *p)\n{\n\tif (p->oids) {\n\t\tgit__free(p->oids);\n\t\tp->oids = NULL;\n\t}\n\tif (p->index_map.data) {\n\t\tgit_futils_mmap_free(&p->index_map);\n\t\tp->index_map.data = NULL;\n\t}\n}"
  },
  {
    "function_name": "cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "152-194",
    "snippet": "static int cache_add(\n\t\tgit_pack_cache_entry **cached_out,\n\t\tgit_pack_cache *cache,\n\t\tgit_rawobj *base,\n\t\tgit_off_t offset)\n{\n\tgit_pack_cache_entry *entry;\n\tint error, exists = 0;\n\tkhiter_t k;\n\n\tif (base->len > GIT_PACK_CACHE_SIZE_LIMIT)\n\t\treturn -1;\n\n\tentry = new_cache_object(base);\n\tif (entry) {\n\t\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to lock cache\");\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Add it to the cache if nobody else has */\n\t\texists = kh_get(off, cache->entries, offset) != kh_end(cache->entries);\n\t\tif (!exists) {\n\t\t\twhile (cache->memory_used + base->len > cache->memory_limit)\n\t\t\t\tfree_lowest_entry(cache);\n\n\t\t\tk = kh_put(off, cache->entries, offset, &error);\n\t\t\tassert(error != 0);\n\t\t\tkh_value(cache->entries, k) = entry;\n\t\t\tcache->memory_used += entry->raw.len;\n\n\t\t\t*cached_out = entry;\n\t\t}\n\t\tgit_mutex_unlock(&cache->lock);\n\t\t/* Somebody beat us to adding it into the cache */\n\t\tif (exists) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "entry"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&cache->lock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error != 0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_put",
          "args": [
            "off",
            "cache->entries",
            "offset",
            "&error"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_lowest_entry",
          "args": [
            "cache"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "free_lowest_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "133-150",
          "snippet": "static void free_lowest_entry(git_pack_cache *cache)\n{\n\tgit_pack_cache_entry *entry;\n\tkhiter_t k;\n\n\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\tif (!kh_exist(cache->entries, k))\n\t\t\tcontinue;\n\n\t\tentry = kh_value(cache->entries, k);\n\n\t\tif (entry && entry->refcount.val == 0) {\n\t\t\tcache->memory_used -= entry->raw.len;\n\t\t\tkh_del(off, cache->entries, k);\n\t\t\tfree_cache_object(entry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic void free_lowest_entry(git_pack_cache *cache)\n{\n\tgit_pack_cache_entry *entry;\n\tkhiter_t k;\n\n\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\tif (!kh_exist(cache->entries, k))\n\t\t\tcontinue;\n\n\t\tentry = kh_value(cache->entries, k);\n\n\t\tif (entry && entry->refcount.val == 0) {\n\t\t\tcache->memory_used -= entry->raw.len;\n\t\t\tkh_del(off, cache->entries, k);\n\t\t\tfree_cache_object(entry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "cache->entries"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_get",
          "args": [
            "off",
            "cache->entries",
            "offset"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to lock cache\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&cache->lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "new_cache_object",
          "args": [
            "base"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "new_cache_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "56-66",
          "snippet": "static git_pack_cache_entry *new_cache_object(git_rawobj *source)\n{\n\tgit_pack_cache_entry *e = git__calloc(1, sizeof(git_pack_cache_entry));\n\tif (!e)\n\t\treturn NULL;\n\n\tgit_atomic_inc(&e->refcount);\n\tmemcpy(&e->raw, source, sizeof(git_rawobj));\n\n\treturn e;\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic git_pack_cache_entry *new_cache_object(git_rawobj *source)\n{\n\tgit_pack_cache_entry *e = git__calloc(1, sizeof(git_pack_cache_entry));\n\tif (!e)\n\t\treturn NULL;\n\n\tgit_atomic_inc(&e->refcount);\n\tmemcpy(&e->raw, source, sizeof(git_rawobj));\n\n\treturn e;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic int cache_add(\n\t\tgit_pack_cache_entry **cached_out,\n\t\tgit_pack_cache *cache,\n\t\tgit_rawobj *base,\n\t\tgit_off_t offset)\n{\n\tgit_pack_cache_entry *entry;\n\tint error, exists = 0;\n\tkhiter_t k;\n\n\tif (base->len > GIT_PACK_CACHE_SIZE_LIMIT)\n\t\treturn -1;\n\n\tentry = new_cache_object(base);\n\tif (entry) {\n\t\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"failed to lock cache\");\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Add it to the cache if nobody else has */\n\t\texists = kh_get(off, cache->entries, offset) != kh_end(cache->entries);\n\t\tif (!exists) {\n\t\t\twhile (cache->memory_used + base->len > cache->memory_limit)\n\t\t\t\tfree_lowest_entry(cache);\n\n\t\t\tk = kh_put(off, cache->entries, offset, &error);\n\t\t\tassert(error != 0);\n\t\t\tkh_value(cache->entries, k) = entry;\n\t\t\tcache->memory_used += entry->raw.len;\n\n\t\t\t*cached_out = entry;\n\t\t}\n\t\tgit_mutex_unlock(&cache->lock);\n\t\t/* Somebody beat us to adding it into the cache */\n\t\tif (exists) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_lowest_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "133-150",
    "snippet": "static void free_lowest_entry(git_pack_cache *cache)\n{\n\tgit_pack_cache_entry *entry;\n\tkhiter_t k;\n\n\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\tif (!kh_exist(cache->entries, k))\n\t\t\tcontinue;\n\n\t\tentry = kh_value(cache->entries, k);\n\n\t\tif (entry && entry->refcount.val == 0) {\n\t\t\tcache->memory_used -= entry->raw.len;\n\t\t\tkh_del(off, cache->entries, k);\n\t\t\tfree_cache_object(entry);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cache_object",
          "args": [
            "entry"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "free_cache_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "68-77",
          "snippet": "static void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_del",
          "args": [
            "off",
            "cache->entries",
            "k"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_exist",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "cache->entries"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_begin",
          "args": [
            "cache->entries"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nstatic void free_lowest_entry(git_pack_cache *cache)\n{\n\tgit_pack_cache_entry *entry;\n\tkhiter_t k;\n\n\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\tif (!kh_exist(cache->entries, k))\n\t\t\tcontinue;\n\n\t\tentry = kh_value(cache->entries, k);\n\n\t\tif (entry && entry->refcount.val == 0) {\n\t\t\tcache->memory_used -= entry->raw.len;\n\t\t\tkh_del(off, cache->entries, k);\n\t\t\tfree_cache_object(entry);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cache_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "113-130",
    "snippet": "static git_pack_cache_entry *cache_get(git_pack_cache *cache, git_off_t offset)\n{\n\tkhiter_t k;\n\tgit_pack_cache_entry *entry = NULL;\n\n\tif (git_mutex_lock(&cache->lock) < 0)\n\t\treturn NULL;\n\n\tk = kh_get(off, cache->entries, offset);\n\tif (k != kh_end(cache->entries)) { /* found it */\n\t\tentry = kh_value(cache->entries, k);\n\t\tgit_atomic_inc(&entry->refcount);\n\t\tentry->last_usage = cache->use_ctr++;\n\t}\n\tgit_mutex_unlock(&cache->lock);\n\n\treturn entry;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "&cache->lock"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&entry->refcount"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "cache->entries"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_get",
          "args": [
            "off",
            "cache->entries",
            "offset"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "&cache->lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "142-143",
          "snippet": "GIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_lock(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic git_pack_cache_entry *cache_get(git_pack_cache *cache, git_off_t offset)\n{\n\tkhiter_t k;\n\tgit_pack_cache_entry *entry = NULL;\n\n\tif (git_mutex_lock(&cache->lock) < 0)\n\t\treturn NULL;\n\n\tk = kh_get(off, cache->entries, offset);\n\tif (k != kh_end(cache->entries)) { /* found it */\n\t\tentry = kh_value(cache->entries, k);\n\t\tgit_atomic_inc(&entry->refcount);\n\t\tentry->last_usage = cache->use_ctr++;\n\t}\n\tgit_mutex_unlock(&cache->lock);\n\n\treturn entry;\n}"
  },
  {
    "function_name": "cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "94-111",
    "snippet": "static int cache_init(git_pack_cache *cache)\n{\n\tcache->entries = git_offmap_alloc();\n\tGITERR_CHECK_ALLOC(cache->entries);\n\n\tcache->memory_limit = GIT_PACK_CACHE_MEMORY_LIMIT;\n\n\tif (git_mutex_init(&cache->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize pack cache mutex\");\n\n\t\tgit__free(cache->entries);\n\t\tcache->entries = NULL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "cache->entries"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to initialize pack cache mutex\""
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_mutex_init",
          "args": [
            "&cache->lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "140-141",
          "snippet": "GIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [
            "#define git_mutex unsigned int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\n#define git_mutex unsigned int\n\nGIT_INLINE(int) git_mutex_init(git_mutex *mutex) \\\n\t{ GIT_UNUSED(mutex); return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cache->entries"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_offmap_alloc",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int cache_init(git_pack_cache *cache)\n{\n\tcache->entries = git_offmap_alloc();\n\tGITERR_CHECK_ALLOC(cache->entries);\n\n\tcache->memory_limit = GIT_PACK_CACHE_MEMORY_LIMIT;\n\n\tif (git_mutex_init(&cache->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize pack cache mutex\");\n\n\t\tgit__free(cache->entries);\n\t\tcache->entries = NULL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "79-92",
    "snippet": "static void cache_free(git_pack_cache *cache)\n{\n\tkhiter_t k;\n\n\tif (cache->entries) {\n\t\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\t\tif (kh_exist(cache->entries, k))\n\t\t\t\tfree_cache_object(kh_value(cache->entries, k));\n\t\t}\n\n\t\tgit_offmap_free(cache->entries);\n\t\tcache->entries = NULL;\n\t}\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_offmap_free",
          "args": [
            "cache->entries"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cache_object",
          "args": [
            "kh_value(cache->entries, k)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "free_cache_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "68-77",
          "snippet": "static void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_value",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_exist",
          "args": [
            "cache->entries",
            "k"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_end",
          "args": [
            "cache->entries"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_begin",
          "args": [
            "cache->entries"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void cache_free(git_pack_cache *cache)\n{\n\tkhiter_t k;\n\n\tif (cache->entries) {\n\t\tfor (k = kh_begin(cache->entries); k != kh_end(cache->entries); k++) {\n\t\t\tif (kh_exist(cache->entries, k))\n\t\t\t\tfree_cache_object(kh_value(cache->entries, k));\n\t\t}\n\n\t\tgit_offmap_free(cache->entries);\n\t\tcache->entries = NULL;\n\t}\n}"
  },
  {
    "function_name": "free_cache_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "68-77",
    "snippet": "static void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "e"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "e->refcount.val == 0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic void free_cache_object(void *o)\n{\n\tgit_pack_cache_entry *e = (git_pack_cache_entry *)o;\n\n\tif (e != NULL) {\n\t\tassert(e->refcount.val == 0);\n\t\tgit__free(e->raw.data);\n\t\tgit__free(e);\n\t}\n}"
  },
  {
    "function_name": "new_cache_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "56-66",
    "snippet": "static git_pack_cache_entry *new_cache_object(git_rawobj *source)\n{\n\tgit_pack_cache_entry *e = git__calloc(1, sizeof(git_pack_cache_entry));\n\tif (!e)\n\t\treturn NULL;\n\n\tgit_atomic_inc(&e->refcount);\n\tmemcpy(&e->raw, source, sizeof(git_rawobj));\n\n\treturn e;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&e->raw",
            "source",
            "sizeof(git_rawobj)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&e->refcount"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_pack_cache_entry)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic git_pack_cache_entry *new_cache_object(git_rawobj *source)\n{\n\tgit_pack_cache_entry *e = git__calloc(1, sizeof(git_pack_cache_entry));\n\tif (!e)\n\t\treturn NULL;\n\n\tgit_atomic_inc(&e->refcount);\n\tmemcpy(&e->raw, source, sizeof(git_rawobj));\n\n\treturn e;\n}"
  },
  {
    "function_name": "packfile_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
    "lines": "46-50",
    "snippet": "static int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}",
    "includes": [
      "#include <zlib.h>",
      "#include \"oid.h\"",
      "#include \"fileops.h\"",
      "#include \"mwindow.h\"",
      "#include \"sha1_lookup.h\"",
      "#include \"delta-apply.h\"",
      "#include \"pack.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"Invalid pack file - %s\"",
            "message"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_error(const char *message)\n{\n\tgiterr_set(GITERR_ODB, \"Invalid pack file - %s\", message);\n\treturn -1;\n}"
  }
]