[
  {
    "function_name": "git_stash_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "1068-1079",
    "snippet": "int git_stash_pop(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *options)\n{\n\tint error;\n\n\tif ((error = git_stash_apply(repo, index, options)) < 0)\n\t\treturn error;\n\n\treturn git_stash_drop(repo, index);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_stash_drop",
          "args": [
            "repo",
            "index"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "git_stash_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "1012-1066",
          "snippet": "int git_stash_drop(\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_transaction *tx;\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tsize_t max;\n\tint error;\n\n\tif ((error = git_transaction_new(&tx, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_transaction_lock_ref(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_reflog_drop(reflog, index, true)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_transaction_set_reflog(tx, GIT_REFS_STASH_FILE, reflog)) < 0)\n\t\tgoto cleanup;\n\n\tif (max == 1) {\n\t\tif ((error = git_transaction_remove(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\t\tgoto cleanup;\n\t} else if (index == 0) {\n\t\tconst git_reflog_entry *entry;\n\n\t\tentry = git_reflog_entry_byindex(reflog, 0);\n\t\tif ((error = git_transaction_set_target(tx, GIT_REFS_STASH_FILE, &entry->oid_cur, NULL, NULL)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_transaction_commit(tx);\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_transaction_free(tx);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_drop(\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_transaction *tx;\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tsize_t max;\n\tint error;\n\n\tif ((error = git_transaction_new(&tx, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_transaction_lock_ref(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_reflog_drop(reflog, index, true)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_transaction_set_reflog(tx, GIT_REFS_STASH_FILE, reflog)) < 0)\n\t\tgoto cleanup;\n\n\tif (max == 1) {\n\t\tif ((error = git_transaction_remove(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\t\tgoto cleanup;\n\t} else if (index == 0) {\n\t\tconst git_reflog_entry *entry;\n\n\t\tentry = git_reflog_entry_byindex(reflog, 0);\n\t\tif ((error = git_transaction_set_target(tx, GIT_REFS_STASH_FILE, &entry->oid_cur, NULL, NULL)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_transaction_commit(tx);\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_transaction_free(tx);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stash_apply",
          "args": [
            "repo",
            "index",
            "options"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "git_stash_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "829-967",
          "snippet": "int git_stash_apply(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *given_opts)\n{\n\tgit_stash_apply_options opts;\n\tunsigned int checkout_strategy;\n\tgit_commit *stash_commit = NULL;\n\tgit_tree *stash_tree = NULL;\n\tgit_tree *stash_parent_tree = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tgit_index *stash_adds = NULL;\n\tgit_index *repo_index = NULL;\n\tgit_index *unstashed_index = NULL;\n\tgit_index *modified_index = NULL;\n\tgit_index *untracked_index = NULL;\n\tint error;\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_STASH_APPLY_OPTIONS_VERSION, \"git_stash_apply_options\");\n\n\tnormalize_apply_options(&opts, given_opts);\n\tcheckout_strategy = opts.checkout_options.checkout_strategy;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_LOADING_STASH);\n\n\t/* Retrieve commit corresponding to the given stash */\n\tif ((error = retrieve_stash_commit(&stash_commit, repo, index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Retrieve all trees in the stash */\n\tif ((error = retrieve_stash_trees(\n\t\t\t&stash_tree, &stash_parent_tree, &index_tree,\n\t\t\t&index_parent_tree, &untracked_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\t/* Load repo index */\n\tif ((error = git_repository_index(&repo_index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX);\n\n\tif ((error = ensure_clean_index(repo, repo_index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Restore index if required */\n\tif ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) &&\n\t\tgit_oid_cmp(git_tree_id(stash_parent_tree), git_tree_id(index_tree))) {\n\n\t\tif ((error = merge_index_and_tree(\n\t\t\t\t&unstashed_index, repo, index_parent_tree, repo_index, index_tree)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_index_has_conflicts(unstashed_index)) {\n\t\t\terror = GIT_ECONFLICT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t/* Otherwise, stage any new files in the stash tree.  (Note: their\n\t * previously unstaged contents are staged, not the previously staged.)\n\t */\n\t} else if ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) == 0) {\n\t\tif ((error = stage_new_files(\n\t\t\t\t&stash_adds, stash_parent_tree, stash_tree)) < 0 ||\n\t\t\t(error = merge_indexes(\n\t\t\t\t&unstashed_index, repo, stash_parent_tree, repo_index, stash_adds)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED);\n\n\t/* Restore modified files in workdir */\n\tif ((error = merge_index_and_tree(\n\t\t\t&modified_index, repo, stash_parent_tree, repo_index, stash_tree)) < 0)\n\t\tgoto cleanup;\n\n\t/* If applicable, restore untracked / ignored files in workdir */\n\tif (untracked_tree) {\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED);\n\n\t\tif ((error = merge_index_and_tree(&untracked_index, repo, NULL, repo_index, untracked_tree)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (untracked_index) {\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED);\n\n\t\tif ((error = git_checkout_index(repo, untracked_index, &opts.checkout_options)) < 0)\n\t\t\tgoto cleanup;\n\n\t\topts.checkout_options.checkout_strategy = checkout_strategy;\n\t}\n\n\n\t/* If there are conflicts in the modified index, then we need to actually\n\t * check that out as the repo's index.  Otherwise, we don't update the\n\t * index.\n\t */\n\n\tif (!git_index_has_conflicts(modified_index))\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t/* Check out the modified index using the existing repo index as baseline,\n\t * so that existing modifications in the index can be rewritten even when\n\t * checking out safely.\n\t */\n\topts.checkout_options.baseline_index = repo_index;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED);\n\n\tif ((error = git_checkout_index(repo, modified_index, &opts.checkout_options)) < 0)\n\t\tgoto cleanup;\n\n\tif (unstashed_index && !git_index_has_conflicts(modified_index)) {\n\t\tif ((error = git_index_read_index(repo_index, unstashed_index)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_DONE);\n\n\terror = git_index_write(repo_index);\n\ncleanup:\n\tgit_index_free(untracked_index);\n\tgit_index_free(modified_index);\n\tgit_index_free(unstashed_index);\n\tgit_index_free(stash_adds);\n\tgit_index_free(repo_index);\n\tgit_tree_free(untracked_tree);\n\tgit_tree_free(index_parent_tree);\n\tgit_tree_free(index_tree);\n\tgit_tree_free(stash_parent_tree);\n\tgit_tree_free(stash_tree);\n\tgit_commit_free(stash_commit);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_apply(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *given_opts)\n{\n\tgit_stash_apply_options opts;\n\tunsigned int checkout_strategy;\n\tgit_commit *stash_commit = NULL;\n\tgit_tree *stash_tree = NULL;\n\tgit_tree *stash_parent_tree = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tgit_index *stash_adds = NULL;\n\tgit_index *repo_index = NULL;\n\tgit_index *unstashed_index = NULL;\n\tgit_index *modified_index = NULL;\n\tgit_index *untracked_index = NULL;\n\tint error;\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_STASH_APPLY_OPTIONS_VERSION, \"git_stash_apply_options\");\n\n\tnormalize_apply_options(&opts, given_opts);\n\tcheckout_strategy = opts.checkout_options.checkout_strategy;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_LOADING_STASH);\n\n\t/* Retrieve commit corresponding to the given stash */\n\tif ((error = retrieve_stash_commit(&stash_commit, repo, index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Retrieve all trees in the stash */\n\tif ((error = retrieve_stash_trees(\n\t\t\t&stash_tree, &stash_parent_tree, &index_tree,\n\t\t\t&index_parent_tree, &untracked_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\t/* Load repo index */\n\tif ((error = git_repository_index(&repo_index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX);\n\n\tif ((error = ensure_clean_index(repo, repo_index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Restore index if required */\n\tif ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) &&\n\t\tgit_oid_cmp(git_tree_id(stash_parent_tree), git_tree_id(index_tree))) {\n\n\t\tif ((error = merge_index_and_tree(\n\t\t\t\t&unstashed_index, repo, index_parent_tree, repo_index, index_tree)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_index_has_conflicts(unstashed_index)) {\n\t\t\terror = GIT_ECONFLICT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t/* Otherwise, stage any new files in the stash tree.  (Note: their\n\t * previously unstaged contents are staged, not the previously staged.)\n\t */\n\t} else if ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) == 0) {\n\t\tif ((error = stage_new_files(\n\t\t\t\t&stash_adds, stash_parent_tree, stash_tree)) < 0 ||\n\t\t\t(error = merge_indexes(\n\t\t\t\t&unstashed_index, repo, stash_parent_tree, repo_index, stash_adds)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED);\n\n\t/* Restore modified files in workdir */\n\tif ((error = merge_index_and_tree(\n\t\t\t&modified_index, repo, stash_parent_tree, repo_index, stash_tree)) < 0)\n\t\tgoto cleanup;\n\n\t/* If applicable, restore untracked / ignored files in workdir */\n\tif (untracked_tree) {\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED);\n\n\t\tif ((error = merge_index_and_tree(&untracked_index, repo, NULL, repo_index, untracked_tree)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (untracked_index) {\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED);\n\n\t\tif ((error = git_checkout_index(repo, untracked_index, &opts.checkout_options)) < 0)\n\t\t\tgoto cleanup;\n\n\t\topts.checkout_options.checkout_strategy = checkout_strategy;\n\t}\n\n\n\t/* If there are conflicts in the modified index, then we need to actually\n\t * check that out as the repo's index.  Otherwise, we don't update the\n\t * index.\n\t */\n\n\tif (!git_index_has_conflicts(modified_index))\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t/* Check out the modified index using the existing repo index as baseline,\n\t * so that existing modifications in the index can be rewritten even when\n\t * checking out safely.\n\t */\n\topts.checkout_options.baseline_index = repo_index;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED);\n\n\tif ((error = git_checkout_index(repo, modified_index, &opts.checkout_options)) < 0)\n\t\tgoto cleanup;\n\n\tif (unstashed_index && !git_index_has_conflicts(modified_index)) {\n\t\tif ((error = git_index_read_index(repo_index, unstashed_index)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_DONE);\n\n\terror = git_index_write(repo_index);\n\ncleanup:\n\tgit_index_free(untracked_index);\n\tgit_index_free(modified_index);\n\tgit_index_free(unstashed_index);\n\tgit_index_free(stash_adds);\n\tgit_index_free(repo_index);\n\tgit_tree_free(untracked_tree);\n\tgit_tree_free(index_parent_tree);\n\tgit_tree_free(index_tree);\n\tgit_tree_free(stash_parent_tree);\n\tgit_tree_free(stash_tree);\n\tgit_commit_free(stash_commit);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_pop(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *options)\n{\n\tint error;\n\n\tif ((error = git_stash_apply(repo, index, options)) < 0)\n\t\treturn error;\n\n\treturn git_stash_drop(repo, index);\n}"
  },
  {
    "function_name": "git_stash_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "1012-1066",
    "snippet": "int git_stash_drop(\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_transaction *tx;\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tsize_t max;\n\tint error;\n\n\tif ((error = git_transaction_new(&tx, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_transaction_lock_ref(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_reflog_drop(reflog, index, true)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_transaction_set_reflog(tx, GIT_REFS_STASH_FILE, reflog)) < 0)\n\t\tgoto cleanup;\n\n\tif (max == 1) {\n\t\tif ((error = git_transaction_remove(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\t\tgoto cleanup;\n\t} else if (index == 0) {\n\t\tconst git_reflog_entry *entry;\n\n\t\tentry = git_reflog_entry_byindex(reflog, 0);\n\t\tif ((error = git_transaction_set_target(tx, GIT_REFS_STASH_FILE, &entry->oid_cur, NULL, NULL)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_transaction_commit(tx);\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_transaction_free(tx);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "reflog"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_free",
          "args": [
            "tx"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "357-393",
          "snippet": "void git_transaction_free(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_pool pool;\n\tgit_strmap_iter pos;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\tif (tx->cfg) {\n\t\t\tgit_config_unlock(tx->cfg, false);\n\t\t\tgit_config_free(tx->cfg);\n\t\t}\n\n\t\tgit__free(tx);\n\t\treturn;\n\t}\n\n\t/* start by unlocking the ones we've left hanging, if any */\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->committed)\n\t\t\tcontinue;\n\n\t\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\t}\n\n\tgit_refdb_free(tx->db);\n\tgit_strmap_free(tx->locks);\n\n\t/* tx is inside the pool, so we need to extract the data */\n\tmemcpy(&pool, &tx->pool, sizeof(git_pool));\n\tgit_pool_clear(&pool);\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_transaction_free(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_pool pool;\n\tgit_strmap_iter pos;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\tif (tx->cfg) {\n\t\t\tgit_config_unlock(tx->cfg, false);\n\t\t\tgit_config_free(tx->cfg);\n\t\t}\n\n\t\tgit__free(tx);\n\t\treturn;\n\t}\n\n\t/* start by unlocking the ones we've left hanging, if any */\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->committed)\n\t\t\tcontinue;\n\n\t\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\t}\n\n\tgit_refdb_free(tx->db);\n\tgit_strmap_free(tx->locks);\n\n\t/* tx is inside the pool, so we need to extract the data */\n\tmemcpy(&pool, &tx->pool, sizeof(git_pool));\n\tgit_pool_clear(&pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "stash"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_commit",
          "args": [
            "tx"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "323-355",
          "snippet": "int git_transaction_commit(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_strmap_iter pos;\n\tint error = 0;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\terror = git_config_unlock(tx->cfg, true);\n\t\ttx->cfg = NULL;\n\n\t\treturn error;\n\t}\n\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->reflog) {\n\t\t\tif ((error = tx->db->backend->reflog_write(tx->db->backend, node->reflog)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (node->ref_type != GIT_REF_INVALID) {\n\t\t\tif ((error = update_target(tx->db, node)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_commit(git_transaction *tx)\n{\n\ttransaction_node *node;\n\tgit_strmap_iter pos;\n\tint error = 0;\n\n\tassert(tx);\n\n\tif (tx->type == TRANSACTION_CONFIG) {\n\t\terror = git_config_unlock(tx->cfg, true);\n\t\ttx->cfg = NULL;\n\n\t\treturn error;\n\t}\n\n\tfor (pos = kh_begin(tx->locks); pos < kh_end(tx->locks); pos++) {\n\t\tif (!git_strmap_has_data(tx->locks, pos))\n\t\t\tcontinue;\n\n\t\tnode = git_strmap_value_at(tx->locks, pos);\n\t\tif (node->reflog) {\n\t\t\tif ((error = tx->db->backend->reflog_write(tx->db->backend, node->reflog)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (node->ref_type != GIT_REF_INVALID) {\n\t\t\tif ((error = update_target(tx->db, node)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_set_target",
          "args": [
            "tx",
            "GIT_REFS_STASH_FILE",
            "&entry->oid_cur",
            "NULL",
            "NULL"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_set_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "179-196",
          "snippet": "int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&node->target.id, target);\n\tnode->ref_type = GIT_REF_OID;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && target);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = copy_common(node, tx, sig, msg)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&node->target.id, target);\n\tnode->ref_type = GIT_REF_OID;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_byindex",
          "args": [
            "reflog",
            "0"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "151-160",
          "snippet": "const git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_remove",
          "args": [
            "tx",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "218-230",
          "snippet": "int git_transaction_remove(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tnode->remove = true;\n\tnode->ref_type = GIT_REF_OID; /* the id will be ignored */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_remove(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tnode->remove = true;\n\tnode->ref_type = GIT_REF_OID; /* the id will be ignored */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_set_reflog",
          "args": [
            "tx",
            "GIT_REFS_STASH_FILE",
            "reflog"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_set_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "275-289",
          "snippet": "int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && reflog);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = dup_reflog(&node->reflog, reflog, &tx->pool)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname && reflog);\n\n\tif ((error = find_locked(&node, tx, refname)) < 0)\n\t\treturn error;\n\n\tif ((error = dup_reflog(&node->reflog, reflog, &tx->pool)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_drop",
          "args": [
            "reflog",
            "index",
            "true"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "186-232",
          "snippet": "int git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)\n{\n\tsize_t entrycount;\n\tgit_reflog_entry *entry, *previous;\n\n\tentrycount = git_reflog_entrycount(reflog);\n\n\tentry = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"No reflog entry at index %\"PRIuZ, idx);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tgit_reflog_entry__free(entry);\n\n\tif (git_vector_remove(\n\t\t\t&reflog->entries, reflog_inverse_index(idx, entrycount)) < 0)\n\t\treturn -1;\n\n\tif (!rewrite_previous_entry)\n\t\treturn 0;\n\n\t/* No need to rewrite anything when removing the most recent entry */\n\tif (idx == 0)\n\t\treturn 0;\n\n\t/* Have the latest entry just been dropped? */\n\tif (entrycount == 1)\n\t\treturn 0;\n\n\tentry = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx - 1);\n\n\t/* If the oldest entry has just been removed... */\n\tif (idx == entrycount - 1) {\n\t\t/* ...clear the oid_old member of the \"new\" oldest entry */\n\t\tif (git_oid_fromstr(&entry->oid_old, GIT_OID_HEX_ZERO) < 0)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\tprevious = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx);\n\tgit_oid_cpy(&entry->oid_old, &previous->oid_cur);\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)\n{\n\tsize_t entrycount;\n\tgit_reflog_entry *entry, *previous;\n\n\tentrycount = git_reflog_entrycount(reflog);\n\n\tentry = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_REFERENCE, \"No reflog entry at index %\"PRIuZ, idx);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tgit_reflog_entry__free(entry);\n\n\tif (git_vector_remove(\n\t\t\t&reflog->entries, reflog_inverse_index(idx, entrycount)) < 0)\n\t\treturn -1;\n\n\tif (!rewrite_previous_entry)\n\t\treturn 0;\n\n\t/* No need to rewrite anything when removing the most recent entry */\n\tif (idx == 0)\n\t\treturn 0;\n\n\t/* Have the latest entry just been dropped? */\n\tif (entrycount == 1)\n\t\treturn 0;\n\n\tentry = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx - 1);\n\n\t/* If the oldest entry has just been removed... */\n\tif (idx == entrycount - 1) {\n\t\t/* ...clear the oid_old member of the \"new\" oldest entry */\n\t\tif (git_oid_fromstr(&entry->oid_old, GIT_OID_HEX_ZERO) < 0)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\tprevious = (git_reflog_entry *)git_reflog_entry_byindex(reflog, idx);\n\tgit_oid_cpy(&entry->oid_old, &previous->oid_cur);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_STASH",
            "\"No stashed state at position %\" PRIuZ",
            "index"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entrycount",
          "args": [
            "reflog"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "145-149",
          "snippet": "size_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nsize_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_read",
          "args": [
            "&reflog",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "51-62",
          "snippet": "int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&stash",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_lock_ref",
          "args": [
            "tx",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_lock_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "107-133",
          "snippet": "int git_transaction_lock_ref(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname);\n\n\tnode = git_pool_mallocz(&tx->pool, sizeof(transaction_node));\n\tGITERR_CHECK_ALLOC(node);\n\n\tnode->name = git_pool_strdup(&tx->pool, refname);\n\tGITERR_CHECK_ALLOC(node->name);\n\n\tif ((error = git_refdb_lock(&node->payload, tx->db, refname)) < 0)\n\t\treturn error;\n\n\tgit_strmap_insert(tx->locks, node->name, node, error);\n\tif (error < 0) \n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_lock_ref(git_transaction *tx, const char *refname)\n{\n\tint error;\n\ttransaction_node *node;\n\n\tassert(tx && refname);\n\n\tnode = git_pool_mallocz(&tx->pool, sizeof(transaction_node));\n\tGITERR_CHECK_ALLOC(node);\n\n\tnode->name = git_pool_strdup(&tx->pool, refname);\n\tGITERR_CHECK_ALLOC(node->name);\n\n\tif ((error = git_refdb_lock(&node->payload, tx->db, refname)) < 0)\n\t\treturn error;\n\n\tgit_strmap_insert(tx->locks, node->name, node, error);\n\tif (error < 0) \n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tgit_refdb_unlock(tx->db, node->payload, false, false, NULL, NULL, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_transaction_new",
          "args": [
            "&tx",
            "repo"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "git_transaction_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transaction.c",
          "lines": "72-105",
          "snippet": "int git_transaction_new(git_transaction **out, git_repository *repo)\n{\n\tint error;\n\tgit_pool pool;\n\tgit_transaction *tx = NULL;\n\n\tassert(out && repo);\n\n\tgit_pool_init(&pool, 1);\n\n\ttx = git_pool_mallocz(&pool, sizeof(git_transaction));\n\tif (!tx) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_strmap_alloc(&tx->locks)) < 0) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_repository_refdb(&tx->db, repo)) < 0)\n\t\tgoto on_error;\n\n\ttx->type = TRANSACTION_REFS;\n\tmemcpy(&tx->pool, &pool, sizeof(git_pool));\n\ttx->repo = repo;\n\t*out = tx;\n\treturn 0;\n\non_error:\n\tgit_pool_clear(&pool);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/refdb_backend.h\"",
            "#include \"git2/sys/refs.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"config.h\"",
            "#include \"signature.h\"",
            "#include \"reflog.h\"",
            "#include \"pool.h\"",
            "#include \"refdb.h\"",
            "#include \"strmap.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/refdb_backend.h\"\n#include \"git2/sys/refs.h\"\n#include \"git2/signature.h\"\n#include \"git2/transaction.h\"\n#include \"config.h\"\n#include \"signature.h\"\n#include \"reflog.h\"\n#include \"pool.h\"\n#include \"refdb.h\"\n#include \"strmap.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_transaction_new(git_transaction **out, git_repository *repo)\n{\n\tint error;\n\tgit_pool pool;\n\tgit_transaction *tx = NULL;\n\n\tassert(out && repo);\n\n\tgit_pool_init(&pool, 1);\n\n\ttx = git_pool_mallocz(&pool, sizeof(git_transaction));\n\tif (!tx) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_strmap_alloc(&tx->locks)) < 0) {\n\t\terror = -1;\n\t\tgoto on_error;\n\t}\n\n\tif ((error = git_repository_refdb(&tx->db, repo)) < 0)\n\t\tgoto on_error;\n\n\ttx->type = TRANSACTION_REFS;\n\tmemcpy(&tx->pool, &pool, sizeof(git_pool));\n\ttx->repo = repo;\n\t*out = tx;\n\treturn 0;\n\non_error:\n\tgit_pool_clear(&pool);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_drop(\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_transaction *tx;\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tsize_t max;\n\tint error;\n\n\tif ((error = git_transaction_new(&tx, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_transaction_lock_ref(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_reflog_drop(reflog, index, true)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_transaction_set_reflog(tx, GIT_REFS_STASH_FILE, reflog)) < 0)\n\t\tgoto cleanup;\n\n\tif (max == 1) {\n\t\tif ((error = git_transaction_remove(tx, GIT_REFS_STASH_FILE)) < 0)\n\t\t\tgoto cleanup;\n\t} else if (index == 0) {\n\t\tconst git_reflog_entry *entry;\n\n\t\tentry = git_reflog_entry_byindex(reflog, 0);\n\t\tif ((error = git_transaction_set_target(tx, GIT_REFS_STASH_FILE, &entry->oid_cur, NULL, NULL)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_transaction_commit(tx);\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_transaction_free(tx);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
  },
  {
    "function_name": "git_stash_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "969-1010",
    "snippet": "int git_stash_foreach(\n\tgit_repository *repo,\n\tgit_stash_cb callback,\n\tvoid *payload)\n{\n\tgit_reference *stash;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t i, max;\n\tconst git_reflog_entry *entry;\n\n\terror = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tfor (i = 0; i < max; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\n\t\terror = callback(i,\n\t\t\tgit_reflog_entry_message(entry),\n\t\t\tgit_reflog_entry_id_new(entry),\n\t\t\tpayload);\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "reflog"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "stash"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "i",
            "git_reflog_entry_message(entry)",
            "git_reflog_entry_id_new(entry)",
            "payload"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_print_callback__to_file_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_print.c",
          "lines": "644-660",
          "snippet": "int git_diff_print_callback__to_file_handle(\n\tconst git_diff_delta *delta,\n\tconst git_diff_hunk *hunk,\n\tconst git_diff_line *line,\n\tvoid *payload)\n{\n\tFILE *fp = payload ? payload : stdout;\n\n\tGIT_UNUSED(delta); GIT_UNUSED(hunk);\n\n\tif (line->origin == GIT_DIFF_LINE_CONTEXT ||\n\t\tline->origin == GIT_DIFF_LINE_ADDITION ||\n\t\tline->origin == GIT_DIFF_LINE_DELETION)\n\t\tfputc(line->origin, fp);\n\tfwrite(line->content, 1, line->content_len, fp);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/diff.h\"",
            "#include \"delta.h\"",
            "#include \"blob.h\"",
            "#include \"zstream.h\"",
            "#include \"fileops.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/diff.h\"\n#include \"delta.h\"\n#include \"blob.h\"\n#include \"zstream.h\"\n#include \"fileops.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_print_callback__to_file_handle(\n\tconst git_diff_delta *delta,\n\tconst git_diff_hunk *hunk,\n\tconst git_diff_line *line,\n\tvoid *payload)\n{\n\tFILE *fp = payload ? payload : stdout;\n\n\tGIT_UNUSED(delta); GIT_UNUSED(hunk);\n\n\tif (line->origin == GIT_DIFF_LINE_CONTEXT ||\n\t\tline->origin == GIT_DIFF_LINE_ADDITION ||\n\t\tline->origin == GIT_DIFF_LINE_DELETION)\n\t\tfputc(line->origin, fp);\n\tfwrite(line->content, 1, line->content_len, fp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_id_new",
          "args": [
            "entry"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_id_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "168-172",
          "snippet": "const git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_message",
          "args": [
            "entry"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "180-184",
          "snippet": "const char * git_reflog_entry_message(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->msg;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst char * git_reflog_entry_message(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_byindex",
          "args": [
            "reflog",
            "i"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "151-160",
          "snippet": "const git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entrycount",
          "args": [
            "reflog"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "145-149",
          "snippet": "size_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nsize_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_read",
          "args": [
            "&reflog",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "51-62",
          "snippet": "int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&stash",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_foreach(\n\tgit_repository *repo,\n\tgit_stash_cb callback,\n\tvoid *payload)\n{\n\tgit_reference *stash;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t i, max;\n\tconst git_reflog_entry *entry;\n\n\terror = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tfor (i = 0; i < max; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\n\t\terror = callback(i,\n\t\t\tgit_reflog_entry_message(entry),\n\t\t\tgit_reflog_entry_id_new(entry),\n\t\t\tpayload);\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
  },
  {
    "function_name": "git_stash_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "829-967",
    "snippet": "int git_stash_apply(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *given_opts)\n{\n\tgit_stash_apply_options opts;\n\tunsigned int checkout_strategy;\n\tgit_commit *stash_commit = NULL;\n\tgit_tree *stash_tree = NULL;\n\tgit_tree *stash_parent_tree = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tgit_index *stash_adds = NULL;\n\tgit_index *repo_index = NULL;\n\tgit_index *unstashed_index = NULL;\n\tgit_index *modified_index = NULL;\n\tgit_index *untracked_index = NULL;\n\tint error;\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_STASH_APPLY_OPTIONS_VERSION, \"git_stash_apply_options\");\n\n\tnormalize_apply_options(&opts, given_opts);\n\tcheckout_strategy = opts.checkout_options.checkout_strategy;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_LOADING_STASH);\n\n\t/* Retrieve commit corresponding to the given stash */\n\tif ((error = retrieve_stash_commit(&stash_commit, repo, index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Retrieve all trees in the stash */\n\tif ((error = retrieve_stash_trees(\n\t\t\t&stash_tree, &stash_parent_tree, &index_tree,\n\t\t\t&index_parent_tree, &untracked_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\t/* Load repo index */\n\tif ((error = git_repository_index(&repo_index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX);\n\n\tif ((error = ensure_clean_index(repo, repo_index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Restore index if required */\n\tif ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) &&\n\t\tgit_oid_cmp(git_tree_id(stash_parent_tree), git_tree_id(index_tree))) {\n\n\t\tif ((error = merge_index_and_tree(\n\t\t\t\t&unstashed_index, repo, index_parent_tree, repo_index, index_tree)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_index_has_conflicts(unstashed_index)) {\n\t\t\terror = GIT_ECONFLICT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t/* Otherwise, stage any new files in the stash tree.  (Note: their\n\t * previously unstaged contents are staged, not the previously staged.)\n\t */\n\t} else if ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) == 0) {\n\t\tif ((error = stage_new_files(\n\t\t\t\t&stash_adds, stash_parent_tree, stash_tree)) < 0 ||\n\t\t\t(error = merge_indexes(\n\t\t\t\t&unstashed_index, repo, stash_parent_tree, repo_index, stash_adds)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED);\n\n\t/* Restore modified files in workdir */\n\tif ((error = merge_index_and_tree(\n\t\t\t&modified_index, repo, stash_parent_tree, repo_index, stash_tree)) < 0)\n\t\tgoto cleanup;\n\n\t/* If applicable, restore untracked / ignored files in workdir */\n\tif (untracked_tree) {\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED);\n\n\t\tif ((error = merge_index_and_tree(&untracked_index, repo, NULL, repo_index, untracked_tree)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (untracked_index) {\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED);\n\n\t\tif ((error = git_checkout_index(repo, untracked_index, &opts.checkout_options)) < 0)\n\t\t\tgoto cleanup;\n\n\t\topts.checkout_options.checkout_strategy = checkout_strategy;\n\t}\n\n\n\t/* If there are conflicts in the modified index, then we need to actually\n\t * check that out as the repo's index.  Otherwise, we don't update the\n\t * index.\n\t */\n\n\tif (!git_index_has_conflicts(modified_index))\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t/* Check out the modified index using the existing repo index as baseline,\n\t * so that existing modifications in the index can be rewritten even when\n\t * checking out safely.\n\t */\n\topts.checkout_options.baseline_index = repo_index;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED);\n\n\tif ((error = git_checkout_index(repo, modified_index, &opts.checkout_options)) < 0)\n\t\tgoto cleanup;\n\n\tif (unstashed_index && !git_index_has_conflicts(modified_index)) {\n\t\tif ((error = git_index_read_index(repo_index, unstashed_index)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_DONE);\n\n\terror = git_index_write(repo_index);\n\ncleanup:\n\tgit_index_free(untracked_index);\n\tgit_index_free(modified_index);\n\tgit_index_free(unstashed_index);\n\tgit_index_free(stash_adds);\n\tgit_index_free(repo_index);\n\tgit_tree_free(untracked_tree);\n\tgit_tree_free(index_parent_tree);\n\tgit_tree_free(index_tree);\n\tgit_tree_free(stash_parent_tree);\n\tgit_tree_free(stash_tree);\n\tgit_commit_free(stash_commit);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "stash_commit"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "stash_tree"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "repo_index"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_write",
          "args": [
            "repo_index"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "750-763",
          "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_DONE"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_read_index",
          "args": [
            "repo_index",
            "unstashed_index"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2928-3062",
          "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_has_conflicts",
          "args": [
            "modified_index"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_has_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1887-1900",
          "snippet": "int git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_index",
          "args": [
            "repo",
            "modified_index",
            "&opts.checkout_options"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_checkout_index",
          "args": [
            "repo",
            "untracked_index",
            "&opts.checkout_options"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_index_and_tree",
          "args": [
            "&untracked_index",
            "repo",
            "NULL",
            "repo_index",
            "untracked_tree"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "merge_index_and_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "701-726",
          "snippet": "static int merge_index_and_tree(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_tree *theirs_tree)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(&theirs, theirs_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int merge_index_and_tree(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_tree *theirs_tree)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(&theirs, theirs_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_indexes",
          "args": [
            "&unstashed_index",
            "repo",
            "stash_parent_tree",
            "repo_index",
            "stash_adds"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "merge_indexes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "674-699",
          "snippet": "static int merge_indexes(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_index *theirs_index)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&theirs, repo, theirs_index, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int merge_indexes(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_index *theirs_index)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&theirs, repo, theirs_index, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stage_new_files",
          "args": [
            "&stash_adds",
            "stash_parent_tree",
            "stash_tree"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "stage_new_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "798-827",
          "snippet": "static int stage_new_files(\n\tgit_index **out,\n\tgit_tree *parent_tree,\n\tgit_tree *tree)\n{\n\tgit_iterator *iterators[2] = { NULL, NULL };\n\tgit_iterator_options iterator_options = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_index *index = NULL;\n\tint error;\n\n\tif ((error = git_index_new(&index)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[0], parent_tree, &iterator_options)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[1], tree, &iterator_options)) < 0)\n\t\tgoto done;\n\n\terror = git_iterator_walk(iterators, 2, stage_new_file, index);\n\ndone:\n\tif (error < 0)\n\t\tgit_index_free(index);\n\telse\n\t\t*out = index;\n\n\tgit_iterator_free(iterators[0]);\n\tgit_iterator_free(iterators[1]);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stage_new_files(\n\tgit_index **out,\n\tgit_tree *parent_tree,\n\tgit_tree *tree)\n{\n\tgit_iterator *iterators[2] = { NULL, NULL };\n\tgit_iterator_options iterator_options = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_index *index = NULL;\n\tint error;\n\n\tif ((error = git_index_new(&index)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[0], parent_tree, &iterator_options)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[1], tree, &iterator_options)) < 0)\n\t\tgoto done;\n\n\terror = git_iterator_walk(iterators, 2, stage_new_file, index);\n\ndone:\n\tif (error < 0)\n\t\tgit_index_free(index);\n\telse\n\t\t*out = index;\n\n\tgit_iterator_free(iterators[0]);\n\tgit_iterator_free(iterators[1]);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "git_tree_id(stash_parent_tree)",
            "git_tree_id(index_tree)"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_id",
          "args": [
            "index_tree"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "64-67",
          "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_clean_index",
          "args": [
            "repo",
            "repo_index"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_clean_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "765-786",
          "snippet": "static int ensure_clean_index(git_repository *repo, git_index *index)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_diff *index_diff = NULL;\n\tint error = 0;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(\n\t\t\t&index_diff, repo, head_tree, index, NULL)) < 0)\n\t\tgoto done;\n\n\tif (git_diff_num_deltas(index_diff) > 0) {\n\t\tgiterr_set(GITERR_STASH, \"%\" PRIuZ \" uncommitted changes exist in the index\",\n\t\t\tgit_diff_num_deltas(index_diff));\n\t\terror = GIT_EUNCOMMITTED;\n\t}\n\ndone:\n\tgit_diff_free(index_diff);\n\tgit_tree_free(head_tree);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int ensure_clean_index(git_repository *repo, git_index *index)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_diff *index_diff = NULL;\n\tint error = 0;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(\n\t\t\t&index_diff, repo, head_tree, index, NULL)) < 0)\n\t\tgoto done;\n\n\tif (git_diff_num_deltas(index_diff) > 0) {\n\t\tgiterr_set(GITERR_STASH, \"%\" PRIuZ \" uncommitted changes exist in the index\",\n\t\t\tgit_diff_num_deltas(index_diff));\n\t\terror = GIT_EUNCOMMITTED;\n\t}\n\ndone:\n\tgit_diff_free(index_diff);\n\tgit_tree_free(head_tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&repo_index",
            "repo"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_stash_trees",
          "args": [
            "&stash_tree",
            "&stash_parent_tree",
            "&index_tree",
            "&index_parent_tree",
            "&untracked_tree",
            "stash_commit"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_stash_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "609-672",
          "snippet": "static int retrieve_stash_trees(\n\tgit_tree **out_stash_tree,\n\tgit_tree **out_base_tree,\n\tgit_tree **out_index_tree,\n\tgit_tree **out_index_parent_tree,\n\tgit_tree **out_untracked_tree,\n\tgit_commit *stash_commit)\n{\n\tgit_tree *stash_tree = NULL;\n\tgit_commit *base_commit = NULL;\n\tgit_tree *base_tree = NULL;\n\tgit_commit *index_commit = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_commit *index_parent_commit = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_commit *untracked_commit = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tint error;\n\n\tif ((error = git_commit_tree(&stash_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&base_commit, stash_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&base_tree, base_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_commit, stash_commit, 1)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_tree, index_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_parent_commit, index_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_parent_tree, index_parent_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_commit_parentcount(stash_commit) == 3) {\n\t\tif ((error = git_commit_parent(&untracked_commit, stash_commit, 2)) < 0)\n\t\t\tgoto cleanup;\n\t\tif ((error = git_commit_tree(&untracked_tree, untracked_commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*out_stash_tree = stash_tree;\n\t*out_base_tree = base_tree;\n\t*out_index_tree = index_tree;\n\t*out_index_parent_tree = index_parent_tree;\n\t*out_untracked_tree = untracked_tree;\n\ncleanup:\n\tgit_commit_free(untracked_commit);\n\tgit_commit_free(index_parent_commit);\n\tgit_commit_free(index_commit);\n\tgit_commit_free(base_commit);\n\tif (error < 0) {\n\t\tgit_tree_free(stash_tree);\n\t\tgit_tree_free(base_tree);\n\t\tgit_tree_free(index_tree);\n\t\tgit_tree_free(index_parent_tree);\n\t\tgit_tree_free(untracked_tree);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_stash_trees(\n\tgit_tree **out_stash_tree,\n\tgit_tree **out_base_tree,\n\tgit_tree **out_index_tree,\n\tgit_tree **out_index_parent_tree,\n\tgit_tree **out_untracked_tree,\n\tgit_commit *stash_commit)\n{\n\tgit_tree *stash_tree = NULL;\n\tgit_commit *base_commit = NULL;\n\tgit_tree *base_tree = NULL;\n\tgit_commit *index_commit = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_commit *index_parent_commit = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_commit *untracked_commit = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tint error;\n\n\tif ((error = git_commit_tree(&stash_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&base_commit, stash_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&base_tree, base_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_commit, stash_commit, 1)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_tree, index_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_parent_commit, index_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_parent_tree, index_parent_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_commit_parentcount(stash_commit) == 3) {\n\t\tif ((error = git_commit_parent(&untracked_commit, stash_commit, 2)) < 0)\n\t\t\tgoto cleanup;\n\t\tif ((error = git_commit_tree(&untracked_tree, untracked_commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*out_stash_tree = stash_tree;\n\t*out_base_tree = base_tree;\n\t*out_index_tree = index_tree;\n\t*out_index_parent_tree = index_parent_tree;\n\t*out_untracked_tree = untracked_tree;\n\ncleanup:\n\tgit_commit_free(untracked_commit);\n\tgit_commit_free(index_parent_commit);\n\tgit_commit_free(index_commit);\n\tgit_commit_free(base_commit);\n\tif (error < 0) {\n\t\tgit_tree_free(stash_tree);\n\t\tgit_tree_free(base_tree);\n\t\tgit_tree_free(index_tree);\n\t\tgit_tree_free(index_parent_tree);\n\t\tgit_tree_free(untracked_tree);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_stash_commit",
          "args": [
            "&stash_commit",
            "repo",
            "index"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_stash_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "575-607",
          "snippet": "static int retrieve_stash_commit(\n\tgit_commit **commit,\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t max;\n\tconst git_reflog_entry *entry;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tentry = git_reflog_entry_byindex(reflog, index);\n\tif ((error = git_commit_lookup(commit, repo, git_reflog_entry_id_new(entry))) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_stash_commit(\n\tgit_commit **commit,\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t max;\n\tconst git_reflog_entry *entry;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tentry = git_reflog_entry_byindex(reflog, index);\n\tif ((error = git_commit_lookup(commit, repo, git_reflog_entry_id_new(entry))) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NOTIFY_PROGRESS",
          "args": [
            "opts",
            "GIT_STASH_APPLY_PROGRESS_LOADING_STASH"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "normalize_apply_options",
          "args": [
            "&opts",
            "given_opts"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "normalize_apply_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "728-747",
          "snippet": "static void normalize_apply_options(\n\tgit_stash_apply_options *opts,\n\tconst git_stash_apply_options *given_apply_opts)\n{\n\tif (given_apply_opts != NULL) {\n\t\tmemcpy(opts, given_apply_opts, sizeof(git_stash_apply_options));\n\t} else {\n\t\tgit_stash_apply_options default_apply_opts = GIT_STASH_APPLY_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_apply_opts, sizeof(git_stash_apply_options));\n\t}\n\n\tif ((opts->checkout_options.checkout_strategy & (GIT_CHECKOUT_SAFE | GIT_CHECKOUT_FORCE)) == 0)\n\t\topts->checkout_options.checkout_strategy = GIT_CHECKOUT_SAFE;\n\n\tif (!opts->checkout_options.our_label)\n\t\topts->checkout_options.our_label = \"Updated upstream\";\n\n\tif (!opts->checkout_options.their_label)\n\t\topts->checkout_options.their_label = \"Stashed changes\";\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void normalize_apply_options(\n\tgit_stash_apply_options *opts,\n\tconst git_stash_apply_options *given_apply_opts)\n{\n\tif (given_apply_opts != NULL) {\n\t\tmemcpy(opts, given_apply_opts, sizeof(git_stash_apply_options));\n\t} else {\n\t\tgit_stash_apply_options default_apply_opts = GIT_STASH_APPLY_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_apply_opts, sizeof(git_stash_apply_options));\n\t}\n\n\tif ((opts->checkout_options.checkout_strategy & (GIT_CHECKOUT_SAFE | GIT_CHECKOUT_FORCE)) == 0)\n\t\topts->checkout_options.checkout_strategy = GIT_CHECKOUT_SAFE;\n\n\tif (!opts->checkout_options.our_label)\n\t\topts->checkout_options.our_label = \"Updated upstream\";\n\n\tif (!opts->checkout_options.their_label)\n\t\topts->checkout_options.their_label = \"Stashed changes\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "given_opts",
            "GIT_STASH_APPLY_OPTIONS_VERSION",
            "\"git_stash_apply_options\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_apply(\n\tgit_repository *repo,\n\tsize_t index,\n\tconst git_stash_apply_options *given_opts)\n{\n\tgit_stash_apply_options opts;\n\tunsigned int checkout_strategy;\n\tgit_commit *stash_commit = NULL;\n\tgit_tree *stash_tree = NULL;\n\tgit_tree *stash_parent_tree = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tgit_index *stash_adds = NULL;\n\tgit_index *repo_index = NULL;\n\tgit_index *unstashed_index = NULL;\n\tgit_index *modified_index = NULL;\n\tgit_index *untracked_index = NULL;\n\tint error;\n\n\tGITERR_CHECK_VERSION(given_opts, GIT_STASH_APPLY_OPTIONS_VERSION, \"git_stash_apply_options\");\n\n\tnormalize_apply_options(&opts, given_opts);\n\tcheckout_strategy = opts.checkout_options.checkout_strategy;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_LOADING_STASH);\n\n\t/* Retrieve commit corresponding to the given stash */\n\tif ((error = retrieve_stash_commit(&stash_commit, repo, index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Retrieve all trees in the stash */\n\tif ((error = retrieve_stash_trees(\n\t\t\t&stash_tree, &stash_parent_tree, &index_tree,\n\t\t\t&index_parent_tree, &untracked_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\t/* Load repo index */\n\tif ((error = git_repository_index(&repo_index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX);\n\n\tif ((error = ensure_clean_index(repo, repo_index)) < 0)\n\t\tgoto cleanup;\n\n\t/* Restore index if required */\n\tif ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) &&\n\t\tgit_oid_cmp(git_tree_id(stash_parent_tree), git_tree_id(index_tree))) {\n\n\t\tif ((error = merge_index_and_tree(\n\t\t\t\t&unstashed_index, repo, index_parent_tree, repo_index, index_tree)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (git_index_has_conflicts(unstashed_index)) {\n\t\t\terror = GIT_ECONFLICT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t/* Otherwise, stage any new files in the stash tree.  (Note: their\n\t * previously unstaged contents are staged, not the previously staged.)\n\t */\n\t} else if ((opts.flags & GIT_STASH_APPLY_REINSTATE_INDEX) == 0) {\n\t\tif ((error = stage_new_files(\n\t\t\t\t&stash_adds, stash_parent_tree, stash_tree)) < 0 ||\n\t\t\t(error = merge_indexes(\n\t\t\t\t&unstashed_index, repo, stash_parent_tree, repo_index, stash_adds)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED);\n\n\t/* Restore modified files in workdir */\n\tif ((error = merge_index_and_tree(\n\t\t\t&modified_index, repo, stash_parent_tree, repo_index, stash_tree)) < 0)\n\t\tgoto cleanup;\n\n\t/* If applicable, restore untracked / ignored files in workdir */\n\tif (untracked_tree) {\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED);\n\n\t\tif ((error = merge_index_and_tree(&untracked_index, repo, NULL, repo_index, untracked_tree)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (untracked_index) {\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED);\n\n\t\tif ((error = git_checkout_index(repo, untracked_index, &opts.checkout_options)) < 0)\n\t\t\tgoto cleanup;\n\n\t\topts.checkout_options.checkout_strategy = checkout_strategy;\n\t}\n\n\n\t/* If there are conflicts in the modified index, then we need to actually\n\t * check that out as the repo's index.  Otherwise, we don't update the\n\t * index.\n\t */\n\n\tif (!git_index_has_conflicts(modified_index))\n\t\topts.checkout_options.checkout_strategy |= GIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\t/* Check out the modified index using the existing repo index as baseline,\n\t * so that existing modifications in the index can be rewritten even when\n\t * checking out safely.\n\t */\n\topts.checkout_options.baseline_index = repo_index;\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED);\n\n\tif ((error = git_checkout_index(repo, modified_index, &opts.checkout_options)) < 0)\n\t\tgoto cleanup;\n\n\tif (unstashed_index && !git_index_has_conflicts(modified_index)) {\n\t\tif ((error = git_index_read_index(repo_index, unstashed_index)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tNOTIFY_PROGRESS(opts, GIT_STASH_APPLY_PROGRESS_DONE);\n\n\terror = git_index_write(repo_index);\n\ncleanup:\n\tgit_index_free(untracked_index);\n\tgit_index_free(modified_index);\n\tgit_index_free(unstashed_index);\n\tgit_index_free(stash_adds);\n\tgit_index_free(repo_index);\n\tgit_tree_free(untracked_tree);\n\tgit_tree_free(index_parent_tree);\n\tgit_tree_free(index_tree);\n\tgit_tree_free(stash_parent_tree);\n\tgit_tree_free(stash_tree);\n\tgit_commit_free(stash_commit);\n\treturn error;\n}"
  },
  {
    "function_name": "stage_new_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "798-827",
    "snippet": "static int stage_new_files(\n\tgit_index **out,\n\tgit_tree *parent_tree,\n\tgit_tree *tree)\n{\n\tgit_iterator *iterators[2] = { NULL, NULL };\n\tgit_iterator_options iterator_options = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_index *index = NULL;\n\tint error;\n\n\tif ((error = git_index_new(&index)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[0], parent_tree, &iterator_options)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[1], tree, &iterator_options)) < 0)\n\t\tgoto done;\n\n\terror = git_iterator_walk(iterators, 2, stage_new_file, index);\n\ndone:\n\tif (error < 0)\n\t\tgit_index_free(index);\n\telse\n\t\t*out = index;\n\n\tgit_iterator_free(iterators[0]);\n\tgit_iterator_free(iterators[1]);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "iterators[1]"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_walk",
          "args": [
            "iterators",
            "2",
            "stage_new_file",
            "index"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2116-2201",
          "snippet": "int git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&iterators[1]",
            "tree",
            "&iterator_options"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_new",
          "args": [
            "&index"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "452-455",
          "snippet": "int git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stage_new_files(\n\tgit_index **out,\n\tgit_tree *parent_tree,\n\tgit_tree *tree)\n{\n\tgit_iterator *iterators[2] = { NULL, NULL };\n\tgit_iterator_options iterator_options = GIT_ITERATOR_OPTIONS_INIT;\n\tgit_index *index = NULL;\n\tint error;\n\n\tif ((error = git_index_new(&index)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[0], parent_tree, &iterator_options)) < 0 ||\n\t\t(error = git_iterator_for_tree(\n\t\t\t&iterators[1], tree, &iterator_options)) < 0)\n\t\tgoto done;\n\n\terror = git_iterator_walk(iterators, 2, stage_new_file, index);\n\ndone:\n\tif (error < 0)\n\t\tgit_index_free(index);\n\telse\n\t\t*out = index;\n\n\tgit_iterator_free(iterators[0]);\n\tgit_iterator_free(iterators[1]);\n\n\treturn error;\n}"
  },
  {
    "function_name": "stage_new_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "788-796",
    "snippet": "static int stage_new_file(const git_index_entry **entries, void *data)\n{\n\tgit_index *index = data;\n\n\tif(entries[0] == NULL)\n\t\treturn git_index_add(index, entries[1]);\n\telse\n\t\treturn git_index_add(index, entries[0]);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_add",
          "args": [
            "index",
            "entries[0]"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1580-1598",
          "snippet": "int git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stage_new_file(const git_index_entry **entries, void *data)\n{\n\tgit_index *index = data;\n\n\tif(entries[0] == NULL)\n\t\treturn git_index_add(index, entries[1]);\n\telse\n\t\treturn git_index_add(index, entries[0]);\n}"
  },
  {
    "function_name": "ensure_clean_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "765-786",
    "snippet": "static int ensure_clean_index(git_repository *repo, git_index *index)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_diff *index_diff = NULL;\n\tint error = 0;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(\n\t\t\t&index_diff, repo, head_tree, index, NULL)) < 0)\n\t\tgoto done;\n\n\tif (git_diff_num_deltas(index_diff) > 0) {\n\t\tgiterr_set(GITERR_STASH, \"%\" PRIuZ \" uncommitted changes exist in the index\",\n\t\t\tgit_diff_num_deltas(index_diff));\n\t\terror = GIT_EUNCOMMITTED;\n\t}\n\ndone:\n\tgit_diff_free(index_diff);\n\tgit_tree_free(head_tree);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head_tree"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "index_diff"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_STASH",
            "\"%\" PRIuZ \" uncommitted changes exist in the index\"",
            "git_diff_num_deltas(index_diff)"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "index_diff"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&index_diff",
            "repo",
            "head_tree",
            "index",
            "NULL"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head_tree",
            "repo"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int ensure_clean_index(git_repository *repo, git_index *index)\n{\n\tgit_tree *head_tree = NULL;\n\tgit_diff *index_diff = NULL;\n\tint error = 0;\n\n\tif ((error = git_repository_head_tree(&head_tree, repo)) < 0 ||\n\t\t(error = git_diff_tree_to_index(\n\t\t\t&index_diff, repo, head_tree, index, NULL)) < 0)\n\t\tgoto done;\n\n\tif (git_diff_num_deltas(index_diff) > 0) {\n\t\tgiterr_set(GITERR_STASH, \"%\" PRIuZ \" uncommitted changes exist in the index\",\n\t\t\tgit_diff_num_deltas(index_diff));\n\t\terror = GIT_EUNCOMMITTED;\n\t}\n\ndone:\n\tgit_diff_free(index_diff);\n\tgit_tree_free(head_tree);\n\treturn error;\n}"
  },
  {
    "function_name": "git_stash_apply_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "749-754",
    "snippet": "int git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_stash_apply_options, GIT_STASH_APPLY_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_stash_apply_options",
            "GIT_STASH_APPLY_OPTIONS_INIT"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_stash_apply_options, GIT_STASH_APPLY_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "normalize_apply_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "728-747",
    "snippet": "static void normalize_apply_options(\n\tgit_stash_apply_options *opts,\n\tconst git_stash_apply_options *given_apply_opts)\n{\n\tif (given_apply_opts != NULL) {\n\t\tmemcpy(opts, given_apply_opts, sizeof(git_stash_apply_options));\n\t} else {\n\t\tgit_stash_apply_options default_apply_opts = GIT_STASH_APPLY_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_apply_opts, sizeof(git_stash_apply_options));\n\t}\n\n\tif ((opts->checkout_options.checkout_strategy & (GIT_CHECKOUT_SAFE | GIT_CHECKOUT_FORCE)) == 0)\n\t\topts->checkout_options.checkout_strategy = GIT_CHECKOUT_SAFE;\n\n\tif (!opts->checkout_options.our_label)\n\t\topts->checkout_options.our_label = \"Updated upstream\";\n\n\tif (!opts->checkout_options.their_label)\n\t\topts->checkout_options.their_label = \"Stashed changes\";\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "&default_apply_opts",
            "sizeof(git_stash_apply_options)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "given_apply_opts",
            "sizeof(git_stash_apply_options)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void normalize_apply_options(\n\tgit_stash_apply_options *opts,\n\tconst git_stash_apply_options *given_apply_opts)\n{\n\tif (given_apply_opts != NULL) {\n\t\tmemcpy(opts, given_apply_opts, sizeof(git_stash_apply_options));\n\t} else {\n\t\tgit_stash_apply_options default_apply_opts = GIT_STASH_APPLY_OPTIONS_INIT;\n\t\tmemcpy(opts, &default_apply_opts, sizeof(git_stash_apply_options));\n\t}\n\n\tif ((opts->checkout_options.checkout_strategy & (GIT_CHECKOUT_SAFE | GIT_CHECKOUT_FORCE)) == 0)\n\t\topts->checkout_options.checkout_strategy = GIT_CHECKOUT_SAFE;\n\n\tif (!opts->checkout_options.our_label)\n\t\topts->checkout_options.our_label = \"Updated upstream\";\n\n\tif (!opts->checkout_options.their_label)\n\t\topts->checkout_options.their_label = \"Stashed changes\";\n}"
  },
  {
    "function_name": "merge_index_and_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "701-726",
    "snippet": "static int merge_index_and_tree(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_tree *theirs_tree)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(&theirs, theirs_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "theirs"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__iterators",
          "args": [
            "out",
            "repo",
            "ancestor",
            "ours",
            "theirs",
            "NULL"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1822-1908",
          "snippet": "int git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&theirs",
            "theirs_tree",
            "&iter_opts"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&ours",
            "repo",
            "ours_index",
            "&iter_opts"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int merge_index_and_tree(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_tree *theirs_tree)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_tree(&theirs, theirs_tree, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}"
  },
  {
    "function_name": "merge_indexes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "674-699",
    "snippet": "static int merge_indexes(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_index *theirs_index)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&theirs, repo, theirs_index, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "theirs"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_merge__iterators",
          "args": [
            "out",
            "repo",
            "ancestor",
            "ours",
            "theirs",
            "NULL"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "git_merge__iterators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/merge.c",
          "lines": "1822-1908",
          "snippet": "int git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/sys/index.h\"",
            "#include \"git2/annotated_commit.h\"",
            "#include \"git2/oidarray.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/reset.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/types.h\"",
            "#include \"oidarray.h\"",
            "#include \"commit.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"oidarray.h\"",
            "#include \"config.h\"",
            "#include \"filebuf.h\"",
            "#include \"index.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"checkout.h\"",
            "#include \"diff.h\"",
            "#include \"refs.h\"",
            "#include \"iterator.h\"",
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"path.h\"",
            "#include \"merge.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"repository.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/hashsig.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/annotated_commit.h\"\n#include \"git2/oidarray.h\"\n#include \"git2/tree.h\"\n#include \"git2/config.h\"\n#include \"git2/signature.h\"\n#include \"git2/checkout.h\"\n#include \"git2/reset.h\"\n#include \"git2/refs.h\"\n#include \"git2/merge.h\"\n#include \"git2/commit.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/types.h\"\n#include \"oidarray.h\"\n#include \"commit.h\"\n#include \"annotated_commit.h\"\n#include \"oidarray.h\"\n#include \"config.h\"\n#include \"filebuf.h\"\n#include \"index.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"checkout.h\"\n#include \"diff.h\"\n#include \"refs.h\"\n#include \"iterator.h\"\n#include \"object.h\"\n#include \"refs.h\"\n#include \"path.h\"\n#include \"merge.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nstatic int merge_annotated_commits(\n\tgit_index **index_out,\n\tgit_annotated_commit **base_out,\n\tgit_repository *repo,\n\tgit_annotated_commit *our_commit,\n\tgit_annotated_commit *their_commit,\n\tsize_t recursion_level,\n\tconst git_merge_options *opts);\n\nint git_merge__iterators(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_iterator *ancestor_iter,\n\tgit_iterator *our_iter,\n\tgit_iterator *theirs_iter,\n\tconst git_merge_options *given_opts)\n{\n\tgit_iterator *empty_ancestor = NULL,\n\t\t*empty_ours = NULL,\n\t\t*empty_theirs = NULL;\n\tgit_merge_diff_list *diff_list;\n\tgit_merge_options opts;\n\tgit_merge_file_options file_opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_diff *conflict;\n\tgit_vector changes;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(out && repo);\n\n\t*out = NULL;\n\n\tGITERR_CHECK_VERSION(\n\t\tgiven_opts, GIT_MERGE_OPTIONS_VERSION, \"git_merge_options\");\n\n\tif ((error = merge_normalize_opts(repo, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tfile_opts.favor = opts.file_favor;\n\tfile_opts.flags = opts.file_flags;\n\n\t/* use the git-inspired labels when virtual base building */\n\tif (opts.flags & GIT_MERGE__VIRTUAL_BASE) {\n\t\tfile_opts.ancestor_label = \"merged common ancestors\";\n\t\tfile_opts.our_label = \"Temporary merge branch 1\";\n\t\tfile_opts.their_label = \"Temporary merge branch 2\";\n\t\tfile_opts.flags |= GIT_MERGE_FILE_FAVOR__CONFLICTED;\n\t}\n\n\tdiff_list = git_merge_diff_list__alloc(repo);\n\tGITERR_CHECK_ALLOC(diff_list);\n\n\tancestor_iter = iterator_given_or_empty(&empty_ancestor, ancestor_iter);\n\tour_iter = iterator_given_or_empty(&empty_ours, our_iter);\n\ttheirs_iter = iterator_given_or_empty(&empty_theirs, theirs_iter);\n\n\tif ((error = git_merge_diff_list__find_differences(\n\t\t\tdiff_list, ancestor_iter, our_iter, theirs_iter)) < 0 ||\n\t\t(error = git_merge_diff_list__find_renames(repo, diff_list, &opts)) < 0)\n\t\tgoto done;\n\n\tmemcpy(&changes, &diff_list->conflicts, sizeof(git_vector));\n\tgit_vector_clear(&diff_list->conflicts);\n\n\tgit_vector_foreach(&changes, i, conflict) {\n\t\tint resolved = 0;\n\n\t\tif ((error = merge_conflict_resolve(\n\t\t\t&resolved, diff_list, conflict, &file_opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (!resolved) {\n\t\t\tif ((opts.flags & GIT_MERGE_FAIL_ON_CONFLICT)) {\n\t\t\t\tgiterr_set(GITERR_MERGE, \"merge conflicts exist\");\n\t\t\t\terror = GIT_EMERGECONFLICT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgit_vector_insert(&diff_list->conflicts, conflict);\n\t\t}\n\t}\n\n\terror = index_from_diff_list(out, diff_list,\n\t\t(opts.flags & GIT_MERGE_SKIP_REUC));\n\ndone:\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\tgit_merge_diff_list__free(diff_list);\n\tgit_iterator_free(empty_ancestor);\n\tgit_iterator_free(empty_ours);\n\tgit_iterator_free(empty_theirs);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&theirs",
            "repo",
            "theirs_index",
            "&iter_opts"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&ancestor",
            "ancestor_tree",
            "&iter_opts"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int merge_indexes(\n\tgit_index **out,\n\tgit_repository *repo,\n\tgit_tree *ancestor_tree,\n\tgit_index *ours_index,\n\tgit_index *theirs_index)\n{\n\tgit_iterator *ancestor = NULL, *ours = NULL, *theirs = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tint error;\n\n\titer_opts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_tree(&ancestor, ancestor_tree, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&ours, repo, ours_index, &iter_opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&theirs, repo, theirs_index, &iter_opts)) < 0)\n\t\tgoto done;\n\n\terror = git_merge__iterators(out, repo, ancestor, ours, theirs, NULL);\n\ndone:\n\tgit_iterator_free(ancestor);\n\tgit_iterator_free(ours);\n\tgit_iterator_free(theirs);\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_stash_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "609-672",
    "snippet": "static int retrieve_stash_trees(\n\tgit_tree **out_stash_tree,\n\tgit_tree **out_base_tree,\n\tgit_tree **out_index_tree,\n\tgit_tree **out_index_parent_tree,\n\tgit_tree **out_untracked_tree,\n\tgit_commit *stash_commit)\n{\n\tgit_tree *stash_tree = NULL;\n\tgit_commit *base_commit = NULL;\n\tgit_tree *base_tree = NULL;\n\tgit_commit *index_commit = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_commit *index_parent_commit = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_commit *untracked_commit = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tint error;\n\n\tif ((error = git_commit_tree(&stash_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&base_commit, stash_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&base_tree, base_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_commit, stash_commit, 1)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_tree, index_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_parent_commit, index_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_parent_tree, index_parent_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_commit_parentcount(stash_commit) == 3) {\n\t\tif ((error = git_commit_parent(&untracked_commit, stash_commit, 2)) < 0)\n\t\t\tgoto cleanup;\n\t\tif ((error = git_commit_tree(&untracked_tree, untracked_commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*out_stash_tree = stash_tree;\n\t*out_base_tree = base_tree;\n\t*out_index_tree = index_tree;\n\t*out_index_parent_tree = index_parent_tree;\n\t*out_untracked_tree = untracked_tree;\n\ncleanup:\n\tgit_commit_free(untracked_commit);\n\tgit_commit_free(index_parent_commit);\n\tgit_commit_free(index_commit);\n\tgit_commit_free(base_commit);\n\tif (error < 0) {\n\t\tgit_tree_free(stash_tree);\n\t\tgit_tree_free(base_tree);\n\t\tgit_tree_free(index_tree);\n\t\tgit_tree_free(index_parent_tree);\n\t\tgit_tree_free(untracked_tree);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "untracked_tree"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "base_commit"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&untracked_tree",
            "untracked_commit"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&untracked_commit",
            "stash_commit",
            "2"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "stash_commit"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_stash_trees(\n\tgit_tree **out_stash_tree,\n\tgit_tree **out_base_tree,\n\tgit_tree **out_index_tree,\n\tgit_tree **out_index_parent_tree,\n\tgit_tree **out_untracked_tree,\n\tgit_commit *stash_commit)\n{\n\tgit_tree *stash_tree = NULL;\n\tgit_commit *base_commit = NULL;\n\tgit_tree *base_tree = NULL;\n\tgit_commit *index_commit = NULL;\n\tgit_tree *index_tree = NULL;\n\tgit_commit *index_parent_commit = NULL;\n\tgit_tree *index_parent_tree = NULL;\n\tgit_commit *untracked_commit = NULL;\n\tgit_tree *untracked_tree = NULL;\n\tint error;\n\n\tif ((error = git_commit_tree(&stash_tree, stash_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&base_commit, stash_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&base_tree, base_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_commit, stash_commit, 1)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_tree, index_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_parent(&index_parent_commit, index_commit, 0)) < 0)\n\t\tgoto cleanup;\n\tif ((error = git_commit_tree(&index_parent_tree, index_parent_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif (git_commit_parentcount(stash_commit) == 3) {\n\t\tif ((error = git_commit_parent(&untracked_commit, stash_commit, 2)) < 0)\n\t\t\tgoto cleanup;\n\t\tif ((error = git_commit_tree(&untracked_tree, untracked_commit)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t*out_stash_tree = stash_tree;\n\t*out_base_tree = base_tree;\n\t*out_index_tree = index_tree;\n\t*out_index_parent_tree = index_parent_tree;\n\t*out_untracked_tree = untracked_tree;\n\ncleanup:\n\tgit_commit_free(untracked_commit);\n\tgit_commit_free(index_parent_commit);\n\tgit_commit_free(index_commit);\n\tgit_commit_free(base_commit);\n\tif (error < 0) {\n\t\tgit_tree_free(stash_tree);\n\t\tgit_tree_free(base_tree);\n\t\tgit_tree_free(index_tree);\n\t\tgit_tree_free(index_parent_tree);\n\t\tgit_tree_free(untracked_tree);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_stash_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "575-607",
    "snippet": "static int retrieve_stash_commit(\n\tgit_commit **commit,\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t max;\n\tconst git_reflog_entry *entry;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tentry = git_reflog_entry_byindex(reflog, index);\n\tif ((error = git_commit_lookup(commit, repo, git_reflog_entry_id_new(entry))) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "reflog"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "stash"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "commit",
            "repo",
            "git_reflog_entry_id_new(entry)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_id_new",
          "args": [
            "entry"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_id_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "168-172",
          "snippet": "const git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_byindex",
          "args": [
            "reflog",
            "index"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "151-160",
          "snippet": "const git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_STASH",
            "\"No stashed state at position %\" PRIuZ",
            "index"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entrycount",
          "args": [
            "reflog"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "145-149",
          "snippet": "size_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nsize_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_read",
          "args": [
            "&reflog",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "51-62",
          "snippet": "int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&stash",
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_stash_commit(\n\tgit_commit **commit,\n\tgit_repository *repo,\n\tsize_t index)\n{\n\tgit_reference *stash = NULL;\n\tgit_reflog *reflog = NULL;\n\tint error;\n\tsize_t max;\n\tconst git_reflog_entry *entry;\n\n\tif ((error = git_reference_lookup(&stash, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_reflog_read(&reflog, repo, GIT_REFS_STASH_FILE)) < 0)\n\t\tgoto cleanup;\n\n\tmax = git_reflog_entrycount(reflog);\n\tif (!max || index > max - 1) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_STASH, \"No stashed state at position %\" PRIuZ, index);\n\t\tgoto cleanup;\n\t}\n\n\tentry = git_reflog_entry_byindex(reflog, index);\n\tif ((error = git_commit_lookup(commit, repo, git_reflog_entry_id_new(entry))) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(stash);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
  },
  {
    "function_name": "git_stash_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "505-573",
    "snippet": "int git_stash_save(\n\tgit_oid *out,\n\tgit_repository *repo,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tuint32_t flags)\n{\n\tgit_index *index = NULL;\n\tgit_commit *b_commit = NULL, *i_commit = NULL, *u_commit = NULL;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tassert(out && repo && stasher);\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"stash save\")) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_base_commit_and_message(&b_commit, &msg, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = ensure_there_are_changes_to_stash(\n\t\trepo,\n\t\t(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0,\n\t\t(flags & GIT_STASH_INCLUDE_IGNORED) != 0)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = commit_index(\n\t\t\t&i_commit, index, stasher, git_buf_cstr(&msg), b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((flags & (GIT_STASH_INCLUDE_UNTRACKED | GIT_STASH_INCLUDE_IGNORED)) &&\n\t\t(error = commit_untracked(\n\t\t\t&u_commit, index, stasher, git_buf_cstr(&msg),\n\t\t\ti_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = prepare_worktree_commit_message(&msg, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = commit_worktree(\n\t\t\tout, index, stasher, git_buf_cstr(&msg),\n\t\t\ti_commit, b_commit, u_commit)) < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_rtrim(&msg);\n\n\tif ((error = update_reflog(out, repo, git_buf_cstr(&msg))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = reset_index_and_workdir(\n\t\trepo,\n\t\t((flags & GIT_STASH_KEEP_INDEX) != 0) ? i_commit : b_commit,\n\t\t(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0,\n\t\t(flags & GIT_STASH_INCLUDE_IGNORED) != 0)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\n\tgit_buf_free(&msg);\n\tgit_commit_free(i_commit);\n\tgit_commit_free(b_commit);\n\tgit_commit_free(u_commit);\n\tgit_index_free(index);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "u_commit"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&msg"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_index_and_workdir",
          "args": [
            "repo",
            "((flags & GIT_STASH_KEEP_INDEX) != 0) ? i_commit : b_commit",
            "(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0",
            "(flags & GIT_STASH_INCLUDE_IGNORED) != 0"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "reset_index_and_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "486-503",
          "snippet": "static int reset_index_and_workdir(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tbool remove_untracked,\n\tbool remove_ignored)\n{\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tif (remove_untracked)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_UNTRACKED;\n\n\tif (remove_ignored)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_IGNORED;\n\n\treturn git_checkout_tree(repo, (git_object *)commit, &opts);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int reset_index_and_workdir(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tbool remove_untracked,\n\tbool remove_ignored)\n{\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tif (remove_untracked)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_UNTRACKED;\n\n\tif (remove_ignored)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_IGNORED;\n\n\treturn git_checkout_tree(repo, (git_object *)commit, &opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_reflog",
          "args": [
            "out",
            "repo",
            "git_buf_cstr(&msg)"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "update_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "429-445",
          "snippet": "static int update_reflog(\n\tgit_oid *w_commit_oid,\n\tgit_repository *repo,\n\tconst char *message)\n{\n\tgit_reference *stash;\n\tint error;\n\n\tif ((error = git_reference_ensure_log(repo, GIT_REFS_STASH_FILE)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&stash, repo, GIT_REFS_STASH_FILE, w_commit_oid, 1, message);\n\n\tgit_reference_free(stash);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int update_reflog(\n\tgit_oid *w_commit_oid,\n\tgit_repository *repo,\n\tconst char *message)\n{\n\tgit_reference *stash;\n\tint error;\n\n\tif ((error = git_reference_ensure_log(repo, GIT_REFS_STASH_FILE)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&stash, repo, GIT_REFS_STASH_FILE, w_commit_oid, 1, message);\n\n\tgit_reference_free(stash);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&msg"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtrim",
          "args": [
            "&msg"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "718-729",
          "snippet": "void git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_worktree",
          "args": [
            "out",
            "index",
            "stasher",
            "git_buf_cstr(&msg)",
            "i_commit",
            "b_commit",
            "u_commit"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "commit_worktree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "352-394",
          "snippet": "static int commit_worktree(\n\tgit_oid *w_commit_oid,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tgit_commit *b_commit,\n\tgit_commit *u_commit)\n{\n\tint error = 0;\n\tgit_tree *w_tree = NULL, *i_tree = NULL;\n\tconst git_commit *parents[] = {\tNULL, NULL,\tNULL };\n\n\tparents[0] = b_commit;\n\tparents[1] = i_commit;\n\tparents[2] = u_commit;\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_index_read_tree(index, i_tree)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = build_workdir_tree(&w_tree, index, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_create(\n\t\tw_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tmessage,\n\t\tw_tree,\n\t\tu_commit ? 3 : 2,\n\t\tparents);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_tree_free(w_tree);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_worktree(\n\tgit_oid *w_commit_oid,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tgit_commit *b_commit,\n\tgit_commit *u_commit)\n{\n\tint error = 0;\n\tgit_tree *w_tree = NULL, *i_tree = NULL;\n\tconst git_commit *parents[] = {\tNULL, NULL,\tNULL };\n\n\tparents[0] = b_commit;\n\tparents[1] = i_commit;\n\tparents[2] = u_commit;\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_index_read_tree(index, i_tree)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = build_workdir_tree(&w_tree, index, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_create(\n\t\tw_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tmessage,\n\t\tw_tree,\n\t\tu_commit ? 3 : 2,\n\t\tparents);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_tree_free(w_tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_worktree_commit_message",
          "args": [
            "&msg",
            "message"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_worktree_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "396-427",
          "snippet": "static int prepare_worktree_commit_message(\n\tgit_buf* msg,\n\tconst char *user_message)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_buf_set(&buf, git_buf_cstr(msg), git_buf_len(msg))) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(msg);\n\n\tif (!user_message)\n\t\tgit_buf_printf(msg, \"WIP on %s\", git_buf_cstr(&buf));\n\telse {\n\t\tconst char *colon;\n\n\t\tif ((colon = strchr(git_buf_cstr(&buf), ':')) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tgit_buf_puts(msg, \"On \");\n\t\tgit_buf_put(msg, git_buf_cstr(&buf), colon - buf.ptr);\n\t\tgit_buf_printf(msg, \": %s\\n\", user_message);\n\t}\n\n\terror = (git_buf_oom(msg) || git_buf_oom(&buf)) ? -1 : 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int prepare_worktree_commit_message(\n\tgit_buf* msg,\n\tconst char *user_message)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_buf_set(&buf, git_buf_cstr(msg), git_buf_len(msg))) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(msg);\n\n\tif (!user_message)\n\t\tgit_buf_printf(msg, \"WIP on %s\", git_buf_cstr(&buf));\n\telse {\n\t\tconst char *colon;\n\n\t\tif ((colon = strchr(git_buf_cstr(&buf), ':')) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tgit_buf_puts(msg, \"On \");\n\t\tgit_buf_put(msg, git_buf_cstr(&buf), colon - buf.ptr);\n\t\tgit_buf_printf(msg, \": %s\\n\", user_message);\n\t}\n\n\terror = (git_buf_oom(msg) || git_buf_oom(&buf)) ? -1 : 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_untracked",
          "args": [
            "&u_commit",
            "index",
            "stasher",
            "git_buf_cstr(&msg)",
            "i_commit",
            "flags"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "commit_untracked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "256-294",
          "snippet": "static int commit_untracked(\n\tgit_commit **u_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *u_tree = NULL;\n\tgit_oid u_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_untracked_tree(&u_tree, index, i_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"untracked files on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&u_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\tu_tree,\n\t\t0,\n\t\tNULL)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(u_commit, git_index_owner(index), &u_commit_oid);\n\ncleanup:\n\tgit_tree_free(u_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_untracked(\n\tgit_commit **u_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *u_tree = NULL;\n\tgit_oid u_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_untracked_tree(&u_tree, index, i_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"untracked files on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&u_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\tu_tree,\n\t\t0,\n\t\tNULL)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(u_commit, git_index_owner(index), &u_commit_oid);\n\ncleanup:\n\tgit_tree_free(u_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_index",
          "args": [
            "&i_commit",
            "index",
            "stasher",
            "git_buf_cstr(&msg)",
            "b_commit"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "commit_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "115-152",
          "snippet": "static int commit_index(\n\tgit_commit **i_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tconst git_commit *parent)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_oid i_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_tree_from_index(&i_tree, index)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"index on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&i_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\ti_tree,\n\t\t1,\n\t\t&parent)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(i_commit, git_index_owner(index), &i_commit_oid);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_index(\n\tgit_commit **i_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tconst git_commit *parent)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_oid i_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_tree_from_index(&i_tree, index)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"index on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&i_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\ti_tree,\n\t\t1,\n\t\t&parent)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(i_commit, git_index_owner(index), &i_commit_oid);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_there_are_changes_to_stash",
          "args": [
            "repo",
            "(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0",
            "(flags & GIT_STASH_INCLUDE_IGNORED) != 0"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_there_are_changes_to_stash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "456-484",
          "snippet": "static int ensure_there_are_changes_to_stash(\n\tgit_repository *repo,\n\tbool include_untracked_files,\n\tbool include_ignored_files)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\n\topts.show  = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_EXCLUDE_SUBMODULES;\n\n\tif (include_untracked_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;\n\n\tif (include_ignored_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS;\n\n\terror = git_status_foreach_ext(repo, &opts, is_dirty_cb, NULL);\n\n\tif (error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\tif (!error)\n\t\treturn create_error(GIT_ENOTFOUND, \"There is nothing to stash.\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int ensure_there_are_changes_to_stash(\n\tgit_repository *repo,\n\tbool include_untracked_files,\n\tbool include_ignored_files)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\n\topts.show  = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_EXCLUDE_SUBMODULES;\n\n\tif (include_untracked_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;\n\n\tif (include_ignored_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS;\n\n\terror = git_status_foreach_ext(repo, &opts, is_dirty_cb, NULL);\n\n\tif (error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\tif (!error)\n\t\treturn create_error(GIT_ENOTFOUND, \"There is nothing to stash.\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_base_commit_and_message",
          "args": [
            "&b_commit",
            "&msg",
            "repo"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_base_commit_and_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "71-102",
          "snippet": "static int retrieve_base_commit_and_message(\n\tgit_commit **b_commit,\n\tgit_buf *stash_message,\n\tgit_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint error;\n\n\tif ((error = retrieve_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif (strcmp(\"HEAD\", git_reference_name(head)) == 0)\n\t\terror = git_buf_puts(stash_message, \"(no branch): \");\n\telse\n\t\terror = git_buf_printf(\n\t\t\tstash_message,\n\t\t\t\"%s: \",\n\t\t\tgit_reference_name(head) + strlen(GIT_REFS_HEADS_DIR));\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_lookup(\n\t\t\t b_commit, repo, git_reference_target(head))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = append_commit_description(stash_message, *b_commit)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_base_commit_and_message(\n\tgit_commit **b_commit,\n\tgit_buf *stash_message,\n\tgit_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint error;\n\n\tif ((error = retrieve_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif (strcmp(\"HEAD\", git_reference_name(head)) == 0)\n\t\terror = git_buf_puts(stash_message, \"(no branch): \");\n\telse\n\t\terror = git_buf_printf(\n\t\t\tstash_message,\n\t\t\t\"%s: \",\n\t\t\tgit_reference_name(head) + strlen(GIT_REFS_HEADS_DIR));\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_lookup(\n\t\t\t b_commit, repo, git_reference_target(head))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = append_commit_description(stash_message, *b_commit)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"stash save\""
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && stasher"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_stash_save(\n\tgit_oid *out,\n\tgit_repository *repo,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tuint32_t flags)\n{\n\tgit_index *index = NULL;\n\tgit_commit *b_commit = NULL, *i_commit = NULL, *u_commit = NULL;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tassert(out && repo && stasher);\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"stash save\")) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_base_commit_and_message(&b_commit, &msg, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = ensure_there_are_changes_to_stash(\n\t\trepo,\n\t\t(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0,\n\t\t(flags & GIT_STASH_INCLUDE_IGNORED) != 0)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = commit_index(\n\t\t\t&i_commit, index, stasher, git_buf_cstr(&msg), b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((flags & (GIT_STASH_INCLUDE_UNTRACKED | GIT_STASH_INCLUDE_IGNORED)) &&\n\t\t(error = commit_untracked(\n\t\t\t&u_commit, index, stasher, git_buf_cstr(&msg),\n\t\t\ti_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = prepare_worktree_commit_message(&msg, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = commit_worktree(\n\t\t\tout, index, stasher, git_buf_cstr(&msg),\n\t\t\ti_commit, b_commit, u_commit)) < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_rtrim(&msg);\n\n\tif ((error = update_reflog(out, repo, git_buf_cstr(&msg))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = reset_index_and_workdir(\n\t\trepo,\n\t\t((flags & GIT_STASH_KEEP_INDEX) != 0) ? i_commit : b_commit,\n\t\t(flags & GIT_STASH_INCLUDE_UNTRACKED) != 0,\n\t\t(flags & GIT_STASH_INCLUDE_IGNORED) != 0)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\n\tgit_buf_free(&msg);\n\tgit_commit_free(i_commit);\n\tgit_commit_free(b_commit);\n\tgit_commit_free(u_commit);\n\tgit_index_free(index);\n\n\treturn error;\n}"
  },
  {
    "function_name": "reset_index_and_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "486-503",
    "snippet": "static int reset_index_and_workdir(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tbool remove_untracked,\n\tbool remove_ignored)\n{\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tif (remove_untracked)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_UNTRACKED;\n\n\tif (remove_ignored)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_IGNORED;\n\n\treturn git_checkout_tree(repo, (git_object *)commit, &opts);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_checkout_tree",
          "args": [
            "repo",
            "(git_object *)commit",
            "&opts"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int reset_index_and_workdir(\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tbool remove_untracked,\n\tbool remove_ignored)\n{\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tif (remove_untracked)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_UNTRACKED;\n\n\tif (remove_ignored)\n\t\topts.checkout_strategy |= GIT_CHECKOUT_REMOVE_IGNORED;\n\n\treturn git_checkout_tree(repo, (git_object *)commit, &opts);\n}"
  },
  {
    "function_name": "ensure_there_are_changes_to_stash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "456-484",
    "snippet": "static int ensure_there_are_changes_to_stash(\n\tgit_repository *repo,\n\tbool include_untracked_files,\n\tbool include_ignored_files)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\n\topts.show  = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_EXCLUDE_SUBMODULES;\n\n\tif (include_untracked_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;\n\n\tif (include_ignored_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS;\n\n\terror = git_status_foreach_ext(repo, &opts, is_dirty_cb, NULL);\n\n\tif (error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\tif (!error)\n\t\treturn create_error(GIT_ENOTFOUND, \"There is nothing to stash.\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_error",
          "args": [
            "GIT_ENOTFOUND",
            "\"There is nothing to stash.\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "create_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "27-31",
          "snippet": "static int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_status_foreach_ext",
          "args": [
            "repo",
            "&opts",
            "is_dirty_cb",
            "NULL"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_foreach_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "413-442",
          "snippet": "int git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int ensure_there_are_changes_to_stash(\n\tgit_repository *repo,\n\tbool include_untracked_files,\n\tbool include_ignored_files)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\n\topts.show  = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_EXCLUDE_SUBMODULES;\n\n\tif (include_untracked_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;\n\n\tif (include_ignored_files)\n\t\topts.flags |= GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS;\n\n\terror = git_status_foreach_ext(repo, &opts, is_dirty_cb, NULL);\n\n\tif (error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\tif (!error)\n\t\treturn create_error(GIT_ENOTFOUND, \"There is nothing to stash.\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "is_dirty_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "447-454",
    "snippet": "static int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "status"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "path"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}"
  },
  {
    "function_name": "update_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "429-445",
    "snippet": "static int update_reflog(\n\tgit_oid *w_commit_oid,\n\tgit_repository *repo,\n\tconst char *message)\n{\n\tgit_reference *stash;\n\tint error;\n\n\tif ((error = git_reference_ensure_log(repo, GIT_REFS_STASH_FILE)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&stash, repo, GIT_REFS_STASH_FILE, w_commit_oid, 1, message);\n\n\tgit_reference_free(stash);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "stash"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_create",
          "args": [
            "&stash",
            "repo",
            "GIT_REFS_STASH_FILE",
            "w_commit_oid",
            "1",
            "message"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "464-473",
          "snippet": "int git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_create(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tconst git_oid *id,\n\tint force,\n\tconst char *log_message)\n{\n        return git_reference_create_matching(ref_out, repo, name, id, force, NULL, log_message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_ensure_log",
          "args": [
            "repo",
            "GIT_REFS_STASH_FILE"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_ensure_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1159-1170",
          "snippet": "int git_reference_ensure_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_ensure_log(refdb, refname);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_ensure_log(git_repository *repo, const char *refname)\n{\n\tint error;\n\tgit_refdb *refdb;\n\n\tassert(repo && refname);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_ensure_log(refdb, refname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int update_reflog(\n\tgit_oid *w_commit_oid,\n\tgit_repository *repo,\n\tconst char *message)\n{\n\tgit_reference *stash;\n\tint error;\n\n\tif ((error = git_reference_ensure_log(repo, GIT_REFS_STASH_FILE)) < 0)\n\t\treturn error;\n\n\terror = git_reference_create(&stash, repo, GIT_REFS_STASH_FILE, w_commit_oid, 1, message);\n\n\tgit_reference_free(stash);\n\n\treturn error;\n}"
  },
  {
    "function_name": "prepare_worktree_commit_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "396-427",
    "snippet": "static int prepare_worktree_commit_message(\n\tgit_buf* msg,\n\tconst char *user_message)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_buf_set(&buf, git_buf_cstr(msg), git_buf_len(msg))) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(msg);\n\n\tif (!user_message)\n\t\tgit_buf_printf(msg, \"WIP on %s\", git_buf_cstr(&buf));\n\telse {\n\t\tconst char *colon;\n\n\t\tif ((colon = strchr(git_buf_cstr(&buf), ':')) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tgit_buf_puts(msg, \"On \");\n\t\tgit_buf_put(msg, git_buf_cstr(&buf), colon - buf.ptr);\n\t\tgit_buf_printf(msg, \": %s\\n\", user_message);\n\t}\n\n\terror = (git_buf_oom(msg) || git_buf_oom(&buf)) ? -1 : 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&buf"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "msg",
            "\": %s\\n\"",
            "user_message"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "msg",
            "git_buf_cstr(&buf)",
            "colon - buf.ptr"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "msg",
            "\"On \""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "git_buf_cstr(&buf)",
            "':'"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "msg"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "&buf",
            "git_buf_cstr(msg)",
            "git_buf_len(msg)"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "msg"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int prepare_worktree_commit_message(\n\tgit_buf* msg,\n\tconst char *user_message)\n{\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_buf_set(&buf, git_buf_cstr(msg), git_buf_len(msg))) < 0)\n\t\treturn error;\n\n\tgit_buf_clear(msg);\n\n\tif (!user_message)\n\t\tgit_buf_printf(msg, \"WIP on %s\", git_buf_cstr(&buf));\n\telse {\n\t\tconst char *colon;\n\n\t\tif ((colon = strchr(git_buf_cstr(&buf), ':')) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tgit_buf_puts(msg, \"On \");\n\t\tgit_buf_put(msg, git_buf_cstr(&buf), colon - buf.ptr);\n\t\tgit_buf_printf(msg, \": %s\\n\", user_message);\n\t}\n\n\terror = (git_buf_oom(msg) || git_buf_oom(&buf)) ? -1 : 0;\n\ncleanup:\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "commit_worktree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "352-394",
    "snippet": "static int commit_worktree(\n\tgit_oid *w_commit_oid,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tgit_commit *b_commit,\n\tgit_commit *u_commit)\n{\n\tint error = 0;\n\tgit_tree *w_tree = NULL, *i_tree = NULL;\n\tconst git_commit *parents[] = {\tNULL, NULL,\tNULL };\n\n\tparents[0] = b_commit;\n\tparents[1] = i_commit;\n\tparents[2] = u_commit;\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_index_read_tree(index, i_tree)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = build_workdir_tree(&w_tree, index, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_create(\n\t\tw_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tmessage,\n\t\tw_tree,\n\t\tu_commit ? 3 : 2,\n\t\tparents);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_tree_free(w_tree);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "w_tree"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_create",
          "args": [
            "w_commit_oid",
            "git_index_owner(index)",
            "NULL",
            "stasher",
            "stasher",
            "NULL",
            "message",
            "w_tree",
            "u_commit ? 3 : 2",
            "parents"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "240-260",
          "snippet": "int git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_workdir_tree",
          "args": [
            "&w_tree",
            "index",
            "b_commit"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "build_workdir_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "315-350",
          "snippet": "static int build_workdir_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *b_commit)\n{\n\tgit_repository *repo = git_index_owner(index);\n\tgit_tree *b_tree = NULL;\n\tgit_diff *diff = NULL, *idx_to_wd = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\topts.flags = GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_INCLUDE_UNTRACKED;\n\n\tif ((error = git_commit_tree(&b_tree, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_index(&diff, repo, b_tree, index, &opts)) < 0 ||\n\t\t(error = git_diff_index_to_workdir(&idx_to_wd, repo, index, &opts)) < 0 ||\n\t\t(error = git_diff__merge(diff, idx_to_wd, stash_delta_merge)) < 0)\n\t\tgoto cleanup;\n\n\tdata.include_changed = true;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(idx_to_wd);\n\tgit_diff_free(diff);\n\tgit_tree_free(b_tree);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_workdir_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *b_commit)\n{\n\tgit_repository *repo = git_index_owner(index);\n\tgit_tree *b_tree = NULL;\n\tgit_diff *diff = NULL, *idx_to_wd = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\topts.flags = GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_INCLUDE_UNTRACKED;\n\n\tif ((error = git_commit_tree(&b_tree, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_index(&diff, repo, b_tree, index, &opts)) < 0 ||\n\t\t(error = git_diff_index_to_workdir(&idx_to_wd, repo, index, &opts)) < 0 ||\n\t\t(error = git_diff__merge(diff, idx_to_wd, stash_delta_merge)) < 0)\n\t\tgoto cleanup;\n\n\tdata.include_changed = true;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(idx_to_wd);\n\tgit_diff_free(diff);\n\tgit_tree_free(b_tree);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_read_tree",
          "args": [
            "index",
            "i_tree"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2865-2926",
          "snippet": "int git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&i_tree",
            "i_commit"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_worktree(\n\tgit_oid *w_commit_oid,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tgit_commit *b_commit,\n\tgit_commit *u_commit)\n{\n\tint error = 0;\n\tgit_tree *w_tree = NULL, *i_tree = NULL;\n\tconst git_commit *parents[] = {\tNULL, NULL,\tNULL };\n\n\tparents[0] = b_commit;\n\tparents[1] = i_commit;\n\tparents[2] = u_commit;\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_index_read_tree(index, i_tree)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = build_workdir_tree(&w_tree, index, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_create(\n\t\tw_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tmessage,\n\t\tw_tree,\n\t\tu_commit ? 3 : 2,\n\t\tparents);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_tree_free(w_tree);\n\treturn error;\n}"
  },
  {
    "function_name": "build_workdir_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "315-350",
    "snippet": "static int build_workdir_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *b_commit)\n{\n\tgit_repository *repo = git_index_owner(index);\n\tgit_tree *b_tree = NULL;\n\tgit_diff *diff = NULL, *idx_to_wd = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\topts.flags = GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_INCLUDE_UNTRACKED;\n\n\tif ((error = git_commit_tree(&b_tree, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_index(&diff, repo, b_tree, index, &opts)) < 0 ||\n\t\t(error = git_diff_index_to_workdir(&idx_to_wd, repo, index, &opts)) < 0 ||\n\t\t(error = git_diff__merge(diff, idx_to_wd, stash_delta_merge)) < 0)\n\t\tgoto cleanup;\n\n\tdata.include_changed = true;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(idx_to_wd);\n\tgit_diff_free(diff);\n\tgit_tree_free(b_tree);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "b_tree"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_tree_from_index",
          "args": [
            "tree_out",
            "index"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "build_tree_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "104-113",
          "snippet": "static int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_update_index_from_diff",
          "args": [
            "index",
            "diff",
            "&data"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "stash_update_index_from_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "160-210",
          "snippet": "static int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__merge",
          "args": [
            "diff",
            "idx_to_wd",
            "stash_delta_merge"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "112-195",
          "snippet": "int git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&idx_to_wd",
            "repo",
            "index",
            "&opts"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&diff",
            "repo",
            "b_tree",
            "index",
            "&opts"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&b_tree",
            "b_commit"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_workdir_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *b_commit)\n{\n\tgit_repository *repo = git_index_owner(index);\n\tgit_tree *b_tree = NULL;\n\tgit_diff *diff = NULL, *idx_to_wd = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\topts.flags = GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_INCLUDE_UNTRACKED;\n\n\tif ((error = git_commit_tree(&b_tree, b_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_index(&diff, repo, b_tree, index, &opts)) < 0 ||\n\t\t(error = git_diff_index_to_workdir(&idx_to_wd, repo, index, &opts)) < 0 ||\n\t\t(error = git_diff__merge(diff, idx_to_wd, stash_delta_merge)) < 0)\n\t\tgoto cleanup;\n\n\tdata.include_changed = true;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(idx_to_wd);\n\tgit_diff_free(diff);\n\tgit_tree_free(b_tree);\n\n\treturn error;\n}"
  },
  {
    "function_name": "stash_delta_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "296-313",
    "snippet": "static git_diff_delta *stash_delta_merge(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\t/* Special case for stash: if a file is deleted in the index, but exists\n\t * in the working tree, we need to stash the workdir copy for the workdir.\n\t */\n\tif (a->status == GIT_DELTA_DELETED && b->status == GIT_DELTA_UNTRACKED) {\n\t\tgit_diff_delta *dup = git_diff__delta_dup(b, pool);\n\n\t\tif (dup)\n\t\t\tdup->status = GIT_DELTA_MODIFIED;\n\t\treturn dup;\n\t}\n\n\treturn git_diff__merge_like_cgit(a, b, pool);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff__merge_like_cgit",
          "args": [
            "a",
            "b",
            "pool"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__merge_like_cgit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "49-110",
          "snippet": "git_diff_delta *git_diff__merge_like_cgit(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\tgit_diff_delta *dup;\n\n\t/* Emulate C git for merging two diffs (a la 'git diff <sha>').\n\t *\n\t * When C git does a diff between the work dir and a tree, it actually\n\t * diffs with the index but uses the workdir contents.  This emulates\n\t * those choices so we can emulate the type of diff.\n\t *\n\t * We have three file descriptions here, let's call them:\n\t *  f1 = a->old_file\n\t *  f2 = a->new_file AND b->old_file\n\t *  f3 = b->new_file\n\t */\n\n\t/* If one of the diffs is a conflict, just dup it */\n\tif (b->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(b, pool);\n\tif (a->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* if f2 == f3 or f2 is deleted, then just dup the 'a' diff */\n\tif (b->status == GIT_DELTA_UNMODIFIED || a->status == GIT_DELTA_DELETED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* otherwise, base this diff on the 'b' diff */\n\tif ((dup = git_diff__delta_dup(b, pool)) == NULL)\n\t\treturn NULL;\n\n\t/* If 'a' status is uninteresting, then we're done */\n\tif (a->status == GIT_DELTA_UNMODIFIED ||\n\t\ta->status == GIT_DELTA_UNTRACKED ||\n\t\ta->status == GIT_DELTA_UNREADABLE)\n\t\treturn dup;\n\n\tassert(b->status != GIT_DELTA_UNMODIFIED);\n\n\t/* A cgit exception is that the diff of a file that is only in the\n\t * index (i.e. not in HEAD nor workdir) is given as empty.\n\t */\n\tif (dup->status == GIT_DELTA_DELETED) {\n\t\tif (a->status == GIT_DELTA_ADDED) {\n\t\t\tdup->status = GIT_DELTA_UNMODIFIED;\n\t\t\tdup->nfiles = 2;\n\t\t}\n\t\t/* else don't overwrite DELETE status */\n\t} else {\n\t\tdup->status = a->status;\n\t\tdup->nfiles = a->nfiles;\n\t}\n\n\tgit_oid_cpy(&dup->old_file.id, &a->old_file.id);\n\tdup->old_file.mode  = a->old_file.mode;\n\tdup->old_file.size  = a->old_file.size;\n\tdup->old_file.flags = a->old_file.flags;\n\n\treturn dup;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__merge_like_cgit(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\tgit_diff_delta *dup;\n\n\t/* Emulate C git for merging two diffs (a la 'git diff <sha>').\n\t *\n\t * When C git does a diff between the work dir and a tree, it actually\n\t * diffs with the index but uses the workdir contents.  This emulates\n\t * those choices so we can emulate the type of diff.\n\t *\n\t * We have three file descriptions here, let's call them:\n\t *  f1 = a->old_file\n\t *  f2 = a->new_file AND b->old_file\n\t *  f3 = b->new_file\n\t */\n\n\t/* If one of the diffs is a conflict, just dup it */\n\tif (b->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(b, pool);\n\tif (a->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* if f2 == f3 or f2 is deleted, then just dup the 'a' diff */\n\tif (b->status == GIT_DELTA_UNMODIFIED || a->status == GIT_DELTA_DELETED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* otherwise, base this diff on the 'b' diff */\n\tif ((dup = git_diff__delta_dup(b, pool)) == NULL)\n\t\treturn NULL;\n\n\t/* If 'a' status is uninteresting, then we're done */\n\tif (a->status == GIT_DELTA_UNMODIFIED ||\n\t\ta->status == GIT_DELTA_UNTRACKED ||\n\t\ta->status == GIT_DELTA_UNREADABLE)\n\t\treturn dup;\n\n\tassert(b->status != GIT_DELTA_UNMODIFIED);\n\n\t/* A cgit exception is that the diff of a file that is only in the\n\t * index (i.e. not in HEAD nor workdir) is given as empty.\n\t */\n\tif (dup->status == GIT_DELTA_DELETED) {\n\t\tif (a->status == GIT_DELTA_ADDED) {\n\t\t\tdup->status = GIT_DELTA_UNMODIFIED;\n\t\t\tdup->nfiles = 2;\n\t\t}\n\t\t/* else don't overwrite DELETE status */\n\t} else {\n\t\tdup->status = a->status;\n\t\tdup->nfiles = a->nfiles;\n\t}\n\n\tgit_oid_cpy(&dup->old_file.id, &a->old_file.id);\n\tdup->old_file.mode  = a->old_file.mode;\n\tdup->old_file.size  = a->old_file.size;\n\tdup->old_file.flags = a->old_file.flags;\n\n\treturn dup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__delta_dup",
          "args": [
            "b",
            "pool"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__delta_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "18-47",
          "snippet": "git_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *stash_delta_merge(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\t/* Special case for stash: if a file is deleted in the index, but exists\n\t * in the working tree, we need to stash the workdir copy for the workdir.\n\t */\n\tif (a->status == GIT_DELTA_DELETED && b->status == GIT_DELTA_UNTRACKED) {\n\t\tgit_diff_delta *dup = git_diff__delta_dup(b, pool);\n\n\t\tif (dup)\n\t\t\tdup->status = GIT_DELTA_MODIFIED;\n\t\treturn dup;\n\t}\n\n\treturn git_diff__merge_like_cgit(a, b, pool);\n}"
  },
  {
    "function_name": "commit_untracked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "256-294",
    "snippet": "static int commit_untracked(\n\tgit_commit **u_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *u_tree = NULL;\n\tgit_oid u_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_untracked_tree(&u_tree, index, i_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"untracked files on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&u_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\tu_tree,\n\t\t0,\n\t\tNULL)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(u_commit, git_index_owner(index), &u_commit_oid);\n\ncleanup:\n\tgit_tree_free(u_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&msg"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "u_tree"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "u_commit",
            "git_index_owner(index)",
            "&u_commit_oid"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_create",
          "args": [
            "&u_commit_oid",
            "git_index_owner(index)",
            "NULL",
            "stasher",
            "stasher",
            "NULL",
            "git_buf_cstr(&msg)",
            "u_tree",
            "0",
            "NULL"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "240-260",
          "snippet": "int git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&msg"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&msg",
            "\"untracked files on %s\\n\"",
            "message"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_untracked_tree",
          "args": [
            "&u_tree",
            "index",
            "i_commit",
            "flags"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "build_untracked_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "212-254",
          "snippet": "static int build_untracked_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\tgit_index_clear(index);\n\n\tif (flags & GIT_STASH_INCLUDE_UNTRACKED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\t\tdata.include_untracked = true;\n\t}\n\n\tif (flags & GIT_STASH_INCLUDE_IGNORED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED |\n\t\t\tGIT_DIFF_RECURSE_IGNORED_DIRS;\n\t\tdata.include_ignored = true;\n\t}\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_workdir(\n\t\t\t&diff, git_index_owner(index), i_tree, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(diff);\n\tgit_tree_free(i_tree);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_untracked_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\tgit_index_clear(index);\n\n\tif (flags & GIT_STASH_INCLUDE_UNTRACKED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\t\tdata.include_untracked = true;\n\t}\n\n\tif (flags & GIT_STASH_INCLUDE_IGNORED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED |\n\t\t\tGIT_DIFF_RECURSE_IGNORED_DIRS;\n\t\tdata.include_ignored = true;\n\t}\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_workdir(\n\t\t\t&diff, git_index_owner(index), i_tree, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(diff);\n\tgit_tree_free(i_tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_untracked(\n\tgit_commit **u_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *u_tree = NULL;\n\tgit_oid u_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_untracked_tree(&u_tree, index, i_commit, flags)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"untracked files on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&u_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\tu_tree,\n\t\t0,\n\t\tNULL)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(u_commit, git_index_owner(index), &u_commit_oid);\n\ncleanup:\n\tgit_tree_free(u_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}"
  },
  {
    "function_name": "build_untracked_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "212-254",
    "snippet": "static int build_untracked_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\tgit_index_clear(index);\n\n\tif (flags & GIT_STASH_INCLUDE_UNTRACKED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\t\tdata.include_untracked = true;\n\t}\n\n\tif (flags & GIT_STASH_INCLUDE_IGNORED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED |\n\t\t\tGIT_DIFF_RECURSE_IGNORED_DIRS;\n\t\tdata.include_ignored = true;\n\t}\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_workdir(\n\t\t\t&diff, git_index_owner(index), i_tree, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(diff);\n\tgit_tree_free(i_tree);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "i_tree"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_tree_from_index",
          "args": [
            "tree_out",
            "index"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "build_tree_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "104-113",
          "snippet": "static int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_update_index_from_diff",
          "args": [
            "index",
            "diff",
            "&data"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "stash_update_index_from_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "160-210",
          "snippet": "static int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_workdir",
          "args": [
            "&diff",
            "git_index_owner(index)",
            "i_tree",
            "&opts"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_workdir_with_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1433-1461",
          "snippet": "int git_diff_tree_to_workdir_with_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_diff *d1 = NULL, *d2 = NULL;\n\tgit_index *index = NULL;\n\n\tassert(diff && repo);\n\n\tif ((error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_diff_tree_to_index(&d1, repo, old_tree, index, opts)) &&\n\t\t!(error = git_diff_index_to_workdir(&d2, repo, index, opts)))\n\t\terror = git_diff_merge(d1, d2);\n\n\tgit_diff_free(d2);\n\n\tif (error) {\n\t\tgit_diff_free(d1);\n\t\td1 = NULL;\n\t}\n\n\t*diff = d1;\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_workdir_with_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_diff *d1 = NULL, *d2 = NULL;\n\tgit_index *index = NULL;\n\n\tassert(diff && repo);\n\n\tif ((error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_diff_tree_to_index(&d1, repo, old_tree, index, opts)) &&\n\t\t!(error = git_diff_index_to_workdir(&d2, repo, index, opts)))\n\t\terror = git_diff_merge(d1, d2);\n\n\tgit_diff_free(d2);\n\n\tif (error) {\n\t\tgit_diff_free(d1);\n\t\td1 = NULL;\n\t}\n\n\t*diff = d1;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&i_tree",
            "i_commit"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_clear",
          "args": [
            "index"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "526-546",
          "snippet": "int git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_untracked_tree(\n\tgit_tree **tree_out,\n\tgit_index *index,\n\tgit_commit *i_commit,\n\tuint32_t flags)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_diff *diff = NULL;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct stash_update_rules data = {0};\n\tint error;\n\n\tgit_index_clear(index);\n\n\tif (flags & GIT_STASH_INCLUDE_UNTRACKED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\t\tdata.include_untracked = true;\n\t}\n\n\tif (flags & GIT_STASH_INCLUDE_IGNORED) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED |\n\t\t\tGIT_DIFF_RECURSE_IGNORED_DIRS;\n\t\tdata.include_ignored = true;\n\t}\n\n\tif ((error = git_commit_tree(&i_tree, i_commit)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_diff_tree_to_workdir(\n\t\t\t&diff, git_index_owner(index), i_tree, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = stash_update_index_from_diff(index, diff, &data)) < 0)\n\t\tgoto cleanup;\n\n\terror = build_tree_from_index(tree_out, index);\n\ncleanup:\n\tgit_diff_free(diff);\n\tgit_tree_free(i_tree);\n\treturn error;\n}"
  },
  {
    "function_name": "stash_update_index_from_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "160-210",
    "snippet": "static int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_add_bypath",
          "args": [
            "index",
            "add_path"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1470-1521",
          "snippet": "int git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Cannot update index. Unimplemented status (%d)\"",
            "delta->status"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove",
          "args": [
            "index",
            "delta->old_file.path",
            "0"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1622-1651",
          "snippet": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_find",
          "args": [
            "NULL",
            "index",
            "delta->old_file.path"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1677-1703",
          "snippet": "int git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_get_delta",
          "args": [
            "diff",
            "d"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_get_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1506-1510",
          "snippet": "const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "diff"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int stash_update_index_from_diff(\n\tgit_index *index,\n\tconst git_diff *diff,\n\tstruct stash_update_rules *data)\n{\n\tint error = 0;\n\tsize_t d, max_d = git_diff_num_deltas(diff);\n\n\tfor (d = 0; !error && d < max_d; ++d) {\n\t\tconst char *add_path = NULL;\n\t\tconst git_diff_delta *delta = git_diff_get_delta(diff, d);\n\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_IGNORED:\n\t\t\tif (data->include_ignored)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\t\tif (data->include_untracked &&\n\t\t\t\tdelta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\t\tif (data->include_changed)\n\t\t\t\tadd_path = delta->new_file.path;\n\t\t\tbreak;\n\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tif (data->include_changed &&\n\t\t\t\t!git_index_find(NULL, index, delta->old_file.path))\n\t\t\t\terror = git_index_remove(index, delta->old_file.path, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Unimplemented */\n\t\t\tgiterr_set(\n\t\t\t\tGITERR_INVALID,\n\t\t\t\t\"Cannot update index. Unimplemented status (%d)\",\n\t\t\t\tdelta->status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (add_path != NULL)\n\t\t\terror = git_index_add_bypath(index, add_path);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "commit_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "115-152",
    "snippet": "static int commit_index(\n\tgit_commit **i_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tconst git_commit *parent)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_oid i_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_tree_from_index(&i_tree, index)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"index on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&i_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\ti_tree,\n\t\t1,\n\t\t&parent)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(i_commit, git_index_owner(index), &i_commit_oid);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&msg"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "i_tree"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "i_commit",
            "git_index_owner(index)",
            "&i_commit_oid"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_create",
          "args": [
            "&i_commit_oid",
            "git_index_owner(index)",
            "NULL",
            "stasher",
            "stasher",
            "NULL",
            "git_buf_cstr(&msg)",
            "i_tree",
            "1",
            "&parent"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "240-260",
          "snippet": "int git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&msg"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&msg",
            "\"index on %s\\n\"",
            "message"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_tree_from_index",
          "args": [
            "&i_tree",
            "index"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "build_tree_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "104-113",
          "snippet": "static int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int commit_index(\n\tgit_commit **i_commit,\n\tgit_index *index,\n\tconst git_signature *stasher,\n\tconst char *message,\n\tconst git_commit *parent)\n{\n\tgit_tree *i_tree = NULL;\n\tgit_oid i_commit_oid;\n\tgit_buf msg = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = build_tree_from_index(&i_tree, index)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_buf_printf(&msg, \"index on %s\\n\", message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_create(\n\t\t&i_commit_oid,\n\t\tgit_index_owner(index),\n\t\tNULL,\n\t\tstasher,\n\t\tstasher,\n\t\tNULL,\n\t\tgit_buf_cstr(&msg),\n\t\ti_tree,\n\t\t1,\n\t\t&parent)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_commit_lookup(i_commit, git_index_owner(index), &i_commit_oid);\n\ncleanup:\n\tgit_tree_free(i_tree);\n\tgit_buf_free(&msg);\n\treturn error;\n}"
  },
  {
    "function_name": "build_tree_from_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "104-113",
    "snippet": "static int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "out",
            "git_index_owner(index)",
            "&i_tree_oid"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "index"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_write_tree",
          "args": [
            "&i_tree_oid",
            "index"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "771-784",
          "snippet": "int git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"The index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nint git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"The index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int build_tree_from_index(git_tree **out, git_index *index)\n{\n\tint error;\n\tgit_oid i_tree_oid;\n\n\tif ((error = git_index_write_tree(&i_tree_oid, index)) < 0)\n\t\treturn error;\n\n\treturn git_tree_lookup(out, git_index_owner(index), &i_tree_oid);\n}"
  },
  {
    "function_name": "retrieve_base_commit_and_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "71-102",
    "snippet": "static int retrieve_base_commit_and_message(\n\tgit_commit **b_commit,\n\tgit_buf *stash_message,\n\tgit_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint error;\n\n\tif ((error = retrieve_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif (strcmp(\"HEAD\", git_reference_name(head)) == 0)\n\t\terror = git_buf_puts(stash_message, \"(no branch): \");\n\telse\n\t\terror = git_buf_printf(\n\t\t\tstash_message,\n\t\t\t\"%s: \",\n\t\t\tgit_reference_name(head) + strlen(GIT_REFS_HEADS_DIR));\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_lookup(\n\t\t\t b_commit, repo, git_reference_target(head))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = append_commit_description(stash_message, *b_commit)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_commit_description",
          "args": [
            "stash_message",
            "*b_commit"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "append_commit_description",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "56-69",
          "snippet": "static int append_commit_description(git_buf *out, git_commit* commit)\n{\n\tconst char *summary = git_commit_summary(commit);\n\tGITERR_CHECK_ALLOC(summary);\n\n\tif (append_abbreviated_oid(out, git_commit_id(commit)) < 0)\n\t\treturn -1;\n\n\tgit_buf_putc(out, ' ');\n\tgit_buf_puts(out, summary);\n\tgit_buf_putc(out, '\\n');\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int append_commit_description(git_buf *out, git_commit* commit)\n{\n\tconst char *summary = git_commit_summary(commit);\n\tGITERR_CHECK_ALLOC(summary);\n\n\tif (append_abbreviated_oid(out, git_commit_id(commit)) < 0)\n\t\treturn -1;\n\n\tgit_buf_putc(out, ' ');\n\tgit_buf_puts(out, summary);\n\tgit_buf_putc(out, '\\n');\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "b_commit",
            "repo",
            "git_reference_target(head)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "head"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "stash_message",
            "\"%s: \"",
            "git_reference_name(head) + strlen(GIT_REFS_HEADS_DIR)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "head"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "stash_message",
            "\"(no branch): \""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"HEAD\"",
            "git_reference_name(head)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_head",
          "args": [
            "&head",
            "repo"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "33-41",
          "snippet": "static int retrieve_head(git_reference **out, git_repository *repo)\n{\n\tint error = git_repository_head(out, repo);\n\n\tif (error == GIT_EUNBORNBRANCH)\n\t\treturn create_error(error, \"You do not have the initial commit yet.\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_head(git_reference **out, git_repository *repo)\n{\n\tint error = git_repository_head(out, repo);\n\n\tif (error == GIT_EUNBORNBRANCH)\n\t\treturn create_error(error, \"You do not have the initial commit yet.\");\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_base_commit_and_message(\n\tgit_commit **b_commit,\n\tgit_buf *stash_message,\n\tgit_repository *repo)\n{\n\tgit_reference *head = NULL;\n\tint error;\n\n\tif ((error = retrieve_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif (strcmp(\"HEAD\", git_reference_name(head)) == 0)\n\t\terror = git_buf_puts(stash_message, \"(no branch): \");\n\telse\n\t\terror = git_buf_printf(\n\t\t\tstash_message,\n\t\t\t\"%s: \",\n\t\t\tgit_reference_name(head) + strlen(GIT_REFS_HEADS_DIR));\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_commit_lookup(\n\t\t\t b_commit, repo, git_reference_target(head))) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = append_commit_description(stash_message, *b_commit)) < 0)\n\t\tgoto cleanup;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
  },
  {
    "function_name": "append_commit_description",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "56-69",
    "snippet": "static int append_commit_description(git_buf *out, git_commit* commit)\n{\n\tconst char *summary = git_commit_summary(commit);\n\tGITERR_CHECK_ALLOC(summary);\n\n\tif (append_abbreviated_oid(out, git_commit_id(commit)) < 0)\n\t\treturn -1;\n\n\tgit_buf_putc(out, ' ');\n\tgit_buf_puts(out, summary);\n\tgit_buf_putc(out, '\\n');\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "'\\n'"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "summary"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_abbreviated_oid",
          "args": [
            "out",
            "git_commit_id(commit)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "append_abbreviated_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "43-54",
          "snippet": "static int append_abbreviated_oid(git_buf *out, const git_oid *b_commit)\n{\n\tchar *formatted_oid;\n\n\tformatted_oid = git_oid_allocfmt(b_commit);\n\tGITERR_CHECK_ALLOC(formatted_oid);\n\n\tgit_buf_put(out, formatted_oid, 7);\n\tgit__free(formatted_oid);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int append_abbreviated_oid(git_buf *out, const git_oid *b_commit)\n{\n\tchar *formatted_oid;\n\n\tformatted_oid = git_oid_allocfmt(b_commit);\n\tGITERR_CHECK_ALLOC(formatted_oid);\n\n\tgit_buf_put(out, formatted_oid, 7);\n\tgit__free(formatted_oid);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "summary"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_summary",
          "args": [
            "commit"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "458-501",
          "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int append_commit_description(git_buf *out, git_commit* commit)\n{\n\tconst char *summary = git_commit_summary(commit);\n\tGITERR_CHECK_ALLOC(summary);\n\n\tif (append_abbreviated_oid(out, git_commit_id(commit)) < 0)\n\t\treturn -1;\n\n\tgit_buf_putc(out, ' ');\n\tgit_buf_puts(out, summary);\n\tgit_buf_putc(out, '\\n');\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
  },
  {
    "function_name": "append_abbreviated_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "43-54",
    "snippet": "static int append_abbreviated_oid(git_buf *out, const git_oid *b_commit)\n{\n\tchar *formatted_oid;\n\n\tformatted_oid = git_oid_allocfmt(b_commit);\n\tGITERR_CHECK_ALLOC(formatted_oid);\n\n\tgit_buf_put(out, formatted_oid, 7);\n\tgit__free(formatted_oid);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "formatted_oid"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "out",
            "formatted_oid",
            "7"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "formatted_oid"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_allocfmt",
          "args": [
            "b_commit"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_allocfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "110-117",
          "snippet": "char *git_oid_allocfmt(const git_oid *oid)\n{\n\tchar *str = git__malloc(GIT_OID_HEXSZ + 1);\n\tif (!str)\n\t\treturn NULL;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_allocfmt(const git_oid *oid)\n{\n\tchar *str = git__malloc(GIT_OID_HEXSZ + 1);\n\tif (!str)\n\t\treturn NULL;\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ + 1, oid);\n\treturn str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int append_abbreviated_oid(git_buf *out, const git_oid *b_commit)\n{\n\tchar *formatted_oid;\n\n\tformatted_oid = git_oid_allocfmt(b_commit);\n\tGITERR_CHECK_ALLOC(formatted_oid);\n\n\tgit_buf_put(out, formatted_oid, 7);\n\tgit__free(formatted_oid);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
  },
  {
    "function_name": "retrieve_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "33-41",
    "snippet": "static int retrieve_head(git_reference **out, git_repository *repo)\n{\n\tint error = git_repository_head(out, repo);\n\n\tif (error == GIT_EUNBORNBRANCH)\n\t\treturn create_error(error, \"You do not have the initial commit yet.\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_error",
          "args": [
            "error",
            "\"You do not have the initial commit yet.\""
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "create_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "27-31",
          "snippet": "static int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head",
          "args": [
            "out",
            "repo"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int retrieve_head(git_reference **out, git_repository *repo)\n{\n\tint error = git_repository_head(out, repo);\n\n\tif (error == GIT_EUNBORNBRANCH)\n\t\treturn create_error(error, \"You do not have the initial commit yet.\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "create_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
    "lines": "27-31",
    "snippet": "static int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"merge.h\"",
      "#include \"iterator.h\"",
      "#include \"signature.h\"",
      "#include \"index.h\"",
      "#include \"git2/merge.h\"",
      "#include \"git2/transaction.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/checkout.h\"",
      "#include \"git2/status.h\"",
      "#include \"git2/stash.h\"",
      "#include \"git2/diff.h\"",
      "#include \"reflog.h\"",
      "#include \"tree.h\"",
      "#include \"message.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_STASH",
            "\"Cannot stash changes - %s\"",
            "msg"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int create_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_STASH, \"Cannot stash changes - %s\", msg);\n\treturn error;\n}"
  }
]