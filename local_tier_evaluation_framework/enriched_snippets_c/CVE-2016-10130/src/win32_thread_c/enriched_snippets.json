[
  {
    "function_name": "git_rwlock_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "233-239",
    "snippet": "int git_rwlock_free(git_rwlock *lock)\n{\n\tif (!win32_srwlock_initialize)\n\t\tDeleteCriticalSection(&lock->native.csec);\n\tgit__memzero(lock, sizeof(*lock));\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_initialize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "lock",
            "sizeof(*lock)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_initialize;\n\nint git_rwlock_free(git_rwlock *lock)\n{\n\tif (!win32_srwlock_initialize)\n\t\tDeleteCriticalSection(&lock->native.csec);\n\tgit__memzero(lock, sizeof(*lock));\n\treturn 0;\n}"
  },
  {
    "function_name": "git_rwlock_wrunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "223-231",
    "snippet": "int git_rwlock_wrunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_exclusive)\n\t\twin32_srwlock_release_exclusive(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_release_exclusive;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32_srwlock_release_exclusive",
          "args": [
            "&lock->native.srwl"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_release_exclusive;\n\nint git_rwlock_wrunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_exclusive)\n\t\twin32_srwlock_release_exclusive(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_rwlock_wrlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "213-221",
    "snippet": "int git_rwlock_wrlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_exclusive)\n\t\twin32_srwlock_acquire_exclusive(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_acquire_exclusive;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32_srwlock_acquire_exclusive",
          "args": [
            "&lock->native.srwl"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_acquire_exclusive;\n\nint git_rwlock_wrlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_exclusive)\n\t\twin32_srwlock_acquire_exclusive(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_rwlock_rdunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "203-211",
    "snippet": "int git_rwlock_rdunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_shared)\n\t\twin32_srwlock_release_shared(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_release_shared;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32_srwlock_release_shared",
          "args": [
            "&lock->native.srwl"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_release_shared;\n\nint git_rwlock_rdunlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_release_shared)\n\t\twin32_srwlock_release_shared(&lock->native.srwl);\n\telse\n\t\tLeaveCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_rwlock_rdlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "193-201",
    "snippet": "int git_rwlock_rdlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_shared)\n\t\twin32_srwlock_acquire_shared(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_acquire_shared;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32_srwlock_acquire_shared",
          "args": [
            "&lock->native.srwl"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_acquire_shared;\n\nint git_rwlock_rdlock(git_rwlock *lock)\n{\n\tif (win32_srwlock_acquire_shared)\n\t\twin32_srwlock_acquire_shared(&lock->native.srwl);\n\telse\n\t\tEnterCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_rwlock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "183-191",
    "snippet": "int git_rwlock_init(git_rwlock *GIT_RESTRICT lock)\n{\n\tif (win32_srwlock_initialize)\n\t\twin32_srwlock_initialize(&lock->native.srwl);\n\telse\n\t\tInitializeCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_initialize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitializeCriticalSection",
          "args": [
            "&lock->native.csec"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32_srwlock_initialize",
          "args": [
            "&lock->native.srwl"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_initialize;\n\nint git_rwlock_init(git_rwlock *GIT_RESTRICT lock)\n{\n\tif (win32_srwlock_initialize)\n\t\twin32_srwlock_initialize(&lock->native.srwl);\n\telse\n\t\tInitializeCriticalSection(&lock->native.csec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_cond_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "169-181",
    "snippet": "int git_cond_signal(git_cond *cond)\n{\n\tBOOL signaled;\n\n\tif (!cond)\n\t\treturn EINVAL;\n\n\tsignaled = SetEvent(*cond);\n\tassert(signaled);\n\tGIT_UNUSED(signaled);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "signaled"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "signaled"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEvent",
          "args": [
            "*cond"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_cond_signal(git_cond *cond)\n{\n\tBOOL signaled;\n\n\tif (!cond)\n\t\treturn EINVAL;\n\n\tsignaled = SetEvent(*cond);\n\tassert(signaled);\n\tGIT_UNUSED(signaled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_cond_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "148-167",
    "snippet": "int git_cond_wait(git_cond *cond, git_mutex *mutex)\n{\n\tint error;\n\tDWORD wait_result;\n\n\tif (!cond || !mutex)\n\t\treturn EINVAL;\n\n\t/* The caller must be holding the mutex. */\n\terror = git_mutex_unlock(mutex);\n\n\tif (error)\n\t\treturn error;\n\n\twait_result = WaitForSingleObject(*cond, INFINITE);\n\tassert(WAIT_OBJECT_0 == wait_result);\n\tGIT_UNUSED(wait_result);\n\n\treturn git_mutex_lock(mutex);\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_mutex_lock",
          "args": [
            "mutex"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "110-114",
          "snippet": "int git_mutex_lock(git_mutex *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_lock(git_mutex *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "wait_result"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "WAIT_OBJECT_0 == wait_result"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WaitForSingleObject",
          "args": [
            "*cond",
            "INFINITE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_mutex_unlock",
          "args": [
            "mutex"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
          "lines": "116-120",
          "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"../global.h\"",
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_cond_wait(git_cond *cond, git_mutex *mutex)\n{\n\tint error;\n\tDWORD wait_result;\n\n\tif (!cond || !mutex)\n\t\treturn EINVAL;\n\n\t/* The caller must be holding the mutex. */\n\terror = git_mutex_unlock(mutex);\n\n\tif (error)\n\t\treturn error;\n\n\twait_result = WaitForSingleObject(*cond, INFINITE);\n\tassert(WAIT_OBJECT_0 == wait_result);\n\tGIT_UNUSED(wait_result);\n\n\treturn git_mutex_lock(mutex);\n}"
  },
  {
    "function_name": "git_cond_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "133-146",
    "snippet": "int git_cond_free(git_cond *cond)\n{\n\tBOOL closed;\n\n\tif (!cond)\n\t\treturn EINVAL;\n\n\tclosed = CloseHandle(*cond);\n\tassert(closed);\n\tGIT_UNUSED(closed);\n\n\t*cond = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "closed"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "closed"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "*cond"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_cond_free(git_cond *cond)\n{\n\tBOOL closed;\n\n\tif (!cond)\n\t\treturn EINVAL;\n\n\tclosed = CloseHandle(*cond);\n\tassert(closed);\n\tGIT_UNUSED(closed);\n\n\t*cond = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_cond_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "122-131",
    "snippet": "int git_cond_init(git_cond *cond)\n{\n\t/* This is an auto-reset event. */\n\t*cond = CreateEventW(NULL, FALSE, FALSE, NULL);\n\tassert(*cond);\n\n\t/* If we can't create the event, claim that the reason was out-of-memory.\n\t * The actual reason can be fetched with GetLastError(). */\n\treturn *cond ? 0 : ENOMEM;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*cond"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateEventW",
          "args": [
            "NULL",
            "FALSE",
            "FALSE",
            "NULL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_cond_init(git_cond *cond)\n{\n\t/* This is an auto-reset event. */\n\t*cond = CreateEventW(NULL, FALSE, FALSE, NULL);\n\tassert(*cond);\n\n\t/* If we can't create the event, claim that the reason was out-of-memory.\n\t * The actual reason can be fetched with GetLastError(). */\n\treturn *cond ? 0 : ENOMEM;\n}"
  },
  {
    "function_name": "git_mutex_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "116-120",
    "snippet": "int git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCriticalSection",
          "args": [
            "mutex"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_unlock(git_mutex *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_mutex_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "110-114",
    "snippet": "int git_mutex_lock(git_mutex *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnterCriticalSection",
          "args": [
            "mutex"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_lock(git_mutex *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_mutex_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "104-108",
    "snippet": "int git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DeleteCriticalSection",
          "args": [
            "mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_free(git_mutex *mutex)\n{\n\tDeleteCriticalSection(mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_mutex_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "98-102",
    "snippet": "int git_mutex_init(git_mutex *GIT_RESTRICT mutex)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitializeCriticalSection",
          "args": [
            "mutex"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_mutex_init(git_mutex *GIT_RESTRICT mutex)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_thread_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "70-96",
    "snippet": "int git_thread_join(\n\tgit_thread *thread,\n\tvoid **value_ptr)\n{\n\tDWORD exit;\n\n\tif (WaitForSingleObject(thread->thread, INFINITE) != WAIT_OBJECT_0)\n\t\treturn -1;\n\n\tif (!GetExitCodeThread(thread->thread, &exit)) {\n\t\tCloseHandle(thread->thread);\n\t\treturn -1;\n\t}\n\n\t/* Check for the thread having exited uncleanly. If exit was unclean,\n\t * then we don't have a return value to give back to the caller. */\n\tif (exit != CLEAN_THREAD_EXIT) {\n\t\tassert(false);\n\t\tthread->result = NULL;\n\t}\n\n\tif (value_ptr)\n\t\t*value_ptr = thread->result;\n\n\tCloseHandle(thread->thread);\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [
      "#define CLEAN_THREAD_EXIT 0x6F012842"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "thread->thread"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "thread->thread"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetExitCodeThread",
          "args": [
            "thread->thread",
            "&exit"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WaitForSingleObject",
          "args": [
            "thread->thread",
            "INFINITE"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\n#define CLEAN_THREAD_EXIT 0x6F012842\n\nint git_thread_join(\n\tgit_thread *thread,\n\tvoid **value_ptr)\n{\n\tDWORD exit;\n\n\tif (WaitForSingleObject(thread->thread, INFINITE) != WAIT_OBJECT_0)\n\t\treturn -1;\n\n\tif (!GetExitCodeThread(thread->thread, &exit)) {\n\t\tCloseHandle(thread->thread);\n\t\treturn -1;\n\t}\n\n\t/* Check for the thread having exited uncleanly. If exit was unclean,\n\t * then we don't have a return value to give back to the caller. */\n\tif (exit != CLEAN_THREAD_EXIT) {\n\t\tassert(false);\n\t\tthread->result = NULL;\n\t}\n\n\tif (value_ptr)\n\t\t*value_ptr = thread->result;\n\n\tCloseHandle(thread->thread);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_thread_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "56-68",
    "snippet": "int git_thread_create(\n\tgit_thread *GIT_RESTRICT thread,\n\tvoid *(*start_routine)(void*),\n\tvoid *GIT_RESTRICT arg)\n{\n\tthread->result = NULL;\n\tthread->param = arg;\n\tthread->proc = start_routine;\n\tthread->thread = CreateThread(\n\t\tNULL, 0, git_win32__threadproc, thread, 0, NULL);\n\n\treturn thread->thread ? 0 : -1;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateThread",
          "args": [
            "NULL",
            "0",
            "git_win32__threadproc",
            "thread",
            "0",
            "NULL"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nint git_thread_create(\n\tgit_thread *GIT_RESTRICT thread,\n\tvoid *(*start_routine)(void*),\n\tvoid *GIT_RESTRICT arg)\n{\n\tthread->result = NULL;\n\tthread->param = arg;\n\tthread->proc = start_routine;\n\tthread->thread = CreateThread(\n\t\tNULL, 0, git_win32__threadproc, thread, 0, NULL);\n\n\treturn thread->thread ? 0 : -1;\n}"
  },
  {
    "function_name": "git_threads_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "36-54",
    "snippet": "int git_threads_init(void)\n{\n\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\tif (hModule) {\n\t\twin32_srwlock_initialize = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"InitializeSRWLock\");\n\t\twin32_srwlock_acquire_shared = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"AcquireSRWLockShared\");\n\t\twin32_srwlock_release_shared = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"ReleaseSRWLockShared\");\n\t\twin32_srwlock_acquire_exclusive = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"AcquireSRWLockExclusive\");\n\t\twin32_srwlock_release_exclusive = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"ReleaseSRWLockExclusive\");\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static win32_srwlock_fn win32_srwlock_initialize;",
      "static win32_srwlock_fn win32_srwlock_acquire_shared;",
      "static win32_srwlock_fn win32_srwlock_release_shared;",
      "static win32_srwlock_fn win32_srwlock_acquire_exclusive;",
      "static win32_srwlock_fn win32_srwlock_release_exclusive;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"ReleaseSRWLockExclusive\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"AcquireSRWLockExclusive\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"ReleaseSRWLockShared\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"AcquireSRWLockShared\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"InitializeSRWLock\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModuleHandleW",
          "args": [
            "L\"kernel32\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\nstatic win32_srwlock_fn win32_srwlock_initialize;\nstatic win32_srwlock_fn win32_srwlock_acquire_shared;\nstatic win32_srwlock_fn win32_srwlock_release_shared;\nstatic win32_srwlock_fn win32_srwlock_acquire_exclusive;\nstatic win32_srwlock_fn win32_srwlock_release_exclusive;\n\nint git_threads_init(void)\n{\n\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\tif (hModule) {\n\t\twin32_srwlock_initialize = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"InitializeSRWLock\");\n\t\twin32_srwlock_acquire_shared = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"AcquireSRWLockShared\");\n\t\twin32_srwlock_release_shared = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"ReleaseSRWLockShared\");\n\t\twin32_srwlock_acquire_exclusive = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"AcquireSRWLockExclusive\");\n\t\twin32_srwlock_release_exclusive = (win32_srwlock_fn)\n\t\t\tGetProcAddress(hModule, \"ReleaseSRWLockExclusive\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_win32__threadproc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/thread.c",
    "lines": "25-34",
    "snippet": "static DWORD WINAPI git_win32__threadproc(LPVOID lpParameter)\n{\n\tgit_thread *thread = lpParameter;\n\n\tthread->result = thread->proc(thread->param);\n\n\tgit__free_tls_data();\n\n\treturn CLEAN_THREAD_EXIT;\n}",
    "includes": [
      "#include \"../global.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [
      "#define CLEAN_THREAD_EXIT 0x6F012842"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free_tls_data",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "git__free_tls_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/global.c",
          "lines": "217-226",
          "snippet": "void git__free_tls_data(void)\n{\n\tvoid *ptr = TlsGetValue(_tls_index);\n\tif (!ptr)\n\t\treturn;\n\n\tgit__global_state_cleanup(ptr);\n\tgit__free(ptr);\n\tTlsSetValue(_tls_index, NULL);\n}",
          "includes": [
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include \"win32/w32_stack.h\"",
            "#include \"transports/ssh.h\"",
            "#include \"git2/global.h\"",
            "#include \"thread-utils.h\"",
            "#include \"openssl_stream.h\"",
            "#include \"filter.h\"",
            "#include \"sysdir.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/w32_crtdbg_stacktrace.h\"\n#include \"win32/w32_stack.h\"\n#include \"transports/ssh.h\"\n#include \"git2/global.h\"\n#include \"thread-utils.h\"\n#include \"openssl_stream.h\"\n#include \"filter.h\"\n#include \"sysdir.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git__free_tls_data(void)\n{\n\tvoid *ptr = TlsGetValue(_tls_index);\n\tif (!ptr)\n\t\treturn;\n\n\tgit__global_state_cleanup(ptr);\n\tgit__free(ptr);\n\tTlsSetValue(_tls_index, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->proc",
          "args": [
            "thread->param"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../global.h\"\n#include \"thread.h\"\n\n#define CLEAN_THREAD_EXIT 0x6F012842\n\nstatic DWORD WINAPI git_win32__threadproc(LPVOID lpParameter)\n{\n\tgit_thread *thread = lpParameter;\n\n\tthread->result = thread->proc(thread->param);\n\n\tgit__free_tls_data();\n\n\treturn CLEAN_THREAD_EXIT;\n}"
  }
]