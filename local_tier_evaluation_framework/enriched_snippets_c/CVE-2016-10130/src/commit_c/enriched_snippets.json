[
  {
    "function_name": "git_commit_extract_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "652-742",
    "snippet": "int git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)\n{\n\tgit_odb_object *obj;\n\tgit_odb *odb;\n\tconst char *buf;\n\tconst char *h, *eol;\n\tint error;\n\n\tgit_buf_sanitize(signature);\n\tgit_buf_sanitize(signed_data);\n\n\tif (!field)\n\t\tfield = \"gpgsig\";\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_read(&obj, odb, commit_id)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"the requested type does not match the type in ODB\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tbuf = git_odb_object_data(obj);\n\n\twhile ((h = strchr(buf, '\\n')) && h[1] != '\\0') {\n\t\th++;\n\t\tif (git__prefixcmp(buf, field)) {\n\t\t\tif (git_buf_put(signed_data, buf, h - buf) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tbuf = h;\n\t\t\tcontinue;\n\t\t}\n\n\t\th = buf;\n\t\th += strlen(field);\n\t\teol = strchr(h, '\\n');\n\t\tif (h[0] != ' ') {\n\t\t\tbuf = h;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!eol)\n\t\t\tgoto malformed;\n\n\t\th++; /* skip the SP */\n\n\t\tgit_buf_put(signature, h, eol - h);\n\t\tif (git_buf_oom(signature))\n\t\t\tgoto oom;\n\n\t\t/* If the next line starts with SP, it's multi-line, we must continue */\n\t\twhile (eol[1] == ' ') {\n\t\t\tgit_buf_putc(signature, '\\n');\n\t\t\th = eol + 2;\n\t\t\teol = strchr(h, '\\n');\n\t\t\tif (!eol)\n\t\t\t\tgoto malformed;\n\n\t\t\tgit_buf_put(signature, h, eol - h);\n\t\t}\n\n\t\tif (git_buf_oom(signature))\n\t\t\tgoto oom;\n\n\t\tgit_odb_object_free(obj);\n\t\treturn git_buf_puts(signed_data, eol+1);\n\t}\n\n\tgiterr_set(GITERR_OBJECT, \"this commit is not signed\");\n\terror = GIT_ENOTFOUND;\n\tgoto cleanup;\n\nmalformed:\n\tgiterr_set(GITERR_OBJECT, \"malformed header\");\n\terror = -1;\n\tgoto cleanup;\noom:\n\tgiterr_set_oom();\n\terror = -1;\n\tgoto cleanup;\n\ncleanup:\n\tgit_odb_object_free(obj);\n\tgit_buf_clear(signature);\n\tgit_buf_clear(signed_data);\n\treturn error;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "signed_data"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "obj"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"malformed header\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "signed_data",
            "eol+1"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "signature"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "signature",
            "h",
            "eol - h"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "h",
            "'\\n'"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "signature",
            "'\\n'"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "h",
            "'\\n'"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "buf",
            "field"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "obj"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read",
          "args": [
            "&obj",
            "odb",
            "commit_id"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "862-881",
          "snippet": "int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "signed_data"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)\n{\n\tgit_odb_object *obj;\n\tgit_odb *odb;\n\tconst char *buf;\n\tconst char *h, *eol;\n\tint error;\n\n\tgit_buf_sanitize(signature);\n\tgit_buf_sanitize(signed_data);\n\n\tif (!field)\n\t\tfield = \"gpgsig\";\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_read(&obj, odb, commit_id)) < 0)\n\t\treturn error;\n\n\tif (obj->cached.type != GIT_OBJ_COMMIT) {\n\t\tgiterr_set(GITERR_INVALID, \"the requested type does not match the type in ODB\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tbuf = git_odb_object_data(obj);\n\n\twhile ((h = strchr(buf, '\\n')) && h[1] != '\\0') {\n\t\th++;\n\t\tif (git__prefixcmp(buf, field)) {\n\t\t\tif (git_buf_put(signed_data, buf, h - buf) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tbuf = h;\n\t\t\tcontinue;\n\t\t}\n\n\t\th = buf;\n\t\th += strlen(field);\n\t\teol = strchr(h, '\\n');\n\t\tif (h[0] != ' ') {\n\t\t\tbuf = h;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!eol)\n\t\t\tgoto malformed;\n\n\t\th++; /* skip the SP */\n\n\t\tgit_buf_put(signature, h, eol - h);\n\t\tif (git_buf_oom(signature))\n\t\t\tgoto oom;\n\n\t\t/* If the next line starts with SP, it's multi-line, we must continue */\n\t\twhile (eol[1] == ' ') {\n\t\t\tgit_buf_putc(signature, '\\n');\n\t\t\th = eol + 2;\n\t\t\teol = strchr(h, '\\n');\n\t\t\tif (!eol)\n\t\t\t\tgoto malformed;\n\n\t\t\tgit_buf_put(signature, h, eol - h);\n\t\t}\n\n\t\tif (git_buf_oom(signature))\n\t\t\tgoto oom;\n\n\t\tgit_odb_object_free(obj);\n\t\treturn git_buf_puts(signed_data, eol+1);\n\t}\n\n\tgiterr_set(GITERR_OBJECT, \"this commit is not signed\");\n\terror = GIT_ENOTFOUND;\n\tgoto cleanup;\n\nmalformed:\n\tgiterr_set(GITERR_OBJECT, \"malformed header\");\n\terror = -1;\n\tgoto cleanup;\noom:\n\tgiterr_set_oom();\n\terror = -1;\n\tgoto cleanup;\n\ncleanup:\n\tgit_odb_object_free(obj);\n\tgit_buf_clear(signature);\n\tgit_buf_clear(signed_data);\n\treturn error;\n}"
  },
  {
    "function_name": "git_commit_header_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "592-650",
    "snippet": "int git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)\n{\n\tconst char *eol, *buf = commit->raw_header;\n\n\tgit_buf_sanitize(out);\n\n\twhile ((eol = strchr(buf, '\\n'))) {\n\t\t/* We can skip continuations here */\n\t\tif (buf[0] == ' ') {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skip until we find the field we're after */\n\t\tif (git__prefixcmp(buf, field)) {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf += strlen(field);\n\t\t/* Check that we're not matching a prefix but the field itself */\n\t\tif (buf[0] != ' ') {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf++; /* skip the SP */\n\n\t\tgit_buf_put(out, buf, eol - buf);\n\t\tif (git_buf_oom(out))\n\t\t\tgoto oom;\n\n\t\t/* If the next line starts with SP, it's multi-line, we must continue */\n\t\twhile (eol[1] == ' ') {\n\t\t\tgit_buf_putc(out, '\\n');\n\t\t\tbuf = eol + 2;\n\t\t\teol = strchr(buf, '\\n');\n\t\t\tif (!eol)\n\t\t\t\tgoto malformed;\n\n\t\t\tgit_buf_put(out, buf, eol - buf);\n\t\t}\n\n\t\tif (git_buf_oom(out))\n\t\t\tgoto oom;\n\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_OBJECT, \"no such field '%s'\", field);\n\treturn GIT_ENOTFOUND;\n\nmalformed:\n\tgiterr_set(GITERR_OBJECT, \"malformed header\");\n\treturn -1;\noom:\n\tgiterr_set_oom();\n\treturn -1;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"malformed header\""
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"no such field '%s'\"",
            "field"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "out",
            "buf",
            "eol - buf"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "'\\n'"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "buf",
            "field"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)\n{\n\tconst char *eol, *buf = commit->raw_header;\n\n\tgit_buf_sanitize(out);\n\n\twhile ((eol = strchr(buf, '\\n'))) {\n\t\t/* We can skip continuations here */\n\t\tif (buf[0] == ' ') {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skip until we find the field we're after */\n\t\tif (git__prefixcmp(buf, field)) {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf += strlen(field);\n\t\t/* Check that we're not matching a prefix but the field itself */\n\t\tif (buf[0] != ' ') {\n\t\t\tbuf = eol + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuf++; /* skip the SP */\n\n\t\tgit_buf_put(out, buf, eol - buf);\n\t\tif (git_buf_oom(out))\n\t\t\tgoto oom;\n\n\t\t/* If the next line starts with SP, it's multi-line, we must continue */\n\t\twhile (eol[1] == ' ') {\n\t\t\tgit_buf_putc(out, '\\n');\n\t\t\tbuf = eol + 2;\n\t\t\teol = strchr(buf, '\\n');\n\t\t\tif (!eol)\n\t\t\t\tgoto malformed;\n\n\t\t\tgit_buf_put(out, buf, eol - buf);\n\t\t}\n\n\t\tif (git_buf_oom(out))\n\t\t\tgoto oom;\n\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_OBJECT, \"no such field '%s'\", field);\n\treturn GIT_ENOTFOUND;\n\nmalformed:\n\tgiterr_set(GITERR_OBJECT, \"malformed header\");\n\treturn -1;\noom:\n\tgiterr_set_oom();\n\treturn -1;\n}"
  },
  {
    "function_name": "git_commit_nth_gen_ancestor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "559-590",
    "snippet": "int git_commit_nth_gen_ancestor(\n\tgit_commit **ancestor,\n\tconst git_commit *commit,\n\tunsigned int n)\n{\n\tgit_commit *current, *parent = NULL;\n\tint error;\n\n\tassert(ancestor && commit);\n\n\tif (git_object_dup((git_object **) &current, (git_object *) commit) < 0)\n\t\treturn -1;\n\n\tif (n == 0) {\n\t\t*ancestor = current;\n\t\treturn 0;\n\t}\n\n\twhile (n--) {\n\t\terror = git_commit_parent(&parent, current, 0);\n\n\t\tgit_commit_free(current);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tcurrent = parent;\n\t}\n\n\t*ancestor = parent;\n\treturn 0;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "current"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&parent",
            "current",
            "0"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "(git_object **) &current",
            "(git_object *) commit"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ancestor && commit"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_nth_gen_ancestor(\n\tgit_commit **ancestor,\n\tconst git_commit *commit,\n\tunsigned int n)\n{\n\tgit_commit *current, *parent = NULL;\n\tint error;\n\n\tassert(ancestor && commit);\n\n\tif (git_object_dup((git_object **) &current, (git_object *) commit) < 0)\n\t\treturn -1;\n\n\tif (n == 0) {\n\t\t*ancestor = current;\n\t\treturn 0;\n\t}\n\n\twhile (n--) {\n\t\terror = git_commit_parent(&parent, current, 0);\n\n\t\tgit_commit_free(current);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tcurrent = parent;\n\t}\n\n\t*ancestor = parent;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_commit_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "544-557",
    "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "parent",
            "commit->object.repo",
            "parent_id"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Parent %u does not exist\"",
            "n"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent_id",
          "args": [
            "commit",
            "n"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "536-542",
          "snippet": "const git_oid *git_commit_parent_id(\n\tconst git_commit *commit, unsigned int n)\n{\n\tassert(commit);\n\n\treturn git_array_get(commit->parent_ids, n);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst git_oid *git_commit_parent_id(\n\tconst git_commit *commit, unsigned int n)\n{\n\tassert(commit);\n\n\treturn git_array_get(commit->parent_ids, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
  },
  {
    "function_name": "git_commit_parent_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "536-542",
    "snippet": "const git_oid *git_commit_parent_id(\n\tconst git_commit *commit, unsigned int n)\n{\n\tassert(commit);\n\n\treturn git_array_get(commit->parent_ids, n);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "commit->parent_ids",
            "n"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst git_oid *git_commit_parent_id(\n\tconst git_commit *commit, unsigned int n)\n{\n\tassert(commit);\n\n\treturn git_array_get(commit->parent_ids, n);\n}"
  },
  {
    "function_name": "git_commit_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "530-534",
    "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "tree_out",
            "commit->object.repo",
            "&commit->tree_id"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
  },
  {
    "function_name": "git_commit_body",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "503-528",
    "snippet": "const char *git_commit_body(git_commit *commit)\n{\n\tconst char *msg, *end;\n\n\tassert(commit);\n\n\tif (!commit->body) {\n\t\t/* search for end of summary */\n\t\tfor (msg = git_commit_message(commit); *msg; ++msg)\n\t\t\tif (msg[0] == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\n\t\t/* trim leading and trailing whitespace */\n\t\tfor (; *msg; ++msg)\n\t\t\tif (!git__isspace(*msg))\n\t\t\t\tbreak;\n\t\tfor (end = msg + strlen(msg) - 1; msg <= end; --end)\n\t\t\tif (!git__isspace(*end))\n\t\t\t\tbreak;\n\n\t\tif (*msg)\n\t\t\t    commit->body = git__strndup(msg, end - msg + 1);\n\t}\n\n\treturn commit->body;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "msg",
            "end - msg + 1"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "*end"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_message",
          "args": [
            "commit"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "433-456",
          "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_body(git_commit *commit)\n{\n\tconst char *msg, *end;\n\n\tassert(commit);\n\n\tif (!commit->body) {\n\t\t/* search for end of summary */\n\t\tfor (msg = git_commit_message(commit); *msg; ++msg)\n\t\t\tif (msg[0] == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\n\t\t/* trim leading and trailing whitespace */\n\t\tfor (; *msg; ++msg)\n\t\t\tif (!git__isspace(*msg))\n\t\t\t\tbreak;\n\t\tfor (end = msg + strlen(msg) - 1; msg <= end; --end)\n\t\t\tif (!git__isspace(*end))\n\t\t\t\tbreak;\n\n\t\tif (*msg)\n\t\t\t    commit->body = git__strndup(msg, end - msg + 1);\n\t}\n\n\treturn commit->body;\n}"
  },
  {
    "function_name": "git_commit_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "458-501",
    "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "\"\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&summary"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&summary",
            "next_character"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&summary",
            "space",
            "(msg - space)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "next_character"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_message",
          "args": [
            "commit"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "433-456",
          "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
  },
  {
    "function_name": "git_commit_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "433-456",
    "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "commit"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "commit->parent_ids"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "unsignedint",
            "parentcount",
            "(unsigned int)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "int",
            "time_offset",
            "commit->committer->when.offset"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "git_time_t",
            "time",
            "commit->committer->when.time"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "const char *, raw_header",
            "commit->raw_header"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "const char *, message_encoding",
            "commit->message_encoding"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_COMMIT_GETTER",
          "args": [
            "const char *, message_raw",
            "commit->raw_message"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
  },
  {
    "function_name": "git_commit__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "332-424",
    "snippet": "int git_commit__parse(void *_commit, git_odb_object *odb_obj)\n{\n\tgit_commit *commit = _commit;\n\tconst char *buffer_start = git_odb_object_data(odb_obj), *buffer;\n\tconst char *buffer_end = buffer_start + git_odb_object_size(odb_obj);\n\tgit_oid parent_id;\n\tsize_t header_len;\n\tgit_signature dummy_sig;\n\n\tbuffer = buffer_start;\n\n\t/* Allocate for one, which will allow not to realloc 90% of the time  */\n\tgit_array_init_to_size(commit->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(commit->parent_ids);\n\n\t/* The tree is always the first field */\n\tif (git_oid__parse(&commit->tree_id, &buffer, buffer_end, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/*\n\t * TODO: commit grafts!\n\t */\n\n\twhile (git_oid__parse(&parent_id, &buffer, buffer_end, \"parent \") == 0) {\n\t\tgit_oid *new_id = git_array_alloc(commit->parent_ids);\n\t\tGITERR_CHECK_ALLOC(new_id);\n\n\t\tgit_oid_cpy(new_id, &parent_id);\n\t}\n\n\tcommit->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->author);\n\n\tif (git_signature__parse(commit->author, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Some tools create multiple author fields, ignore the extra ones */\n\twhile ((size_t)(buffer_end - buffer) >= strlen(\"author \") && !git__prefixcmp(buffer, \"author \")) {\n\t\tif (git_signature__parse(&dummy_sig, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(dummy_sig.name);\n\t\tgit__free(dummy_sig.email);\n\t}\n\n\t/* Always parse the committer; we need the commit time */\n\tcommit->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->committer);\n\n\tif (git_signature__parse(commit->committer, &buffer, buffer_end, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Parse add'l header entries */\n\twhile (buffer < buffer_end) {\n\t\tconst char *eoln = buffer;\n\t\tif (buffer[-1] == '\\n' && buffer[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (eoln < buffer_end && *eoln != '\\n')\n\t\t\t++eoln;\n\n\t\tif (git__prefixcmp(buffer, \"encoding \") == 0) {\n\t\t\tbuffer += strlen(\"encoding \");\n\n\t\t\tcommit->message_encoding = git__strndup(buffer, eoln - buffer);\n\t\t\tGITERR_CHECK_ALLOC(commit->message_encoding);\n\t\t}\n\n\t\tif (eoln < buffer_end && *eoln == '\\n')\n\t\t\t++eoln;\n\t\tbuffer = eoln;\n\t}\n\n\theader_len = buffer - buffer_start;\n\tcommit->raw_header = git__strndup(buffer_start, header_len);\n\tGITERR_CHECK_ALLOC(commit->raw_header);\n\n\t/* point \"buffer\" to data after header, +1 for the final LF */\n\tbuffer = buffer_start + header_len + 1;\n\n\t/* extract commit message */\n\tif (buffer <= buffer_end)\n\t\tcommit->raw_message = git__strndup(buffer, buffer_end - buffer);\n\telse\n\t\tcommit->raw_message = git__strdup(\"\");\n\tGITERR_CHECK_ALLOC(commit->raw_message);\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(GITERR_OBJECT, \"Failed to parse bad commit object\");\n\treturn -1;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"Failed to parse bad commit object\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "commit->raw_message"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "\"\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "buffer",
            "buffer_end - buffer"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "commit->raw_header"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "commit->message_encoding"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"encoding \""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "buffer",
            "\"encoding \""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature__parse",
          "args": [
            "commit->committer",
            "&buffer",
            "buffer_end",
            "\"committer \"",
            "'\\n'"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "195-263",
          "snippet": "int git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "commit->committer"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_signature)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "dummy_sig.email"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"author \""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "commit->author"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "new_id",
            "&parent_id"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "new_id"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_alloc",
          "args": [
            "commit->parent_ids"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid__parse",
          "args": [
            "&parent_id",
            "&buffer",
            "buffer_end",
            "\"parent \""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "133-157",
          "snippet": "int git_oid__parse(\n\tgit_oid *oid, const char **buffer_out,\n\tconst char *buffer_end, const char *header)\n{\n\tconst size_t sha_len = GIT_OID_HEXSZ;\n\tconst size_t header_len = strlen(header);\n\n\tconst char *buffer = *buffer_out;\n\n\tif (buffer + (header_len + sha_len + 1) > buffer_end)\n\t\treturn -1;\n\n\tif (memcmp(buffer, header, header_len) != 0)\n\t\treturn -1;\n\n\tif (buffer[header_len + sha_len] != '\\n')\n\t\treturn -1;\n\n\tif (git_oid_fromstr(oid, buffer + header_len) < 0)\n\t\treturn -1;\n\n\t*buffer_out = buffer + (header_len + sha_len + 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid__parse(\n\tgit_oid *oid, const char **buffer_out,\n\tconst char *buffer_end, const char *header)\n{\n\tconst size_t sha_len = GIT_OID_HEXSZ;\n\tconst size_t header_len = strlen(header);\n\n\tconst char *buffer = *buffer_out;\n\n\tif (buffer + (header_len + sha_len + 1) > buffer_end)\n\t\treturn -1;\n\n\tif (memcmp(buffer, header, header_len) != 0)\n\t\treturn -1;\n\n\tif (buffer[header_len + sha_len] != '\\n')\n\t\treturn -1;\n\n\tif (git_oid_fromstr(oid, buffer + header_len) < 0)\n\t\treturn -1;\n\n\t*buffer_out = buffer + (header_len + sha_len + 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ARRAY",
          "args": [
            "commit->parent_ids"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_init_to_size",
          "args": [
            "commit->parent_ids",
            "1"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_odb_object_size",
          "args": [
            "odb_obj"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "120-123",
          "snippet": "size_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nsize_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "odb_obj"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit__parse(void *_commit, git_odb_object *odb_obj)\n{\n\tgit_commit *commit = _commit;\n\tconst char *buffer_start = git_odb_object_data(odb_obj), *buffer;\n\tconst char *buffer_end = buffer_start + git_odb_object_size(odb_obj);\n\tgit_oid parent_id;\n\tsize_t header_len;\n\tgit_signature dummy_sig;\n\n\tbuffer = buffer_start;\n\n\t/* Allocate for one, which will allow not to realloc 90% of the time  */\n\tgit_array_init_to_size(commit->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(commit->parent_ids);\n\n\t/* The tree is always the first field */\n\tif (git_oid__parse(&commit->tree_id, &buffer, buffer_end, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/*\n\t * TODO: commit grafts!\n\t */\n\n\twhile (git_oid__parse(&parent_id, &buffer, buffer_end, \"parent \") == 0) {\n\t\tgit_oid *new_id = git_array_alloc(commit->parent_ids);\n\t\tGITERR_CHECK_ALLOC(new_id);\n\n\t\tgit_oid_cpy(new_id, &parent_id);\n\t}\n\n\tcommit->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->author);\n\n\tif (git_signature__parse(commit->author, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Some tools create multiple author fields, ignore the extra ones */\n\twhile ((size_t)(buffer_end - buffer) >= strlen(\"author \") && !git__prefixcmp(buffer, \"author \")) {\n\t\tif (git_signature__parse(&dummy_sig, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(dummy_sig.name);\n\t\tgit__free(dummy_sig.email);\n\t}\n\n\t/* Always parse the committer; we need the commit time */\n\tcommit->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->committer);\n\n\tif (git_signature__parse(commit->committer, &buffer, buffer_end, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Parse add'l header entries */\n\twhile (buffer < buffer_end) {\n\t\tconst char *eoln = buffer;\n\t\tif (buffer[-1] == '\\n' && buffer[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (eoln < buffer_end && *eoln != '\\n')\n\t\t\t++eoln;\n\n\t\tif (git__prefixcmp(buffer, \"encoding \") == 0) {\n\t\t\tbuffer += strlen(\"encoding \");\n\n\t\t\tcommit->message_encoding = git__strndup(buffer, eoln - buffer);\n\t\t\tGITERR_CHECK_ALLOC(commit->message_encoding);\n\t\t}\n\n\t\tif (eoln < buffer_end && *eoln == '\\n')\n\t\t\t++eoln;\n\t\tbuffer = eoln;\n\t}\n\n\theader_len = buffer - buffer_start;\n\tcommit->raw_header = git__strndup(buffer_start, header_len);\n\tGITERR_CHECK_ALLOC(commit->raw_header);\n\n\t/* point \"buffer\" to data after header, +1 for the final LF */\n\tbuffer = buffer_start + header_len + 1;\n\n\t/* extract commit message */\n\tif (buffer <= buffer_end)\n\t\tcommit->raw_message = git__strndup(buffer, buffer_end - buffer);\n\telse\n\t\tcommit->raw_message = git__strdup(\"\");\n\tGITERR_CHECK_ALLOC(commit->raw_message);\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(GITERR_OBJECT, \"Failed to parse bad commit object\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git_commit_amend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "270-330",
    "snippet": "int git_commit_amend(\n\tgit_oid *id,\n\tconst git_commit *commit_to_amend,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree)\n{\n\tgit_repository *repo;\n\tgit_oid tree_id;\n\tgit_reference *ref;\n\tint error;\n\n\tassert(id && commit_to_amend);\n\n\trepo = git_commit_owner(commit_to_amend);\n\n\tif (!author)\n\t\tauthor = git_commit_author(commit_to_amend);\n\tif (!committer)\n\t\tcommitter = git_commit_committer(commit_to_amend);\n\tif (!message_encoding)\n\t\tmessage_encoding = git_commit_message_encoding(commit_to_amend);\n\tif (!message)\n\t\tmessage = git_commit_message(commit_to_amend);\n\n\tif (!tree) {\n\t\tgit_tree *old_tree;\n\t\tGITERR_CHECK_ERROR( git_commit_tree(&old_tree, commit_to_amend) );\n\t\tgit_oid_cpy(&tree_id, git_tree_id(old_tree));\n\t\tgit_tree_free(old_tree);\n\t} else {\n\t\tassert(git_tree_owner(tree) == repo);\n\t\tgit_oid_cpy(&tree_id, git_tree_id(tree));\n\t}\n\n\tif (update_ref) {\n\t\tif ((error = git_reference_lookup_resolved(&ref, repo, update_ref, 5)) < 0)\n\t\t\treturn error;\n\n\t\tif (git_oid_cmp(git_commit_id(commit_to_amend), git_reference_target(ref))) {\n\t\t\tgit_reference_free(ref);\n\t\t\tgiterr_set(GITERR_REFERENCE, \"commit to amend is not the tip of the given branch\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\terror = git_commit__create_internal(\n\t\tid, repo, NULL, author, committer, message_encoding, message,\n\t\t&tree_id, commit_parent_for_amend, (void *)commit_to_amend, false);\n\n\tif (!error && update_ref) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, NULL, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__update_for_commit",
          "args": [
            "repo",
            "ref",
            "NULL",
            "id",
            "\"commit\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__update_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1106-1144",
          "snippet": "int git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit__create_internal",
          "args": [
            "id",
            "repo",
            "NULL",
            "author",
            "committer",
            "message_encoding",
            "message",
            "&tree_id",
            "commit_parent_for_amend",
            "(void *)commit_to_amend",
            "false"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit__create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "40-128",
          "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"commit to amend is not the tip of the given branch\""
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "git_commit_id(commit_to_amend)",
            "git_reference_target(ref)"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit_to_amend"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "&ref",
            "repo",
            "update_ref",
            "5"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&tree_id",
            "git_tree_id(tree)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_id",
          "args": [
            "tree"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "64-67",
          "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_tree_owner(tree) == repo"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "tree"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "old_tree"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ERROR",
          "args": [
            "git_commit_tree(&old_tree, commit_to_amend)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&old_tree",
            "commit_to_amend"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_message",
          "args": [
            "commit_to_amend"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "433-456",
          "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_message_encoding",
          "args": [
            "commit_to_amend"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_committer",
          "args": [
            "commit_to_amend"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_author",
          "args": [
            "commit_to_amend"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_owner",
          "args": [
            "commit_to_amend"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "40-43",
          "snippet": "git_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "id && commit_to_amend"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_amend(\n\tgit_oid *id,\n\tconst git_commit *commit_to_amend,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree)\n{\n\tgit_repository *repo;\n\tgit_oid tree_id;\n\tgit_reference *ref;\n\tint error;\n\n\tassert(id && commit_to_amend);\n\n\trepo = git_commit_owner(commit_to_amend);\n\n\tif (!author)\n\t\tauthor = git_commit_author(commit_to_amend);\n\tif (!committer)\n\t\tcommitter = git_commit_committer(commit_to_amend);\n\tif (!message_encoding)\n\t\tmessage_encoding = git_commit_message_encoding(commit_to_amend);\n\tif (!message)\n\t\tmessage = git_commit_message(commit_to_amend);\n\n\tif (!tree) {\n\t\tgit_tree *old_tree;\n\t\tGITERR_CHECK_ERROR( git_commit_tree(&old_tree, commit_to_amend) );\n\t\tgit_oid_cpy(&tree_id, git_tree_id(old_tree));\n\t\tgit_tree_free(old_tree);\n\t} else {\n\t\tassert(git_tree_owner(tree) == repo);\n\t\tgit_oid_cpy(&tree_id, git_tree_id(tree));\n\t}\n\n\tif (update_ref) {\n\t\tif ((error = git_reference_lookup_resolved(&ref, repo, update_ref, 5)) < 0)\n\t\t\treturn error;\n\n\t\tif (git_oid_cmp(git_commit_id(commit_to_amend), git_reference_target(ref))) {\n\t\t\tgit_reference_free(ref);\n\t\t\tgiterr_set(GITERR_REFERENCE, \"commit to amend is not the tip of the given branch\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\terror = git_commit__create_internal(\n\t\tid, repo, NULL, author, committer, message_encoding, message,\n\t\t&tree_id, commit_parent_for_amend, (void *)commit_to_amend, false);\n\n\tif (!error && update_ref) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, NULL, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "commit_parent_for_amend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "262-268",
    "snippet": "static const git_oid *commit_parent_for_amend(size_t curr, void *payload)\n{\n\tconst git_commit *commit_to_amend = payload;\n\tif (curr >= git_array_size(commit_to_amend->parent_ids))\n\t\treturn NULL;\n\treturn git_array_get(commit_to_amend->parent_ids, curr);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_array_get",
          "args": [
            "commit_to_amend->parent_ids",
            "curr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_array_size",
          "args": [
            "commit_to_amend->parent_ids"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic const git_oid *commit_parent_for_amend(size_t curr, void *payload)\n{\n\tconst git_commit *commit_to_amend = payload;\n\tif (curr >= git_array_size(commit_to_amend->parent_ids))\n\t\treturn NULL;\n\treturn git_array_get(commit_to_amend->parent_ids, curr);\n}"
  },
  {
    "function_name": "git_commit_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "240-260",
    "snippet": "int git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit__create_internal",
          "args": [
            "id",
            "repo",
            "update_ref",
            "author",
            "committer",
            "message_encoding",
            "message",
            "git_tree_id(tree)",
            "commit_parent_from_array",
            "&data",
            "false"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit__create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "40-128",
          "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_id",
          "args": [
            "tree"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "64-67",
          "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tree && git_tree_owner(tree) == repo"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "tree"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\tconst git_commit *parents[])\n{\n\tcommit_parent_data data = { parent_count, parents, repo };\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_array, &data, false);\n}"
  },
  {
    "function_name": "commit_parent_from_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "228-238",
    "snippet": "static const git_oid *commit_parent_from_array(size_t curr, void *payload)\n{\n\tcommit_parent_data *data = payload;\n\tconst git_commit *commit;\n\tif (curr >= data->total)\n\t\treturn NULL;\n\tcommit = data->parents[curr];\n\tif (git_commit_owner(commit) != data->repo)\n\t\treturn NULL;\n\treturn git_commit_id(commit);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_owner",
          "args": [
            "commit"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "40-43",
          "snippet": "git_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_commit_owner(const git_commit *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic const git_oid *commit_parent_from_array(size_t curr, void *payload)\n{\n\tcommit_parent_data *data = payload;\n\tconst git_commit *commit;\n\tif (curr >= data->total)\n\t\treturn NULL;\n\tcommit = data->parents[curr];\n\tif (git_commit_owner(commit) != data->repo)\n\t\treturn NULL;\n\treturn git_commit_id(commit);\n}"
  },
  {
    "function_name": "git_commit_create_from_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "202-220",
    "snippet": "int git_commit_create_from_ids(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tsize_t parent_count,\n\tconst git_oid *parents[])\n{\n\tcommit_parent_oids data = { parent_count, parents };\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, tree,\n\t\tcommit_parent_from_ids, &data, true);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit__create_internal",
          "args": [
            "id",
            "repo",
            "update_ref",
            "author",
            "committer",
            "message_encoding",
            "message",
            "tree",
            "commit_parent_from_ids",
            "&data",
            "true"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit__create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "40-128",
          "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create_from_ids(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tsize_t parent_count,\n\tconst git_oid *parents[])\n{\n\tcommit_parent_oids data = { parent_count, parents };\n\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, tree,\n\t\tcommit_parent_from_ids, &data, true);\n}"
  },
  {
    "function_name": "commit_parent_from_ids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "196-200",
    "snippet": "static const git_oid *commit_parent_from_ids(size_t curr, void *payload)\n{\n\tcommit_parent_oids *data = payload;\n\treturn (curr < data->total) ? data->parents[curr] : NULL;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic const git_oid *commit_parent_from_ids(size_t curr, void *payload)\n{\n\tcommit_parent_oids *data = payload;\n\treturn (curr < data->total) ? data->parents[curr] : NULL;\n}"
  },
  {
    "function_name": "git_commit_create_v",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "162-189",
    "snippet": "int git_commit_create_v(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\t...)\n{\n\tint error = 0;\n\tcommit_parent_varargs data;\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\tdata.total = parent_count;\n\tva_start(data.args, parent_count);\n\n\terror = git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_varargs, &data, false);\n\n\tva_end(data.args);\n\treturn error;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "data.args"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit__create_internal",
          "args": [
            "id",
            "repo",
            "update_ref",
            "author",
            "committer",
            "message_encoding",
            "message",
            "git_tree_id(tree)",
            "commit_parent_from_varargs",
            "&data",
            "false"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit__create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "40-128",
          "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_id",
          "args": [
            "tree"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "64-67",
          "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "data.args",
            "parent_count"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tree && git_tree_owner(tree) == repo"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "tree"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create_v(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_tree *tree,\n\tsize_t parent_count,\n\t...)\n{\n\tint error = 0;\n\tcommit_parent_varargs data;\n\n\tassert(tree && git_tree_owner(tree) == repo);\n\n\tdata.total = parent_count;\n\tva_start(data.args, parent_count);\n\n\terror = git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer,\n\t\tmessage_encoding, message, git_tree_id(tree),\n\t\tcommit_parent_from_varargs, &data, false);\n\n\tva_end(data.args);\n\treturn error;\n}"
  },
  {
    "function_name": "commit_parent_from_varargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "152-160",
    "snippet": "static const git_oid *commit_parent_from_varargs(size_t curr, void *payload)\n{\n\tcommit_parent_varargs *data = payload;\n\tconst git_commit *commit;\n\tif (curr >= data->total)\n\t\treturn NULL;\n\tcommit = va_arg(data->args, const git_commit *);\n\treturn commit ? git_commit_id(commit) : NULL;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "data->args",
            "constgit_commit*"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic const git_oid *commit_parent_from_varargs(size_t curr, void *payload)\n{\n\tcommit_parent_varargs *data = payload;\n\tconst git_commit *commit;\n\tif (curr >= data->total)\n\t\treturn NULL;\n\tcommit = va_arg(data->args, const git_commit *);\n\treturn commit ? git_commit_id(commit) : NULL;\n}"
  },
  {
    "function_name": "git_commit_create_from_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "130-145",
    "snippet": "int git_commit_create_from_callback(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload)\n{\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer, message_encoding, message,\n\t\ttree, parent_cb, parent_payload, true);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit__create_internal",
          "args": [
            "id",
            "repo",
            "update_ref",
            "author",
            "committer",
            "message_encoding",
            "message",
            "tree",
            "parent_cb",
            "parent_payload",
            "true"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit__create_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "40-128",
          "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_create_from_callback(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload)\n{\n\treturn git_commit__create_internal(\n\t\tid, repo, update_ref, author, committer, message_encoding, message,\n\t\ttree, parent_cb, parent_payload, true);\n}"
  },
  {
    "function_name": "git_commit__create_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "40-128",
    "snippet": "static int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&commit"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__update_for_commit",
          "args": [
            "repo",
            "ref",
            "update_ref",
            "id",
            "\"commit\""
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__update_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1106-1144",
          "snippet": "int git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__update_for_commit(\n\tgit_repository *repo,\n\tgit_reference *ref,\n\tconst char *ref_name,\n\tconst git_oid *id,\n\tconst char *operation)\n{\n\tgit_reference *ref_new = NULL;\n\tgit_commit *commit = NULL;\n\tgit_buf reflog_msg = GIT_BUF_INIT;\n\tconst git_signature *who;\n\tint error;\n\n\tif ((error = git_commit_lookup(&commit, repo, id)) < 0 ||\n\t\t(error = git_buf_printf(&reflog_msg, \"%s%s: %s\",\n\t\t\toperation ? operation : \"commit\",\n\t\t\tgit_commit_parentcount(commit) == 0 ? \" (initial)\" : \"\",\n\t\t\tgit_commit_summary(commit))) < 0)\n\t\tgoto done;\n\n\twho = git_commit_committer(commit);\n\n\tif (ref) {\n\t\tif ((error = ensure_is_an_updatable_direct_reference(ref)) < 0)\n\t\t\treturn error;\n\n\t\terror = reference__create(&ref_new, repo, ref->name, id, NULL, 1, who,\n\t\t\t\t\t  git_buf_cstr(&reflog_msg), &ref->target.oid, NULL);\n\t}\n\telse\n\t\terror = git_reference__update_terminal(\n\t\t\trepo, ref_name, id, who, git_buf_cstr(&reflog_msg));\n\ndone:\n\tgit_reference_free(ref_new);\n\tgit_buf_free(&reflog_msg);\n\tgit_commit_free(commit);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write",
          "args": [
            "id",
            "odb",
            "commit.ptr",
            "commit.size",
            "GIT_OBJ_COMMIT"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "984-1024",
          "snippet": "int git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&commit",
            "message"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&commit",
            "'\\n'"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&commit",
            "\"encoding %s\\n\"",
            "message_encoding"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature__writebuf",
          "args": [
            "&commit",
            "\"committer \"",
            "committer"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__writebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "265-284",
          "snippet": "void git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"failed to create commit: current tip is not the first parent\""
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "current_id",
            "parent"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__writebuf",
          "args": [
            "&commit",
            "\"parent \"",
            "parent"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__writebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "159-167",
          "snippet": "void git_oid__writebuf(git_buf *buf, const char *header, const git_oid *oid)\n{\n\tchar hex_oid[GIT_OID_HEXSZ];\n\n\tgit_oid_fmt(hex_oid, oid);\n\tgit_buf_puts(buf, header);\n\tgit_buf_put(buf, hex_oid, GIT_OID_HEXSZ);\n\tgit_buf_putc(buf, '\\n');\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid__writebuf(git_buf *buf, const char *header, const git_oid *oid)\n{\n\tchar hex_oid[GIT_OID_HEXSZ];\n\n\tgit_oid_fmt(hex_oid, oid);\n\tgit_buf_puts(buf, header);\n\tgit_buf_put(buf, hex_oid, GIT_OID_HEXSZ);\n\tgit_buf_putc(buf, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__is_valid",
          "args": [
            "repo",
            "parent",
            "GIT_OBJ_COMMIT"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "467-489",
          "snippet": "bool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool git_object__strict_input_validation = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nbool git_object__strict_input_validation = true;\n\nbool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cb",
          "args": [
            "i",
            "parent_payload"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup_resolved",
          "args": [
            "&ref",
            "repo",
            "update_ref",
            "10"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "181-234",
          "snippet": "int git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [
            "#define MAX_NESTING_LEVEL\t\t10",
            "#define DEFAULT_NESTING_LEVEL\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\n#define MAX_NESTING_LEVEL\t\t10\n#define DEFAULT_NESTING_LEVEL\t5\n\nint git_reference_lookup_resolved(\n\tgit_reference **ref_out,\n\tgit_repository *repo,\n\tconst char *name,\n\tint max_nesting)\n{\n\tgit_refname_t scan_name;\n\tgit_ref_t scan_type;\n\tint error = 0, nesting;\n\tgit_reference *ref = NULL;\n\tgit_refdb *refdb;\n\n\tassert(ref_out && repo && name);\n\n\t*ref_out = NULL;\n\n\tif (max_nesting > MAX_NESTING_LEVEL)\n\t\tmax_nesting = MAX_NESTING_LEVEL;\n\telse if (max_nesting < 0)\n\t\tmax_nesting = DEFAULT_NESTING_LEVEL;\n\n\tscan_type = GIT_REF_SYMBOLIC;\n\n\tif ((error = reference_normalize_for_repo(scan_name, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\tfor (nesting = max_nesting;\n\t\t nesting >= 0 && scan_type == GIT_REF_SYMBOLIC;\n\t\t nesting--)\n\t{\n\t\tif (nesting != max_nesting) {\n\t\t\tstrncpy(scan_name, ref->target.symbolic, sizeof(scan_name));\n\t\t\tgit_reference_free(ref);\n\t\t}\n\n\t\tif ((error = git_refdb_lookup(&ref, refdb, scan_name)) < 0)\n\t\t\treturn error;\n\n\t\tscan_type = ref->type;\n\t}\n\n\tif (scan_type != GIT_REF_OID && max_nesting != 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Cannot resolve reference (>%u levels deep)\", max_nesting);\n\t\tgit_reference_free(ref);\n\t\treturn -1;\n\t}\n\n\t*ref_out = ref;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "id && repo && tree && parent_cb"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int git_commit__create_internal(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *update_ref,\n\tconst git_signature *author,\n\tconst git_signature *committer,\n\tconst char *message_encoding,\n\tconst char *message,\n\tconst git_oid *tree,\n\tgit_commit_parent_callback parent_cb,\n\tvoid *parent_payload,\n\tbool validate)\n{\n\tgit_reference *ref = NULL;\n\tint error = 0, matched_parent = 0;\n\tconst git_oid *current_id = NULL;\n\tgit_buf commit = GIT_BUF_INIT;\n\tsize_t i = 0;\n\tgit_odb *odb;\n\tconst git_oid *parent;\n\n\tassert(id && repo && tree && parent_cb);\n\n\tif (validate && !git_object__is_valid(repo, tree, GIT_OBJ_TREE))\n\t\treturn -1;\n\n\tif (update_ref) {\n\t\terror = git_reference_lookup_resolved(&ref, repo, update_ref, 10);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\tgiterr_clear();\n\n\tif (ref)\n\t\tcurrent_id = git_reference_target(ref);\n\n\tgit_oid__writebuf(&commit, \"tree \", tree);\n\n\twhile ((parent = parent_cb(i, parent_payload)) != NULL) {\n\t\tif (validate && !git_object__is_valid(repo, parent, GIT_OBJ_COMMIT)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_oid__writebuf(&commit, \"parent \", parent);\n\t\tif (i == 0 && current_id && git_oid_equal(current_id, parent))\n\t\t\tmatched_parent = 1;\n\t\ti++;\n\t}\n\n\tif (ref && !matched_parent) {\n\t\tgit_reference_free(ref);\n\t\tgit_buf_free(&commit);\n\t\tgiterr_set(GITERR_OBJECT, \"failed to create commit: current tip is not the first parent\");\n\t\treturn GIT_EMODIFIED;\n\t}\n\n\tgit_signature__writebuf(&commit, \"author \", author);\n\tgit_signature__writebuf(&commit, \"committer \", committer);\n\n\tif (message_encoding != NULL)\n\t\tgit_buf_printf(&commit, \"encoding %s\\n\", message_encoding);\n\n\tgit_buf_putc(&commit, '\\n');\n\n\tif (git_buf_puts(&commit, message) < 0)\n\t\tgoto on_error;\n\n\tif (git_repository_odb__weakptr(&odb, repo) < 0)\n\t\tgoto on_error;\n\n\tif (git_odb_write(id, odb, commit.ptr, commit.size, GIT_OBJ_COMMIT) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&commit);\n\n\tif (update_ref != NULL) {\n\t\terror = git_reference__update_for_commit(\n\t\t\trepo, ref, update_ref, id, \"commit\");\n\t\tgit_reference_free(ref);\n\t\treturn error;\n\t}\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&commit);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_commit__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
    "lines": "22-38",
    "snippet": "void git_commit__free(void *_commit)\n{\n\tgit_commit *commit = _commit;\n\n\tgit_array_clear(commit->parent_ids);\n\n\tgit_signature_free(commit->author);\n\tgit_signature_free(commit->committer);\n\n\tgit__free(commit->raw_header);\n\tgit__free(commit->raw_message);\n\tgit__free(commit->message_encoding);\n\tgit__free(commit->summary);\n\tgit__free(commit->body);\n\n\tgit__free(commit);\n}",
    "includes": [
      "#include \"object.h\"",
      "#include \"refs.h\"",
      "#include \"message.h\"",
      "#include \"signature.h\"",
      "#include \"commit.h\"",
      "#include \"odb.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/commit.h\"",
      "#include \"git2/signature.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "commit"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature_free",
          "args": [
            "commit->committer"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "14-24",
          "snippet": "void git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature_free(git_signature *sig)\n{\n\tif (sig == NULL)\n\t\treturn;\n\n\tgit__free(sig->name);\n\tsig->name = NULL;\n\tgit__free(sig->email);\n\tsig->email = NULL;\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_array_clear",
          "args": [
            "commit->parent_ids"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nvoid git_commit__free(void *_commit)\n{\n\tgit_commit *commit = _commit;\n\n\tgit_array_clear(commit->parent_ids);\n\n\tgit_signature_free(commit->author);\n\tgit_signature_free(commit->committer);\n\n\tgit__free(commit->raw_header);\n\tgit__free(commit->raw_message);\n\tgit__free(commit->message_encoding);\n\tgit__free(commit->summary);\n\tgit__free(commit->body);\n\n\tgit__free(commit);\n}"
  }
]