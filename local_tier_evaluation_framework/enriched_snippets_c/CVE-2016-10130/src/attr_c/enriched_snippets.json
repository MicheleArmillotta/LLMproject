[
  {
    "function_name": "collect_attr_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "467-544",
    "snippet": "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&dir"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_attr_files",
          "args": [
            "files"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "release_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "455-465",
          "snippet": "static void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_attr_file",
          "args": [
            "repo",
            "attr_session",
            "files",
            "GIT_ATTR_FILE__FROM_FILE",
            "NULL",
            "dir.ptr"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "push_attr_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "414-437",
          "snippet": "static int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "system_attr_file",
          "args": [
            "&dir",
            "attr_session"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "system_attr_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "252-288",
          "snippet": "static int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_attr_cache",
          "args": [
            "repo"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "148-151",
          "snippet": "GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_walk_up",
          "args": [
            "&dir",
            "workdir",
            "push_one_attr",
            "&info"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_walk_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "439-501",
          "snippet": "int git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_walk_up(\n\tgit_buf *path,\n\tconst char *ceiling,\n\tint (*cb)(void *data, const char *),\n\tvoid *data)\n{\n\tint error = 0;\n\tgit_buf iter;\n\tssize_t stop = 0, scan;\n\tchar oldc = '\\0';\n\n\tassert(path && cb);\n\n\tif (ceiling != NULL) {\n\t\tif (git__prefixcmp(path->ptr, ceiling) == 0)\n\t\t\tstop = (ssize_t)strlen(ceiling);\n\t\telse\n\t\t\tstop = git_buf_len(path);\n\t}\n\tscan = git_buf_len(path);\n\n\t/* empty path: yield only once */\n\tif (!scan) {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t\treturn error;\n\t}\n\n\titer.ptr = path->ptr;\n\titer.size = git_buf_len(path);\n\titer.asize = path->asize;\n\n\twhile (scan >= stop) {\n\t\terror = cb(data, iter.ptr);\n\t\titer.ptr[scan] = oldc;\n\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\n\t\tscan = git_buf_rfind_next(&iter, '/');\n\t\tif (scan >= 0) {\n\t\t\tscan++;\n\t\t\toldc = iter.ptr[scan];\n\t\t\titer.size = scan;\n\t\t\titer.ptr[scan] = '\\0';\n\t\t}\n\t}\n\n\tif (scan >= 0)\n\t\titer.ptr[scan] = oldc;\n\n\t/* relative path: yield for the last component */\n\tif (!error && stop == 0 && iter.ptr[0] != '/') {\n\t\terror = cb(data, \"\");\n\t\tif (error)\n\t\t\tgiterr_set_after_callback(error);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_one_attr",
          "args": [
            "&info",
            "\"\""
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "push_one_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "439-453",
          "snippet": "static int push_one_attr(void *ref, const char *path)\n{\n\tint error = 0, n_src, i;\n\tattr_walk_up_info *info = (attr_walk_up_info *)ref;\n\tgit_attr_file_source src[2];\n\n\tn_src = attr_decide_sources(\n\t\tinfo->flags, info->workdir != NULL, info->index != NULL, src);\n\n\tfor (i = 0; !error && i < n_src; ++i)\n\t\terror = push_attr_file(info->repo, info->attr_session,\n\t\t\tinfo->files, src[i], path, GIT_ATTR_FILE);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int push_one_attr(void *ref, const char *path)\n{\n\tint error = 0, n_src, i;\n\tattr_walk_up_info *info = (attr_walk_up_info *)ref;\n\tgit_attr_file_source src[2];\n\n\tn_src = attr_decide_sources(\n\t\tinfo->flags, info->workdir != NULL, info->index != NULL, src);\n\n\tfor (i = 0; !error && i < n_src; ++i)\n\t\terror = push_attr_file(info->repo, info->attr_session,\n\t\t\tinfo->files, src[i], path, GIT_ATTR_FILE);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir.ptr",
            "\".\""
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&info.index",
            "repo"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_dirname_r",
          "args": [
            "&dir",
            "path"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_dirname_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "117-178",
          "snippet": "int git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_dirname_r(git_buf *buffer, const char *path)\n{\n\tconst char *endp;\n\tint result, len;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tpath = \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\t/* Strip trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tpath = (*endp == '/') ? \"/\" : \".\";\n\t\tlen = 1;\n\t\tgoto Exit;\n\t}\n\n\tdo {\n\t\tendp--;\n\t} while (endp > path && *endp == '/');\n\n\t/* Cast is safe because max path < max int */\n\tlen = (int)(endp - path + 1);\n\n#ifdef GIT_WIN32\n\t/* Mimic unix behavior where '/.git' returns '/': 'C:/.git' will return\n\t\t'C:/' here */\n\n\tif (len == 2 && LOOKS_LIKE_DRIVE_PREFIX(path)) {\n\t\tlen = 3;\n\t\tgoto Exit;\n\t}\n\n\t/* Similarly checks if we're dealing with a network computer name\n\t\t'//computername/.git' will return '//computername/' */\n\n\tif (looks_like_network_computer_name(path, len)) {\n\t\tlen++;\n\t\tgoto Exit;\n\t}\n\n#endif\n\nExit:\n\tresult = len;\n\n\tif (buffer != NULL && git_buf_set(buffer, path, len) < 0)\n\t\treturn -1;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_find_dir",
          "args": [
            "&dir",
            "path",
            "workdir"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_find_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "683-701",
          "snippet": "int git_path_find_dir(git_buf *dir, const char *path, const char *base)\n{\n\tint error = git_path_join_unrooted(dir, path, base, NULL);\n\n\tif (!error) {\n\t\tchar buf[GIT_PATH_MAX];\n\t\tif (p_realpath(dir->ptr, buf) != NULL)\n\t\t\terror = git_buf_sets(dir, buf);\n\t}\n\n\t/* call dirname if this is not a directory */\n\tif (!error) /* && git_path_isdir(dir->ptr) == false) */\n\t\terror = (git_path_dirname_r(dir, dir->ptr) < 0) ? -1 : 0;\n\n\tif (!error)\n\t\terror = git_path_to_dir(dir);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_find_dir(git_buf *dir, const char *path, const char *base)\n{\n\tint error = git_path_join_unrooted(dir, path, base, NULL);\n\n\tif (!error) {\n\t\tchar buf[GIT_PATH_MAX];\n\t\tif (p_realpath(dir->ptr, buf) != NULL)\n\t\t\terror = git_buf_sets(dir, buf);\n\t}\n\n\t/* call dirname if this is not a directory */\n\tif (!error) /* && git_path_isdir(dir->ptr) == false) */\n\t\terror = (git_path_dirname_r(dir, dir->ptr) < 0) ? -1 : 0;\n\n\tif (!error)\n\t\terror = git_path_to_dir(dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_setup",
          "args": [
            "repo",
            "attr_session"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "attr_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "290-342",
          "snippet": "static int attr_setup(git_repository *repo, git_attr_session *attr_session)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_index *idx = NULL;\n\tgit_buf sys = GIT_BUF_INIT;\n\n\tif (attr_session && attr_session->init_setup)\n\t\treturn 0;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\t/* preload attribute files that could contain macros so the\n\t * definitions will be available for later file parsing\n\t */\n\n\terror = system_attr_file(&sys, attr_session);\n\n\tif (error == 0)\n\t\terror = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, NULL, sys.ptr);\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_buf_free(&sys);\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file)) < 0)\n\t\treturn error;\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO)) < 0)\n\t\treturn error;\n\n\tif (workdir != NULL &&\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, workdir, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_INDEX, NULL, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif (attr_session)\n\t\tattr_session->init_setup = 1;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int attr_setup(git_repository *repo, git_attr_session *attr_session)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_index *idx = NULL;\n\tgit_buf sys = GIT_BUF_INIT;\n\n\tif (attr_session && attr_session->init_setup)\n\t\treturn 0;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\t/* preload attribute files that could contain macros so the\n\t * definitions will be available for later file parsing\n\t */\n\n\terror = system_attr_file(&sys, attr_session);\n\n\tif (error == 0)\n\t\terror = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, NULL, sys.ptr);\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_buf_free(&sys);\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file)) < 0)\n\t\treturn error;\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO)) < 0)\n\t\treturn error;\n\n\tif (workdir != NULL &&\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, workdir, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_INDEX, NULL, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif (attr_session)\n\t\tattr_session->init_setup = 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}"
  },
  {
    "function_name": "release_attr_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "455-465",
    "snippet": "static void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "files"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "files",
            "i",
            "file"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}"
  },
  {
    "function_name": "push_one_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "439-453",
    "snippet": "static int push_one_attr(void *ref, const char *path)\n{\n\tint error = 0, n_src, i;\n\tattr_walk_up_info *info = (attr_walk_up_info *)ref;\n\tgit_attr_file_source src[2];\n\n\tn_src = attr_decide_sources(\n\t\tinfo->flags, info->workdir != NULL, info->index != NULL, src);\n\n\tfor (i = 0; !error && i < n_src; ++i)\n\t\terror = push_attr_file(info->repo, info->attr_session,\n\t\t\tinfo->files, src[i], path, GIT_ATTR_FILE);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_attr_file",
          "args": [
            "info->repo",
            "info->attr_session",
            "info->files",
            "src[i]",
            "path",
            "GIT_ATTR_FILE"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "push_attr_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "414-437",
          "snippet": "static int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_decide_sources",
          "args": [
            "info->flags",
            "info->workdir != NULL",
            "info->index != NULL",
            "src"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "attr_decide_sources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "387-412",
          "snippet": "static int attr_decide_sources(\n\tuint32_t flags, bool has_wd, bool has_index, git_attr_file_source *srcs)\n{\n\tint count = 0;\n\n\tswitch (flags & 0x03) {\n\tcase GIT_ATTR_CHECK_FILE_THEN_INDEX:\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_THEN_FILE:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_ONLY:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int attr_decide_sources(\n\tuint32_t flags, bool has_wd, bool has_index, git_attr_file_source *srcs)\n{\n\tint count = 0;\n\n\tswitch (flags & 0x03) {\n\tcase GIT_ATTR_CHECK_FILE_THEN_INDEX:\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_THEN_FILE:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_ONLY:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\t}\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int push_one_attr(void *ref, const char *path)\n{\n\tint error = 0, n_src, i;\n\tattr_walk_up_info *info = (attr_walk_up_info *)ref;\n\tgit_attr_file_source src[2];\n\n\tn_src = attr_decide_sources(\n\t\tinfo->flags, info->workdir != NULL, info->index != NULL, src);\n\n\tfor (i = 0; !error && i < n_src; ++i)\n\t\terror = push_attr_file(info->repo, info->attr_session,\n\t\t\tinfo->files, src[i], path, GIT_ATTR_FILE);\n\n\treturn error;\n}"
  },
  {
    "function_name": "push_attr_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "414-437",
    "snippet": "static int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "file"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "list",
            "file"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__get",
          "args": [
            "&file",
            "repo",
            "attr_session",
            "source",
            "base",
            "filename",
            "git_attr_file__parse_buffer"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "200-249",
          "snippet": "int git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int push_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_vector *list,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename)\n{\n\tint error = 0;\n\tgit_attr_file *file = NULL;\n\n\terror = git_attr_cache__get(&file, repo, attr_session,\n\t\tsource, base, filename, git_attr_file__parse_buffer);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (file != NULL) {\n\t\tif ((error = git_vector_insert(list, file)) < 0)\n\t\t\tgit_attr_file__free(file);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "attr_decide_sources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "387-412",
    "snippet": "static int attr_decide_sources(\n\tuint32_t flags, bool has_wd, bool has_index, git_attr_file_source *srcs)\n{\n\tint count = 0;\n\n\tswitch (flags & 0x03) {\n\tcase GIT_ATTR_CHECK_FILE_THEN_INDEX:\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_THEN_FILE:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_ONLY:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int attr_decide_sources(\n\tuint32_t flags, bool has_wd, bool has_index, git_attr_file_source *srcs)\n{\n\tint count = 0;\n\n\tswitch (flags & 0x03) {\n\tcase GIT_ATTR_CHECK_FILE_THEN_INDEX:\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_THEN_FILE:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tif (has_wd)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_FILE;\n\t\tbreak;\n\tcase GIT_ATTR_CHECK_INDEX_ONLY:\n\t\tif (has_index)\n\t\t\tsrcs[count++] = GIT_ATTR_FILE__FROM_INDEX;\n\t\tbreak;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "git_attr_add_macro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "344-376",
    "snippet": "int git_attr_add_macro(\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *values)\n{\n\tint error;\n\tgit_attr_rule *macro = NULL;\n\tgit_pool *pool;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\tmacro = git__calloc(1, sizeof(git_attr_rule));\n\tGITERR_CHECK_ALLOC(macro);\n\n\tpool = &git_repository_attr_cache(repo)->pool;\n\n\tmacro->match.pattern = git_pool_strdup(pool, name);\n\tGITERR_CHECK_ALLOC(macro->match.pattern);\n\n\tmacro->match.length = strlen(macro->match.pattern);\n\tmacro->match.flags = GIT_ATTR_FNMATCH_MACRO;\n\n\terror = git_attr_assignment__parse(repo, pool, &macro->assigns, &values);\n\n\tif (!error)\n\t\terror = git_attr_cache__insert_macro(repo, macro);\n\n\tif (error < 0)\n\t\tgit_attr_rule__free(macro);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_rule__free",
          "args": [
            "macro"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_rule__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "842-846",
          "snippet": "void git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void git_attr_rule__clear(git_attr_rule *rule);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic void git_attr_rule__clear(git_attr_rule *rule);\n\nvoid git_attr_rule__free(git_attr_rule *rule)\n{\n\tgit_attr_rule__clear(rule);\n\tgit__free(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__insert_macro",
          "args": [
            "repo",
            "macro"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__insert_macro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "422-441",
          "snippet": "int git_attr_cache__insert_macro(git_repository *repo, git_attr_rule *macro)\n{\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_strmap *macros = cache->macros;\n\tint error;\n\n\t/* TODO: generate warning log if (macro->assigns.length == 0) */\n\tif (macro->assigns.length == 0)\n\t\treturn 0;\n\n\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to get attr cache lock\");\n\t\terror = -1;\n\t} else {\n\t\tgit_strmap_insert(macros, macro->match.pattern, macro, error);\n\t\tgit_mutex_unlock(&cache->lock);\n\t}\n\n\treturn (error < 0) ? -1 : 0;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__insert_macro(git_repository *repo, git_attr_rule *macro)\n{\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_strmap *macros = cache->macros;\n\tint error;\n\n\t/* TODO: generate warning log if (macro->assigns.length == 0) */\n\tif (macro->assigns.length == 0)\n\t\treturn 0;\n\n\tif (git_mutex_lock(&cache->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to get attr cache lock\");\n\t\terror = -1;\n\t} else {\n\t\tgit_strmap_insert(macros, macro->match.pattern, macro, error);\n\t\tgit_mutex_unlock(&cache->lock);\n\t}\n\n\treturn (error < 0) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_assignment__parse",
          "args": [
            "repo",
            "pool",
            "&macro->assigns",
            "&values"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_assignment__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "714-821",
          "snippet": "int git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_assignment__parse(\n\tgit_repository *repo,\n\tgit_pool *pool,\n\tgit_vector *assigns,\n\tconst char **base)\n{\n\tint error;\n\tconst char *scan = *base;\n\tgit_attr_assignment *assign = NULL;\n\n\tassert(assigns && !assigns->length);\n\n\tgit_vector_set_cmp(assigns, sort_by_hash_and_name);\n\n\twhile (*scan && *scan != '\\n') {\n\t\tconst char *name_start, *value_start;\n\n\t\t/* skip leading blanks */\n\t\twhile (git__isspace(*scan) && *scan != '\\n') scan++;\n\n\t\t/* allocate assign if needed */\n\t\tif (!assign) {\n\t\t\tassign = git__calloc(1, sizeof(git_attr_assignment));\n\t\t\tGITERR_CHECK_ALLOC(assign);\n\t\t\tGIT_REFCOUNT_INC(assign);\n\t\t}\n\n\t\tassign->name_hash = 5381;\n\t\tassign->value = git_attr__true;\n\n\t\t/* look for magic name prefixes */\n\t\tif (*scan == '-') {\n\t\t\tassign->value = git_attr__false;\n\t\t\tscan++;\n\t\t} else if (*scan == '!') {\n\t\t\tassign->value = git_attr__unset; /* explicit unspecified state */\n\t\t\tscan++;\n\t\t} else if (*scan == '#') /* comment rest of line */\n\t\t\tbreak;\n\n\t\t/* find the name */\n\t\tname_start = scan;\n\t\twhile (*scan && !git__isspace(*scan) && *scan != '=') {\n\t\t\tassign->name_hash =\n\t\t\t\t((assign->name_hash << 5) + assign->name_hash) + *scan;\n\t\t\tscan++;\n\t\t}\n\t\tif (scan == name_start) {\n\t\t\t/* must have found lone prefix (\" - \") or leading = (\"=foo\")\n\t\t\t * or end of buffer -- advance until whitespace and continue\n\t\t\t */\n\t\t\twhile (*scan && !git__isspace(*scan)) scan++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* allocate permanent storage for name */\n\t\tassign->name = git_pool_strndup(pool, name_start, scan - name_start);\n\t\tGITERR_CHECK_ALLOC(assign->name);\n\n\t\t/* if there is an equals sign, find the value */\n\t\tif (*scan == '=') {\n\t\t\tfor (value_start = ++scan; *scan && !git__isspace(*scan); ++scan);\n\n\t\t\t/* if we found a value, allocate permanent storage for it */\n\t\t\tif (scan > value_start) {\n\t\t\t\tassign->value = git_pool_strndup(pool, value_start, scan - value_start);\n\t\t\t\tGITERR_CHECK_ALLOC(assign->value);\n\t\t\t}\n\t\t}\n\n\t\t/* expand macros (if given a repo with a macro cache) */\n\t\tif (repo != NULL && assign->value == git_attr__true) {\n\t\t\tgit_attr_rule *macro =\n\t\t\t\tgit_attr_cache__lookup_macro(repo, assign->name);\n\n\t\t\tif (macro != NULL) {\n\t\t\t\tunsigned int i;\n\t\t\t\tgit_attr_assignment *massign;\n\n\t\t\t\tgit_vector_foreach(&macro->assigns, i, massign) {\n\t\t\t\t\tGIT_REFCOUNT_INC(massign);\n\n\t\t\t\t\terror = git_vector_insert_sorted(\n\t\t\t\t\t\tassigns, massign, &merge_assignments);\n\t\t\t\t\tif (error < 0 && error != GIT_EEXISTS) {\n\t\t\t\t\t\tgit_attr_assignment__free(assign);\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* insert allocated assign into vector */\n\t\terror = git_vector_insert_sorted(assigns, assign, &merge_assignments);\n\t\tif (error < 0 && error != GIT_EEXISTS)\n\t\t\treturn error;\n\n\t\t/* clear assign since it is now \"owned\" by the vector */\n\t\tassign = NULL;\n\t}\n\n\tif (assign != NULL)\n\t\tgit_attr_assignment__free(assign);\n\n\t*base = git__next_line(scan);\n\n\treturn (assigns->length == 0) ? GIT_ENOTFOUND : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "macro->match.pattern"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "macro->match.pattern"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "pool",
            "name"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_attr_cache",
          "args": [
            "repo"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "148-151",
          "snippet": "GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "macro"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_attr_rule)"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__init",
          "args": [
            "repo"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_add_macro(\n\tgit_repository *repo,\n\tconst char *name,\n\tconst char *values)\n{\n\tint error;\n\tgit_attr_rule *macro = NULL;\n\tgit_pool *pool;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\tmacro = git__calloc(1, sizeof(git_attr_rule));\n\tGITERR_CHECK_ALLOC(macro);\n\n\tpool = &git_repository_attr_cache(repo)->pool;\n\n\tmacro->match.pattern = git_pool_strdup(pool, name);\n\tGITERR_CHECK_ALLOC(macro->match.pattern);\n\n\tmacro->match.length = strlen(macro->match.pattern);\n\tmacro->match.flags = GIT_ATTR_FNMATCH_MACRO;\n\n\terror = git_attr_assignment__parse(repo, pool, &macro->assigns, &values);\n\n\tif (!error)\n\t\terror = git_attr_cache__insert_macro(repo, macro);\n\n\tif (error < 0)\n\t\tgit_attr_rule__free(macro);\n\n\treturn error;\n}"
  },
  {
    "function_name": "attr_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "290-342",
    "snippet": "static int attr_setup(git_repository *repo, git_attr_session *attr_session)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_index *idx = NULL;\n\tgit_buf sys = GIT_BUF_INIT;\n\n\tif (attr_session && attr_session->init_setup)\n\t\treturn 0;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\t/* preload attribute files that could contain macros so the\n\t * definitions will be available for later file parsing\n\t */\n\n\terror = system_attr_file(&sys, attr_session);\n\n\tif (error == 0)\n\t\terror = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, NULL, sys.ptr);\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_buf_free(&sys);\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file)) < 0)\n\t\treturn error;\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO)) < 0)\n\t\treturn error;\n\n\tif (workdir != NULL &&\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, workdir, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_INDEX, NULL, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif (attr_session)\n\t\tattr_session->init_setup = 1;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preload_attr_file",
          "args": [
            "repo",
            "attr_session",
            "GIT_ATTR_FILE__FROM_INDEX",
            "NULL",
            "GIT_ATTR_FILE"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "preload_attr_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "233-250",
          "snippet": "static int preload_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *file)\n{\n\tint error;\n\tgit_attr_file *preload = NULL;\n\n\tif (!file)\n\t\treturn 0;\n\tif (!(error = git_attr_cache__get(\n\t\t\t&preload, repo, attr_session, source, base, file, git_attr_file__parse_buffer)))\n\t\tgit_attr_file__free(preload);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int preload_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *file)\n{\n\tint error;\n\tgit_attr_file *preload = NULL;\n\n\tif (!file)\n\t\treturn 0;\n\tif (!(error = git_attr_cache__get(\n\t\t\t&preload, repo, attr_session, source, base, file, git_attr_file__parse_buffer)))\n\t\tgit_attr_file__free(preload);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&idx",
            "repo"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_attr_cache",
          "args": [
            "repo"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "148-151",
          "snippet": "GIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(git_attr_cache *) git_repository_attr_cache(git_repository *repo)\n{\n\treturn repo->attrcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&sys"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system_attr_file",
          "args": [
            "&sys",
            "attr_session"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "system_attr_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "252-288",
          "snippet": "static int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__init",
          "args": [
            "repo"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int attr_setup(git_repository *repo, git_attr_session *attr_session)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_index *idx = NULL;\n\tgit_buf sys = GIT_BUF_INIT;\n\n\tif (attr_session && attr_session->init_setup)\n\t\treturn 0;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\treturn error;\n\n\t/* preload attribute files that could contain macros so the\n\t * definitions will be available for later file parsing\n\t */\n\n\terror = system_attr_file(&sys, attr_session);\n\n\tif (error == 0)\n\t\terror = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, NULL, sys.ptr);\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_buf_free(&sys);\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file)) < 0)\n\t\treturn error;\n\n\tif ((error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO)) < 0)\n\t\treturn error;\n\n\tif (workdir != NULL &&\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_FILE, workdir, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_index__weakptr(&idx, repo)) < 0 ||\n\t\t(error = preload_attr_file(\n\t\t\trepo, attr_session, GIT_ATTR_FILE__FROM_INDEX, NULL, GIT_ATTR_FILE)) < 0)\n\t\treturn error;\n\n\tif (attr_session)\n\t\tattr_session->init_setup = 1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "system_attr_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "252-288",
    "snippet": "static int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_attach_notowned",
          "args": [
            "out",
            "attr_session->sysdir.ptr",
            "attr_session->sysdir.size"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_attach_notowned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "505-517",
          "snippet": "void git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sysdir_find_system_file",
          "args": [
            "&attr_session->sysdir",
            "GIT_ATTR_FILE_SYSTEM"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_sysdir_find_system_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sysdir.c",
          "lines": "248-252",
          "snippet": "int git_sysdir_find_system_file(git_buf *path, const char *filename)\n{\n\treturn git_sysdir_find_in_dirlist(\n\t\tpath, filename, GIT_SYSDIR_SYSTEM, \"system\");\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"path.h\"",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"path.h\"\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_sysdir_find_system_file(git_buf *path, const char *filename)\n{\n\treturn git_sysdir_find_in_dirlist(\n\t\tpath, filename, GIT_SYSDIR_SYSTEM, \"system\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int system_attr_file(\n\tgit_buf *out,\n\tgit_attr_session *attr_session)\n{\n\tint error;\n\n\tif (!attr_session) {\n\t\terror = git_sysdir_find_system_file(out, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\n\t\treturn error;\n\t}\n\n\tif (!attr_session->init_sysdir) {\n\t\terror = git_sysdir_find_system_file(&attr_session->sysdir, GIT_ATTR_FILE_SYSTEM);\n\n\t\tif (error == GIT_ENOTFOUND)\n\t\t\tgiterr_clear();\n\t\telse if (error)\n\t\t\treturn error;\n\n\t\tattr_session->init_sysdir = 1;\n\t}\n\n\tif (attr_session->sysdir.size == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\t/* We can safely provide a git_buf with no allocation (asize == 0) to\n\t * a consumer. This allows them to treat this as a regular `git_buf`,\n\t * but their call to `git_buf_free` will not attempt to free it.\n\t */\n\tgit_buf_attach_notowned(\n\t\tout, attr_session->sysdir.ptr, attr_session->sysdir.size);\n\treturn 0;\n}"
  },
  {
    "function_name": "preload_attr_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "233-250",
    "snippet": "static int preload_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *file)\n{\n\tint error;\n\tgit_attr_file *preload = NULL;\n\n\tif (!file)\n\t\treturn 0;\n\tif (!(error = git_attr_cache__get(\n\t\t\t&preload, repo, attr_session, source, base, file, git_attr_file__parse_buffer)))\n\t\tgit_attr_file__free(preload);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_file__free",
          "args": [
            "preload"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "66-71",
          "snippet": "void git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_file__free(git_attr_file *file)\n{\n\tif (!file)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(file, attr_file_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_cache__get",
          "args": [
            "&preload",
            "repo",
            "attr_session",
            "source",
            "base",
            "file",
            "git_attr_file__parse_buffer"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_cache__get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attrcache.c",
          "lines": "200-249",
          "snippet": "int git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"sysdir.h\"",
            "#include \"config.h\"",
            "#include \"attr_file.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"sysdir.h\"\n#include \"config.h\"\n#include \"attr_file.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_cache__get(\n\tgit_attr_file **out,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *filename,\n\tgit_attr_file_parser parser)\n{\n\tint error = 0;\n\tgit_attr_cache *cache = git_repository_attr_cache(repo);\n\tgit_attr_file_entry *entry = NULL;\n\tgit_attr_file *file = NULL, *updated = NULL;\n\n\tif ((error = attr_cache_lookup(\n\t\t\t&file, &entry, repo, attr_session, source, base, filename)) < 0)\n\t\treturn error;\n\n\t/* load file if we don't have one or if existing one is out of date */\n\tif (!file || (error = git_attr_file__out_of_date(repo, attr_session, file)) > 0)\n\t\terror = git_attr_file__load(&updated, repo, attr_session, entry, source, parser);\n\n\t/* if we loaded the file, insert into and/or update cache */\n\tif (updated) {\n\t\tif ((error = attr_cache_upsert(cache, updated)) < 0)\n\t\t\tgit_attr_file__free(updated);\n\t\telse {\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = updated;\n\t\t}\n\t}\n\n\t/* if file could not be loaded */\n\tif (error < 0) {\n\t\t/* remove existing entry */\n\t\tif (file) {\n\t\t\tattr_cache_remove(cache, file);\n\t\t\tgit_attr_file__free(file); /* offset incref from lookup */\n\t\t\tfile = NULL;\n\t\t}\n\t\t/* no error if file simply doesn't exist */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t}\n\n\t*out = file;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int preload_attr_file(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tgit_attr_file_source source,\n\tconst char *base,\n\tconst char *file)\n{\n\tint error;\n\tgit_attr_file *preload = NULL;\n\n\tif (!file)\n\t\treturn 0;\n\tif (!(error = git_attr_cache__get(\n\t\t\t&preload, repo, attr_session, source, base, file, git_attr_file__parse_buffer)))\n\t\tgit_attr_file__free(preload);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "178-231",
    "snippet": "int git_attr_foreach(\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tint (*callback)(const char *name, const char *value, void *payload),\n\tvoid *payload)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tgit_attr_assignment *assign;\n\tgit_strmap *seen = NULL;\n\n\tassert(repo && callback);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, NULL, flags, pathname, &files)) < 0 ||\n\t\t(error = git_strmap_alloc(&seen)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tgit_vector_foreach(&rule->assigns, k, assign) {\n\t\t\t\t/* skip if higher priority assignment was already seen */\n\t\t\t\tif (git_strmap_exists(seen, assign->name))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tgit_strmap_insert(seen, assign->name, assign, error);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\terror = callback(assign->name, assign->value, payload);\n\t\t\t\tif (error) {\n\t\t\t\t\tgiterr_set_after_callback(error);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_strmap_free(seen);\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_path__free",
          "args": [
            "&path"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "508-513",
          "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_attr_files",
          "args": [
            "&files"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "release_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "455-465",
          "snippet": "static void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "seen"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "assign->name",
            "assign->value",
            "payload"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_set_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1715-1724",
          "snippet": "int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "seen",
            "assign->name",
            "assign",
            "error"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_exists",
          "args": [
            "seen",
            "assign->name"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&rule->assigns",
            "k",
            "assign"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_attr_file__foreach_matching_rule",
          "args": [
            "file",
            "&path",
            "j",
            "rule"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&files",
            "i",
            "file"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&seen"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_attr_files",
          "args": [
            "repo",
            "NULL",
            "flags",
            "pathname",
            "&files"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "collect_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "467-544",
          "snippet": "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__init",
          "args": [
            "&path",
            "pathname",
            "git_repository_workdir(repo)",
            "GIT_DIR_FLAG_UNKNOWN"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "457-506",
          "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && callback"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nint git_attr_foreach(\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tint (*callback)(const char *name, const char *value, void *payload),\n\tvoid *payload)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tgit_attr_assignment *assign;\n\tgit_strmap *seen = NULL;\n\n\tassert(repo && callback);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, NULL, flags, pathname, &files)) < 0 ||\n\t\t(error = git_strmap_alloc(&seen)) < 0)\n\t\tgoto cleanup;\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tgit_vector_foreach(&rule->assigns, k, assign) {\n\t\t\t\t/* skip if higher priority assignment was already seen */\n\t\t\t\tif (git_strmap_exists(seen, assign->name))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tgit_strmap_insert(seen, assign->name, assign, error);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\terror = callback(assign->name, assign->value, payload);\n\t\t\t\tif (error) {\n\t\t\t\t\tgiterr_set_after_callback(error);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_strmap_free(seen);\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_get_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "166-176",
    "snippet": "int git_attr_get_many(\n\tconst char **values,\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\treturn git_attr_get_many_with_session(\n\t\tvalues, repo, NULL, flags, pathname, num_attr, names);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_get_many_with_session",
          "args": [
            "values",
            "repo",
            "NULL",
            "flags",
            "pathname",
            "num_attr",
            "names"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_get_many_with_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "94-164",
          "snippet": "int git_attr_get_many_with_session(\n\tconst char **values,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tattr_get_many_info *info = NULL;\n\tsize_t num_found = 0;\n\n\tif (!num_attr)\n\t\treturn 0;\n\n\tassert(values && repo && names);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, attr_session, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tinfo = git__calloc(num_attr, sizeof(attr_get_many_info));\n\tGITERR_CHECK_ALLOC(info);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tfor (k = 0; k < num_attr; k++) {\n\t\t\t\tsize_t pos;\n\n\t\t\t\tif (info[k].found != NULL) /* already found assignment */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!info[k].name.name) {\n\t\t\t\t\tinfo[k].name.name = names[k];\n\t\t\t\t\tinfo[k].name.name_hash = git_attr_file__name_hash(names[k]);\n\t\t\t\t}\n\n\t\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &info[k].name)) {\n\t\t\t\t\tinfo[k].found = (git_attr_assignment *)\n\t\t\t\t\t\tgit_vector_get(&rule->assigns, pos);\n\t\t\t\t\tvalues[k] = info[k].found->value;\n\n\t\t\t\t\tif (++num_found == num_attr)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < num_attr; k++) {\n\t\tif (!info[k].found)\n\t\t\tvalues[k] = NULL;\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\tgit__free(info);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nint git_attr_get_many_with_session(\n\tconst char **values,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tattr_get_many_info *info = NULL;\n\tsize_t num_found = 0;\n\n\tif (!num_attr)\n\t\treturn 0;\n\n\tassert(values && repo && names);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, attr_session, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tinfo = git__calloc(num_attr, sizeof(attr_get_many_info));\n\tGITERR_CHECK_ALLOC(info);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tfor (k = 0; k < num_attr; k++) {\n\t\t\t\tsize_t pos;\n\n\t\t\t\tif (info[k].found != NULL) /* already found assignment */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!info[k].name.name) {\n\t\t\t\t\tinfo[k].name.name = names[k];\n\t\t\t\t\tinfo[k].name.name_hash = git_attr_file__name_hash(names[k]);\n\t\t\t\t}\n\n\t\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &info[k].name)) {\n\t\t\t\t\tinfo[k].found = (git_attr_assignment *)\n\t\t\t\t\t\tgit_vector_get(&rule->assigns, pos);\n\t\t\t\t\tvalues[k] = info[k].found->value;\n\n\t\t\t\t\tif (++num_found == num_attr)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < num_attr; k++) {\n\t\tif (!info[k].found)\n\t\t\tvalues[k] = NULL;\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\tgit__free(info);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_get_many(\n\tconst char **values,\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\treturn git_attr_get_many_with_session(\n\t\tvalues, repo, NULL, flags, pathname, num_attr, names);\n}"
  },
  {
    "function_name": "git_attr_get_many_with_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "94-164",
    "snippet": "int git_attr_get_many_with_session(\n\tconst char **values,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tattr_get_many_info *info = NULL;\n\tsize_t num_found = 0;\n\n\tif (!num_attr)\n\t\treturn 0;\n\n\tassert(values && repo && names);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, attr_session, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tinfo = git__calloc(num_attr, sizeof(attr_get_many_info));\n\tGITERR_CHECK_ALLOC(info);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tfor (k = 0; k < num_attr; k++) {\n\t\t\t\tsize_t pos;\n\n\t\t\t\tif (info[k].found != NULL) /* already found assignment */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!info[k].name.name) {\n\t\t\t\t\tinfo[k].name.name = names[k];\n\t\t\t\t\tinfo[k].name.name_hash = git_attr_file__name_hash(names[k]);\n\t\t\t\t}\n\n\t\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &info[k].name)) {\n\t\t\t\t\tinfo[k].found = (git_attr_assignment *)\n\t\t\t\t\t\tgit_vector_get(&rule->assigns, pos);\n\t\t\t\t\tvalues[k] = info[k].found->value;\n\n\t\t\t\t\tif (++num_found == num_attr)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < num_attr; k++) {\n\t\tif (!info[k].found)\n\t\t\tvalues[k] = NULL;\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\tgit__free(info);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "info"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__free",
          "args": [
            "&path"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "508-513",
          "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_attr_files",
          "args": [
            "&files"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "release_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "455-465",
          "snippet": "static void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&rule->assigns",
            "pos"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch",
          "args": [
            "&pos",
            "&rule->assigns",
            "&info[k].name"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "55-58",
          "snippet": "GIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__name_hash",
          "args": [
            "names[k]"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "284-292",
          "snippet": "uint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nuint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__foreach_matching_rule",
          "args": [
            "file",
            "&path",
            "j",
            "rule"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&files",
            "i",
            "file"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "info"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "num_attr",
            "sizeof(attr_get_many_info)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_attr_files",
          "args": [
            "repo",
            "attr_session",
            "flags",
            "pathname",
            "&files"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "collect_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "467-544",
          "snippet": "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__init",
          "args": [
            "&path",
            "pathname",
            "git_repository_workdir(repo)",
            "GIT_DIR_FLAG_UNKNOWN"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "457-506",
          "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "values && repo && names"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nint git_attr_get_many_with_session(\n\tconst char **values,\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *pathname,\n\tsize_t num_attr,\n\tconst char **names)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j, k;\n\tgit_attr_file *file;\n\tgit_attr_rule *rule;\n\tattr_get_many_info *info = NULL;\n\tsize_t num_found = 0;\n\n\tif (!num_attr)\n\t\treturn 0;\n\n\tassert(values && repo && names);\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, attr_session, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tinfo = git__calloc(num_attr, sizeof(attr_get_many_info));\n\tGITERR_CHECK_ALLOC(info);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\n\t\t\tfor (k = 0; k < num_attr; k++) {\n\t\t\t\tsize_t pos;\n\n\t\t\t\tif (info[k].found != NULL) /* already found assignment */\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!info[k].name.name) {\n\t\t\t\t\tinfo[k].name.name = names[k];\n\t\t\t\t\tinfo[k].name.name_hash = git_attr_file__name_hash(names[k]);\n\t\t\t\t}\n\n\t\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &info[k].name)) {\n\t\t\t\t\tinfo[k].found = (git_attr_assignment *)\n\t\t\t\t\t\tgit_vector_get(&rule->assigns, pos);\n\t\t\t\t\tvalues[k] = info[k].found->value;\n\n\t\t\t\t\tif (++num_found == num_attr)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (k = 0; k < num_attr; k++) {\n\t\tif (!info[k].found)\n\t\t\tvalues[k] = NULL;\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\tgit__free(info);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "39-86",
    "snippet": "int git_attr_get(\n\tconst char **value,\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tconst char *name)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j;\n\tgit_attr_file *file;\n\tgit_attr_name attr;\n\tgit_attr_rule *rule;\n\n\tassert(value && repo && name);\n\n\t*value = NULL;\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, NULL, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.name = name;\n\tattr.name_hash = git_attr_file__name_hash(name);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\t\t\tsize_t pos;\n\n\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &attr)) {\n\t\t\t\t*value = ((git_attr_assignment *)git_vector_get(\n\t\t\t\t\t\t\t  &rule->assigns, pos))->value;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
      "static void release_attr_files(git_vector *files);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_attr_path__free",
          "args": [
            "&path"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "508-513",
          "snippet": "void git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_attr_path__free(git_attr_path *info)\n{\n\tgit_buf_free(&info->full);\n\tinfo->path = NULL;\n\tinfo->basename = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_attr_files",
          "args": [
            "&files"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "release_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "455-465",
          "snippet": "static void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic void release_attr_files(git_vector *files)\n{\n\tsize_t i;\n\tgit_attr_file *file;\n\n\tgit_vector_foreach(files, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tfiles->contents[i] = NULL;\n\t}\n\tgit_vector_free(files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&rule->assigns",
            "pos"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch",
          "args": [
            "&pos",
            "&rule->assigns",
            "&attr"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "55-58",
          "snippet": "GIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_file__foreach_matching_rule",
          "args": [
            "file",
            "&path",
            "j",
            "rule"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&files",
            "i",
            "file"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_attr_file__name_hash",
          "args": [
            "name"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_file__name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "284-292",
          "snippet": "uint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nuint32_t git_attr_file__name_hash(const char *name)\n{\n\tuint32_t h = 5381;\n\tint c;\n\tassert(name);\n\twhile ((c = (int)*name++) != 0)\n\t\th = ((h << 5) + h) + c;\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&attr",
            "0",
            "sizeof(attr)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_attr_files",
          "args": [
            "repo",
            "NULL",
            "flags",
            "pathname",
            "&files"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "collect_attr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
          "lines": "467-544",
          "snippet": "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"git2/oid.h\"",
            "#include \"ignore.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);",
            "static void release_attr_files(git_vector *files);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files)\n{\n\tint error = 0;\n\tgit_buf dir = GIT_BUF_INIT;\n\tconst char *workdir = git_repository_workdir(repo);\n\tattr_walk_up_info info = { NULL };\n\n\tif ((error = attr_setup(repo, attr_session)) < 0)\n\t\treturn error;\n\n\t/* Resolve path in a non-bare repo */\n\tif (workdir != NULL)\n\t\terror = git_path_find_dir(&dir, path, workdir);\n\telse\n\t\terror = git_path_dirname_r(&dir, path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* in precendence order highest to lowest:\n\t * - $GIT_DIR/info/attributes\n\t * - path components with .gitattributes\n\t * - config core.attributesfile\n\t * - $GIT_PREFIX/etc/gitattributes\n\t */\n\n\terror = push_attr_file(\n\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\tgit_repository_path(repo), GIT_ATTR_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinfo.repo = repo;\n\tinfo.attr_session = attr_session;\n\tinfo.flags = flags;\n\tinfo.workdir = workdir;\n\tif (git_repository_index__weakptr(&info.index, repo) < 0)\n\t\tgiterr_clear(); /* no error even if there is no index */\n\tinfo.files = files;\n\n\tif (!strcmp(dir.ptr, \".\"))\n\t\terror = push_one_attr(&info, \"\");\n\telse\n\t\terror = git_path_walk_up(&dir, workdir, push_one_attr, &info);\n\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (git_repository_attr_cache(repo)->cfg_attr_file != NULL) {\n\t\terror = push_attr_file(\n\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\tNULL, git_repository_attr_cache(repo)->cfg_attr_file);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((flags & GIT_ATTR_CHECK_NO_SYSTEM) == 0) {\n\t\terror = system_attr_file(&dir, attr_session);\n\n\t\tif (!error)\n\t\t\terror = push_attr_file(\n\t\t\t\trepo, attr_session, files, GIT_ATTR_FILE__FROM_FILE,\n\t\t\t\tNULL, dir.ptr);\n\t\telse if (error == GIT_ENOTFOUND)\n\t\t\terror = 0;\n\t}\n\n cleanup:\n\tif (error < 0)\n\t\trelease_attr_files(files);\n\tgit_buf_free(&dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_attr_path__init",
          "args": [
            "&path",
            "pathname",
            "git_repository_workdir(repo)",
            "GIT_DIR_FLAG_UNKNOWN"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "git_attr_path__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr_file.c",
          "lines": "457-506",
          "snippet": "int git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"index.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/blob.h\"",
            "#include \"attrcache.h\"",
            "#include \"attr_file.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"index.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"attrcache.h\"\n#include \"attr_file.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nint git_attr_path__init(\n\tgit_attr_path *info, const char *path, const char *base, git_dir_flag dir_flag)\n{\n\tssize_t root;\n\n\t/* build full path as best we can */\n\tgit_buf_init(&info->full, 0);\n\n\tif (git_path_join_unrooted(&info->full, path, base, &root) < 0)\n\t\treturn -1;\n\n\tinfo->path = info->full.ptr + root;\n\n\t/* remove trailing slashes */\n\twhile (info->full.size > 0) {\n\t\tif (info->full.ptr[info->full.size - 1] != '/')\n\t\t\tbreak;\n\t\tinfo->full.size--;\n\t}\n\tinfo->full.ptr[info->full.size] = '\\0';\n\n\t/* skip leading slashes in path */\n\twhile (*info->path == '/')\n\t\tinfo->path++;\n\n\t/* find trailing basename component */\n\tinfo->basename = strrchr(info->path, '/');\n\tif (info->basename)\n\t\tinfo->basename++;\n\tif (!info->basename || !*info->basename)\n\t\tinfo->basename = info->path;\n\n\tswitch (dir_flag)\n\t{\n\tcase GIT_DIR_FLAG_FALSE:\n\t\tinfo->is_dir = 0;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_TRUE:\n\t\tinfo->is_dir = 1;\n\t\tbreak;\n\n\tcase GIT_DIR_FLAG_UNKNOWN:\n\tdefault:\n\t\tinfo->is_dir = (int)git_path_isdir(info->full.ptr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "value && repo && name"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int collect_attr_files(\n\tgit_repository *repo,\n\tgit_attr_session *attr_session,\n\tuint32_t flags,\n\tconst char *path,\n\tgit_vector *files);\nstatic void release_attr_files(git_vector *files);\n\nint git_attr_get(\n\tconst char **value,\n\tgit_repository *repo,\n\tuint32_t flags,\n\tconst char *pathname,\n\tconst char *name)\n{\n\tint error;\n\tgit_attr_path path;\n\tgit_vector files = GIT_VECTOR_INIT;\n\tsize_t i, j;\n\tgit_attr_file *file;\n\tgit_attr_name attr;\n\tgit_attr_rule *rule;\n\n\tassert(value && repo && name);\n\n\t*value = NULL;\n\n\tif (git_attr_path__init(&path, pathname, git_repository_workdir(repo), GIT_DIR_FLAG_UNKNOWN) < 0)\n\t\treturn -1;\n\n\tif ((error = collect_attr_files(repo, NULL, flags, pathname, &files)) < 0)\n\t\tgoto cleanup;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.name = name;\n\tattr.name_hash = git_attr_file__name_hash(name);\n\n\tgit_vector_foreach(&files, i, file) {\n\n\t\tgit_attr_file__foreach_matching_rule(file, &path, j, rule) {\n\t\t\tsize_t pos;\n\n\t\t\tif (!git_vector_bsearch(&pos, &rule->assigns, &attr)) {\n\t\t\t\t*value = ((git_attr_assignment *)git_vector_get(\n\t\t\t\t\t\t\t  &rule->assigns, pos))->value;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\trelease_attr_files(&files);\n\tgit_attr_path__free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_attr_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/attr.c",
    "lines": "16-28",
    "snippet": "git_attr_t git_attr_value(const char *attr)\n{\n\tif (attr == NULL || attr == git_attr__unset)\n\t\treturn GIT_ATTR_UNSPECIFIED_T;\n\n\tif (attr == git_attr__true)\n\t\treturn GIT_ATTR_TRUE_T;\n\n\tif (attr == git_attr__false)\n\t\treturn GIT_ATTR_FALSE_T;\n\n\treturn GIT_ATTR_VALUE_T;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"git2/oid.h\"",
      "#include \"ignore.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"sysdir.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "GIT__USE_STRMAP\n\nconst char *git_attr__true  = \"[internal]__TRUE__\";",
      "const char *git_attr__false = \"[internal]__FALSE__\";",
      "const char *git_attr__unset = \"[internal]__UNSET__\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"git2/oid.h\"\n#include \"ignore.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nconst char *git_attr__true  = \"[internal]__TRUE__\";\nconst char *git_attr__false = \"[internal]__FALSE__\";\nconst char *git_attr__unset = \"[internal]__UNSET__\";\n\ngit_attr_t git_attr_value(const char *attr)\n{\n\tif (attr == NULL || attr == git_attr__unset)\n\t\treturn GIT_ATTR_UNSPECIFIED_T;\n\n\tif (attr == git_attr__true)\n\t\treturn GIT_ATTR_TRUE_T;\n\n\tif (attr == git_attr__false)\n\t\treturn GIT_ATTR_FALSE_T;\n\n\treturn GIT_ATTR_VALUE_T;\n}"
  }
]