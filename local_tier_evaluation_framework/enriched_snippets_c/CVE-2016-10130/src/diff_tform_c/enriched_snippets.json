[
  {
    "function_name": "git_diff_find_similar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "795-1112",
    "snippet": "int git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "opts.metric"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opts.metric->free_signature",
          "args": [
            "sigcache[t]",
            "opts.metric->payload"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_splits_and_deletes",
          "args": [
            "diff",
            "diff->deltas.length - num_rewrites",
            "FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY)"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "apply_splits_and_deletes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "369-432",
          "snippet": "static int apply_splits_and_deletes(\n\tgit_diff *diff, size_t expected_size, bool actually_split)\n{\n\tgit_vector onto = GIT_VECTOR_INIT;\n\tsize_t i;\n\tgit_diff_delta *delta;\n\n\tif (git_vector_init(&onto, expected_size, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\t/* build new delta list without TO_DELETE and splitting TO_SPLIT */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tcontinue;\n\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0 && actually_split) {\n\t\t\tdelta->similarity = 0;\n\n\t\t\tif (insert_delete_side_of_split(diff, &onto, delta) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\t\t\tdelta->status = GIT_DELTA_UNTRACKED;\n\t\t\telse\n\t\t\t\tdelta->status = GIT_DELTA_ADDED;\n\t\t\tdelta->nfiles = 1;\n\t\t\tmemset(&delta->old_file, 0, sizeof(delta->old_file));\n\t\t\tdelta->old_file.path = delta->new_file.path;\n\t\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\t/* clean up delta before inserting into new list */\n\t\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\t\tif (delta->status != GIT_DELTA_COPIED &&\n\t\t\tdelta->status != GIT_DELTA_RENAMED &&\n\t\t\t(delta->status != GIT_DELTA_MODIFIED || actually_split))\n\t\t\tdelta->similarity = 0;\n\n\t\t/* insert into new list */\n\t\tif (git_vector_insert(&onto, delta) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* cannot return an error past this point */\n\n\t/* free deltas from old list that didn't make it to the new one */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tgit__free(delta);\n\t}\n\n\t/* swap new delta list into place */\n\tgit_vector_swap(&diff->deltas, &onto);\n\tgit_vector_free(&onto);\n\tgit_vector_sort(&diff->deltas);\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&onto);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int apply_splits_and_deletes(\n\tgit_diff *diff, size_t expected_size, bool actually_split)\n{\n\tgit_vector onto = GIT_VECTOR_INIT;\n\tsize_t i;\n\tgit_diff_delta *delta;\n\n\tif (git_vector_init(&onto, expected_size, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\t/* build new delta list without TO_DELETE and splitting TO_SPLIT */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tcontinue;\n\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0 && actually_split) {\n\t\t\tdelta->similarity = 0;\n\n\t\t\tif (insert_delete_side_of_split(diff, &onto, delta) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\t\t\tdelta->status = GIT_DELTA_UNTRACKED;\n\t\t\telse\n\t\t\t\tdelta->status = GIT_DELTA_ADDED;\n\t\t\tdelta->nfiles = 1;\n\t\t\tmemset(&delta->old_file, 0, sizeof(delta->old_file));\n\t\t\tdelta->old_file.path = delta->new_file.path;\n\t\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\t/* clean up delta before inserting into new list */\n\t\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\t\tif (delta->status != GIT_DELTA_COPIED &&\n\t\t\tdelta->status != GIT_DELTA_RENAMED &&\n\t\t\t(delta->status != GIT_DELTA_MODIFIED || actually_split))\n\t\t\tdelta->similarity = 0;\n\n\t\t/* insert into new list */\n\t\tif (git_vector_insert(&onto, delta) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* cannot return an error past this point */\n\n\t/* free deltas from old list that didn't make it to the new one */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tgit__free(delta);\n\t}\n\n\t/* swap new delta list into place */\n\tgit_vector_swap(&diff->deltas, &onto);\n\tgit_vector_free(&onto);\n\tgit_vector_sort(&diff->deltas);\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&onto);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "&opts",
            "GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "&opts",
            "GIT_DIFF_BREAK_REWRITES"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tgt->old_file",
            "&src->old_file",
            "sizeof(tgt->old_file)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delta_is_new_only",
          "args": [
            "tgt"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "delta_is_new_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "772-778",
          "snippet": "GIT_INLINE(bool) delta_is_new_only(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_UNTRACKED ||\n\t\t\tdelta->status == GIT_DELTA_UNREADABLE ||\n\t\t\tdelta->status == GIT_DELTA_IGNORED);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) delta_is_new_only(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_UNTRACKED ||\n\t\t\tdelta->status == GIT_DELTA_UNREADABLE ||\n\t\t\tdelta->status == GIT_DELTA_IGNORED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delta_is_split",
          "args": [
            "tgt"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "delta_is_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "766-770",
          "snippet": "GIT_INLINE(bool) delta_is_split(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_TYPECHANGE ||\n\t\t\t(delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) delta_is_split(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_TYPECHANGE ||\n\t\t\t(delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_delete_side_of_split",
          "args": [
            "diff",
            "&diff->deltas",
            "tgt"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "insert_delete_side_of_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "353-367",
          "snippet": "static int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&diff->deltas",
            "best_match->idx"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "&opts",
            "GIT_DIFF_FIND_COPIES"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&src->old_file",
            "&swap",
            "sizeof(src->old_file)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delta_make_rename",
          "args": [
            "tgt",
            "src",
            "best_match->similarity"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "delta_make_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "780-788",
          "snippet": "GIT_INLINE(void) delta_make_rename(\n\tgit_diff_delta *to, const git_diff_delta *from, uint16_t similarity)\n{\n\tto->status     = GIT_DELTA_RENAMED;\n\tto->similarity = similarity;\n\tto->nfiles     = 2;\n\tmemcpy(&to->old_file, &from->old_file, sizeof(to->old_file));\n\tto->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) delta_make_rename(\n\tgit_diff_delta *to, const git_diff_delta *from, uint16_t similarity)\n{\n\tto->status     = GIT_DELTA_RENAMED;\n\tto->similarity = similarity;\n\tto->nfiles     = 2;\n\tmemcpy(&to->old_file, &from->old_file, sizeof(to->old_file));\n\tto->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&swap",
            "&tgt->old_file",
            "sizeof(swap)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "delta_is_split(src)"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&src->old_file",
            "0",
            "sizeof(src->old_file)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&src->new_file",
            "0",
            "sizeof(src->new_file)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&src->old_file",
            "&swap",
            "sizeof(src->old_file)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src->status == GIT_DELTA_DELETED"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&swap",
            "&tgt->old_file",
            "sizeof(swap)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "delta_is_split(tgt)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&diff->deltas",
            "s"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "t",
            "tgt"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "similarity_measure",
          "args": [
            "&result",
            "diff",
            "&opts",
            "sigcache",
            "2 * s",
            "2 * t + 1"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_measure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "539-624",
          "snippet": "static int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "s",
            "src"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "t",
            "tgt"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tgt2src_copy"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "num_deltas",
            "sizeof(diff_find_match)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "&opts",
            "GIT_DIFF_FIND_COPIES"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tgt2src"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "src2tgt"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_rename_target",
          "args": [
            "diff",
            "&opts",
            "t",
            "sigcache"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "is_rename_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "651-703",
          "snippet": "static bool is_rename_target(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't plain blobs */\n\tif (!GIT_MODE_ISBLOB(delta->new_file.mode))\n\t\treturn false;\n\n\t/* only consider ADDED, RENAMED, COPIED, and split MODIFIED as\n\t * targets; maybe include UNTRACKED if requested.\n\t */\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_FOR_UNTRACKED))\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault: /* all other status values should be checked */\n\t\tbreak;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_TARGET;\n\treturn true;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic bool is_rename_target(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't plain blobs */\n\tif (!GIT_MODE_ISBLOB(delta->new_file.mode))\n\t\treturn false;\n\n\t/* only consider ADDED, RENAMED, COPIED, and split MODIFIED as\n\t * targets; maybe include UNTRACKED if requested.\n\t */\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_FOR_UNTRACKED))\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault: /* all other status values should be checked */\n\t\tbreak;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_TARGET;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_rename_source",
          "args": [
            "diff",
            "&opts",
            "t",
            "sigcache"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "is_rename_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "705-764",
          "snippet": "static bool is_rename_source(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't blobs */\n\tif (!GIT_MODE_ISBLOB(delta->old_file.mode))\n\t\treturn false;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_UNTRACKED:\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tbreak;\n\n\tcase GIT_DELTA_UNMODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED))\n\t\t\treturn false;\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_REMOVE_UNMODIFIED))\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\tbreak;\n\n\tdefault: /* MODIFIED, RENAMED, COPIED */\n\t\t/* if we're finding copies, this could be a source */\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_COPIES))\n\t\t\tbreak;\n\n\t\t/* otherwise, this is only a source if we can split it */\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_SOURCE;\n\treturn true;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic bool is_rename_source(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't blobs */\n\tif (!GIT_MODE_ISBLOB(delta->old_file.mode))\n\t\treturn false;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_UNTRACKED:\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tbreak;\n\n\tcase GIT_DELTA_UNMODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED))\n\t\t\treturn false;\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_REMOVE_UNMODIFIED))\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\tbreak;\n\n\tdefault: /* MODIFIED, RENAMED, COPIED */\n\t\t/* if we're finding copies, this could be a source */\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_COPIES))\n\t\t\tbreak;\n\n\t\t/* otherwise, this is only a source if we can split it */\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_SOURCE;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "t",
            "tgt"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sigcache"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&sigcache_size",
            "num_deltas",
            "2"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__is_uint32",
          "args": [
            "num_deltas"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_uint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "25-29",
          "snippet": "GIT_INLINE(int) git__is_uint32(size_t p)\n{\n\tuint32_t r = (uint32_t)p;\n\treturn p == (size_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_uint32(size_t p)\n{\n\tuint32_t r = (uint32_t)p;\n\treturn p == (size_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "normalize_find_opts",
          "args": [
            "diff",
            "&opts",
            "given_opts"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "normalize_find_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "244-351",
          "snippet": "static int normalize_find_opts(\n\tgit_diff *diff,\n\tgit_diff_find_options *opts,\n\tconst git_diff_find_options *given)\n{\n\tgit_config *cfg = NULL;\n\tgit_hashsig_option_t hashsig_opts;\n\n\tGITERR_CHECK_VERSION(given, GIT_DIFF_FIND_OPTIONS_VERSION, \"git_diff_find_options\");\n\n\tif (diff->repo != NULL &&\n\t\tgit_repository_config__weakptr(&cfg, diff->repo) < 0)\n\t\treturn -1;\n\n\tif (given)\n\t\tmemcpy(opts, given, sizeof(*opts));\n\n\tif (!given ||\n\t\t (given->flags & GIT_DIFF_FIND_ALL) == GIT_DIFF_FIND_BY_CONFIG)\n\t{\n\t\tif (cfg) {\n\t\t\tchar *rule =\n\t\t\t\tgit_config__get_string_force(cfg, \"diff.renames\", \"true\");\n\t\t\tint boolval;\n\n\t\t\tif (!git__parse_bool(&boolval, rule) && !boolval)\n\t\t\t\t/* don't set FIND_RENAMES if bool value is false */;\n\t\t\telse if (!strcasecmp(rule, \"copies\") || !strcasecmp(rule, \"copy\"))\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES | GIT_DIFF_FIND_COPIES;\n\t\t\telse\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\t\t\tgit__free(rule);\n\t\t} else {\n\t\t\t/* set default flag */\n\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\t\t}\n\t}\n\n\t/* some flags imply others */\n\n\tif (opts->flags & GIT_DIFF_FIND_EXACT_MATCH_ONLY) {\n\t\t/* if we are only looking for exact matches, then don't turn\n\t\t * MODIFIED items into ADD/DELETE pairs because it's too picky\n\t\t */\n\t\topts->flags &= ~(GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES);\n\n\t\t/* similarly, don't look for self-rewrites to split */\n\t\topts->flags &= ~GIT_DIFF_FIND_RENAMES_FROM_REWRITES;\n\t}\n\n\tif (opts->flags & GIT_DIFF_FIND_RENAMES_FROM_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\tif (opts->flags & GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED)\n\t\topts->flags |= GIT_DIFF_FIND_COPIES;\n\n\tif (opts->flags & GIT_DIFF_BREAK_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_REWRITES;\n\n#define USE_DEFAULT(X) ((X) == 0 || (X) > 100)\n\n\tif (USE_DEFAULT(opts->rename_threshold))\n\t\topts->rename_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->rename_from_rewrite_threshold))\n\t\topts->rename_from_rewrite_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->copy_threshold))\n\t\topts->copy_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->break_rewrite_threshold))\n\t\topts->break_rewrite_threshold = DEFAULT_BREAK_REWRITE_THRESHOLD;\n\n#undef USE_DEFAULT\n\n\tif (!opts->rename_limit) {\n\t\tif (cfg) {\n\t\t\topts->rename_limit = git_config__get_int_force(\n\t\t\t\tcfg, \"diff.renamelimit\", DEFAULT_RENAME_LIMIT);\n\t\t}\n\n\t\tif (opts->rename_limit <= 0)\n\t\t\topts->rename_limit = DEFAULT_RENAME_LIMIT;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\n\t\tif (opts->flags & GIT_DIFF_FIND_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_IGNORE_WHITESPACE;\n\t\telse if (opts->flags & GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_NORMAL;\n\t\telse\n\t\t\thashsig_opts = GIT_HASHSIG_SMART_WHITESPACE;\n\t\thashsig_opts |= GIT_HASHSIG_ALLOW_SMALL_FILES;\n\t\topts->metric->payload = (void *)hashsig_opts;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define DEFAULT_RENAME_LIMIT 200",
            "#define DEFAULT_BREAK_REWRITE_THRESHOLD 60",
            "#define DEFAULT_THRESHOLD 50"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define DEFAULT_RENAME_LIMIT 200\n#define DEFAULT_BREAK_REWRITE_THRESHOLD 60\n#define DEFAULT_THRESHOLD 50\n\nstatic int normalize_find_opts(\n\tgit_diff *diff,\n\tgit_diff_find_options *opts,\n\tconst git_diff_find_options *given)\n{\n\tgit_config *cfg = NULL;\n\tgit_hashsig_option_t hashsig_opts;\n\n\tGITERR_CHECK_VERSION(given, GIT_DIFF_FIND_OPTIONS_VERSION, \"git_diff_find_options\");\n\n\tif (diff->repo != NULL &&\n\t\tgit_repository_config__weakptr(&cfg, diff->repo) < 0)\n\t\treturn -1;\n\n\tif (given)\n\t\tmemcpy(opts, given, sizeof(*opts));\n\n\tif (!given ||\n\t\t (given->flags & GIT_DIFF_FIND_ALL) == GIT_DIFF_FIND_BY_CONFIG)\n\t{\n\t\tif (cfg) {\n\t\t\tchar *rule =\n\t\t\t\tgit_config__get_string_force(cfg, \"diff.renames\", \"true\");\n\t\t\tint boolval;\n\n\t\t\tif (!git__parse_bool(&boolval, rule) && !boolval)\n\t\t\t\t/* don't set FIND_RENAMES if bool value is false */;\n\t\t\telse if (!strcasecmp(rule, \"copies\") || !strcasecmp(rule, \"copy\"))\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES | GIT_DIFF_FIND_COPIES;\n\t\t\telse\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\t\t\tgit__free(rule);\n\t\t} else {\n\t\t\t/* set default flag */\n\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\t\t}\n\t}\n\n\t/* some flags imply others */\n\n\tif (opts->flags & GIT_DIFF_FIND_EXACT_MATCH_ONLY) {\n\t\t/* if we are only looking for exact matches, then don't turn\n\t\t * MODIFIED items into ADD/DELETE pairs because it's too picky\n\t\t */\n\t\topts->flags &= ~(GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES);\n\n\t\t/* similarly, don't look for self-rewrites to split */\n\t\topts->flags &= ~GIT_DIFF_FIND_RENAMES_FROM_REWRITES;\n\t}\n\n\tif (opts->flags & GIT_DIFF_FIND_RENAMES_FROM_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\tif (opts->flags & GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED)\n\t\topts->flags |= GIT_DIFF_FIND_COPIES;\n\n\tif (opts->flags & GIT_DIFF_BREAK_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_REWRITES;\n\n#define USE_DEFAULT(X) ((X) == 0 || (X) > 100)\n\n\tif (USE_DEFAULT(opts->rename_threshold))\n\t\topts->rename_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->rename_from_rewrite_threshold))\n\t\topts->rename_from_rewrite_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->copy_threshold))\n\t\topts->copy_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->break_rewrite_threshold))\n\t\topts->break_rewrite_threshold = DEFAULT_BREAK_REWRITE_THRESHOLD;\n\n#undef USE_DEFAULT\n\n\tif (!opts->rename_limit) {\n\t\tif (cfg) {\n\t\t\topts->rename_limit = git_config__get_int_force(\n\t\t\t\tcfg, \"diff.renamelimit\", DEFAULT_RENAME_LIMIT);\n\t\t}\n\n\t\tif (opts->rename_limit <= 0)\n\t\t\topts->rename_limit = DEFAULT_RENAME_LIMIT;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\n\t\tif (opts->flags & GIT_DIFF_FIND_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_IGNORE_WHITESPACE;\n\t\telse if (opts->flags & GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_NORMAL;\n\t\telse\n\t\t\thashsig_opts = GIT_HASHSIG_SMART_WHITESPACE;\n\t\thashsig_opts |= GIT_HASHSIG_ALLOW_SMALL_FILES;\n\t\topts->metric->payload = (void *)hashsig_opts;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}"
  },
  {
    "function_name": "delta_make_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "780-788",
    "snippet": "GIT_INLINE(void) delta_make_rename(\n\tgit_diff_delta *to, const git_diff_delta *from, uint16_t similarity)\n{\n\tto->status     = GIT_DELTA_RENAMED;\n\tto->similarity = similarity;\n\tto->nfiles     = 2;\n\tmemcpy(&to->old_file, &from->old_file, sizeof(to->old_file));\n\tto->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&to->old_file",
            "&from->old_file",
            "sizeof(to->old_file)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) delta_make_rename(\n\tgit_diff_delta *to, const git_diff_delta *from, uint16_t similarity)\n{\n\tto->status     = GIT_DELTA_RENAMED;\n\tto->similarity = similarity;\n\tto->nfiles     = 2;\n\tmemcpy(&to->old_file, &from->old_file, sizeof(to->old_file));\n\tto->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n}"
  },
  {
    "function_name": "delta_is_new_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "772-778",
    "snippet": "GIT_INLINE(bool) delta_is_new_only(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_UNTRACKED ||\n\t\t\tdelta->status == GIT_DELTA_UNREADABLE ||\n\t\t\tdelta->status == GIT_DELTA_IGNORED);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) delta_is_new_only(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_ADDED ||\n\t\t\tdelta->status == GIT_DELTA_UNTRACKED ||\n\t\t\tdelta->status == GIT_DELTA_UNREADABLE ||\n\t\t\tdelta->status == GIT_DELTA_IGNORED);\n}"
  },
  {
    "function_name": "delta_is_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "766-770",
    "snippet": "GIT_INLINE(bool) delta_is_split(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_TYPECHANGE ||\n\t\t\t(delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) delta_is_split(git_diff_delta *delta)\n{\n\treturn (delta->status == GIT_DELTA_TYPECHANGE ||\n\t\t\t(delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0);\n}"
  },
  {
    "function_name": "is_rename_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "705-764",
    "snippet": "static bool is_rename_source(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't blobs */\n\tif (!GIT_MODE_ISBLOB(delta->old_file.mode))\n\t\treturn false;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_UNTRACKED:\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tbreak;\n\n\tcase GIT_DELTA_UNMODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED))\n\t\t\treturn false;\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_REMOVE_UNMODIFIED))\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\tbreak;\n\n\tdefault: /* MODIFIED, RENAMED, COPIED */\n\t\t/* if we're finding copies, this could be a source */\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_COPIES))\n\t\t\tbreak;\n\n\t\t/* otherwise, this is only a source if we can split it */\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_SOURCE;\n\treturn true;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_RENAMES_FROM_REWRITES"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_BREAK_REWRITES"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_self_similarity",
          "args": [
            "diff",
            "opts",
            "delta_idx",
            "cache"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "calc_self_similarity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "626-649",
          "snippet": "static int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_RENAMES_FROM_REWRITES"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_REWRITES"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_COPIES"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_REMOVE_UNMODIFIED"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_ISBLOB",
          "args": [
            "delta->old_file.mode"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&diff->deltas",
            "delta_idx"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic bool is_rename_source(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't blobs */\n\tif (!GIT_MODE_ISBLOB(delta->old_file.mode))\n\t\treturn false;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_UNTRACKED:\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tbreak;\n\n\tcase GIT_DELTA_UNMODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED))\n\t\t\treturn false;\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_REMOVE_UNMODIFIED))\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\tbreak;\n\n\tdefault: /* MODIFIED, RENAMED, COPIED */\n\t\t/* if we're finding copies, this could be a source */\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_COPIES))\n\t\t\tbreak;\n\n\t\t/* otherwise, this is only a source if we can split it */\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_SOURCE;\n\treturn true;\n}"
  },
  {
    "function_name": "is_rename_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "651-703",
    "snippet": "static bool is_rename_target(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't plain blobs */\n\tif (!GIT_MODE_ISBLOB(delta->new_file.mode))\n\t\treturn false;\n\n\t/* only consider ADDED, RENAMED, COPIED, and split MODIFIED as\n\t * targets; maybe include UNTRACKED if requested.\n\t */\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_FOR_UNTRACKED))\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault: /* all other status values should be checked */\n\t\tbreak;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_TARGET;\n\treturn true;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_FOR_UNTRACKED"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_RENAMES_FROM_REWRITES"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_BREAK_REWRITES"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_self_similarity",
          "args": [
            "diff",
            "opts",
            "delta_idx",
            "cache"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "calc_self_similarity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "626-649",
          "snippet": "static int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_RENAMES_FROM_REWRITES"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_REWRITES"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_ISBLOB",
          "args": [
            "delta->new_file.mode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&diff->deltas",
            "delta_idx"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic bool is_rename_target(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\t/* skip things that aren't plain blobs */\n\tif (!GIT_MODE_ISBLOB(delta->new_file.mode))\n\t\treturn false;\n\n\t/* only consider ADDED, RENAMED, COPIED, and split MODIFIED as\n\t * targets; maybe include UNTRACKED if requested.\n\t */\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\tcase GIT_DELTA_IGNORED:\n\tcase GIT_DELTA_CONFLICTED:\n\t\treturn false;\n\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_REWRITES) &&\n\t\t\t!FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES))\n\t\t\treturn false;\n\n\t\tif (calc_self_similarity(diff, opts, delta_idx, cache) < 0)\n\t\t\treturn false;\n\n\t\tif (FLAG_SET(opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\tdelta->similarity < opts->break_rewrite_threshold) {\n\t\t\tdelta->flags |= GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\tbreak;\n\t\t}\n\t\tif (FLAG_SET(opts, GIT_DIFF_FIND_RENAMES_FROM_REWRITES) &&\n\t\t\tdelta->similarity < opts->rename_from_rewrite_threshold)\n\t\t\tbreak;\n\n\t\treturn false;\n\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (!FLAG_SET(opts, GIT_DIFF_FIND_FOR_UNTRACKED))\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault: /* all other status values should be checked */\n\t\tbreak;\n\t}\n\n\tdelta->flags |= GIT_DIFF_FLAG__IS_RENAME_TARGET;\n\treturn true;\n}"
  },
  {
    "function_name": "calc_self_similarity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "626-649",
    "snippet": "static int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "similarity_measure",
          "args": [
            "&similarity",
            "diff",
            "opts",
            "cache",
            "2 * delta_idx",
            "2 * delta_idx + 1"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_measure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "539-624",
          "snippet": "static int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&diff->deltas",
            "delta_idx"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int calc_self_similarity(\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tsize_t delta_idx,\n\tvoid **cache)\n{\n\tint error, similarity = -1;\n\tgit_diff_delta *delta = GIT_VECTOR_GET(&diff->deltas, delta_idx);\n\n\tif ((delta->flags & GIT_DIFF_FLAG__HAS_SELF_SIMILARITY) != 0)\n\t\treturn 0;\n\n\terror = similarity_measure(\n\t\t&similarity, diff, opts, cache, 2 * delta_idx, 2 * delta_idx + 1);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (similarity >= 0) {\n\t\tdelta->similarity = (uint16_t)similarity;\n\t\tdelta->flags |= GIT_DIFF_FLAG__HAS_SELF_SIMILARITY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "similarity_measure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "539-624",
    "snippet": "static int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "similarity_unload",
          "args": [
            "&b_info"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "522-531",
          "snippet": "static void similarity_unload(similarity_info *info)\n{\n\tif (info->odb_obj)\n\t\tgit_odb_object_free(info->odb_obj);\n\n\tif (info->blob)\n\t\tgit_blob_free(info->blob);\n\telse\n\t\tgit_buf_free(&info->data);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic void similarity_unload(similarity_info *info)\n{\n\tif (info->odb_obj)\n\t\tgit_odb_object_free(info->odb_obj);\n\n\tif (info->blob)\n\t\tgit_blob_free(info->blob);\n\telse\n\t\tgit_buf_free(&info->data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opts->metric->similarity",
          "args": [
            "score",
            "cache[a_idx]",
            "cache[b_idx]",
            "opts->metric->payload"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "similarity_sig",
          "args": [
            "&b_info",
            "opts",
            "cache"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "468-520",
          "snippet": "static int similarity_sig(\n\tsimilarity_info *info,\n\tconst git_diff_find_options *opts,\n\tvoid **cache)\n{\n\tint error = 0;\n\tgit_diff_file *file = info->file;\n\n\tif (info->src == GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif ((error = git_buf_joinpath(\n\t\t\t&info->data, git_repository_workdir(info->repo), file->path)) < 0)\n\t\t\treturn error;\n\n\t\t/* if path is not a regular file, just skip this item */\n\t\tif (!git_path_isfile(info->data.ptr))\n\t\t\treturn 0;\n\n\t\t/* TODO: apply wd-to-odb filters to file data if necessary */\n\n\t\terror = opts->metric->file_signature(\n\t\t\t&cache[info->idx], info->file,\n\t\t\tinfo->data.ptr, opts->metric->payload);\n\t} else {\n\t\t/* if we didn't initially know the size, we might have an odb_obj\n\t\t * around from earlier, so convert that, otherwise load the blob now\n\t\t */\n\t\tif (info->odb_obj != NULL)\n\t\t\terror = git_object__from_odb_object(\n\t\t\t\t(git_object **)&info->blob, info->repo,\n\t\t\t\tinfo->odb_obj, GIT_OBJ_BLOB);\n\t\telse\n\t\t\terror = git_blob_lookup(&info->blob, info->repo, &file->id);\n\n\t\tif (error < 0) {\n\t\t\t/* if lookup fails, just skip this item in similarity calc */\n\t\t\tgiterr_clear();\n\t\t} else {\n\t\t\tsize_t sz;\n\n\t\t\t/* index size may not be actual blob size if filtered */\n\t\t\tif (file->size != git_blob_rawsize(info->blob))\n\t\t\t\tfile->size = git_blob_rawsize(info->blob);\n\n\t\t\tsz = (size_t)(git__is_sizet(file->size) ? file->size : -1);\n\n\t\t\terror = opts->metric->buffer_signature(\n\t\t\t\t&cache[info->idx], info->file,\n\t\t\t\tgit_blob_rawcontent(info->blob), sz, opts->metric->payload);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_sig(\n\tsimilarity_info *info,\n\tconst git_diff_find_options *opts,\n\tvoid **cache)\n{\n\tint error = 0;\n\tgit_diff_file *file = info->file;\n\n\tif (info->src == GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif ((error = git_buf_joinpath(\n\t\t\t&info->data, git_repository_workdir(info->repo), file->path)) < 0)\n\t\t\treturn error;\n\n\t\t/* if path is not a regular file, just skip this item */\n\t\tif (!git_path_isfile(info->data.ptr))\n\t\t\treturn 0;\n\n\t\t/* TODO: apply wd-to-odb filters to file data if necessary */\n\n\t\terror = opts->metric->file_signature(\n\t\t\t&cache[info->idx], info->file,\n\t\t\tinfo->data.ptr, opts->metric->payload);\n\t} else {\n\t\t/* if we didn't initially know the size, we might have an odb_obj\n\t\t * around from earlier, so convert that, otherwise load the blob now\n\t\t */\n\t\tif (info->odb_obj != NULL)\n\t\t\terror = git_object__from_odb_object(\n\t\t\t\t(git_object **)&info->blob, info->repo,\n\t\t\t\tinfo->odb_obj, GIT_OBJ_BLOB);\n\t\telse\n\t\t\terror = git_blob_lookup(&info->blob, info->repo, &file->id);\n\n\t\tif (error < 0) {\n\t\t\t/* if lookup fails, just skip this item in similarity calc */\n\t\t\tgiterr_clear();\n\t\t} else {\n\t\t\tsize_t sz;\n\n\t\t\t/* index size may not be actual blob size if filtered */\n\t\t\tif (file->size != git_blob_rawsize(info->blob))\n\t\t\t\tfile->size = git_blob_rawsize(info->blob);\n\n\t\t\tsz = (size_t)(git__is_sizet(file->size) ? file->size : -1);\n\n\t\t\terror = opts->metric->buffer_signature(\n\t\t\t\t&cache[info->idx], info->file,\n\t\t\t\tgit_blob_rawcontent(info->blob), sz, opts->metric->payload);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "similarity_init",
          "args": [
            "&b_info",
            "diff",
            "b_idx"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "450-466",
          "snippet": "static int similarity_init(\n\tsimilarity_info *info, git_diff *diff, size_t file_idx)\n{\n\tinfo->idx  = file_idx;\n\tinfo->src  = (file_idx & 1) ? diff->new_src : diff->old_src;\n\tinfo->repo = diff->repo;\n\tinfo->file = similarity_get_file(diff, file_idx);\n\tinfo->odb_obj = NULL;\n\tinfo->blob = NULL;\n\tgit_buf_init(&info->data, 0);\n\n\tif (info->file->size > 0 || info->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn 0;\n\n\treturn git_diff_file__resolve_zero_size(\n\t\tinfo->file, &info->odb_obj, info->repo);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_init(\n\tsimilarity_info *info, git_diff *diff, size_t file_idx)\n{\n\tinfo->idx  = file_idx;\n\tinfo->src  = (file_idx & 1) ? diff->new_src : diff->old_src;\n\tinfo->repo = diff->repo;\n\tinfo->file = similarity_get_file(diff, file_idx);\n\tinfo->odb_obj = NULL;\n\tinfo->blob = NULL;\n\tgit_buf_init(&info->data, 0);\n\n\tif (info->file->size > 0 || info->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn 0;\n\n\treturn git_diff_file__resolve_zero_size(\n\t\tinfo->file, &info->odb_obj, info->repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&b_info",
            "0",
            "sizeof(b_info)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&a_info",
            "0",
            "sizeof(a_info)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&a_file->id",
            "&b_file->id"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__oid_for_file",
          "args": [
            "&b_file->id",
            "diff",
            "b_file->path",
            "b_file->mode",
            "b_file->size"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__oid_for_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "589-604",
          "snippet": "int git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&b_file->id"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "b_file->mode"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "a_file->mode"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAG_SET",
          "args": [
            "opts",
            "GIT_DIFF_FIND_EXACT_MATCH_ONLY"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "similarity_get_file",
          "args": [
            "diff",
            "b_idx"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_get_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "434-438",
          "snippet": "GIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_measure(\n\tint *score,\n\tgit_diff *diff,\n\tconst git_diff_find_options *opts,\n\tvoid **cache,\n\tsize_t a_idx,\n\tsize_t b_idx)\n{\n\tgit_diff_file *a_file = similarity_get_file(diff, a_idx);\n\tgit_diff_file *b_file = similarity_get_file(diff, b_idx);\n\tbool exact_match = FLAG_SET(opts, GIT_DIFF_FIND_EXACT_MATCH_ONLY);\n\tint error = 0;\n\tsimilarity_info a_info, b_info;\n\n\t*score = -1;\n\n\t/* don't try to compare files of different types */\n\tif (GIT_MODE_TYPE(a_file->mode) != GIT_MODE_TYPE(b_file->mode))\n\t\treturn 0;\n\n\t/* if exact match is requested, force calculation of missing OIDs now */\n\tif (exact_match) {\n\t\tif (git_oid_iszero(&a_file->id) &&\n\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&a_file->id,\n\t\t\t\tdiff, a_file->path, a_file->mode, a_file->size))\n\t\t\ta_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\tif (git_oid_iszero(&b_file->id) &&\n\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t!git_diff__oid_for_file(&b_file->id,\n\t\t\t\tdiff, b_file->path, b_file->mode, b_file->size))\n\t\t\tb_file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\t/* check OID match as a quick test */\n\tif (git_oid__cmp(&a_file->id, &b_file->id) == 0) {\n\t\t*score = 100;\n\t\treturn 0;\n\t}\n\n\t/* don't calculate signatures if we are doing exact match */\n\tif (exact_match) {\n\t\t*score = 0;\n\t\treturn 0;\n\t}\n\n\tmemset(&a_info, 0, sizeof(a_info));\n\tmemset(&b_info, 0, sizeof(b_info));\n\n\t/* set up similarity data (will try to update missing file sizes) */\n\tif (!cache[a_idx] && (error = similarity_init(&a_info, diff, a_idx)) < 0)\n\t\treturn error;\n\tif (!cache[b_idx] && (error = similarity_init(&b_info, diff, b_idx)) < 0)\n\t\tgoto cleanup;\n\n\t/* check if file sizes are nowhere near each other */\n\tif (a_file->size > 127 &&\n\t\tb_file->size > 127 &&\n\t\t(a_file->size > (b_file->size << 3) ||\n\t\t b_file->size > (a_file->size << 3)))\n\t\tgoto cleanup;\n\n\t/* update signature cache if needed */\n\tif (!cache[a_idx]) {\n\t\tif ((error = similarity_sig(&a_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\tif (!cache[b_idx]) {\n\t\tif ((error = similarity_sig(&b_info, opts, cache)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* calculate similarity provided that the metric choose to process\n\t * both the a and b files (some may not if file is too big, etc).\n\t */\n\tif (cache[a_idx] && cache[b_idx])\n\t\terror = opts->metric->similarity(\n\t\t\tscore, cache[a_idx], cache[b_idx], opts->metric->payload);\n\ncleanup:\n\tsimilarity_unload(&a_info);\n\tsimilarity_unload(&b_info);\n\n\treturn error;\n}"
  },
  {
    "function_name": "similarity_unload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "522-531",
    "snippet": "static void similarity_unload(similarity_info *info)\n{\n\tif (info->odb_obj)\n\t\tgit_odb_object_free(info->odb_obj);\n\n\tif (info->blob)\n\t\tgit_blob_free(info->blob);\n\telse\n\t\tgit_buf_free(&info->data);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&info->data"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "info->blob"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "info->odb_obj"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic void similarity_unload(similarity_info *info)\n{\n\tif (info->odb_obj)\n\t\tgit_odb_object_free(info->odb_obj);\n\n\tif (info->blob)\n\t\tgit_blob_free(info->blob);\n\telse\n\t\tgit_buf_free(&info->data);\n}"
  },
  {
    "function_name": "similarity_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "468-520",
    "snippet": "static int similarity_sig(\n\tsimilarity_info *info,\n\tconst git_diff_find_options *opts,\n\tvoid **cache)\n{\n\tint error = 0;\n\tgit_diff_file *file = info->file;\n\n\tif (info->src == GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif ((error = git_buf_joinpath(\n\t\t\t&info->data, git_repository_workdir(info->repo), file->path)) < 0)\n\t\t\treturn error;\n\n\t\t/* if path is not a regular file, just skip this item */\n\t\tif (!git_path_isfile(info->data.ptr))\n\t\t\treturn 0;\n\n\t\t/* TODO: apply wd-to-odb filters to file data if necessary */\n\n\t\terror = opts->metric->file_signature(\n\t\t\t&cache[info->idx], info->file,\n\t\t\tinfo->data.ptr, opts->metric->payload);\n\t} else {\n\t\t/* if we didn't initially know the size, we might have an odb_obj\n\t\t * around from earlier, so convert that, otherwise load the blob now\n\t\t */\n\t\tif (info->odb_obj != NULL)\n\t\t\terror = git_object__from_odb_object(\n\t\t\t\t(git_object **)&info->blob, info->repo,\n\t\t\t\tinfo->odb_obj, GIT_OBJ_BLOB);\n\t\telse\n\t\t\terror = git_blob_lookup(&info->blob, info->repo, &file->id);\n\n\t\tif (error < 0) {\n\t\t\t/* if lookup fails, just skip this item in similarity calc */\n\t\t\tgiterr_clear();\n\t\t} else {\n\t\t\tsize_t sz;\n\n\t\t\t/* index size may not be actual blob size if filtered */\n\t\t\tif (file->size != git_blob_rawsize(info->blob))\n\t\t\t\tfile->size = git_blob_rawsize(info->blob);\n\n\t\t\tsz = (size_t)(git__is_sizet(file->size) ? file->size : -1);\n\n\t\t\terror = opts->metric->buffer_signature(\n\t\t\t\t&cache[info->idx], info->file,\n\t\t\t\tgit_blob_rawcontent(info->blob), sz, opts->metric->payload);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opts->metric->buffer_signature",
          "args": [
            "&cache[info->idx]",
            "info->file",
            "git_blob_rawcontent(info->blob)",
            "sz",
            "opts->metric->payload"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "info->blob"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "file->size"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "info->blob"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_lookup",
          "args": [
            "&info->blob",
            "info->repo",
            "&file->id"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "106-109",
          "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__from_odb_object",
          "args": [
            "(git_object **)&info->blob",
            "info->repo",
            "info->odb_obj",
            "GIT_OBJ_BLOB"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__from_odb_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "52-97",
          "snippet": "int git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opts->metric->file_signature",
          "args": [
            "&cache[info->idx]",
            "info->file",
            "info->data.ptr",
            "opts->metric->payload"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "info->data.ptr"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&info->data",
            "git_repository_workdir(info->repo)",
            "file->path"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "info->repo"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_sig(\n\tsimilarity_info *info,\n\tconst git_diff_find_options *opts,\n\tvoid **cache)\n{\n\tint error = 0;\n\tgit_diff_file *file = info->file;\n\n\tif (info->src == GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif ((error = git_buf_joinpath(\n\t\t\t&info->data, git_repository_workdir(info->repo), file->path)) < 0)\n\t\t\treturn error;\n\n\t\t/* if path is not a regular file, just skip this item */\n\t\tif (!git_path_isfile(info->data.ptr))\n\t\t\treturn 0;\n\n\t\t/* TODO: apply wd-to-odb filters to file data if necessary */\n\n\t\terror = opts->metric->file_signature(\n\t\t\t&cache[info->idx], info->file,\n\t\t\tinfo->data.ptr, opts->metric->payload);\n\t} else {\n\t\t/* if we didn't initially know the size, we might have an odb_obj\n\t\t * around from earlier, so convert that, otherwise load the blob now\n\t\t */\n\t\tif (info->odb_obj != NULL)\n\t\t\terror = git_object__from_odb_object(\n\t\t\t\t(git_object **)&info->blob, info->repo,\n\t\t\t\tinfo->odb_obj, GIT_OBJ_BLOB);\n\t\telse\n\t\t\terror = git_blob_lookup(&info->blob, info->repo, &file->id);\n\n\t\tif (error < 0) {\n\t\t\t/* if lookup fails, just skip this item in similarity calc */\n\t\t\tgiterr_clear();\n\t\t} else {\n\t\t\tsize_t sz;\n\n\t\t\t/* index size may not be actual blob size if filtered */\n\t\t\tif (file->size != git_blob_rawsize(info->blob))\n\t\t\t\tfile->size = git_blob_rawsize(info->blob);\n\n\t\t\tsz = (size_t)(git__is_sizet(file->size) ? file->size : -1);\n\n\t\t\terror = opts->metric->buffer_signature(\n\t\t\t\t&cache[info->idx], info->file,\n\t\t\t\tgit_blob_rawcontent(info->blob), sz, opts->metric->payload);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "similarity_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "450-466",
    "snippet": "static int similarity_init(\n\tsimilarity_info *info, git_diff *diff, size_t file_idx)\n{\n\tinfo->idx  = file_idx;\n\tinfo->src  = (file_idx & 1) ? diff->new_src : diff->old_src;\n\tinfo->repo = diff->repo;\n\tinfo->file = similarity_get_file(diff, file_idx);\n\tinfo->odb_obj = NULL;\n\tinfo->blob = NULL;\n\tgit_buf_init(&info->data, 0);\n\n\tif (info->file->size > 0 || info->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn 0;\n\n\treturn git_diff_file__resolve_zero_size(\n\t\tinfo->file, &info->odb_obj, info->repo);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_file__resolve_zero_size",
          "args": [
            "info->file",
            "&info->odb_obj",
            "info->repo"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_file__resolve_zero_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.h",
          "lines": "151-171",
          "snippet": "GIT_INLINE(int) git_diff_file__resolve_zero_size(\n\tgit_diff_file *file, git_odb_object **odb_obj, git_repository *repo)\n{\n\tint error;\n\tgit_odb *odb;\n\tsize_t len;\n\tgit_otype type;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\terror = git_odb__read_header_or_object(\n\t\todb_obj, &len, &type, odb, &file->id);\n\n\tgit_odb_free(odb);\n\n\tif (!error)\n\t\tfile->size = (git_off_t)len;\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include <stdio.h>",
            "#include \"git2/oid.h\"",
            "#include \"git2/sys/diff.h\"",
            "#include \"git2/diff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include <stdio.h>\n#include \"git2/oid.h\"\n#include \"git2/sys/diff.h\"\n#include \"git2/diff.h\"\n\nGIT_INLINE(int) git_diff_file__resolve_zero_size(\n\tgit_diff_file *file, git_odb_object **odb_obj, git_repository *repo)\n{\n\tint error;\n\tgit_odb *odb;\n\tsize_t len;\n\tgit_otype type;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\terror = git_odb__read_header_or_object(\n\t\todb_obj, &len, &type, odb, &file->id);\n\n\tgit_odb_free(odb);\n\n\tif (!error)\n\t\tfile->size = (git_off_t)len;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&info->data",
            "0"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "similarity_get_file",
          "args": [
            "diff",
            "file_idx"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "similarity_get_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "434-438",
          "snippet": "GIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int similarity_init(\n\tsimilarity_info *info, git_diff *diff, size_t file_idx)\n{\n\tinfo->idx  = file_idx;\n\tinfo->src  = (file_idx & 1) ? diff->new_src : diff->old_src;\n\tinfo->repo = diff->repo;\n\tinfo->file = similarity_get_file(diff, file_idx);\n\tinfo->odb_obj = NULL;\n\tinfo->blob = NULL;\n\tgit_buf_init(&info->data, 0);\n\n\tif (info->file->size > 0 || info->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn 0;\n\n\treturn git_diff_file__resolve_zero_size(\n\t\tinfo->file, &info->odb_obj, info->repo);\n}"
  },
  {
    "function_name": "similarity_get_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "434-438",
    "snippet": "GIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&diff->deltas",
            "idx / 2"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nGIT_INLINE(git_diff_file *) similarity_get_file(git_diff *diff, size_t idx)\n{\n\tgit_diff_delta *delta = git_vector_get(&diff->deltas, idx / 2);\n\treturn (idx & 1) ? &delta->new_file : &delta->old_file;\n}"
  },
  {
    "function_name": "apply_splits_and_deletes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "369-432",
    "snippet": "static int apply_splits_and_deletes(\n\tgit_diff *diff, size_t expected_size, bool actually_split)\n{\n\tgit_vector onto = GIT_VECTOR_INIT;\n\tsize_t i;\n\tgit_diff_delta *delta;\n\n\tif (git_vector_init(&onto, expected_size, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\t/* build new delta list without TO_DELETE and splitting TO_SPLIT */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tcontinue;\n\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0 && actually_split) {\n\t\t\tdelta->similarity = 0;\n\n\t\t\tif (insert_delete_side_of_split(diff, &onto, delta) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\t\t\tdelta->status = GIT_DELTA_UNTRACKED;\n\t\t\telse\n\t\t\t\tdelta->status = GIT_DELTA_ADDED;\n\t\t\tdelta->nfiles = 1;\n\t\t\tmemset(&delta->old_file, 0, sizeof(delta->old_file));\n\t\t\tdelta->old_file.path = delta->new_file.path;\n\t\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\t/* clean up delta before inserting into new list */\n\t\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\t\tif (delta->status != GIT_DELTA_COPIED &&\n\t\t\tdelta->status != GIT_DELTA_RENAMED &&\n\t\t\t(delta->status != GIT_DELTA_MODIFIED || actually_split))\n\t\t\tdelta->similarity = 0;\n\n\t\t/* insert into new list */\n\t\tif (git_vector_insert(&onto, delta) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* cannot return an error past this point */\n\n\t/* free deltas from old list that didn't make it to the new one */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tgit__free(delta);\n\t}\n\n\t/* swap new delta list into place */\n\tgit_vector_swap(&diff->deltas, &onto);\n\tgit_vector_free(&onto);\n\tgit_vector_sort(&diff->deltas);\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&onto);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&onto"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&diff->deltas"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_swap",
          "args": [
            "&diff->deltas",
            "&onto"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "305-316",
          "snippet": "void git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "i",
            "delta"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&onto",
            "delta"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_DIFF_FLAG__CLEAR_INTERNAL",
          "args": [
            "delta->flags"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&delta->old_file",
            "0",
            "sizeof(delta->old_file)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_delete_side_of_split",
          "args": [
            "diff",
            "&onto",
            "delta"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "insert_delete_side_of_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "353-367",
          "snippet": "static int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "i",
            "delta"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&onto",
            "expected_size",
            "git_diff_delta__cmp"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int apply_splits_and_deletes(\n\tgit_diff *diff, size_t expected_size, bool actually_split)\n{\n\tgit_vector onto = GIT_VECTOR_INIT;\n\tsize_t i;\n\tgit_diff_delta *delta;\n\n\tif (git_vector_init(&onto, expected_size, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\t/* build new delta list without TO_DELETE and splitting TO_SPLIT */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tcontinue;\n\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0 && actually_split) {\n\t\t\tdelta->similarity = 0;\n\n\t\t\tif (insert_delete_side_of_split(diff, &onto, delta) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tif (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\t\t\tdelta->status = GIT_DELTA_UNTRACKED;\n\t\t\telse\n\t\t\t\tdelta->status = GIT_DELTA_ADDED;\n\t\t\tdelta->nfiles = 1;\n\t\t\tmemset(&delta->old_file, 0, sizeof(delta->old_file));\n\t\t\tdelta->old_file.path = delta->new_file.path;\n\t\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\t/* clean up delta before inserting into new list */\n\t\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\t\tif (delta->status != GIT_DELTA_COPIED &&\n\t\t\tdelta->status != GIT_DELTA_RENAMED &&\n\t\t\t(delta->status != GIT_DELTA_MODIFIED || actually_split))\n\t\t\tdelta->similarity = 0;\n\n\t\t/* insert into new list */\n\t\tif (git_vector_insert(&onto, delta) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\t/* cannot return an error past this point */\n\n\t/* free deltas from old list that didn't make it to the new one */\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tif ((delta->flags & GIT_DIFF_FLAG__TO_DELETE) != 0)\n\t\t\tgit__free(delta);\n\t}\n\n\t/* swap new delta list into place */\n\tgit_vector_swap(&diff->deltas, &onto);\n\tgit_vector_free(&onto);\n\tgit_vector_sort(&diff->deltas);\n\n\treturn 0;\n\non_error:\n\tgit_vector_free_deep(&onto);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "insert_delete_side_of_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "353-367",
    "snippet": "static int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "onto",
            "deleted"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&deleted->new_file",
            "0",
            "sizeof(deleted->new_file)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "deleted"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff__delta_dup",
          "args": [
            "delta",
            "&diff->pool"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__delta_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "18-47",
          "snippet": "git_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int insert_delete_side_of_split(\n\tgit_diff *diff, git_vector *onto, const git_diff_delta *delta)\n{\n\t/* make new record for DELETED side of split */\n\tgit_diff_delta *deleted = git_diff__delta_dup(delta, &diff->pool);\n\tGITERR_CHECK_ALLOC(deleted);\n\n\tdeleted->status = GIT_DELTA_DELETED;\n\tdeleted->nfiles = 1;\n\tmemset(&deleted->new_file, 0, sizeof(deleted->new_file));\n\tdeleted->new_file.path = deleted->old_file.path;\n\tdeleted->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn git_vector_insert(onto, deleted);\n}"
  },
  {
    "function_name": "normalize_find_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "244-351",
    "snippet": "static int normalize_find_opts(\n\tgit_diff *diff,\n\tgit_diff_find_options *opts,\n\tconst git_diff_find_options *given)\n{\n\tgit_config *cfg = NULL;\n\tgit_hashsig_option_t hashsig_opts;\n\n\tGITERR_CHECK_VERSION(given, GIT_DIFF_FIND_OPTIONS_VERSION, \"git_diff_find_options\");\n\n\tif (diff->repo != NULL &&\n\t\tgit_repository_config__weakptr(&cfg, diff->repo) < 0)\n\t\treturn -1;\n\n\tif (given)\n\t\tmemcpy(opts, given, sizeof(*opts));\n\n\tif (!given ||\n\t\t (given->flags & GIT_DIFF_FIND_ALL) == GIT_DIFF_FIND_BY_CONFIG)\n\t{\n\t\tif (cfg) {\n\t\t\tchar *rule =\n\t\t\t\tgit_config__get_string_force(cfg, \"diff.renames\", \"true\");\n\t\t\tint boolval;\n\n\t\t\tif (!git__parse_bool(&boolval, rule) && !boolval)\n\t\t\t\t/* don't set FIND_RENAMES if bool value is false */;\n\t\t\telse if (!strcasecmp(rule, \"copies\") || !strcasecmp(rule, \"copy\"))\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES | GIT_DIFF_FIND_COPIES;\n\t\t\telse\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\t\t\tgit__free(rule);\n\t\t} else {\n\t\t\t/* set default flag */\n\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\t\t}\n\t}\n\n\t/* some flags imply others */\n\n\tif (opts->flags & GIT_DIFF_FIND_EXACT_MATCH_ONLY) {\n\t\t/* if we are only looking for exact matches, then don't turn\n\t\t * MODIFIED items into ADD/DELETE pairs because it's too picky\n\t\t */\n\t\topts->flags &= ~(GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES);\n\n\t\t/* similarly, don't look for self-rewrites to split */\n\t\topts->flags &= ~GIT_DIFF_FIND_RENAMES_FROM_REWRITES;\n\t}\n\n\tif (opts->flags & GIT_DIFF_FIND_RENAMES_FROM_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\tif (opts->flags & GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED)\n\t\topts->flags |= GIT_DIFF_FIND_COPIES;\n\n\tif (opts->flags & GIT_DIFF_BREAK_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_REWRITES;\n\n#define USE_DEFAULT(X) ((X) == 0 || (X) > 100)\n\n\tif (USE_DEFAULT(opts->rename_threshold))\n\t\topts->rename_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->rename_from_rewrite_threshold))\n\t\topts->rename_from_rewrite_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->copy_threshold))\n\t\topts->copy_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->break_rewrite_threshold))\n\t\topts->break_rewrite_threshold = DEFAULT_BREAK_REWRITE_THRESHOLD;\n\n#undef USE_DEFAULT\n\n\tif (!opts->rename_limit) {\n\t\tif (cfg) {\n\t\t\topts->rename_limit = git_config__get_int_force(\n\t\t\t\tcfg, \"diff.renamelimit\", DEFAULT_RENAME_LIMIT);\n\t\t}\n\n\t\tif (opts->rename_limit <= 0)\n\t\t\topts->rename_limit = DEFAULT_RENAME_LIMIT;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\n\t\tif (opts->flags & GIT_DIFF_FIND_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_IGNORE_WHITESPACE;\n\t\telse if (opts->flags & GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_NORMAL;\n\t\telse\n\t\t\thashsig_opts = GIT_HASHSIG_SMART_WHITESPACE;\n\t\thashsig_opts |= GIT_HASHSIG_ALLOW_SMALL_FILES;\n\t\topts->metric->payload = (void *)hashsig_opts;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define DEFAULT_RENAME_LIMIT 200",
      "#define DEFAULT_BREAK_REWRITE_THRESHOLD 60",
      "#define DEFAULT_THRESHOLD 50"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "opts->metric"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_diff_similarity_metric)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__get_int_force",
          "args": [
            "cfg",
            "\"diff.renamelimit\"",
            "DEFAULT_RENAME_LIMIT"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_int_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "905-918",
          "snippet": "int git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USE_DEFAULT",
          "args": [
            "opts->break_rewrite_threshold"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USE_DEFAULT",
          "args": [
            "opts->copy_threshold"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USE_DEFAULT",
          "args": [
            "opts->rename_from_rewrite_threshold"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USE_DEFAULT",
          "args": [
            "opts->rename_threshold"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "rule"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rule",
            "\"copy\""
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__parse_bool",
          "args": [
            "&boolval",
            "rule"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "git__parse_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "572-591",
          "snippet": "int git__parse_bool(int *out, const char *value)\n{\n\t/* A missing value means true */\n\tif (value == NULL ||\n\t\t!strcasecmp(value, \"true\") ||\n\t\t!strcasecmp(value, \"yes\") ||\n\t\t!strcasecmp(value, \"on\")) {\n\t\t*out = 1;\n\t\treturn 0;\n\t}\n\tif (!strcasecmp(value, \"false\") ||\n\t\t!strcasecmp(value, \"no\") ||\n\t\t!strcasecmp(value, \"off\") ||\n\t\tvalue[0] == '\\0') {\n\t\t*out = 0;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__parse_bool(int *out, const char *value)\n{\n\t/* A missing value means true */\n\tif (value == NULL ||\n\t\t!strcasecmp(value, \"true\") ||\n\t\t!strcasecmp(value, \"yes\") ||\n\t\t!strcasecmp(value, \"on\")) {\n\t\t*out = 1;\n\t\treturn 0;\n\t}\n\tif (!strcasecmp(value, \"false\") ||\n\t\t!strcasecmp(value, \"no\") ||\n\t\t!strcasecmp(value, \"off\") ||\n\t\tvalue[0] == '\\0') {\n\t\t*out = 0;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__get_string_force",
          "args": [
            "cfg",
            "\"diff.renames\"",
            "\"true\""
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_string_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "877-888",
          "snippet": "char *git_config__get_string_force(\n\tconst git_config *cfg, const char *key, const char *fallback_value)\n{\n\tgit_config_entry *entry;\n\tchar *ret;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\tret = (entry && entry->value) ? git__strdup(entry->value) : fallback_value ? git__strdup(fallback_value) : NULL;\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nchar *git_config__get_string_force(\n\tconst git_config *cfg, const char *key, const char *fallback_value)\n{\n\tgit_config_entry *entry;\n\tchar *ret;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\tret = (entry && entry->value) ? git__strdup(entry->value) : fallback_value ? git__strdup(fallback_value) : NULL;\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "given",
            "sizeof(*opts)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "diff->repo"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "given",
            "GIT_DIFF_FIND_OPTIONS_VERSION",
            "\"git_diff_find_options\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define DEFAULT_RENAME_LIMIT 200\n#define DEFAULT_BREAK_REWRITE_THRESHOLD 60\n#define DEFAULT_THRESHOLD 50\n\nstatic int normalize_find_opts(\n\tgit_diff *diff,\n\tgit_diff_find_options *opts,\n\tconst git_diff_find_options *given)\n{\n\tgit_config *cfg = NULL;\n\tgit_hashsig_option_t hashsig_opts;\n\n\tGITERR_CHECK_VERSION(given, GIT_DIFF_FIND_OPTIONS_VERSION, \"git_diff_find_options\");\n\n\tif (diff->repo != NULL &&\n\t\tgit_repository_config__weakptr(&cfg, diff->repo) < 0)\n\t\treturn -1;\n\n\tif (given)\n\t\tmemcpy(opts, given, sizeof(*opts));\n\n\tif (!given ||\n\t\t (given->flags & GIT_DIFF_FIND_ALL) == GIT_DIFF_FIND_BY_CONFIG)\n\t{\n\t\tif (cfg) {\n\t\t\tchar *rule =\n\t\t\t\tgit_config__get_string_force(cfg, \"diff.renames\", \"true\");\n\t\t\tint boolval;\n\n\t\t\tif (!git__parse_bool(&boolval, rule) && !boolval)\n\t\t\t\t/* don't set FIND_RENAMES if bool value is false */;\n\t\t\telse if (!strcasecmp(rule, \"copies\") || !strcasecmp(rule, \"copy\"))\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES | GIT_DIFF_FIND_COPIES;\n\t\t\telse\n\t\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\t\t\tgit__free(rule);\n\t\t} else {\n\t\t\t/* set default flag */\n\t\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\t\t}\n\t}\n\n\t/* some flags imply others */\n\n\tif (opts->flags & GIT_DIFF_FIND_EXACT_MATCH_ONLY) {\n\t\t/* if we are only looking for exact matches, then don't turn\n\t\t * MODIFIED items into ADD/DELETE pairs because it's too picky\n\t\t */\n\t\topts->flags &= ~(GIT_DIFF_FIND_REWRITES | GIT_DIFF_BREAK_REWRITES);\n\n\t\t/* similarly, don't look for self-rewrites to split */\n\t\topts->flags &= ~GIT_DIFF_FIND_RENAMES_FROM_REWRITES;\n\t}\n\n\tif (opts->flags & GIT_DIFF_FIND_RENAMES_FROM_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_RENAMES;\n\n\tif (opts->flags & GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED)\n\t\topts->flags |= GIT_DIFF_FIND_COPIES;\n\n\tif (opts->flags & GIT_DIFF_BREAK_REWRITES)\n\t\topts->flags |= GIT_DIFF_FIND_REWRITES;\n\n#define USE_DEFAULT(X) ((X) == 0 || (X) > 100)\n\n\tif (USE_DEFAULT(opts->rename_threshold))\n\t\topts->rename_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->rename_from_rewrite_threshold))\n\t\topts->rename_from_rewrite_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->copy_threshold))\n\t\topts->copy_threshold = DEFAULT_THRESHOLD;\n\n\tif (USE_DEFAULT(opts->break_rewrite_threshold))\n\t\topts->break_rewrite_threshold = DEFAULT_BREAK_REWRITE_THRESHOLD;\n\n#undef USE_DEFAULT\n\n\tif (!opts->rename_limit) {\n\t\tif (cfg) {\n\t\t\topts->rename_limit = git_config__get_int_force(\n\t\t\t\tcfg, \"diff.renamelimit\", DEFAULT_RENAME_LIMIT);\n\t\t}\n\n\t\tif (opts->rename_limit <= 0)\n\t\t\topts->rename_limit = DEFAULT_RENAME_LIMIT;\n\t}\n\n\t/* assign the internal metric with whitespace flag as payload */\n\tif (!opts->metric) {\n\t\topts->metric = git__malloc(sizeof(git_diff_similarity_metric));\n\t\tGITERR_CHECK_ALLOC(opts->metric);\n\n\t\topts->metric->file_signature = git_diff_find_similar__hashsig_for_file;\n\t\topts->metric->buffer_signature = git_diff_find_similar__hashsig_for_buf;\n\t\topts->metric->free_signature = git_diff_find_similar__hashsig_free;\n\t\topts->metric->similarity = git_diff_find_similar__calc_similarity;\n\n\t\tif (opts->flags & GIT_DIFF_FIND_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_IGNORE_WHITESPACE;\n\t\telse if (opts->flags & GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE)\n\t\t\thashsig_opts = GIT_HASHSIG_NORMAL;\n\t\telse\n\t\t\thashsig_opts = GIT_HASHSIG_SMART_WHITESPACE;\n\t\thashsig_opts |= GIT_HASHSIG_ALLOW_SMALL_FILES;\n\t\topts->metric->payload = (void *)hashsig_opts;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_find_similar__calc_similarity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "226-238",
    "snippet": "int git_diff_find_similar__calc_similarity(\n\tint *score, void *siga, void *sigb, void *payload)\n{\n\tint error;\n\n\tGIT_UNUSED(payload);\n\terror = git_hashsig_compare(siga, sigb);\n\tif (error < 0)\n\t\treturn error;\n\n\t*score = error;\n\treturn 0;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_compare",
          "args": [
            "siga",
            "sigb"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "337-359",
          "snippet": "int git_hashsig_compare(const git_hashsig *a, const git_hashsig *b)\n{\n\t/* if we have no elements in either file then each file is either\n\t * empty or blank.  if we're ignoring whitespace then the files are\n\t * similar, otherwise they're dissimilar.\n\t */\n\tif (a->mins.size == 0 && b->mins.size == 0) {\n\t\tif ((!a->lines && !b->lines) ||\n\t\t\t(a->opt & GIT_HASHSIG_IGNORE_WHITESPACE))\n\t\t\treturn HASHSIG_SCALE;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/* if we have fewer than the maximum number of elements, then just use\n\t * one array since the two arrays will be the same\n\t */\n\tif (a->mins.size < HASHSIG_HEAP_SIZE)\n\t\treturn hashsig_heap_compare(&a->mins, &b->mins);\n\telse\n\t\treturn (hashsig_heap_compare(&a->mins, &b->mins) +\n\t\t\t\thashsig_heap_compare(&a->maxs, &b->maxs)) / 2;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)",
            "#define HASHSIG_SCALE 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)\n#define HASHSIG_SCALE 100\n\nint git_hashsig_compare(const git_hashsig *a, const git_hashsig *b)\n{\n\t/* if we have no elements in either file then each file is either\n\t * empty or blank.  if we're ignoring whitespace then the files are\n\t * similar, otherwise they're dissimilar.\n\t */\n\tif (a->mins.size == 0 && b->mins.size == 0) {\n\t\tif ((!a->lines && !b->lines) ||\n\t\t\t(a->opt & GIT_HASHSIG_IGNORE_WHITESPACE))\n\t\t\treturn HASHSIG_SCALE;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/* if we have fewer than the maximum number of elements, then just use\n\t * one array since the two arrays will be the same\n\t */\n\tif (a->mins.size < HASHSIG_HEAP_SIZE)\n\t\treturn hashsig_heap_compare(&a->mins, &b->mins);\n\telse\n\t\treturn (hashsig_heap_compare(&a->mins, &b->mins) +\n\t\t\t\thashsig_heap_compare(&a->maxs, &b->maxs)) / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar__calc_similarity(\n\tint *score, void *siga, void *sigb, void *payload)\n{\n\tint error;\n\n\tGIT_UNUSED(payload);\n\terror = git_hashsig_compare(siga, sigb);\n\tif (error < 0)\n\t\treturn error;\n\n\t*score = error;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_find_similar__hashsig_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "220-224",
    "snippet": "void git_diff_find_similar__hashsig_free(void *sig, void *payload)\n{\n\tGIT_UNUSED(payload);\n\tgit_hashsig_free(sig);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_free",
          "args": [
            "sig"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "309-312",
          "snippet": "void git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nvoid git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nvoid git_diff_find_similar__hashsig_free(void *sig, void *payload)\n{\n\tGIT_UNUSED(payload);\n\tgit_hashsig_free(sig);\n}"
  },
  {
    "function_name": "git_diff_find_similar__hashsig_for_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "211-218",
    "snippet": "int git_diff_find_similar__hashsig_for_buf(\n\tvoid **out, const git_diff_file *f, const char *buf, size_t len, void *p)\n{\n\tgit_hashsig_option_t opt = (git_hashsig_option_t)(intptr_t)p;\n\n\tGIT_UNUSED(f);\n\treturn git_hashsig_create((git_hashsig **)out, buf, len, opt);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_create",
          "args": [
            "(git_hashsig **)out",
            "buf",
            "len",
            "opt"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "240-264",
          "snippet": "int git_hashsig_create(\n\tgit_hashsig **out,\n\tconst char *buf,\n\tsize_t buflen,\n\tgit_hashsig_option_t opts)\n{\n\tint error;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\thashsig_in_progress_init(&prog, sig);\n\n\terror = hashsig_add_hashes(sig, (const uint8_t *)buf, buflen, &prog);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nint git_hashsig_create(\n\tgit_hashsig **out,\n\tconst char *buf,\n\tsize_t buflen,\n\tgit_hashsig_option_t opts)\n{\n\tint error;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\thashsig_in_progress_init(&prog, sig);\n\n\terror = hashsig_add_hashes(sig, (const uint8_t *)buf, buflen, &prog);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "f"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar__hashsig_for_buf(\n\tvoid **out, const git_diff_file *f, const char *buf, size_t len, void *p)\n{\n\tgit_hashsig_option_t opt = (git_hashsig_option_t)(intptr_t)p;\n\n\tGIT_UNUSED(f);\n\treturn git_hashsig_create((git_hashsig **)out, buf, len, opt);\n}"
  },
  {
    "function_name": "git_diff_find_similar__hashsig_for_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "202-209",
    "snippet": "int git_diff_find_similar__hashsig_for_file(\n\tvoid **out, const git_diff_file *f, const char *path, void *p)\n{\n\tgit_hashsig_option_t opt = (git_hashsig_option_t)(intptr_t)p;\n\n\tGIT_UNUSED(f);\n\treturn git_hashsig_create_fromfile((git_hashsig **)out, path, opt);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_create_fromfile",
          "args": [
            "(git_hashsig **)out",
            "path",
            "opt"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_create_fromfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "266-307",
          "snippet": "int git_hashsig_create_fromfile(\n\tgit_hashsig **out,\n\tconst char *path,\n\tgit_hashsig_option_t opts)\n{\n\tuint8_t buf[0x1000];\n\tssize_t buflen = 0;\n\tint error = 0, fd;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit__free(sig);\n\t\treturn fd;\n\t}\n\n\thashsig_in_progress_init(&prog, sig);\n\n\twhile (!error) {\n\t\tif ((buflen = p_read(fd, buf, sizeof(buf))) <= 0) {\n\t\t\tif ((error = (int)buflen) < 0)\n\t\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\t\"Read error on '%s' calculating similarity hashes\", path);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hashsig_add_hashes(sig, buf, buflen, &prog);\n\t}\n\n\tp_close(fd);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nint git_hashsig_create_fromfile(\n\tgit_hashsig **out,\n\tconst char *path,\n\tgit_hashsig_option_t opts)\n{\n\tuint8_t buf[0x1000];\n\tssize_t buflen = 0;\n\tint error = 0, fd;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit__free(sig);\n\t\treturn fd;\n\t}\n\n\thashsig_in_progress_init(&prog, sig);\n\n\twhile (!error) {\n\t\tif ((buflen = p_read(fd, buf, sizeof(buf))) <= 0) {\n\t\t\tif ((error = (int)buflen) < 0)\n\t\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\t\"Read error on '%s' calculating similarity hashes\", path);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hashsig_add_hashes(sig, buf, buflen, &prog);\n\t}\n\n\tp_close(fd);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "f"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar__hashsig_for_file(\n\tvoid **out, const git_diff_file *f, const char *path, void *p)\n{\n\tgit_hashsig_option_t opt = (git_hashsig_option_t)(intptr_t)p;\n\n\tGIT_UNUSED(f);\n\treturn git_hashsig_create_fromfile((git_hashsig **)out, path, opt);\n}"
  },
  {
    "function_name": "git_diff_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "197-200",
    "snippet": "int git_diff_merge(git_diff *onto, const git_diff *from)\n{\n\treturn git_diff__merge(onto, from, git_diff__merge_like_cgit);\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff__merge",
          "args": [
            "onto",
            "from",
            "git_diff__merge_like_cgit"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "112-195",
          "snippet": "int git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_merge(git_diff *onto, const git_diff *from)\n{\n\treturn git_diff__merge(onto, from, git_diff__merge_like_cgit);\n}"
  },
  {
    "function_name": "git_diff__merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "112-195",
    "snippet": "int git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&onto_pool"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&onto_new"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strdup_safe",
          "args": [
            "&onto->pool",
            "onto->opts.new_prefix"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_swap",
          "args": [
            "&onto->pool",
            "&onto_pool"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "152-162",
          "snippet": "void git_pool_swap(git_pool *a, git_pool *b)\n{\n\tgit_pool temp;\n\n\tif (a == b)\n\t\treturn;\n\n\tmemcpy(&temp, a, sizeof(temp));\n\tmemcpy(a, b, sizeof(temp));\n\tmemcpy(b, &temp, sizeof(temp));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_swap(git_pool *a, git_pool *b)\n{\n\tgit_pool temp;\n\n\tif (a == b)\n\t\treturn;\n\n\tmemcpy(&temp, a, sizeof(temp));\n\tmemcpy(a, b, sizeof(temp));\n\tmemcpy(b, &temp, sizeof(temp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_swap",
          "args": [
            "&onto->deltas",
            "&onto_new"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "305-316",
          "snippet": "void git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&onto_new",
            "delta"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_delta__should_skip",
          "args": [
            "&onto->opts",
            "delta"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_delta__should_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "328-350",
          "snippet": "bool git_diff_delta__should_skip(\n\tconst git_diff_options *opts, const git_diff_delta *delta)\n{\n\tuint32_t flags = opts ? opts->flags : 0;\n\n\tif (delta->status == GIT_DELTA_UNMODIFIED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNMODIFIED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_IGNORED &&\n\t\t(flags & GIT_DIFF_INCLUDE_IGNORED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNTRACKED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNTRACKED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNREADABLE &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNREADABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nbool git_diff_delta__should_skip(\n\tconst git_diff_options *opts, const git_diff_delta *delta)\n{\n\tuint32_t flags = opts ? opts->flags : 0;\n\n\tif (delta->status == GIT_DELTA_UNMODIFIED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNMODIFIED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_IGNORED &&\n\t\t(flags & GIT_DIFF_INCLUDE_IGNORED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNTRACKED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNTRACKED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNREADABLE &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNREADABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "left",
            "right",
            "&onto_pool"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "447-454",
          "snippet": "static int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__delta_dup",
          "args": [
            "f",
            "&onto_pool"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__delta_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "18-47",
          "snippet": "git_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCMP_CASESELECT",
          "args": [
            "ignore_case",
            "o->old_file.path",
            "f->old_file.path"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&from->deltas",
            "j"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&onto->deltas",
            "i"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&onto_pool",
            "1"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&onto_new",
            "onto->deltas.length",
            "git_diff_delta__cmp"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Attempt to merge diffs created with conflicting options\""
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "onto && from"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff__merge(\n\tgit_diff *onto, const git_diff *from, git_diff__merge_cb cb)\n{\n\tint error = 0;\n\tgit_pool onto_pool;\n\tgit_vector onto_new;\n\tgit_diff_delta *delta;\n\tbool ignore_case, reversed;\n\tunsigned int i, j;\n\n\tassert(onto && from);\n\n\tif (!from->deltas.length)\n\t\treturn 0;\n\n\tignore_case = ((onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0);\n\treversed    = ((onto->opts.flags & GIT_DIFF_REVERSE) != 0);\n\n\tif (ignore_case != ((from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0) ||\n\t\treversed    != ((from->opts.flags & GIT_DIFF_REVERSE) != 0)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to merge diffs created with conflicting options\");\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&onto_new, onto->deltas.length, git_diff_delta__cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&onto_pool, 1);\n\n\tfor (i = 0, j = 0; i < onto->deltas.length || j < from->deltas.length; ) {\n\t\tgit_diff_delta *o = GIT_VECTOR_GET(&onto->deltas, i);\n\t\tconst git_diff_delta *f = GIT_VECTOR_GET(&from->deltas, j);\n\t\tint cmp = !f ? -1 : !o ? 1 :\n\t\t\tSTRCMP_CASESELECT(ignore_case, o->old_file.path, f->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\tdelta = git_diff__delta_dup(o, &onto_pool);\n\t\t\ti++;\n\t\t} else if (cmp > 0) {\n\t\t\tdelta = git_diff__delta_dup(f, &onto_pool);\n\t\t\tj++;\n\t\t} else {\n\t\t\tconst git_diff_delta *left = reversed ? f : o;\n\t\t\tconst git_diff_delta *right = reversed ? o : f;\n\n\t\t\tdelta = cb(left, right, &onto_pool);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* the ignore rules for the target may not match the source\n\t\t * or the result of a merged delta could be skippable...\n\t\t */\n\t\tif (delta && git_diff_delta__should_skip(&onto->opts, delta)) {\n\t\t\tgit__free(delta);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = !delta ? -1 : git_vector_insert(&onto_new, delta)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\n\t\tgit_vector_swap(&onto->deltas, &onto_new);\n\t\tgit_pool_swap(&onto->pool, &onto_pool);\n\n\t\tif ((onto->opts.flags & GIT_DIFF_REVERSE) != 0)\n\t\t\tonto->old_src = from->old_src;\n\t\telse\n\t\t\tonto->new_src = from->new_src;\n\n\t\t/* prefix strings also come from old pool, so recreate those.*/\n\t\tonto->opts.old_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.old_prefix);\n\t\tonto->opts.new_prefix =\n\t\t\tgit_pool_strdup_safe(&onto->pool, onto->opts.new_prefix);\n\t}\n\n\tgit_vector_free_deep(&onto_new);\n\tgit_pool_clear(&onto_pool);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__merge_like_cgit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "49-110",
    "snippet": "git_diff_delta *git_diff__merge_like_cgit(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\tgit_diff_delta *dup;\n\n\t/* Emulate C git for merging two diffs (a la 'git diff <sha>').\n\t *\n\t * When C git does a diff between the work dir and a tree, it actually\n\t * diffs with the index but uses the workdir contents.  This emulates\n\t * those choices so we can emulate the type of diff.\n\t *\n\t * We have three file descriptions here, let's call them:\n\t *  f1 = a->old_file\n\t *  f2 = a->new_file AND b->old_file\n\t *  f3 = b->new_file\n\t */\n\n\t/* If one of the diffs is a conflict, just dup it */\n\tif (b->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(b, pool);\n\tif (a->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* if f2 == f3 or f2 is deleted, then just dup the 'a' diff */\n\tif (b->status == GIT_DELTA_UNMODIFIED || a->status == GIT_DELTA_DELETED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* otherwise, base this diff on the 'b' diff */\n\tif ((dup = git_diff__delta_dup(b, pool)) == NULL)\n\t\treturn NULL;\n\n\t/* If 'a' status is uninteresting, then we're done */\n\tif (a->status == GIT_DELTA_UNMODIFIED ||\n\t\ta->status == GIT_DELTA_UNTRACKED ||\n\t\ta->status == GIT_DELTA_UNREADABLE)\n\t\treturn dup;\n\n\tassert(b->status != GIT_DELTA_UNMODIFIED);\n\n\t/* A cgit exception is that the diff of a file that is only in the\n\t * index (i.e. not in HEAD nor workdir) is given as empty.\n\t */\n\tif (dup->status == GIT_DELTA_DELETED) {\n\t\tif (a->status == GIT_DELTA_ADDED) {\n\t\t\tdup->status = GIT_DELTA_UNMODIFIED;\n\t\t\tdup->nfiles = 2;\n\t\t}\n\t\t/* else don't overwrite DELETE status */\n\t} else {\n\t\tdup->status = a->status;\n\t\tdup->nfiles = a->nfiles;\n\t}\n\n\tgit_oid_cpy(&dup->old_file.id, &a->old_file.id);\n\tdup->old_file.mode  = a->old_file.mode;\n\tdup->old_file.size  = a->old_file.size;\n\tdup->old_file.flags = a->old_file.flags;\n\n\treturn dup;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&dup->old_file.id",
            "&a->old_file.id"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "b->status != GIT_DELTA_UNMODIFIED"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff__delta_dup",
          "args": [
            "b",
            "pool"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__delta_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "18-47",
          "snippet": "git_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__merge_like_cgit(\n\tconst git_diff_delta *a,\n\tconst git_diff_delta *b,\n\tgit_pool *pool)\n{\n\tgit_diff_delta *dup;\n\n\t/* Emulate C git for merging two diffs (a la 'git diff <sha>').\n\t *\n\t * When C git does a diff between the work dir and a tree, it actually\n\t * diffs with the index but uses the workdir contents.  This emulates\n\t * those choices so we can emulate the type of diff.\n\t *\n\t * We have three file descriptions here, let's call them:\n\t *  f1 = a->old_file\n\t *  f2 = a->new_file AND b->old_file\n\t *  f3 = b->new_file\n\t */\n\n\t/* If one of the diffs is a conflict, just dup it */\n\tif (b->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(b, pool);\n\tif (a->status == GIT_DELTA_CONFLICTED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* if f2 == f3 or f2 is deleted, then just dup the 'a' diff */\n\tif (b->status == GIT_DELTA_UNMODIFIED || a->status == GIT_DELTA_DELETED)\n\t\treturn git_diff__delta_dup(a, pool);\n\n\t/* otherwise, base this diff on the 'b' diff */\n\tif ((dup = git_diff__delta_dup(b, pool)) == NULL)\n\t\treturn NULL;\n\n\t/* If 'a' status is uninteresting, then we're done */\n\tif (a->status == GIT_DELTA_UNMODIFIED ||\n\t\ta->status == GIT_DELTA_UNTRACKED ||\n\t\ta->status == GIT_DELTA_UNREADABLE)\n\t\treturn dup;\n\n\tassert(b->status != GIT_DELTA_UNMODIFIED);\n\n\t/* A cgit exception is that the diff of a file that is only in the\n\t * index (i.e. not in HEAD nor workdir) is given as empty.\n\t */\n\tif (dup->status == GIT_DELTA_DELETED) {\n\t\tif (a->status == GIT_DELTA_ADDED) {\n\t\t\tdup->status = GIT_DELTA_UNMODIFIED;\n\t\t\tdup->nfiles = 2;\n\t\t}\n\t\t/* else don't overwrite DELETE status */\n\t} else {\n\t\tdup->status = a->status;\n\t\tdup->nfiles = a->nfiles;\n\t}\n\n\tgit_oid_cpy(&dup->old_file.id, &a->old_file.id);\n\tdup->old_file.mode  = a->old_file.mode;\n\tdup->old_file.size  = a->old_file.size;\n\tdup->old_file.flags = a->old_file.flags;\n\n\treturn dup;\n}"
  },
  {
    "function_name": "git_diff__delta_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
    "lines": "18-47",
    "snippet": "git_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"path.h\"",
      "#include \"diff.h\"",
      "#include \"git2/sys/hashsig.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "pool",
            "d->new_file.path"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_DIFF_FLAG__CLEAR_INTERNAL",
          "args": [
            "delta->flags"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "delta",
            "d",
            "sizeof(git_diff_delta)"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_diff_delta)"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\ngit_diff_delta *git_diff__delta_dup(\n\tconst git_diff_delta *d, git_pool *pool)\n{\n\tgit_diff_delta *delta = git__malloc(sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tmemcpy(delta, d, sizeof(git_diff_delta));\n\tGIT_DIFF_FLAG__CLEAR_INTERNAL(delta->flags);\n\n\tif (d->old_file.path != NULL) {\n\t\tdelta->old_file.path = git_pool_strdup(pool, d->old_file.path);\n\t\tif (delta->old_file.path == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (d->new_file.path != d->old_file.path && d->new_file.path != NULL) {\n\t\tdelta->new_file.path = git_pool_strdup(pool, d->new_file.path);\n\t\tif (delta->new_file.path == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\tdelta->new_file.path = delta->old_file.path;\n\t}\n\n\treturn delta;\n\nfail:\n\tgit__free(delta);\n\treturn NULL;\n}"
  }
]