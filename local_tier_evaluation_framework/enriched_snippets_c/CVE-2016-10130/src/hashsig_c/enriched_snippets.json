[
  {
    "function_name": "git_hashsig_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "337-359",
    "snippet": "int git_hashsig_compare(const git_hashsig *a, const git_hashsig *b)\n{\n\t/* if we have no elements in either file then each file is either\n\t * empty or blank.  if we're ignoring whitespace then the files are\n\t * similar, otherwise they're dissimilar.\n\t */\n\tif (a->mins.size == 0 && b->mins.size == 0) {\n\t\tif ((!a->lines && !b->lines) ||\n\t\t\t(a->opt & GIT_HASHSIG_IGNORE_WHITESPACE))\n\t\t\treturn HASHSIG_SCALE;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/* if we have fewer than the maximum number of elements, then just use\n\t * one array since the two arrays will be the same\n\t */\n\tif (a->mins.size < HASHSIG_HEAP_SIZE)\n\t\treturn hashsig_heap_compare(&a->mins, &b->mins);\n\telse\n\t\treturn (hashsig_heap_compare(&a->mins, &b->mins) +\n\t\t\t\thashsig_heap_compare(&a->maxs, &b->maxs)) / 2;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [
      "#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)",
      "#define HASHSIG_SCALE 100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashsig_heap_compare",
          "args": [
            "&a->maxs",
            "&b->maxs"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "314-335",
          "snippet": "static int hashsig_heap_compare(const hashsig_heap *a, const hashsig_heap *b)\n{\n\tint matches = 0, i, j, cmp;\n\n\tassert(a->cmp == b->cmp);\n\n\t/* hash heaps are sorted - just look for overlap vs total */\n\n\tfor (i = 0, j = 0; i < a->size && j < b->size; ) {\n\t\tcmp = a->cmp(&a->values[i], &b->values[j], NULL);\n\n\t\tif (cmp < 0)\n\t\t\t++i;\n\t\telse if (cmp > 0)\n\t\t\t++j;\n\t\telse {\n\t\t\t++i; ++j; ++matches;\n\t\t}\n\t}\n\n\treturn HASHSIG_SCALE * (matches * 2) / (a->size + b->size);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_SCALE 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_SCALE 100\n\nstatic int hashsig_heap_compare(const hashsig_heap *a, const hashsig_heap *b)\n{\n\tint matches = 0, i, j, cmp;\n\n\tassert(a->cmp == b->cmp);\n\n\t/* hash heaps are sorted - just look for overlap vs total */\n\n\tfor (i = 0, j = 0; i < a->size && j < b->size; ) {\n\t\tcmp = a->cmp(&a->values[i], &b->values[j], NULL);\n\n\t\tif (cmp < 0)\n\t\t\t++i;\n\t\telse if (cmp > 0)\n\t\t\t++j;\n\t\telse {\n\t\t\t++i; ++j; ++matches;\n\t\t}\n\t}\n\n\treturn HASHSIG_SCALE * (matches * 2) / (a->size + b->size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)\n#define HASHSIG_SCALE 100\n\nint git_hashsig_compare(const git_hashsig *a, const git_hashsig *b)\n{\n\t/* if we have no elements in either file then each file is either\n\t * empty or blank.  if we're ignoring whitespace then the files are\n\t * similar, otherwise they're dissimilar.\n\t */\n\tif (a->mins.size == 0 && b->mins.size == 0) {\n\t\tif ((!a->lines && !b->lines) ||\n\t\t\t(a->opt & GIT_HASHSIG_IGNORE_WHITESPACE))\n\t\t\treturn HASHSIG_SCALE;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\t/* if we have fewer than the maximum number of elements, then just use\n\t * one array since the two arrays will be the same\n\t */\n\tif (a->mins.size < HASHSIG_HEAP_SIZE)\n\t\treturn hashsig_heap_compare(&a->mins, &b->mins);\n\telse\n\t\treturn (hashsig_heap_compare(&a->mins, &b->mins) +\n\t\t\t\thashsig_heap_compare(&a->maxs, &b->maxs)) / 2;\n}"
  },
  {
    "function_name": "hashsig_heap_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "314-335",
    "snippet": "static int hashsig_heap_compare(const hashsig_heap *a, const hashsig_heap *b)\n{\n\tint matches = 0, i, j, cmp;\n\n\tassert(a->cmp == b->cmp);\n\n\t/* hash heaps are sorted - just look for overlap vs total */\n\n\tfor (i = 0, j = 0; i < a->size && j < b->size; ) {\n\t\tcmp = a->cmp(&a->values[i], &b->values[j], NULL);\n\n\t\tif (cmp < 0)\n\t\t\t++i;\n\t\telse if (cmp > 0)\n\t\t\t++j;\n\t\telse {\n\t\t\t++i; ++j; ++matches;\n\t\t}\n\t}\n\n\treturn HASHSIG_SCALE * (matches * 2) / (a->size + b->size);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [
      "#define HASHSIG_SCALE 100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a->cmp",
          "args": [
            "&a->values[i]",
            "&b->values[j]",
            "NULL"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "a->cmp == b->cmp"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_SCALE 100\n\nstatic int hashsig_heap_compare(const hashsig_heap *a, const hashsig_heap *b)\n{\n\tint matches = 0, i, j, cmp;\n\n\tassert(a->cmp == b->cmp);\n\n\t/* hash heaps are sorted - just look for overlap vs total */\n\n\tfor (i = 0, j = 0; i < a->size && j < b->size; ) {\n\t\tcmp = a->cmp(&a->values[i], &b->values[j], NULL);\n\n\t\tif (cmp < 0)\n\t\t\t++i;\n\t\telse if (cmp > 0)\n\t\t\t++j;\n\t\telse {\n\t\t\t++i; ++j; ++matches;\n\t\t}\n\t}\n\n\treturn HASHSIG_SCALE * (matches * 2) / (a->size + b->size);\n}"
  },
  {
    "function_name": "git_hashsig_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "309-312",
    "snippet": "void git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sig"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nvoid git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}"
  },
  {
    "function_name": "git_hashsig_create_fromfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "266-307",
    "snippet": "int git_hashsig_create_fromfile(\n\tgit_hashsig **out,\n\tconst char *path,\n\tgit_hashsig_option_t opts)\n{\n\tuint8_t buf[0x1000];\n\tssize_t buflen = 0;\n\tint error = 0, fd;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit__free(sig);\n\t\treturn fd;\n\t}\n\n\thashsig_in_progress_init(&prog, sig);\n\n\twhile (!error) {\n\t\tif ((buflen = p_read(fd, buf, sizeof(buf))) <= 0) {\n\t\t\tif ((error = (int)buflen) < 0)\n\t\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\t\"Read error on '%s' calculating similarity hashes\", path);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hashsig_add_hashes(sig, buf, buflen, &prog);\n\t}\n\n\tp_close(fd);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_free",
          "args": [
            "sig"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "309-312",
          "snippet": "void git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nvoid git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_finalize_hashes",
          "args": [
            "sig"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_finalize_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "212-225",
          "snippet": "static int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HEAP_MIN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_MIN_SIZE 4\n\nstatic int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_add_hashes",
          "args": [
            "sig",
            "buf",
            "buflen",
            "&prog"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_add_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "155-210",
          "snippet": "static int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL",
            "#define HASHSIG_MAX_RUN 80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL\n#define HASHSIG_MAX_RUN 80\n\nstatic int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Read error on '%s' calculating similarity hashes\"",
            "path"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_in_progress_init",
          "args": [
            "&prog",
            "sig"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_in_progress_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "133-153",
          "snippet": "static void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sig"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "path"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sig"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashsig_alloc",
          "args": [
            "opts"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "227-238",
          "snippet": "static git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nint git_hashsig_create_fromfile(\n\tgit_hashsig **out,\n\tconst char *path,\n\tgit_hashsig_option_t opts)\n{\n\tuint8_t buf[0x1000];\n\tssize_t buflen = 0;\n\tint error = 0, fd;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit__free(sig);\n\t\treturn fd;\n\t}\n\n\thashsig_in_progress_init(&prog, sig);\n\n\twhile (!error) {\n\t\tif ((buflen = p_read(fd, buf, sizeof(buf))) <= 0) {\n\t\t\tif ((error = (int)buflen) < 0)\n\t\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\t\"Read error on '%s' calculating similarity hashes\", path);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hashsig_add_hashes(sig, buf, buflen, &prog);\n\t}\n\n\tp_close(fd);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_hashsig_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "240-264",
    "snippet": "int git_hashsig_create(\n\tgit_hashsig **out,\n\tconst char *buf,\n\tsize_t buflen,\n\tgit_hashsig_option_t opts)\n{\n\tint error;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\thashsig_in_progress_init(&prog, sig);\n\n\terror = hashsig_add_hashes(sig, (const uint8_t *)buf, buflen, &prog);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hashsig_free",
          "args": [
            "sig"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "git_hashsig_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "309-312",
          "snippet": "void git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nvoid git_hashsig_free(git_hashsig *sig)\n{\n\tgit__free(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_finalize_hashes",
          "args": [
            "sig"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_finalize_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "212-225",
          "snippet": "static int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HEAP_MIN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_MIN_SIZE 4\n\nstatic int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_add_hashes",
          "args": [
            "sig",
            "(const uint8_t *)buf",
            "buflen",
            "&prog"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_add_hashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "155-210",
          "snippet": "static int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL",
            "#define HASHSIG_MAX_RUN 80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL\n#define HASHSIG_MAX_RUN 80\n\nstatic int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashsig_in_progress_init",
          "args": [
            "&prog",
            "sig"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_in_progress_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "133-153",
          "snippet": "static void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sig"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashsig_alloc",
          "args": [
            "opts"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "227-238",
          "snippet": "static git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nint git_hashsig_create(\n\tgit_hashsig **out,\n\tconst char *buf,\n\tsize_t buflen,\n\tgit_hashsig_option_t opts)\n{\n\tint error;\n\thashsig_in_progress prog;\n\tgit_hashsig *sig = hashsig_alloc(opts);\n\tGITERR_CHECK_ALLOC(sig);\n\n\thashsig_in_progress_init(&prog, sig);\n\n\terror = hashsig_add_hashes(sig, (const uint8_t *)buf, buflen, &prog);\n\n\tif (!error)\n\t\terror = hashsig_finalize_hashes(sig);\n\n\tif (!error)\n\t\t*out = sig;\n\telse\n\t\tgit_hashsig_free(sig);\n\n\treturn error;\n}"
  },
  {
    "function_name": "hashsig_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "227-238",
    "snippet": "static git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashsig_heap_init",
          "args": [
            "&sig->maxs",
            "hashsig_cmp_max"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "45-50",
          "snippet": "static void hashsig_heap_init(hashsig_heap *h, hashsig_cmp cmp)\n{\n\th->size  = 0;\n\th->asize = HASHSIG_HEAP_SIZE;\n\th->cmp   = cmp;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [
            "#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)\n\nstatic void hashsig_heap_init(hashsig_heap *h, hashsig_cmp cmp)\n{\n\th->size  = 0;\n\th->asize = HASHSIG_HEAP_SIZE;\n\th->cmp   = cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_hashsig)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic git_hashsig *hashsig_alloc(git_hashsig_option_t opts)\n{\n\tgit_hashsig *sig = git__calloc(1, sizeof(git_hashsig));\n\tif (!sig)\n\t\treturn NULL;\n\n\thashsig_heap_init(&sig->mins, hashsig_cmp_min);\n\thashsig_heap_init(&sig->maxs, hashsig_cmp_max);\n\tsig->opt = opts;\n\n\treturn sig;\n}"
  },
  {
    "function_name": "hashsig_finalize_hashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "212-225",
    "snippet": "static int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [
      "#define HASHSIG_HEAP_MIN_SIZE 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashsig_heap_sort",
          "args": [
            "&sig->maxs"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "105-109",
          "snippet": "static void hashsig_heap_sort(hashsig_heap *h)\n{\n\t/* only need to do this at the end for signature comparison */\n\tgit__qsort_r(h->values, h->size, sizeof(hashsig_t), h->cmp, NULL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_sort(hashsig_heap *h)\n{\n\t/* only need to do this at the end for signature comparison */\n\tgit__qsort_r(h->values, h->size, sizeof(hashsig_t), h->cmp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"File too small for similarity signature calculation\""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_MIN_SIZE 4\n\nstatic int hashsig_finalize_hashes(git_hashsig *sig)\n{\n\tif (sig->mins.size < HASHSIG_HEAP_MIN_SIZE &&\n\t\t!(sig->opt & GIT_HASHSIG_ALLOW_SMALL_FILES)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"File too small for similarity signature calculation\");\n\t\treturn GIT_EBUFS;\n\t}\n\n\thashsig_heap_sort(&sig->mins);\n\thashsig_heap_sort(&sig->maxs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hashsig_add_hashes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "155-210",
    "snippet": "static int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [
      "#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL",
      "#define HASHSIG_MAX_RUN 80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashsig_heap_insert",
          "args": [
            "&sig->maxs",
            "(hashsig_t)state"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "111-126",
          "snippet": "static void hashsig_heap_insert(hashsig_heap *h, hashsig_t val)\n{\n\t/* if heap is not full, insert new element */\n\tif (h->size < h->asize) {\n\t\th->values[h->size++] = val;\n\t\thashsig_heap_up(h, h->size - 1);\n\t}\n\n\t/* if heap is full, pop top if new element should replace it */\n\telse if (h->cmp(&val, &h->values[0], NULL) > 0) {\n\t\th->size--;\n\t\th->values[0] = h->values[h->size];\n\t\thashsig_heap_down(h, 0);\n\t}\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_insert(hashsig_heap *h, hashsig_t val)\n{\n\t/* if heap is not full, insert new element */\n\tif (h->size < h->asize) {\n\t\th->values[h->size++] = val;\n\t\thashsig_heap_up(h, h->size - 1);\n\t}\n\n\t/* if heap is full, pop top if new element should replace it */\n\telse if (h->cmp(&val, &h->values[0], NULL) > 0) {\n\t\th->size--;\n\t\th->values[0] = h->values[h->size];\n\t\thashsig_heap_down(h, 0);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "HASHSIG_HASH_MIX",
          "args": [
            "state",
            "ch"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__isspace_nonlf",
          "args": [
            "ch"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HASH_START\t0x012345678ABCDEF0LL\n#define HASHSIG_MAX_RUN 80\n\nstatic int hashsig_add_hashes(\n\tgit_hashsig *sig,\n\tconst uint8_t *data,\n\tsize_t size,\n\thashsig_in_progress *prog)\n{\n\tconst uint8_t *scan = data, *end = data + size;\n\thashsig_state state = HASHSIG_HASH_START;\n\tint use_ignores = prog->use_ignores, len;\n\tuint8_t ch;\n\n\twhile (scan < end) {\n\t\tstate = HASHSIG_HASH_START;\n\n\t\tfor (len = 0; scan < end && len < HASHSIG_MAX_RUN; ) {\n\t\t\tch = *scan;\n\n\t\t\tif (use_ignores)\n\t\t\t\tfor (; scan < end && git__isspace_nonlf(ch); ch = *scan)\n\t\t\t\t\t++scan;\n\t\t\telse if (sig->opt &\n\t\t\t\t\t (GIT_HASHSIG_IGNORE_WHITESPACE | GIT_HASHSIG_SMART_WHITESPACE))\n\t\t\t\tfor (; scan < end && ch == '\\r'; ch = *scan)\n\t\t\t\t\t++scan;\n\n\t\t\t/* peek at next character to decide what to do next */\n\t\t\tif (sig->opt & GIT_HASHSIG_SMART_WHITESPACE)\n\t\t\t\tuse_ignores = (ch == '\\n');\n\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\t++scan;\n\n\t\t\t/* check run terminator */\n\t\t\tif (ch == '\\n' || ch == '\\0') {\n\t\t\t\tsig->lines++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++len;\n\t\t\tHASHSIG_HASH_MIX(state, ch);\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\thashsig_heap_insert(&sig->mins, (hashsig_t)state);\n\t\t\thashsig_heap_insert(&sig->maxs, (hashsig_t)state);\n\n\t\t\twhile (scan < end && (*scan == '\\n' || !*scan))\n\t\t\t\t++scan;\n\t\t}\n\t}\n\n\tprog->use_ignores = use_ignores;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hashsig_in_progress_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "133-153",
    "snippet": "static void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "prog",
            "0",
            "sizeof(*prog)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "i"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_in_progress_init(\n\thashsig_in_progress *prog, git_hashsig *sig)\n{\n\tint i;\n\n\t/* no more than one can be set */\n\tassert(!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) ||\n\t\t   !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE));\n\n\tif (sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace_nonlf(i);\n\t\tprog->use_ignores = 1;\n\t} else if (sig->opt & GIT_HASHSIG_SMART_WHITESPACE) {\n\t\tfor (i = 0; i < 256; ++i)\n\t\t\tprog->ignore_ch[i] = git__isspace(i);\n\t\tprog->use_ignores = 1;\n\t} else {\n\t\tmemset(prog, 0, sizeof(*prog));\n\t}\n}"
  },
  {
    "function_name": "hashsig_heap_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "111-126",
    "snippet": "static void hashsig_heap_insert(hashsig_heap *h, hashsig_t val)\n{\n\t/* if heap is not full, insert new element */\n\tif (h->size < h->asize) {\n\t\th->values[h->size++] = val;\n\t\thashsig_heap_up(h, h->size - 1);\n\t}\n\n\t/* if heap is full, pop top if new element should replace it */\n\telse if (h->cmp(&val, &h->values[0], NULL) > 0) {\n\t\th->size--;\n\t\th->values[0] = h->values[h->size];\n\t\thashsig_heap_down(h, 0);\n\t}\n\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashsig_heap_down",
          "args": [
            "h",
            "0"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "80-103",
          "snippet": "static void hashsig_heap_down(hashsig_heap *h, int el)\n{\n\thashsig_t v, lv, rv;\n\n\t/* 'el < h->size / 2' tests if el is bottom row of heap */\n\n\twhile (el < h->size / 2) {\n\t\tint lel = HEAP_LCHILD_OF(el), rel = HEAP_RCHILD_OF(el), swapel;\n\n\t\tv  = h->values[el];\n\t\tlv = h->values[lel];\n\t\trv = h->values[rel];\n\n\t\tif (h->cmp(&v, &lv, NULL) < 0 && h->cmp(&v, &rv, NULL) < 0)\n\t\t\tbreak;\n\n\t\tswapel = (h->cmp(&lv, &rv, NULL) < 0) ? lel : rel;\n\n\t\th->values[el] = h->values[swapel];\n\t\th->values[swapel] = v;\n\n\t\tel = swapel;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_down(hashsig_heap *h, int el)\n{\n\thashsig_t v, lv, rv;\n\n\t/* 'el < h->size / 2' tests if el is bottom row of heap */\n\n\twhile (el < h->size / 2) {\n\t\tint lel = HEAP_LCHILD_OF(el), rel = HEAP_RCHILD_OF(el), swapel;\n\n\t\tv  = h->values[el];\n\t\tlv = h->values[lel];\n\t\trv = h->values[rel];\n\n\t\tif (h->cmp(&v, &lv, NULL) < 0 && h->cmp(&v, &rv, NULL) < 0)\n\t\t\tbreak;\n\n\t\tswapel = (h->cmp(&lv, &rv, NULL) < 0) ? lel : rel;\n\n\t\th->values[el] = h->values[swapel];\n\t\th->values[swapel] = v;\n\n\t\tel = swapel;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->cmp",
          "args": [
            "&val",
            "&h->values[0]",
            "NULL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashsig_heap_up",
          "args": [
            "h",
            "h->size - 1"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "hashsig_heap_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
          "lines": "66-78",
          "snippet": "static void hashsig_heap_up(hashsig_heap *h, int el)\n{\n\tint parent_el = HEAP_PARENT_OF(el);\n\n\twhile (el > 0 && h->cmp(&h->values[parent_el], &h->values[el], NULL) > 0) {\n\t\thashsig_t t = h->values[el];\n\t\th->values[el] = h->values[parent_el];\n\t\th->values[parent_el] = t;\n\n\t\tel = parent_el;\n\t\tparent_el = HEAP_PARENT_OF(el);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/hashsig.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_up(hashsig_heap *h, int el)\n{\n\tint parent_el = HEAP_PARENT_OF(el);\n\n\twhile (el > 0 && h->cmp(&h->values[parent_el], &h->values[el], NULL) > 0) {\n\t\thashsig_t t = h->values[el];\n\t\th->values[el] = h->values[parent_el];\n\t\th->values[parent_el] = t;\n\n\t\tel = parent_el;\n\t\tparent_el = HEAP_PARENT_OF(el);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_insert(hashsig_heap *h, hashsig_t val)\n{\n\t/* if heap is not full, insert new element */\n\tif (h->size < h->asize) {\n\t\th->values[h->size++] = val;\n\t\thashsig_heap_up(h, h->size - 1);\n\t}\n\n\t/* if heap is full, pop top if new element should replace it */\n\telse if (h->cmp(&val, &h->values[0], NULL) > 0) {\n\t\th->size--;\n\t\th->values[0] = h->values[h->size];\n\t\thashsig_heap_down(h, 0);\n\t}\n\n}"
  },
  {
    "function_name": "hashsig_heap_sort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "105-109",
    "snippet": "static void hashsig_heap_sort(hashsig_heap *h)\n{\n\t/* only need to do this at the end for signature comparison */\n\tgit__qsort_r(h->values, h->size, sizeof(hashsig_t), h->cmp, NULL);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__qsort_r",
          "args": [
            "h->values",
            "h->size",
            "sizeof(hashsig_t)",
            "h->cmp",
            "NULL"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git__qsort_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "628-642",
          "snippet": "void git__qsort_r(\n\tvoid *els, size_t nel, size_t elsize, git__sort_r_cmp cmp, void *payload)\n{\n#if defined(HAVE_QSORT_R) && defined(BSD)\n\tgit__qsort_r_glue glue = { cmp, payload };\n\tqsort_r(els, nel, elsize, &glue, git__qsort_r_glue_cmp);\n#elif defined(HAVE_QSORT_R) && defined(__GLIBC__)\n\tqsort_r(els, nel, elsize, cmp, payload);\n#elif defined(HAVE_QSORT_S)\n\tgit__qsort_r_glue glue = { cmp, payload };\n\tqsort_s(els, nel, elsize, git__qsort_r_glue_cmp, &glue);\n#else\n\tgit__insertsort_r(els, nel, elsize, NULL, cmp, payload);\n#endif\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git__qsort_r(\n\tvoid *els, size_t nel, size_t elsize, git__sort_r_cmp cmp, void *payload)\n{\n#if defined(HAVE_QSORT_R) && defined(BSD)\n\tgit__qsort_r_glue glue = { cmp, payload };\n\tqsort_r(els, nel, elsize, &glue, git__qsort_r_glue_cmp);\n#elif defined(HAVE_QSORT_R) && defined(__GLIBC__)\n\tqsort_r(els, nel, elsize, cmp, payload);\n#elif defined(HAVE_QSORT_S)\n\tgit__qsort_r_glue glue = { cmp, payload };\n\tqsort_s(els, nel, elsize, git__qsort_r_glue_cmp, &glue);\n#else\n\tgit__insertsort_r(els, nel, elsize, NULL, cmp, payload);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_sort(hashsig_heap *h)\n{\n\t/* only need to do this at the end for signature comparison */\n\tgit__qsort_r(h->values, h->size, sizeof(hashsig_t), h->cmp, NULL);\n}"
  },
  {
    "function_name": "hashsig_heap_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "80-103",
    "snippet": "static void hashsig_heap_down(hashsig_heap *h, int el)\n{\n\thashsig_t v, lv, rv;\n\n\t/* 'el < h->size / 2' tests if el is bottom row of heap */\n\n\twhile (el < h->size / 2) {\n\t\tint lel = HEAP_LCHILD_OF(el), rel = HEAP_RCHILD_OF(el), swapel;\n\n\t\tv  = h->values[el];\n\t\tlv = h->values[lel];\n\t\trv = h->values[rel];\n\n\t\tif (h->cmp(&v, &lv, NULL) < 0 && h->cmp(&v, &rv, NULL) < 0)\n\t\t\tbreak;\n\n\t\tswapel = (h->cmp(&lv, &rv, NULL) < 0) ? lel : rel;\n\n\t\th->values[el] = h->values[swapel];\n\t\th->values[swapel] = v;\n\n\t\tel = swapel;\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "h->cmp",
          "args": [
            "&lv",
            "&rv",
            "NULL"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->cmp",
          "args": [
            "&v",
            "&rv",
            "NULL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->cmp",
          "args": [
            "&v",
            "&lv",
            "NULL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_RCHILD_OF",
          "args": [
            "el"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_LCHILD_OF",
          "args": [
            "el"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_down(hashsig_heap *h, int el)\n{\n\thashsig_t v, lv, rv;\n\n\t/* 'el < h->size / 2' tests if el is bottom row of heap */\n\n\twhile (el < h->size / 2) {\n\t\tint lel = HEAP_LCHILD_OF(el), rel = HEAP_RCHILD_OF(el), swapel;\n\n\t\tv  = h->values[el];\n\t\tlv = h->values[lel];\n\t\trv = h->values[rel];\n\n\t\tif (h->cmp(&v, &lv, NULL) < 0 && h->cmp(&v, &rv, NULL) < 0)\n\t\t\tbreak;\n\n\t\tswapel = (h->cmp(&lv, &rv, NULL) < 0) ? lel : rel;\n\n\t\th->values[el] = h->values[swapel];\n\t\th->values[swapel] = v;\n\n\t\tel = swapel;\n\t}\n}"
  },
  {
    "function_name": "hashsig_heap_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "66-78",
    "snippet": "static void hashsig_heap_up(hashsig_heap *h, int el)\n{\n\tint parent_el = HEAP_PARENT_OF(el);\n\n\twhile (el > 0 && h->cmp(&h->values[parent_el], &h->values[el], NULL) > 0) {\n\t\thashsig_t t = h->values[el];\n\t\th->values[el] = h->values[parent_el];\n\t\th->values[parent_el] = t;\n\n\t\tel = parent_el;\n\t\tparent_el = HEAP_PARENT_OF(el);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HEAP_PARENT_OF",
          "args": [
            "el"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->cmp",
          "args": [
            "&h->values[parent_el]",
            "&h->values[el]",
            "NULL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_PARENT_OF",
          "args": [
            "el"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic void hashsig_heap_up(hashsig_heap *h, int el)\n{\n\tint parent_el = HEAP_PARENT_OF(el);\n\n\twhile (el > 0 && h->cmp(&h->values[parent_el], &h->values[el], NULL) > 0) {\n\t\thashsig_t t = h->values[el];\n\t\th->values[el] = h->values[parent_el];\n\t\th->values[parent_el] = t;\n\n\t\tel = parent_el;\n\t\tparent_el = HEAP_PARENT_OF(el);\n\t}\n}"
  },
  {
    "function_name": "hashsig_cmp_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "59-64",
    "snippet": "static int hashsig_cmp_min(const void *a, const void *b, void *payload)\n{\n\thashsig_t av = *(const hashsig_t *)a, bv = *(const hashsig_t *)b;\n\tGIT_UNUSED(payload);\n\treturn (av > bv) ? -1 : (av < bv) ? 1 : 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic int hashsig_cmp_min(const void *a, const void *b, void *payload)\n{\n\thashsig_t av = *(const hashsig_t *)a, bv = *(const hashsig_t *)b;\n\tGIT_UNUSED(payload);\n\treturn (av > bv) ? -1 : (av < bv) ? 1 : 0;\n}"
  },
  {
    "function_name": "hashsig_cmp_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "52-57",
    "snippet": "static int hashsig_cmp_max(const void *a, const void *b, void *payload)\n{\n\thashsig_t av = *(const hashsig_t *)a, bv = *(const hashsig_t *)b;\n\tGIT_UNUSED(payload);\n\treturn (av < bv) ? -1 : (av > bv) ? 1 : 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\nstatic int hashsig_cmp_max(const void *a, const void *b, void *payload)\n{\n\thashsig_t av = *(const hashsig_t *)a, bv = *(const hashsig_t *)b;\n\tGIT_UNUSED(payload);\n\treturn (av < bv) ? -1 : (av > bv) ? 1 : 0;\n}"
  },
  {
    "function_name": "hashsig_heap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hashsig.c",
    "lines": "45-50",
    "snippet": "static void hashsig_heap_init(hashsig_heap *h, hashsig_cmp cmp)\n{\n\th->size  = 0;\n\th->asize = HASHSIG_HEAP_SIZE;\n\th->cmp   = cmp;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"fileops.h\"",
      "#include \"git2/sys/hashsig.h\""
    ],
    "macros_used": [
      "#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"fileops.h\"\n#include \"git2/sys/hashsig.h\"\n\n#define HASHSIG_HEAP_SIZE ((1 << 7) - 1)\n\nstatic void hashsig_heap_init(hashsig_heap *h, hashsig_cmp cmp)\n{\n\th->size  = 0;\n\th->asize = HASHSIG_HEAP_SIZE;\n\th->cmp   = cmp;\n}"
  }
]