[
  {
    "function_name": "git_smart__push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "1006-1092",
    "snippet": "int git_smart__push(git_transport *transport, git_push *push, const git_remote_callbacks *cbs)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tstruct push_packbuilder_payload packbuilder_payload = {0};\n\tgit_buf pktline = GIT_BUF_INIT;\n\tint error = 0, need_pack = 0;\n\tpush_spec *spec;\n\tunsigned int i;\n\n\tpackbuilder_payload.pb = push->pb;\n\n\tif (cbs && cbs->push_transfer_progress) {\n\t\tpackbuilder_payload.cb = cbs->push_transfer_progress;\n\t\tpackbuilder_payload.cb_payload = cbs->payload;\n\t}\n\n#ifdef PUSH_DEBUG\n{\n\tgit_remote_head *head;\n\tchar hex[GIT_OID_HEXSZ+1]; hex[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tgit_oid_fmt(hex, &head->oid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, head->name);\n\t}\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_oid_fmt(hex, &spec->roid);\n\t\tfprintf(stderr, \"%s (%s) -> \", hex, spec->lref);\n\t\tgit_oid_fmt(hex, &spec->loid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, spec->rref ?\n\t\t\tspec->rref : spec->lref);\n\t}\n}\n#endif\n\n\t/*\n\t * Figure out if we need to send a packfile; which is in all\n\t * cases except when we only send delete commands\n\t */\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0] != '\\0') {\n\t\t\tneed_pack = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((error = git_smart__get_push_stream(t, &packbuilder_payload.stream)) < 0 ||\n\t\t(error = gen_pktline(&pktline, push)) < 0 ||\n\t\t(error = packbuilder_payload.stream->write(packbuilder_payload.stream, git_buf_cstr(&pktline), git_buf_len(&pktline))) < 0)\n\t\tgoto done;\n\n\tif (need_pack &&\n\t\t(error = git_packbuilder_foreach(push->pb, &stream_thunk, &packbuilder_payload)) < 0)\n\t\tgoto done;\n\n\t/* If we sent nothing or the server doesn't support report-status, then\n\t * we consider the pack to have been unpacked successfully */\n\tif (!push->specs.length || !push->report_status)\n\t\tpush->unpack_ok = 1;\n\telse if ((error = parse_report(t, push)) < 0)\n\t\tgoto done;\n\n\t/* If progress is being reported write the final report */\n\tif (cbs && cbs->push_transfer_progress) {\n\t\terror = cbs->push_transfer_progress(\n\t\t\t\t\tpush->pb->nr_written,\n\t\t\t\t\tpush->pb->nr_objects,\n\t\t\t\t\tpackbuilder_payload.last_bytes,\n\t\t\t\t\tcbs->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (push->status.length) {\n\t\terror = update_refs_from_report(&t->refs, &push->specs, &push->status);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\terror = git_smart__update_heads(t, NULL);\n\t}\n\ndone:\n\tgit_buf_free(&pktline);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&pktline"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__update_heads",
          "args": [
            "t",
            "NULL"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__update_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "147-182",
          "snippet": "int git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__update_heads(transport_smart *t, git_vector *symrefs)\n{\n\tsize_t i;\n\tgit_pkt *pkt;\n\n\tgit_vector_clear(&t->heads);\n\tgit_vector_foreach(&t->refs, i, pkt) {\n\t\tgit_pkt_ref *ref = (git_pkt_ref *) pkt;\n\t\tif (pkt->type != GIT_PKT_REF)\n\t\t\tcontinue;\n\n\t\tif (symrefs) {\n\t\t\tgit_refspec *spec;\n\t\t\tgit_buf buf = GIT_BUF_INIT;\n\t\t\tsize_t j;\n\t\t\tint error = 0;\n\n\t\t\tgit_vector_foreach(symrefs, j, spec) {\n\t\t\t\tgit_buf_clear(&buf);\n\t\t\t\tif (git_refspec_src_matches(spec, ref->head.name) &&\n\t\t\t\t    !(error = git_refspec_transform(&buf, spec, ref->head.name)))\n\t\t\t\t\tref->head.symref_target = git_buf_detach(&buf);\n\t\t\t}\n\n\t\t\tgit_buf_free(&buf);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (git_vector_insert(&t->heads, &ref->head) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_refs_from_report",
          "args": [
            "&t->refs",
            "&push->specs",
            "&push->status"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "update_refs_from_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "889-973",
          "snippet": "static int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cbs->push_transfer_progress",
          "args": [
            "push->pb->nr_written",
            "push->pb->nr_objects",
            "packbuilder_payload.last_bytes",
            "cbs->payload"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_report",
          "args": [
            "t",
            "push"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "parse_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "786-869",
          "snippet": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packbuilder_foreach",
          "args": [
            "push->pb",
            "&stream_thunk",
            "&packbuilder_payload"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1333-1337",
          "snippet": "int git_packbuilder_foreach(git_packbuilder *pb, int (*cb)(void *buf, size_t size, void *payload), void *payload)\n{\n\tPREPARE_PACK;\n\treturn write_pack(pb, cb, payload);\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [
            "#define PREPARE_PACK if (prepare_pack(pb) < 0) { return -1; }"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\n#define PREPARE_PACK if (prepare_pack(pb) < 0) { return -1; }\n\nint git_packbuilder_foreach(git_packbuilder *pb, int (*cb)(void *buf, size_t size, void *payload), void *payload)\n{\n\tPREPARE_PACK;\n\treturn write_pack(pb, cb, payload);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packbuilder_payload.stream->write",
          "args": [
            "packbuilder_payload.stream",
            "git_buf_cstr(&pktline)",
            "git_buf_len(&pktline)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&pktline"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&pktline"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_pktline",
          "args": [
            "&pktline",
            "push"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "gen_pktline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "643-682",
          "snippet": "static int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__get_push_stream",
          "args": [
            "t",
            "&packbuilder_payload.stream"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__get_push_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "338-362",
          "snippet": "int git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **stream)\n{\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_PUSH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for push\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(stream, t->wrapped, t->url, GIT_SERVICE_RECEIVEPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == *stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = *stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__get_push_stream(transport_smart *t, git_smart_subtransport_stream **stream)\n{\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_PUSH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for push\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(stream, t->wrapped, t->url, GIT_SERVICE_RECEIVEPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == *stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = *stream;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s (%s)\\n\"",
            "hex",
            "spec->rref ?\n\t\t\tspec->rref : spec->lref"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "hex",
            "&spec->loid"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s (%s) -> \"",
            "hex",
            "spec->lref"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s (%s)\\n\"",
            "hex",
            "head->name"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->remote->refs",
            "i",
            "head"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__push(git_transport *transport, git_push *push, const git_remote_callbacks *cbs)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tstruct push_packbuilder_payload packbuilder_payload = {0};\n\tgit_buf pktline = GIT_BUF_INIT;\n\tint error = 0, need_pack = 0;\n\tpush_spec *spec;\n\tunsigned int i;\n\n\tpackbuilder_payload.pb = push->pb;\n\n\tif (cbs && cbs->push_transfer_progress) {\n\t\tpackbuilder_payload.cb = cbs->push_transfer_progress;\n\t\tpackbuilder_payload.cb_payload = cbs->payload;\n\t}\n\n#ifdef PUSH_DEBUG\n{\n\tgit_remote_head *head;\n\tchar hex[GIT_OID_HEXSZ+1]; hex[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->remote->refs, i, head) {\n\t\tgit_oid_fmt(hex, &head->oid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, head->name);\n\t}\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tgit_oid_fmt(hex, &spec->roid);\n\t\tfprintf(stderr, \"%s (%s) -> \", hex, spec->lref);\n\t\tgit_oid_fmt(hex, &spec->loid);\n\t\tfprintf(stderr, \"%s (%s)\\n\", hex, spec->rref ?\n\t\t\tspec->rref : spec->lref);\n\t}\n}\n#endif\n\n\t/*\n\t * Figure out if we need to send a packfile; which is in all\n\t * cases except when we only send delete commands\n\t */\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tif (spec->refspec.src && spec->refspec.src[0] != '\\0') {\n\t\t\tneed_pack = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((error = git_smart__get_push_stream(t, &packbuilder_payload.stream)) < 0 ||\n\t\t(error = gen_pktline(&pktline, push)) < 0 ||\n\t\t(error = packbuilder_payload.stream->write(packbuilder_payload.stream, git_buf_cstr(&pktline), git_buf_len(&pktline))) < 0)\n\t\tgoto done;\n\n\tif (need_pack &&\n\t\t(error = git_packbuilder_foreach(push->pb, &stream_thunk, &packbuilder_payload)) < 0)\n\t\tgoto done;\n\n\t/* If we sent nothing or the server doesn't support report-status, then\n\t * we consider the pack to have been unpacked successfully */\n\tif (!push->specs.length || !push->report_status)\n\t\tpush->unpack_ok = 1;\n\telse if ((error = parse_report(t, push)) < 0)\n\t\tgoto done;\n\n\t/* If progress is being reported write the final report */\n\tif (cbs && cbs->push_transfer_progress) {\n\t\terror = cbs->push_transfer_progress(\n\t\t\t\t\tpush->pb->nr_written,\n\t\t\t\t\tpush->pb->nr_objects,\n\t\t\t\t\tpackbuilder_payload.last_bytes,\n\t\t\t\t\tcbs->payload);\n\n\t\tif (error < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (push->status.length) {\n\t\terror = update_refs_from_report(&t->refs, &push->specs, &push->status);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t\terror = git_smart__update_heads(t, NULL);\n\t}\n\ndone:\n\tgit_buf_free(&pktline);\n\treturn error;\n}"
  },
  {
    "function_name": "stream_thunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "985-1004",
    "snippet": "static int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define MIN_PROGRESS_UPDATE_INTERVAL 0.5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "payload->cb",
          "args": [
            "payload->pb->nr_written",
            "payload->pb->nr_objects",
            "payload->last_bytes",
            "payload->cb_payload"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__timer",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "git__timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "588-601",
          "snippet": "GIT_INLINE(double) git__timer(void)\n{\n\tstruct timespec tp;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {\n\t\treturn (double) tp.tv_sec + (double) tp.tv_nsec / 1.0E9;\n\t} else {\n\t\t/* Fall back to using gettimeofday */\n\t\tstruct timeval tv;\n\t\tstruct timezone tz;\n\t\tgettimeofday(&tv, &tz);\n\t\treturn (double)tv.tv_sec + (double)tv.tv_usec / 1.0E6;\n\t}\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(double) git__timer(void)\n{\n\tstruct timespec tp;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {\n\t\treturn (double) tp.tv_sec + (double) tp.tv_nsec / 1.0E9;\n\t} else {\n\t\t/* Fall back to using gettimeofday */\n\t\tstruct timeval tv;\n\t\tstruct timezone tz;\n\t\tgettimeofday(&tv, &tz);\n\t\treturn (double)tv.tv_sec + (double)tv.tv_usec / 1.0E6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "payload->stream->write",
          "args": [
            "payload->stream",
            "(const char *)buf",
            "size"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\n#define MIN_PROGRESS_UPDATE_INTERVAL 0.5\n\nstatic int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "update_refs_from_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "889-973",
    "snippet": "static int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "refs"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "(git_pkt *)ref"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "refs",
            "i"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&ref->head.oid"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_rforeach",
          "args": [
            "refs",
            "i",
            "ref"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_ref_from_push_spec",
          "args": [
            "refs",
            "push_spec"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "add_ref_from_push_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "871-887",
          "snippet": "static int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "push_report",
            "i"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ref->head.oid",
            "&push_spec->loid"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "push_spec->refspec.dst",
            "ref->head.name"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"report-status: protocol error\""
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "push_specs",
            "i",
            "push_spec"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int update_refs_from_report(\n\tgit_vector *refs,\n\tgit_vector *push_specs,\n\tgit_vector *push_report)\n{\n\tgit_pkt_ref *ref;\n\tpush_spec *push_spec;\n\tpush_status *push_status;\n\tsize_t i, j, refs_len;\n\tint cmp;\n\n\t/* For each push spec we sent to the server, we should have\n\t * gotten back a status packet in the push report */\n\tif (push_specs->length != push_report->length) {\n\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\treturn -1;\n\t}\n\n\t/* We require that push_specs be sorted with push_spec_rref_cmp,\n\t * and that push_report be sorted with push_status_ref_cmp */\n\tgit_vector_sort(push_specs);\n\tgit_vector_sort(push_report);\n\n\tgit_vector_foreach(push_specs, i, push_spec) {\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* For each push spec we sent to the server, we should have\n\t\t * gotten back a status packet in the push report which matches */\n\t\tif (strcmp(push_spec->refspec.dst, push_status->ref)) {\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* We require that refs be sorted with ref_name_cmp */\n\tgit_vector_sort(refs);\n\ti = j = 0;\n\trefs_len = refs->length;\n\n\t/* Merge join push_specs with refs */\n\twhile (i < push_specs->length && j < refs_len) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\t\tref = git_vector_get(refs, j);\n\n\t\tcmp = strcmp(push_spec->refspec.dst, ref->head.name);\n\n\t\t/* Iterate appropriately */\n\t\tif (cmp <= 0) i++;\n\t\tif (cmp >= 0) j++;\n\n\t\t/* Add case */\n\t\tif (cmp < 0 &&\n\t\t\t!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\n\t\t/* Update case, delete case */\n\t\tif (cmp == 0 &&\n\t\t\t!push_status->msg)\n\t\t\tgit_oid_cpy(&ref->head.oid, &push_spec->loid);\n\t}\n\n\tfor (; i < push_specs->length; i++) {\n\t\tpush_spec = git_vector_get(push_specs, i);\n\t\tpush_status = git_vector_get(push_report, i);\n\n\t\t/* Add case */\n\t\tif (!push_status->msg &&\n\t\t\tadd_ref_from_push_spec(refs, push_spec) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* Remove any refs which we updated to have a zero OID. */\n\tgit_vector_rforeach(refs, i, ref) {\n\t\tif (git_oid_iszero(&ref->head.oid)) {\n\t\t\tgit_vector_remove(refs, i);\n\t\t\tgit_pkt_free((git_pkt *)ref);\n\t\t}\n\t}\n\n\tgit_vector_sort(refs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_ref_from_push_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "871-887",
    "snippet": "static int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "(git_pkt *)added"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "refs",
            "added"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "push_spec->refspec.dst"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&added->head.oid",
            "&push_spec->loid"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "added"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_pkt_ref)"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_ref_from_push_spec(git_vector *refs, push_spec *push_spec)\n{\n\tgit_pkt_ref *added = git__calloc(1, sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(added);\n\n\tadded->type = GIT_PKT_REF;\n\tgit_oid_cpy(&added->head.oid, &push_spec->loid);\n\tadded->head.name = git__strdup(push_spec->refspec.dst);\n\n\tif (!added->head.name ||\n\t\tgit_vector_insert(refs, added) < 0) {\n\t\tgit_pkt_free((git_pkt *)added);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "786-869",
    "snippet": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&data_pkt_buf"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Incomplete pack data pkt-line\""
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "pkt"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_push_report_pkt",
          "args": [
            "push",
            "pkt"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "add_push_report_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "684-722",
          "snippet": "static int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transport->progress_cb",
          "args": [
            "p->data",
            "p->len",
            "transport->message_cb_payload"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"report-status: Error reported: %s\"",
            "((git_pkt_err *)pkt)->error"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_push_report_sideband_pkt",
          "args": [
            "push",
            "(git_pkt_data *)pkt",
            "&data_pkt_buf"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "add_push_report_sideband_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "724-784",
          "snippet": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_consume",
          "args": [
            "buf",
            "line_end"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_consume_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "76-81",
          "snippet": "void gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_recv",
          "args": [
            "buf"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "18-21",
          "snippet": "int gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_parse_line",
          "args": [
            "&pkt",
            "buf->data",
            "&line_end",
            "buf->offset"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_parse_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "398-474",
          "snippet": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PKT_LEN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define PKT_LEN_SIZE 4\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}"
  },
  {
    "function_name": "add_push_report_sideband_pkt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "724-784",
    "snippet": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_consume",
          "args": [
            "data_pkt_buf",
            "line_end"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "436-444",
          "snippet": "void git_buf_consume(git_buf *buf, const char *end)\n{\n\tif (end > buf->ptr && end <= buf->ptr + buf->size) {\n\t\tsize_t consumed = end - buf->ptr;\n\t\tmemmove(buf->ptr, end, buf->size - consumed);\n\t\tbuf->size -= consumed;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_consume(git_buf *buf, const char *end)\n{\n\tif (end > buf->ptr && end <= buf->ptr + buf->size) {\n\t\tsize_t consumed = end - buf->ptr;\n\t\tmemmove(buf->ptr, end, buf->size - consumed);\n\t\tbuf->size -= consumed;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "pkt"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_push_report_pkt",
          "args": [
            "push",
            "pkt"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "add_push_report_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "684-722",
          "snippet": "static int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "data_pkt_buf",
            "line",
            "line_len"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_parse_line",
          "args": [
            "&pkt",
            "line",
            "&line_end",
            "line_len"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_parse_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "398-474",
          "snippet": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PKT_LEN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define PKT_LEN_SIZE 4\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}"
  },
  {
    "function_name": "add_push_report_pkt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "684-722",
    "snippet": "static int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"report-status: protocol error\""
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_push_status_free",
          "args": [
            "status"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "git_push_status_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/push.c",
          "lines": "673-681",
          "snippet": "void git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"push.h\"",
            "#include \"vector.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"pack.h\"",
            "#include \"common.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"push.h\"\n#include \"vector.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"pack.h\"\n#include \"common.h\"\n#include \"git2.h\"\n\nvoid git_push_status_free(push_status *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit__free(status->msg);\n\tgit__free(status->ref);\n\tgit__free(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&push->status",
            "status"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "((git_pkt_ng *)pkt)->msg"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "status"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(push_status)"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "status"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int add_push_report_pkt(git_push *push, git_pkt *pkt)\n{\n\tpush_status *status;\n\n\tswitch (pkt->type) {\n\t\tcase GIT_PKT_OK:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->msg = NULL;\n\t\t\tstatus->ref = git__strdup(((git_pkt_ok *)pkt)->ref);\n\t\t\tif (!status->ref ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_NG:\n\t\t\tstatus = git__calloc(1, sizeof(push_status));\n\t\t\tGITERR_CHECK_ALLOC(status);\n\t\t\tstatus->ref = git__strdup(((git_pkt_ng *)pkt)->ref);\n\t\t\tstatus->msg = git__strdup(((git_pkt_ng *)pkt)->msg);\n\t\t\tif (!status->ref || !status->msg ||\n\t\t\t\tgit_vector_insert(&push->status, status) < 0) {\n\t\t\t\tgit_push_status_free(status);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GIT_PKT_UNPACK:\n\t\t\tpush->unpack_ok = ((git_pkt_unpack *)pkt)->unpack_ok;\n\t\t\tbreak;\n\t\tcase GIT_PKT_FLUSH:\n\t\t\treturn GIT_ITEROVER;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_NET, \"report-status: protocol error\");\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gen_pktline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "643-682",
    "snippet": "static int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "buf"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "buf",
            "\"0000\""
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "buf",
            "GIT_CAP_SIDE_BAND_64K"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "new_id",
            "&spec->loid"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_SIDE_BAND_64K"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_REPORT_STATUS"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spec->refspec.dst"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&push->specs",
            "i",
            "spec"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int gen_pktline(git_buf *buf, git_push *push)\n{\n\tpush_spec *spec;\n\tsize_t i, len;\n\tchar old_id[GIT_OID_HEXSZ+1], new_id[GIT_OID_HEXSZ+1];\n\n\told_id[GIT_OID_HEXSZ] = '\\0'; new_id[GIT_OID_HEXSZ] = '\\0';\n\n\tgit_vector_foreach(&push->specs, i, spec) {\n\t\tlen = 2*GIT_OID_HEXSZ + 7 + strlen(spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\t++len; /* '\\0' */\n\t\t\tif (push->report_status)\n\t\t\t\tlen += strlen(GIT_CAP_REPORT_STATUS) + 1;\n\t\t\tlen += strlen(GIT_CAP_SIDE_BAND_64K) + 1;\n\t\t}\n\n\t\tgit_oid_fmt(old_id, &spec->roid);\n\t\tgit_oid_fmt(new_id, &spec->loid);\n\n\t\tgit_buf_printf(buf, \"%04\"PRIxZ\"%s %s %s\", len, old_id, new_id, spec->refspec.dst);\n\n\t\tif (i == 0) {\n\t\t\tgit_buf_putc(buf, '\\0');\n\t\t\t/* Core git always starts their capabilities string with a space */\n\t\t\tif (push->report_status) {\n\t\t\t\tgit_buf_putc(buf, ' ');\n\t\t\t\tgit_buf_printf(buf, GIT_CAP_REPORT_STATUS);\n\t\t\t}\n\t\t\tgit_buf_putc(buf, ' ');\n\t\t\tgit_buf_printf(buf, GIT_CAP_SIDE_BAND_64K);\n\t\t}\n\n\t\tgit_buf_putc(buf, '\\n');\n\t}\n\n\tgit_buf_puts(buf, \"0000\");\n\treturn git_buf_oom(buf) ? -1 : 0;\n}"
  },
  {
    "function_name": "git_smart__download_pack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "534-641",
    "snippet": "int git_smart__download_pack(\n\tgit_transport *transport,\n\tgit_repository *repo,\n\tgit_transfer_progress *stats,\n\tgit_transfer_progress_cb transfer_progress_cb,\n\tvoid *progress_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_odb *odb;\n\tstruct git_odb_writepack *writepack = NULL;\n\tint error = 0;\n\tstruct network_packetsize_payload npp = {0};\n\n\tmemset(stats, 0, sizeof(git_transfer_progress));\n\n\tif (transfer_progress_cb) {\n\t\tnpp.callback = transfer_progress_cb;\n\t\tnpp.payload = progress_payload;\n\t\tnpp.stats = stats;\n\t\tt->packetsize_cb = &network_packetsize;\n\t\tt->packetsize_payload = &npp;\n\n\t\t/* We might have something in the buffer already from negotiate_fetch */\n\t\tif (t->buffer.offset > 0 && !t->cancelled.val)\n\t\t\tif (t->packetsize_cb(t->buffer.offset, t->packetsize_payload))\n\t\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t}\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t((error = git_odb_write_pack(&writepack, odb, transfer_progress_cb, progress_payload)) != 0))\n\t\tgoto done;\n\n\t/*\n\t * If the remote doesn't support the side-band, we can feed\n\t * the data directly to the pack writer. Otherwise, we need to\n\t * check which one belongs there.\n\t */\n\tif (!t->caps.side_band && !t->caps.side_band_64k) {\n\t\terror = no_sideband(t, writepack, buf, stats);\n\t\tgoto done;\n\t}\n\n\tdo {\n\t\tgit_pkt *pkt = NULL;\n\n\t\t/* Check cancellation before network call */\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_clear();\n\t\t\terror = GIT_EUSER;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = recv_pkt(&pkt, buf)) >= 0) {\n\t\t\t/* Check cancellation after network call */\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = GIT_EUSER;\n\t\t\t} else if (pkt->type == GIT_PKT_PROGRESS) {\n\t\t\t\tif (t->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = t->progress_cb(p->data, p->len, t->message_cb_payload);\n\t\t\t\t}\n\t\t\t} else if (pkt->type == GIT_PKT_DATA) {\n\t\t\t\tgit_pkt_data *p = (git_pkt_data *) pkt;\n\n\t\t\t\tif (p->len)\n\t\t\t\t\terror = writepack->append(writepack, p->data, p->len, stats);\n\t\t\t} else if (pkt->type == GIT_PKT_FLUSH) {\n\t\t\t\t/* A flush indicates the end of the packfile */\n\t\t\t\tgit__free(pkt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgit__free(pkt);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t} while (1);\n\n\t/*\n\t * Trailing execution of transfer_progress_cb, if necessary...\n\t * Only the callback through the npp datastructure currently\n\t * updates the last_fired_bytes value. It is possible that\n\t * progress has already been reported with the correct\n\t * \"received_bytes\" value, but until (if?) this is unified\n\t * then we will report progress again to be sure that the\n\t * correct last received_bytes value is reported.\n\t */\n\tif (npp.callback && npp.stats->received_bytes > npp.last_fired_bytes) {\n\t\terror = npp.callback(npp.stats, npp.payload);\n\t\tif (error != 0)\n\t\t\tgoto done;\n\t}\n\n\terror = writepack->commit(writepack, stats);\n\ndone:\n\tif (writepack)\n\t\twritepack->free(writepack);\n\tif (transfer_progress_cb) {\n\t\tt->packetsize_cb = NULL;\n\t\tt->packetsize_payload = NULL;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writepack->free",
          "args": [
            "writepack"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writepack->commit",
          "args": [
            "writepack",
            "stats"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "npp.callback",
          "args": [
            "npp.stats",
            "npp.payload"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writepack->append",
          "args": [
            "writepack",
            "p->data",
            "p->len",
            "stats"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->progress_cb",
          "args": [
            "p->data",
            "p->len",
            "t->message_cb_payload"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_pkt",
          "args": [
            "&pkt",
            "buf"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "recv_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "207-237",
          "snippet": "static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_sideband",
          "args": [
            "t",
            "writepack",
            "buf",
            "stats"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "no_sideband",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "483-506",
          "snippet": "static int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write_pack",
          "args": [
            "&writepack",
            "odb",
            "transfer_progress_cb",
            "progress_payload"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write_pack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1166-1193",
          "snippet": "int git_odb_write_pack(struct git_odb_writepack **out, git_odb *db, git_transfer_progress_cb progress_cb, void *progress_payload)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\n\tassert(out && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writepack != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writepack(out, b, db, progress_cb, progress_payload);\n\t\t}\n\t}\n\n\tif (error == GIT_PASSTHROUGH)\n\t\terror = 0;\n\tif (error < 0 && !writes)\n\t\terror = git_odb__error_unsupported_in_backend(\"write pack\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write_pack(struct git_odb_writepack **out, git_odb *db, git_transfer_progress_cb progress_cb, void *progress_payload)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\n\tassert(out && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writepack != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writepack(out, b, db, progress_cb, progress_payload);\n\t\t}\n\t}\n\n\tif (error == GIT_PASSTHROUGH)\n\t\terror = 0;\n\tif (error < 0 && !writes)\n\t\terror = git_odb__error_unsupported_in_backend(\"write pack\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_set",
          "args": [
            "&t->cancelled",
            "1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "166-169",
          "snippet": "GIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(void) git_atomic_set(git_atomic *a, int val)\n{\n\ta->val = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->packetsize_cb",
          "args": [
            "t->buffer.offset",
            "t->packetsize_payload"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(git_transfer_progress)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__download_pack(\n\tgit_transport *transport,\n\tgit_repository *repo,\n\tgit_transfer_progress *stats,\n\tgit_transfer_progress_cb transfer_progress_cb,\n\tvoid *progress_payload)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_odb *odb;\n\tstruct git_odb_writepack *writepack = NULL;\n\tint error = 0;\n\tstruct network_packetsize_payload npp = {0};\n\n\tmemset(stats, 0, sizeof(git_transfer_progress));\n\n\tif (transfer_progress_cb) {\n\t\tnpp.callback = transfer_progress_cb;\n\t\tnpp.payload = progress_payload;\n\t\tnpp.stats = stats;\n\t\tt->packetsize_cb = &network_packetsize;\n\t\tt->packetsize_payload = &npp;\n\n\t\t/* We might have something in the buffer already from negotiate_fetch */\n\t\tif (t->buffer.offset > 0 && !t->cancelled.val)\n\t\t\tif (t->packetsize_cb(t->buffer.offset, t->packetsize_payload))\n\t\t\t\tgit_atomic_set(&t->cancelled, 1);\n\t}\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t((error = git_odb_write_pack(&writepack, odb, transfer_progress_cb, progress_payload)) != 0))\n\t\tgoto done;\n\n\t/*\n\t * If the remote doesn't support the side-band, we can feed\n\t * the data directly to the pack writer. Otherwise, we need to\n\t * check which one belongs there.\n\t */\n\tif (!t->caps.side_band && !t->caps.side_band_64k) {\n\t\terror = no_sideband(t, writepack, buf, stats);\n\t\tgoto done;\n\t}\n\n\tdo {\n\t\tgit_pkt *pkt = NULL;\n\n\t\t/* Check cancellation before network call */\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_clear();\n\t\t\terror = GIT_EUSER;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = recv_pkt(&pkt, buf)) >= 0) {\n\t\t\t/* Check cancellation after network call */\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = GIT_EUSER;\n\t\t\t} else if (pkt->type == GIT_PKT_PROGRESS) {\n\t\t\t\tif (t->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = t->progress_cb(p->data, p->len, t->message_cb_payload);\n\t\t\t\t}\n\t\t\t} else if (pkt->type == GIT_PKT_DATA) {\n\t\t\t\tgit_pkt_data *p = (git_pkt_data *) pkt;\n\n\t\t\t\tif (p->len)\n\t\t\t\t\terror = writepack->append(writepack, p->data, p->len, stats);\n\t\t\t} else if (pkt->type == GIT_PKT_FLUSH) {\n\t\t\t\t/* A flush indicates the end of the packfile */\n\t\t\t\tgit__free(pkt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgit__free(pkt);\n\t\tif (error < 0)\n\t\t\tgoto done;\n\n\t} while (1);\n\n\t/*\n\t * Trailing execution of transfer_progress_cb, if necessary...\n\t * Only the callback through the npp datastructure currently\n\t * updates the last_fired_bytes value. It is possible that\n\t * progress has already been reported with the correct\n\t * \"received_bytes\" value, but until (if?) this is unified\n\t * then we will report progress again to be sure that the\n\t * correct last received_bytes value is reported.\n\t */\n\tif (npp.callback && npp.stats->received_bytes > npp.last_fired_bytes) {\n\t\terror = npp.callback(npp.stats, npp.payload);\n\t\tif (error != 0)\n\t\t\tgoto done;\n\t}\n\n\terror = writepack->commit(writepack, stats);\n\ndone:\n\tif (writepack)\n\t\twritepack->free(writepack);\n\tif (transfer_progress_cb) {\n\t\tt->packetsize_cb = NULL;\n\t\tt->packetsize_payload = NULL;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "network_packetsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "516-532",
    "snippet": "static int network_packetsize(size_t received, void *payload)\n{\n\tstruct network_packetsize_payload *npp = (struct network_packetsize_payload*)payload;\n\n\t/* Accumulate bytes */\n\tnpp->stats->received_bytes += received;\n\n\t/* Fire notification if the threshold is reached */\n\tif ((npp->stats->received_bytes - npp->last_fired_bytes) > NETWORK_XFER_THRESHOLD) {\n\t\tnpp->last_fired_bytes = npp->stats->received_bytes;\n\n\t\tif (npp->callback(npp->stats, npp->payload))\n\t\t\treturn GIT_EUSER;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [
      "#define NETWORK_XFER_THRESHOLD (100*1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "npp->callback",
          "args": [
            "npp->stats",
            "npp->payload"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\n#define NETWORK_XFER_THRESHOLD (100*1024)\n\nstatic int network_packetsize(size_t received, void *payload)\n{\n\tstruct network_packetsize_payload *npp = (struct network_packetsize_payload*)payload;\n\n\t/* Accumulate bytes */\n\tnpp->stats->received_bytes += received;\n\n\t/* Fire notification if the threshold is reached */\n\tif ((npp->stats->received_bytes - npp->last_fired_bytes) > NETWORK_XFER_THRESHOLD) {\n\t\tnpp->last_fired_bytes = npp->stats->received_bytes;\n\n\t\tif (npp->callback(npp->stats, npp->payload))\n\t\t\treturn GIT_EUSER;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "no_sideband",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "483-506",
    "snippet": "static int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writepack->commit",
          "args": [
            "writepack",
            "stats"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gitno_recv",
          "args": [
            "buf"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "18-21",
          "snippet": "int gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_consume_n",
          "args": [
            "buf",
            "buf->offset"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_consume_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "76-81",
          "snippet": "void gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writepack->append",
          "args": [
            "writepack",
            "buf->data",
            "buf->offset",
            "stats"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"The fetch was cancelled by the user\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int no_sideband(transport_smart *t, struct git_odb_writepack *writepack, gitno_buffer *buf, git_transfer_progress *stats)\n{\n\tint recvd;\n\n\tdo {\n\t\tif (t->cancelled.val) {\n\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\treturn GIT_EUSER;\n\t\t}\n\n\t\tif (writepack->append(writepack, buf->data, buf->offset, stats) < 0)\n\t\t\treturn -1;\n\n\t\tgitno_consume_n(buf, buf->offset);\n\n\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\treturn recvd;\n\t} while(recvd > 0);\n\n\tif (writepack->commit(writepack, stats) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_smart__negotiate_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "332-481",
    "snippet": "int git_smart__negotiate_fetch(git_transport *transport, git_repository *repo, const git_remote_head * const *wants, size_t count)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_buf data = GIT_BUF_INIT;\n\tgit_revwalk *walk = NULL;\n\tint error = -1, pkt_type;\n\tunsigned int i;\n\tgit_oid oid;\n\n\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\treturn error;\n\n\tif ((error = fetch_setup_walk(&walk, repo)) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Our support for ACK extensions is simply to parse them. On\n\t * the first ACK we will accept that as enough common\n\t * objects. We give up if we haven't found an answer in the\n\t * first 256 we send.\n\t */\n\ti = 0;\n\twhile (i < 256) {\n\t\terror = git_revwalk_next(&oid, walk);\n\n\t\tif (error < 0) {\n\t\t\tif (GIT_ITEROVER == error)\n\t\t\t\tbreak;\n\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_pkt_buffer_have(&oid, &data);\n\t\ti++;\n\t\tif (i % 20 == 0) {\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\t\terror = GIT_EUSER;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tgit_pkt_buffer_flush(&data);\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_buf_clear(&data);\n\t\t\tif (t->caps.multi_ack || t->caps.multi_ack_detailed) {\n\t\t\t\tif ((error = store_common(t)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\t\t\tif (pkt_type == GIT_PKT_ACK) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pkt_type == GIT_PKT_NAK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pkt_type < 0) {\n\t\t\t\t\t/* recv_pkt returned an error */\n\t\t\t\t\terror = pkt_type;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t} else {\n\t\t\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->common.length > 0)\n\t\t\tbreak;\n\n\t\tif (i % 20 == 0 && t->rpc) {\n\t\t\tgit_pkt_ack *pkt;\n\t\t\tunsigned int i;\n\n\t\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_vector_foreach(&t->common, i, pkt) {\n\t\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Tell the other end that we're done negotiating */\n\tif (t->rpc && t->common.length > 0) {\n\t\tgit_pkt_ack *pkt;\n\t\tunsigned int i;\n\n\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_foreach(&t->common, i, pkt) {\n\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (git_buf_oom(&data)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif ((error = git_pkt_buffer_done(&data)) < 0)\n\t\tgoto on_error;\n\n\tif (t->cancelled.val) {\n\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\terror = GIT_EUSER;\n\t\tgoto on_error;\n\t}\n\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&data);\n\tgit_revwalk_free(walk);\n\n\t/* Now let's eat up whatever the server gives us */\n\tif (!t->caps.multi_ack && !t->caps.multi_ack_detailed) {\n\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\tif (pkt_type < 0) {\n\t\t\treturn pkt_type;\n\t\t} else if (pkt_type != GIT_PKT_ACK && pkt_type != GIT_PKT_NAK) {\n\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\terror = wait_while_ack(buf);\n\t}\n\n\treturn error;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_buf_free(&data);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&data"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_while_ack",
          "args": [
            "buf"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "wait_while_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "306-330",
          "snippet": "static int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Unexpected pkt type\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_pkt",
          "args": [
            "NULL",
            "buf"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "recv_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "207-237",
          "snippet": "static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_smart__negotiation_step",
          "args": [
            "&t->parent",
            "data.ptr",
            "data.size"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "git_smart__negotiation_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "307-336",
          "snippet": "int git_smart__negotiation_step(git_transport *transport, void *data, size_t len)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_FETCH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for fetch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tif ((error = stream->write(stream, (const char *)data, len)) < 0)\n\t\treturn error;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_smart__negotiation_step(git_transport *transport, void *data, size_t len)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgit_smart_subtransport_stream *stream;\n\tint error;\n\n\tif (t->rpc && git_smart__reset_stream(t, false) < 0)\n\t\treturn -1;\n\n\tif (GIT_DIRECTION_FETCH != t->direction) {\n\t\tgiterr_set(GITERR_NET, \"This operation is only valid for fetch\");\n\t\treturn -1;\n\t}\n\n\tif ((error = t->wrapped->action(&stream, t->wrapped, t->url, GIT_SERVICE_UPLOADPACK)) < 0)\n\t\treturn error;\n\n\t/* If this is a stateful implementation, the stream we get back should be the same */\n\tassert(t->rpc || t->current_stream == stream);\n\n\t/* Save off the current stream (i.e. socket) that we are working with */\n\tt->current_stream = stream;\n\n\tif ((error = stream->write(stream, (const char *)data, len)) < 0)\n\t\treturn error;\n\n\tgitno_buffer_setup_callback(&t->buffer, t->buffer_data, sizeof(t->buffer_data), git_smart__recv_cb, t);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_buffer_done",
          "args": [
            "&data"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_buffer_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "607-610",
          "snippet": "int git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char pkt_done_str[] = \"0009done\\n\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic const char pkt_done_str[] = \"0009done\\n\";\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "&data"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_buffer_have",
          "args": [
            "&pkt->oid",
            "&data"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_buffer_have",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "598-605",
          "snippet": "int git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char pkt_have_prefix[] = \"0032have \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic const char pkt_have_prefix[] = \"0032have \";\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&t->common",
            "i",
            "pkt"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pkt_buffer_wants",
          "args": [
            "wants",
            "count",
            "&t->caps",
            "&data"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_buffer_wants",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "558-596",
          "snippet": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char pkt_want_prefix[] = \"0032want \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&t->common",
            "i",
            "pkt"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_common",
          "args": [
            "t"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "store_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "239-260",
          "snippet": "static int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&data"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_buffer_flush",
          "args": [
            "&data"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_buffer_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "498-501",
          "snippet": "int git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char pkt_flush_str[] = \"0000\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic const char pkt_flush_str[] = \"0000\";\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_next",
          "args": [
            "&oid",
            "walk"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "598-622",
          "snippet": "int git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_setup_walk",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_setup_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "262-304",
          "snippet": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__negotiate_fetch(git_transport *transport, git_repository *repo, const git_remote_head * const *wants, size_t count)\n{\n\ttransport_smart *t = (transport_smart *)transport;\n\tgitno_buffer *buf = &t->buffer;\n\tgit_buf data = GIT_BUF_INIT;\n\tgit_revwalk *walk = NULL;\n\tint error = -1, pkt_type;\n\tunsigned int i;\n\tgit_oid oid;\n\n\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\treturn error;\n\n\tif ((error = fetch_setup_walk(&walk, repo)) < 0)\n\t\tgoto on_error;\n\n\t/*\n\t * Our support for ACK extensions is simply to parse them. On\n\t * the first ACK we will accept that as enough common\n\t * objects. We give up if we haven't found an answer in the\n\t * first 256 we send.\n\t */\n\ti = 0;\n\twhile (i < 256) {\n\t\terror = git_revwalk_next(&oid, walk);\n\n\t\tif (error < 0) {\n\t\t\tif (GIT_ITEROVER == error)\n\t\t\t\tbreak;\n\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tgit_pkt_buffer_have(&oid, &data);\n\t\ti++;\n\t\tif (i % 20 == 0) {\n\t\t\tif (t->cancelled.val) {\n\t\t\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\t\t\terror = GIT_EUSER;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tgit_pkt_buffer_flush(&data);\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_buf_clear(&data);\n\t\t\tif (t->caps.multi_ack || t->caps.multi_ack_detailed) {\n\t\t\t\tif ((error = store_common(t)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t} else {\n\t\t\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\t\t\tif (pkt_type == GIT_PKT_ACK) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pkt_type == GIT_PKT_NAK) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (pkt_type < 0) {\n\t\t\t\t\t/* recv_pkt returned an error */\n\t\t\t\t\terror = pkt_type;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t} else {\n\t\t\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto on_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->common.length > 0)\n\t\t\tbreak;\n\n\t\tif (i % 20 == 0 && t->rpc) {\n\t\t\tgit_pkt_ack *pkt;\n\t\t\tunsigned int i;\n\n\t\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\t\tgoto on_error;\n\n\t\t\tgit_vector_foreach(&t->common, i, pkt) {\n\t\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\t\tgoto on_error;\n\t\t\t}\n\n\t\t\tif (git_buf_oom(&data)) {\n\t\t\t\terror = -1;\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Tell the other end that we're done negotiating */\n\tif (t->rpc && t->common.length > 0) {\n\t\tgit_pkt_ack *pkt;\n\t\tunsigned int i;\n\n\t\tif ((error = git_pkt_buffer_wants(wants, count, &t->caps, &data)) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_vector_foreach(&t->common, i, pkt) {\n\t\t\tif ((error = git_pkt_buffer_have(&pkt->oid, &data)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\n\t\tif (git_buf_oom(&data)) {\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif ((error = git_pkt_buffer_done(&data)) < 0)\n\t\tgoto on_error;\n\n\tif (t->cancelled.val) {\n\t\tgiterr_set(GITERR_NET, \"The fetch was cancelled by the user\");\n\t\terror = GIT_EUSER;\n\t\tgoto on_error;\n\t}\n\tif ((error = git_smart__negotiation_step(&t->parent, data.ptr, data.size)) < 0)\n\t\tgoto on_error;\n\n\tgit_buf_free(&data);\n\tgit_revwalk_free(walk);\n\n\t/* Now let's eat up whatever the server gives us */\n\tif (!t->caps.multi_ack && !t->caps.multi_ack_detailed) {\n\t\tpkt_type = recv_pkt(NULL, buf);\n\n\t\tif (pkt_type < 0) {\n\t\t\treturn pkt_type;\n\t\t} else if (pkt_type != GIT_PKT_ACK && pkt_type != GIT_PKT_NAK) {\n\t\t\tgiterr_set(GITERR_NET, \"Unexpected pkt type\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\terror = wait_while_ack(buf);\n\t}\n\n\treturn error;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_buf_free(&data);\n\treturn error;\n}"
  },
  {
    "function_name": "wait_while_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "306-330",
    "snippet": "static int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_pkt",
          "args": [
            "(git_pkt **)&pkt",
            "buf"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "recv_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "207-237",
          "snippet": "static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\n\twhile (1) {\n\t\tgit__free(pkt);\n\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgit__free(pkt);\n\treturn 0;\n}"
  },
  {
    "function_name": "fetch_setup_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "262-304",
    "snippet": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strarray_free",
          "args": [
            "&refs"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "git_strarray_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "21-34",
          "snippet": "void git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nvoid git_strarray_free(git_strarray *array)\n{\n\tsize_t i;\n\n\tif (array == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < array->count; ++i)\n\t\tgit__free(array->strings[i]);\n\n\tgit__free(array->strings);\n\n\tmemset(array, 0, sizeof(*array));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_push",
          "args": [
            "walk",
            "git_reference_target(ref)"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_push_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "281-304",
          "snippet": "int git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "ref"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&ref",
            "repo",
            "refs.strings[i]"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "refs.strings[i]",
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_sorting",
          "args": [
            "walk",
            "GIT_SORT_TIME"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_sorting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "575-591",
          "snippet": "void git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_list",
          "args": [
            "&refs",
            "repo"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "757-780",
          "snippet": "int git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_list(\n\tgit_strarray *array,\n\tgit_repository *repo)\n{\n\tgit_vector ref_list;\n\n\tassert(array && repo);\n\n\tarray->strings = NULL;\n\tarray->count = 0;\n\n\tif (git_vector_init(&ref_list, 8, NULL) < 0)\n\t\treturn -1;\n\n\tif (git_reference_foreach_name(\n\t\t\trepo, &cb__reflist_add, (void *)&ref_list) < 0) {\n\t\tgit_vector_free(&ref_list);\n\t\treturn -1;\n\t}\n\n\tarray->strings = (char **)git_vector_detach(&array->count, NULL, &ref_list);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tfor (i = 0; i < refs.count; ++i) {\n\t\t/* No tags */\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\n\t\tgit_reference_free(ref);\n\t}\n\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\n\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}"
  },
  {
    "function_name": "store_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "239-260",
    "snippet": "static int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&t->common",
            "pkt"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_pkt",
          "args": [
            "&pkt",
            "buf"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "recv_pkt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "207-237",
          "snippet": "static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int store_common(transport_smart *t)\n{\n\tgit_pkt *pkt = NULL;\n\tgitno_buffer *buf = &t->buffer;\n\tint error;\n\n\tdo {\n\t\tif ((error = recv_pkt(&pkt, buf)) < 0)\n\t\t\treturn error;\n\n\t\tif (pkt->type == GIT_PKT_ACK) {\n\t\t\tif (git_vector_insert(&t->common, pkt) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "recv_pkt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "207-237",
    "snippet": "static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_consume",
          "args": [
            "buf",
            "line_end"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_consume_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "76-81",
          "snippet": "void gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_recv",
          "args": [
            "buf"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "18-21",
          "snippet": "int gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_parse_line",
          "args": [
            "&pkt",
            "ptr",
            "&line_end",
            "buf->offset"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_parse_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "398-474",
          "snippet": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PKT_LEN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define PKT_LEN_SIZE 4\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0)\n\t\t\treturn ret;\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"
  },
  {
    "function_name": "git_smart__detect_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "128-205",
    "snippet": "int git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "' '"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_symref",
          "args": [
            "&ptr",
            "symrefs",
            "ptr"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "append_symref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
          "lines": "80-126",
          "snippet": "static int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"remote.h\"",
            "#include \"pack-objects.h\"",
            "#include \"push.h\"",
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ptr",
            "GIT_CAP_SYMREF"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_THIN_PACK"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_DELETE_REFS"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_SIDE_BAND"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_SIDE_BAND_64K"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_INCLUDE_TAG"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_MULTI_ACK"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_MULTI_ACK_DETAILED"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_OFS_DELTA"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__detect_caps(git_pkt_ref *pkt, transport_smart_caps *caps, git_vector *symrefs)\n{\n\tconst char *ptr;\n\n\t/* No refs or capabilites, odd but not a problem */\n\tif (pkt == NULL || pkt->capabilities == NULL)\n\t\treturn 0;\n\n\tptr = pkt->capabilities;\n\twhile (ptr != NULL && *ptr != '\\0') {\n\t\tif (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_OFS_DELTA)) {\n\t\t\tcaps->common = caps->ofs_delta = 1;\n\t\t\tptr += strlen(GIT_CAP_OFS_DELTA);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep multi_ack_detailed before multi_ack */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK_DETAILED)) {\n\t\t\tcaps->common = caps->multi_ack_detailed = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK_DETAILED);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_MULTI_ACK)) {\n\t\t\tcaps->common = caps->multi_ack = 1;\n\t\t\tptr += strlen(GIT_CAP_MULTI_ACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_INCLUDE_TAG)) {\n\t\t\tcaps->common = caps->include_tag = 1;\n\t\t\tptr += strlen(GIT_CAP_INCLUDE_TAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Keep side-band check after side-band-64k */\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND_64K)) {\n\t\t\tcaps->common = caps->side_band_64k = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND_64K);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SIDE_BAND)) {\n\t\t\tcaps->common = caps->side_band = 1;\n\t\t\tptr += strlen(GIT_CAP_SIDE_BAND);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_DELETE_REFS)) {\n\t\t\tcaps->common = caps->delete_refs = 1;\n\t\t\tptr += strlen(GIT_CAP_DELETE_REFS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_THIN_PACK)) {\n\t\t\tcaps->common = caps->thin_pack = 1;\n\t\t\tptr += strlen(GIT_CAP_THIN_PACK);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, GIT_CAP_SYMREF)) {\n\t\t\tint error;\n\n\t\t\tif ((error = append_symref(&ptr, symrefs, ptr)) < 0)\n\t\t\t\treturn error;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't know this capability, so skip it */\n\t\tptr = strchr(ptr, ' ');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "append_symref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "80-126",
    "snippet": "static int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "mapping"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__free",
          "args": [
            "mapping"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "151-161",
          "snippet": "void git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nvoid git_refspec__free(git_refspec *refspec)\n{\n\tif (refspec == NULL)\n\t\treturn;\n\n\tgit__free(refspec->src);\n\tgit__free(refspec->dst);\n\tgit__free(refspec->string);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"remote sent invalid symref\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "symrefs",
            "mapping"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_refspec__parse",
          "args": [
            "mapping",
            "git_buf_cstr(&buf)",
            "true"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_refspec__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refspec.c",
          "lines": "17-149",
          "snippet": "int git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"refs.h\"",
            "#include \"posix.h\"",
            "#include \"util.h\"",
            "#include \"refspec.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"refs.h\"\n#include \"posix.h\"\n#include \"util.h\"\n#include \"refspec.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n\nint git_refspec__parse(git_refspec *refspec, const char *input, bool is_fetch)\n{\n\t// Ported from https://github.com/git/git/blob/f06d47e7e0d9db709ee204ed13a8a7486149f494/remote.c#L518-636\n\n\tsize_t llen;\n\tint is_glob = 0;\n\tconst char *lhs, *rhs;\n\tint flags;\n\n\tassert(refspec && input);\n\n\tmemset(refspec, 0x0, sizeof(git_refspec));\n\trefspec->push = !is_fetch;\n\n\tlhs = input;\n\tif (*lhs == '+') {\n\t\trefspec->force = 1;\n\t\tlhs++;\n\t}\n\n\trhs = strrchr(lhs, ':');\n\n\t/*\n\t * Before going on, special case \":\" (or \"+:\") as a refspec\n\t * for matching refs.\n\t */\n\tif (!is_fetch && rhs == lhs && rhs[1] == '\\0') {\n\t\trefspec->matching = 1;\n\t\trefspec->string = git__strdup(input);\n\t\tGITERR_CHECK_ALLOC(refspec->string);\n\t\trefspec->src = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->src);\n\t\trefspec->dst = git__strdup(\"\");\n\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\treturn 0;\n\t}\n\n\tif (rhs) {\n\t\tsize_t rlen = strlen(++rhs);\n\t\tif (rlen || !is_fetch) {\n\t\t\tis_glob = (1 <= rlen && strchr(rhs, '*'));\n\t\t\trefspec->dst = git__strndup(rhs, rlen);\n\t\t}\n\t}\n\n\tllen = (rhs ? (size_t)(rhs - lhs - 1) : strlen(lhs));\n\tif (1 <= llen && memchr(lhs, '*', llen)) {\n\t\tif ((rhs && !is_glob) || (!rhs && is_fetch))\n\t\t\tgoto invalid;\n\t\tis_glob = 1;\n\t} else if (rhs && is_glob)\n\t\tgoto invalid;\n\n\trefspec->pattern = is_glob;\n\trefspec->src = git__strndup(lhs, llen);\n\tflags = GIT_REF_FORMAT_ALLOW_ONELEVEL | GIT_REF_FORMAT_REFSPEC_SHORTHAND\n\t\t| (is_glob ? GIT_REF_FORMAT_REFSPEC_PATTERN : 0);\n\n\tif (is_fetch) {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means HEAD.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is ok, and is same as empty.\n\t\t\t* - empty is ok; it means not to store.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!*refspec->dst)\n\t\t\t; /* ok */\n\t\telse if (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\tgoto invalid;\n\t} else {\n\t\t/*\n\t\t\t* LHS\n\t\t\t* - empty is allowed; it means delete.\n\t\t\t* - when wildcarded, it must be a valid looking ref.\n\t\t\t* - otherwise, it must be an extended SHA-1, but\n\t\t\t*   there is no existing way to validate this.\n\t\t\t*/\n\t\tif (!*refspec->src)\n\t\t\t; /* empty is ok */\n\t\telse if (is_glob) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\t\telse {\n\t\t\t; /* anything goes, for now */\n\t\t}\n\t\t/*\n\t\t\t* RHS\n\t\t\t* - missing is allowed, but LHS then must be a\n\t\t\t*   valid looking ref.\n\t\t\t* - empty is not allowed.\n\t\t\t* - otherwise it must be a valid looking ref.\n\t\t\t*/\n\t\tif (!refspec->dst) {\n\t\t\tif (!git_reference__is_valid_name(refspec->src, flags))\n\t\t\t\tgoto invalid;\n\t\t} else if (!*refspec->dst) {\n\t\t\tgoto invalid;\n\t\t} else {\n\t\t\tif (!git_reference__is_valid_name(refspec->dst, flags))\n\t\t\t\tgoto invalid;\n\t\t}\n\n\t\t/* if the RHS is empty, then it's a copy of the LHS */\n\t\tif (!refspec->dst) {\n\t\t\trefspec->dst = git__strdup(refspec->src);\n\t\t\tGITERR_CHECK_ALLOC(refspec->dst);\n\t\t}\n\t}\n\n\trefspec->string = git__strdup(input);\n\tGITERR_CHECK_ALLOC(refspec->string);\n\n\treturn 0;\n\n invalid:\n        giterr_set(\n                GITERR_INVALID,\n                \"'%s' is not a valid refspec.\", input);\n        git_refspec__free(refspec);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "mapping"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_refspec)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&buf",
            "ptr",
            "end - ptr"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\0'"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "' '"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_CAP_SYMREF"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nstatic int append_symref(const char **out, git_vector *symrefs, const char *ptr)\n{\n\tint error;\n\tconst char *end;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_refspec *mapping = NULL;\n\n\tptr += strlen(GIT_CAP_SYMREF);\n\tif (*ptr != '=')\n\t\tgoto on_invalid;\n\n\tptr++;\n\tif (!(end = strchr(ptr, ' ')) &&\n\t    !(end = strchr(ptr, '\\0')))\n\t\tgoto on_invalid;\n\n\tif ((error = git_buf_put(&buf, ptr, end - ptr)) < 0)\n\t\treturn error;\n\n\t/* symref mapping has refspec format */\n\tmapping = git__calloc(1, sizeof(git_refspec));\n\tGITERR_CHECK_ALLOC(mapping);\n\n\terror = git_refspec__parse(mapping, git_buf_cstr(&buf), true);\n\tgit_buf_free(&buf);\n\n\t/* if the error isn't OOM, then it's a parse error; let's use a nicer message */\n\tif (error < 0) {\n\t\tif (giterr_last()->klass != GITERR_NOMEMORY)\n\t\t\tgoto on_invalid;\n\n\t\tgit__free(mapping);\n\t\treturn error;\n\t}\n\n\tif ((error = git_vector_insert(symrefs, mapping)) < 0)\n\t\treturn error;\n\n\t*out = end;\n\treturn 0;\n\non_invalid:\n\tgiterr_set(GITERR_NET, \"remote sent invalid symref\");\n\tgit_refspec__free(mapping);\n\tgit__free(mapping);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_smart__store_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_protocol.c",
    "lines": "22-78",
    "snippet": "int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0 && !flush) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"remote.h\"",
      "#include \"pack-objects.h\"",
      "#include \"push.h\"",
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"smart.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pkt_free",
          "args": [
            "pkt"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "476-496",
          "snippet": "void git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "refs",
            "pkt"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pkt"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Remote error: %s\"",
            "((git_pkt_err *)pkt)->error"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_consume",
          "args": [
            "buf",
            "line_end"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_consume_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "76-81",
          "snippet": "void gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nvoid gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"early EOF\""
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_recv",
          "args": [
            "buf"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "18-21",
          "snippet": "int gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_recv(gitno_buffer *buf)\n{\n\treturn buf->recv(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pkt_parse_line",
          "args": [
            "&pkt",
            "buf->data",
            "&line_end",
            "buf->offset"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "git_pkt_parse_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart_pkt.c",
          "lines": "398-474",
          "snippet": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"util.h\"",
            "#include \"smart.h\"",
            "#include \"git2/revwalk.h\"",
            "#include \"git2/refs.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PKT_LEN_SIZE 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"util.h\"\n#include \"smart.h\"\n#include \"git2/revwalk.h\"\n#include \"git2/refs.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define PKT_LEN_SIZE 4\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "refs"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "refs",
            "i",
            "pkt"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"remote.h\"\n#include \"pack-objects.h\"\n#include \"push.h\"\n#include \"repository.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2.h\"\n\nint git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0 && !flush) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}"
  }
]