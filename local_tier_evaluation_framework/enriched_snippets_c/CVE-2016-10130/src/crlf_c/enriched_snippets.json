[
  {
    "function_name": "git_crlf_filter_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "367-382",
    "snippet": "git_filter *git_crlf_filter_new(void)\n{\n\tstruct crlf_filter *f = git__calloc(1, sizeof(struct crlf_filter));\n\tif (f == NULL)\n\t\treturn NULL;\n\n\tf->f.version = GIT_FILTER_VERSION;\n\tf->f.attributes = \"crlf eol text\";\n\tf->f.initialize = NULL;\n\tf->f.shutdown = git_filter_free;\n\tf->f.check    = crlf_check;\n\tf->f.apply    = crlf_apply;\n\tf->f.cleanup  = crlf_cleanup;\n\n\treturn (git_filter *)f;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(struct crlf_filter)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\ngit_filter *git_crlf_filter_new(void)\n{\n\tstruct crlf_filter *f = git__calloc(1, sizeof(struct crlf_filter));\n\tif (f == NULL)\n\t\treturn NULL;\n\n\tf->f.version = GIT_FILTER_VERSION;\n\tf->f.attributes = \"crlf eol text\";\n\tf->f.initialize = NULL;\n\tf->f.shutdown = git_filter_free;\n\tf->f.check    = crlf_check;\n\tf->f.apply    = crlf_apply;\n\tf->f.cleanup  = crlf_cleanup;\n\n\treturn (git_filter *)f;\n}"
  },
  {
    "function_name": "crlf_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "359-365",
    "snippet": "static void crlf_cleanup(\n\tgit_filter *self,\n\tvoid       *payload)\n{\n\tGIT_UNUSED(self);\n\tgit__free(payload);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "payload"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "self"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic void crlf_cleanup(\n\tgit_filter *self,\n\tvoid       *payload)\n{\n\tGIT_UNUSED(self);\n\tgit__free(payload);\n}"
  },
  {
    "function_name": "crlf_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "339-357",
    "snippet": "static int crlf_apply(\n\tgit_filter    *self,\n\tvoid         **payload, /* may be read and/or set */\n\tgit_buf       *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* initialize payload in case `check` was bypassed */\n\tif (!*payload) {\n\t\tint error = crlf_check(self, payload, src, NULL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\treturn crlf_apply_to_workdir(*payload, to, from);\n\telse\n\t\treturn crlf_apply_to_odb(*payload, to, from, src);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crlf_apply_to_odb",
          "args": [
            "*payload",
            "to",
            "from",
            "src"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "crlf_apply_to_odb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "121-184",
          "snippet": "static int crlf_apply_to_odb(\n\tstruct crlf_attrs *ca,\n\tgit_buf *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* Empty file? Nothing to do */\n\tif (!git_buf_len(from))\n\t\treturn 0;\n\n\t/* Heuristics to see if we can skip the conversion.\n\t * Straight from Core Git.\n\t */\n\tif (ca->crlf_action == GIT_CRLF_AUTO || ca->crlf_action == GIT_CRLF_GUESS) {\n\t\tgit_buf_text_stats stats;\n\n\t\t/* Check heuristics for binary vs text - returns true if binary */\n\t\tif (git_buf_text_gather_stats(&stats, from, false))\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If there are no CR characters to filter out, then just pass */\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If safecrlf is enabled, sanity-check the result. */\n\t\tif (stats.cr != stats.crlf || stats.lf != stats.crlf) {\n\t\t\tswitch (ca->safe_crlf) {\n\t\t\tcase GIT_SAFE_CRLF_FAIL:\n\t\t\t\tgiterr_set(\n\t\t\t\t\tGITERR_FILTER, \"LF would be replaced by CRLF in '%s'\",\n\t\t\t\t\tgit_filter_source_path(src));\n\t\t\t\treturn -1;\n\t\t\tcase GIT_SAFE_CRLF_WARN:\n\t\t\t\t/* TODO: issue warning when warning API is available */;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We're currently not going to even try to convert stuff\n\t\t * that has bare CR characters. Does anybody do that crazy\n\t\t * stuff?\n\t\t */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS) {\n\t\t\t/*\n\t\t\t * If the file in the index has any CR in it, do not convert.\n\t\t\t * This is the new safer autocrlf handling.\n\t\t\t */\n\t\t\tif (has_cr_in_index(src))\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t}\n\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\t/* Actually drop the carriage returns */\n\treturn git_buf_text_crlf_to_lf(to, from);\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_apply_to_odb(\n\tstruct crlf_attrs *ca,\n\tgit_buf *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* Empty file? Nothing to do */\n\tif (!git_buf_len(from))\n\t\treturn 0;\n\n\t/* Heuristics to see if we can skip the conversion.\n\t * Straight from Core Git.\n\t */\n\tif (ca->crlf_action == GIT_CRLF_AUTO || ca->crlf_action == GIT_CRLF_GUESS) {\n\t\tgit_buf_text_stats stats;\n\n\t\t/* Check heuristics for binary vs text - returns true if binary */\n\t\tif (git_buf_text_gather_stats(&stats, from, false))\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If there are no CR characters to filter out, then just pass */\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If safecrlf is enabled, sanity-check the result. */\n\t\tif (stats.cr != stats.crlf || stats.lf != stats.crlf) {\n\t\t\tswitch (ca->safe_crlf) {\n\t\t\tcase GIT_SAFE_CRLF_FAIL:\n\t\t\t\tgiterr_set(\n\t\t\t\t\tGITERR_FILTER, \"LF would be replaced by CRLF in '%s'\",\n\t\t\t\t\tgit_filter_source_path(src));\n\t\t\t\treturn -1;\n\t\t\tcase GIT_SAFE_CRLF_WARN:\n\t\t\t\t/* TODO: issue warning when warning API is available */;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We're currently not going to even try to convert stuff\n\t\t * that has bare CR characters. Does anybody do that crazy\n\t\t * stuff?\n\t\t */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS) {\n\t\t\t/*\n\t\t\t * If the file in the index has any CR in it, do not convert.\n\t\t\t * This is the new safer autocrlf handling.\n\t\t\t */\n\t\t\tif (has_cr_in_index(src))\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t}\n\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\t/* Actually drop the carriage returns */\n\treturn git_buf_text_crlf_to_lf(to, from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crlf_apply_to_workdir",
          "args": [
            "*payload",
            "to",
            "from"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "crlf_apply_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "225-269",
          "snippet": "static int crlf_apply_to_workdir(\n\tstruct crlf_attrs *ca, git_buf *to, const git_buf *from)\n{\n\tgit_buf_text_stats stats;\n\tconst char *workdir_ending = NULL;\n\tbool is_binary;\n\n\t/* Empty file? Nothing to do. */\n\tif (git_buf_len(from) == 0)\n\t\treturn 0;\n\n\t/* Determine proper line ending */\n\tworkdir_ending = line_ending(ca);\n\tif (!workdir_ending)\n\t\treturn -1;\n\n\t/* only LF->CRLF conversion is supported, do nothing on LF platforms */\n\tif (strcmp(workdir_ending, \"\\r\\n\") != 0)\n\t\treturn GIT_PASSTHROUGH;\n\n\t/* If there are no LFs, or all LFs are part of a CRLF, nothing to do */\n\tis_binary = git_buf_text_gather_stats(&stats, from, false);\n\n\tif (stats.lf == 0 || stats.lf == stats.crlf)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca->crlf_action == GIT_CRLF_AUTO ||\n\t\tca->crlf_action == GIT_CRLF_GUESS) {\n\n\t\t/* If we have any existing CR or CRLF line endings, do nothing */\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS &&\n\t\t\tstats.cr > 0 && stats.crlf > 0)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If we have bare CR characters, do nothing */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* Don't filter binary files */\n\t\tif (is_binary)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\treturn git_buf_text_lf_to_crlf(to, from);\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_apply_to_workdir(\n\tstruct crlf_attrs *ca, git_buf *to, const git_buf *from)\n{\n\tgit_buf_text_stats stats;\n\tconst char *workdir_ending = NULL;\n\tbool is_binary;\n\n\t/* Empty file? Nothing to do. */\n\tif (git_buf_len(from) == 0)\n\t\treturn 0;\n\n\t/* Determine proper line ending */\n\tworkdir_ending = line_ending(ca);\n\tif (!workdir_ending)\n\t\treturn -1;\n\n\t/* only LF->CRLF conversion is supported, do nothing on LF platforms */\n\tif (strcmp(workdir_ending, \"\\r\\n\") != 0)\n\t\treturn GIT_PASSTHROUGH;\n\n\t/* If there are no LFs, or all LFs are part of a CRLF, nothing to do */\n\tis_binary = git_buf_text_gather_stats(&stats, from, false);\n\n\tif (stats.lf == 0 || stats.lf == stats.crlf)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca->crlf_action == GIT_CRLF_AUTO ||\n\t\tca->crlf_action == GIT_CRLF_GUESS) {\n\n\t\t/* If we have any existing CR or CRLF line endings, do nothing */\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS &&\n\t\t\tstats.cr > 0 && stats.crlf > 0)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If we have bare CR characters, do nothing */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* Don't filter binary files */\n\t\tif (is_binary)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\treturn git_buf_text_lf_to_crlf(to, from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_mode",
          "args": [
            "src"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "390-393",
          "snippet": "git_filter_mode_t git_filter_source_mode(const git_filter_source *src)\n{\n\treturn src->mode;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_filter_mode_t git_filter_source_mode(const git_filter_source *src)\n{\n\treturn src->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crlf_check",
          "args": [
            "self",
            "payload",
            "src",
            "NULL"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "crlf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "271-337",
          "snippet": "static int crlf_check(\n\tgit_filter        *self,\n\tvoid              **payload, /* points to NULL ptr on entry, may be set */\n\tconst git_filter_source *src,\n\tconst char **attr_values)\n{\n\tint error;\n\tstruct crlf_attrs ca;\n\n\tGIT_UNUSED(self);\n\n\tif (!attr_values) {\n\t\tca.crlf_action = GIT_CRLF_GUESS;\n\t\tca.eol = GIT_EOL_UNSET;\n\t} else {\n\t\tca.crlf_action = check_crlf(attr_values[2]); /* text */\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS)\n\t\t\tca.crlf_action = check_crlf(attr_values[0]); /* clrf */\n\t\tca.eol = check_eol(attr_values[1]); /* eol */\n\t}\n\tca.auto_crlf = GIT_AUTO_CRLF_DEFAULT;\n\n\t/*\n\t * Use the core Git logic to see if we should perform CRLF for this file\n\t * based on its attributes & the value of `core.autocrlf`\n\t */\n\tca.crlf_action = crlf_input_action(&ca);\n\n\tif (ca.crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca.crlf_action == GIT_CRLF_GUESS ||\n\t\t((ca.crlf_action == GIT_CRLF_AUTO || ca.crlf_action == GIT_CRLF_TEXT) &&\n\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)) {\n\n\t\terror = git_repository__cvar(\n\t\t\t&ca.auto_crlf, git_filter_source_repo(src), GIT_CVAR_AUTO_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS &&\n\t\t\tca.auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca.auto_crlf == GIT_AUTO_CRLF_INPUT &&\n\t\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_CLEAN) {\n\t\terror = git_repository__cvar(\n\t\t\t&ca.safe_crlf, git_filter_source_repo(src), GIT_CVAR_SAFE_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\t/* downgrade FAIL to WARN if ALLOW_UNSAFE option is used */\n\t\tif ((git_filter_source_flags(src) & GIT_FILTER_ALLOW_UNSAFE) &&\n\t\t\tca.safe_crlf == GIT_SAFE_CRLF_FAIL)\n\t\t\tca.safe_crlf = GIT_SAFE_CRLF_WARN;\n\t}\n\n\t*payload = git__malloc(sizeof(ca));\n\tGITERR_CHECK_ALLOC(*payload);\n\tmemcpy(*payload, &ca, sizeof(ca));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_check(\n\tgit_filter        *self,\n\tvoid              **payload, /* points to NULL ptr on entry, may be set */\n\tconst git_filter_source *src,\n\tconst char **attr_values)\n{\n\tint error;\n\tstruct crlf_attrs ca;\n\n\tGIT_UNUSED(self);\n\n\tif (!attr_values) {\n\t\tca.crlf_action = GIT_CRLF_GUESS;\n\t\tca.eol = GIT_EOL_UNSET;\n\t} else {\n\t\tca.crlf_action = check_crlf(attr_values[2]); /* text */\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS)\n\t\t\tca.crlf_action = check_crlf(attr_values[0]); /* clrf */\n\t\tca.eol = check_eol(attr_values[1]); /* eol */\n\t}\n\tca.auto_crlf = GIT_AUTO_CRLF_DEFAULT;\n\n\t/*\n\t * Use the core Git logic to see if we should perform CRLF for this file\n\t * based on its attributes & the value of `core.autocrlf`\n\t */\n\tca.crlf_action = crlf_input_action(&ca);\n\n\tif (ca.crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca.crlf_action == GIT_CRLF_GUESS ||\n\t\t((ca.crlf_action == GIT_CRLF_AUTO || ca.crlf_action == GIT_CRLF_TEXT) &&\n\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)) {\n\n\t\terror = git_repository__cvar(\n\t\t\t&ca.auto_crlf, git_filter_source_repo(src), GIT_CVAR_AUTO_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS &&\n\t\t\tca.auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca.auto_crlf == GIT_AUTO_CRLF_INPUT &&\n\t\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_CLEAN) {\n\t\terror = git_repository__cvar(\n\t\t\t&ca.safe_crlf, git_filter_source_repo(src), GIT_CVAR_SAFE_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\t/* downgrade FAIL to WARN if ALLOW_UNSAFE option is used */\n\t\tif ((git_filter_source_flags(src) & GIT_FILTER_ALLOW_UNSAFE) &&\n\t\t\tca.safe_crlf == GIT_SAFE_CRLF_FAIL)\n\t\t\tca.safe_crlf = GIT_SAFE_CRLF_WARN;\n\t}\n\n\t*payload = git__malloc(sizeof(ca));\n\tGITERR_CHECK_ALLOC(*payload);\n\tmemcpy(*payload, &ca, sizeof(ca));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_apply(\n\tgit_filter    *self,\n\tvoid         **payload, /* may be read and/or set */\n\tgit_buf       *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* initialize payload in case `check` was bypassed */\n\tif (!*payload) {\n\t\tint error = crlf_check(self, payload, src, NULL);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\treturn crlf_apply_to_workdir(*payload, to, from);\n\telse\n\t\treturn crlf_apply_to_odb(*payload, to, from, src);\n}"
  },
  {
    "function_name": "crlf_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "271-337",
    "snippet": "static int crlf_check(\n\tgit_filter        *self,\n\tvoid              **payload, /* points to NULL ptr on entry, may be set */\n\tconst git_filter_source *src,\n\tconst char **attr_values)\n{\n\tint error;\n\tstruct crlf_attrs ca;\n\n\tGIT_UNUSED(self);\n\n\tif (!attr_values) {\n\t\tca.crlf_action = GIT_CRLF_GUESS;\n\t\tca.eol = GIT_EOL_UNSET;\n\t} else {\n\t\tca.crlf_action = check_crlf(attr_values[2]); /* text */\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS)\n\t\t\tca.crlf_action = check_crlf(attr_values[0]); /* clrf */\n\t\tca.eol = check_eol(attr_values[1]); /* eol */\n\t}\n\tca.auto_crlf = GIT_AUTO_CRLF_DEFAULT;\n\n\t/*\n\t * Use the core Git logic to see if we should perform CRLF for this file\n\t * based on its attributes & the value of `core.autocrlf`\n\t */\n\tca.crlf_action = crlf_input_action(&ca);\n\n\tif (ca.crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca.crlf_action == GIT_CRLF_GUESS ||\n\t\t((ca.crlf_action == GIT_CRLF_AUTO || ca.crlf_action == GIT_CRLF_TEXT) &&\n\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)) {\n\n\t\terror = git_repository__cvar(\n\t\t\t&ca.auto_crlf, git_filter_source_repo(src), GIT_CVAR_AUTO_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS &&\n\t\t\tca.auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca.auto_crlf == GIT_AUTO_CRLF_INPUT &&\n\t\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_CLEAN) {\n\t\terror = git_repository__cvar(\n\t\t\t&ca.safe_crlf, git_filter_source_repo(src), GIT_CVAR_SAFE_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\t/* downgrade FAIL to WARN if ALLOW_UNSAFE option is used */\n\t\tif ((git_filter_source_flags(src) & GIT_FILTER_ALLOW_UNSAFE) &&\n\t\t\tca.safe_crlf == GIT_SAFE_CRLF_FAIL)\n\t\t\tca.safe_crlf = GIT_SAFE_CRLF_WARN;\n\t}\n\n\t*payload = git__malloc(sizeof(ca));\n\tGITERR_CHECK_ALLOC(*payload);\n\tmemcpy(*payload, &ca, sizeof(ca));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*payload",
            "&ca",
            "sizeof(ca)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "*payload"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(ca)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_flags",
          "args": [
            "src"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "395-398",
          "snippet": "uint32_t git_filter_source_flags(const git_filter_source *src)\n{\n\treturn src->flags;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nuint32_t git_filter_source_flags(const git_filter_source *src)\n{\n\treturn src->flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&ca.safe_crlf",
            "git_filter_source_repo(src)",
            "GIT_CVAR_SAFE_CRLF"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_repo",
          "args": [
            "src"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_repo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "370-373",
          "snippet": "git_repository *git_filter_source_repo(const git_filter_source *src)\n{\n\treturn src->repo;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_repository *git_filter_source_repo(const git_filter_source *src)\n{\n\treturn src->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_mode",
          "args": [
            "src"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "390-393",
          "snippet": "git_filter_mode_t git_filter_source_mode(const git_filter_source *src)\n{\n\treturn src->mode;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_filter_mode_t git_filter_source_mode(const git_filter_source *src)\n{\n\treturn src->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crlf_input_action",
          "args": [
            "&ca"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "crlf_input_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "65-77",
          "snippet": "static int crlf_input_action(struct crlf_attrs *ca)\n{\n\tif (ca->crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (ca->eol == GIT_EOL_LF)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (ca->eol == GIT_EOL_CRLF)\n\t\treturn GIT_CRLF_CRLF;\n\n\treturn ca->crlf_action;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_input_action(struct crlf_attrs *ca)\n{\n\tif (ca->crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (ca->eol == GIT_EOL_LF)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (ca->eol == GIT_EOL_CRLF)\n\t\treturn GIT_CRLF_CRLF;\n\n\treturn ca->crlf_action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_eol",
          "args": [
            "attr_values[1]"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "check_eol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "51-63",
          "snippet": "static int check_eol(const char *value)\n{\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_EOL_UNSET;\n\n\tif (strcmp(value, \"lf\") == 0)\n\t\treturn GIT_EOL_LF;\n\n\tif (strcmp(value, \"crlf\") == 0)\n\t\treturn GIT_EOL_CRLF;\n\n\treturn GIT_EOL_UNSET;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int check_eol(const char *value)\n{\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_EOL_UNSET;\n\n\tif (strcmp(value, \"lf\") == 0)\n\t\treturn GIT_EOL_LF;\n\n\tif (strcmp(value, \"crlf\") == 0)\n\t\treturn GIT_EOL_CRLF;\n\n\treturn GIT_EOL_UNSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_crlf",
          "args": [
            "attr_values[0]"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "check_crlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "31-49",
          "snippet": "static int check_crlf(const char *value)\n{\n\tif (GIT_ATTR_TRUE(value))\n\t\treturn GIT_CRLF_TEXT;\n\n\tif (GIT_ATTR_FALSE(value))\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_CRLF_GUESS;\n\n\tif (strcmp(value, \"input\") == 0)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (strcmp(value, \"auto\") == 0)\n\t\treturn GIT_CRLF_AUTO;\n\n\treturn GIT_CRLF_GUESS;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int check_crlf(const char *value)\n{\n\tif (GIT_ATTR_TRUE(value))\n\t\treturn GIT_CRLF_TEXT;\n\n\tif (GIT_ATTR_FALSE(value))\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_CRLF_GUESS;\n\n\tif (strcmp(value, \"input\") == 0)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (strcmp(value, \"auto\") == 0)\n\t\treturn GIT_CRLF_AUTO;\n\n\treturn GIT_CRLF_GUESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "self"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_check(\n\tgit_filter        *self,\n\tvoid              **payload, /* points to NULL ptr on entry, may be set */\n\tconst git_filter_source *src,\n\tconst char **attr_values)\n{\n\tint error;\n\tstruct crlf_attrs ca;\n\n\tGIT_UNUSED(self);\n\n\tif (!attr_values) {\n\t\tca.crlf_action = GIT_CRLF_GUESS;\n\t\tca.eol = GIT_EOL_UNSET;\n\t} else {\n\t\tca.crlf_action = check_crlf(attr_values[2]); /* text */\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS)\n\t\t\tca.crlf_action = check_crlf(attr_values[0]); /* clrf */\n\t\tca.eol = check_eol(attr_values[1]); /* eol */\n\t}\n\tca.auto_crlf = GIT_AUTO_CRLF_DEFAULT;\n\n\t/*\n\t * Use the core Git logic to see if we should perform CRLF for this file\n\t * based on its attributes & the value of `core.autocrlf`\n\t */\n\tca.crlf_action = crlf_input_action(&ca);\n\n\tif (ca.crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca.crlf_action == GIT_CRLF_GUESS ||\n\t\t((ca.crlf_action == GIT_CRLF_AUTO || ca.crlf_action == GIT_CRLF_TEXT) &&\n\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)) {\n\n\t\terror = git_repository__cvar(\n\t\t\t&ca.auto_crlf, git_filter_source_repo(src), GIT_CVAR_AUTO_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ca.crlf_action == GIT_CRLF_GUESS &&\n\t\t\tca.auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca.auto_crlf == GIT_AUTO_CRLF_INPUT &&\n\t\t\tgit_filter_source_mode(src) == GIT_FILTER_SMUDGE)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\tif (git_filter_source_mode(src) == GIT_FILTER_CLEAN) {\n\t\terror = git_repository__cvar(\n\t\t\t&ca.safe_crlf, git_filter_source_repo(src), GIT_CVAR_SAFE_CRLF);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\t/* downgrade FAIL to WARN if ALLOW_UNSAFE option is used */\n\t\tif ((git_filter_source_flags(src) & GIT_FILTER_ALLOW_UNSAFE) &&\n\t\t\tca.safe_crlf == GIT_SAFE_CRLF_FAIL)\n\t\t\tca.safe_crlf = GIT_SAFE_CRLF_WARN;\n\t}\n\n\t*payload = git__malloc(sizeof(ca));\n\tGITERR_CHECK_ALLOC(*payload);\n\tmemcpy(*payload, &ca, sizeof(ca));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "crlf_apply_to_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "225-269",
    "snippet": "static int crlf_apply_to_workdir(\n\tstruct crlf_attrs *ca, git_buf *to, const git_buf *from)\n{\n\tgit_buf_text_stats stats;\n\tconst char *workdir_ending = NULL;\n\tbool is_binary;\n\n\t/* Empty file? Nothing to do. */\n\tif (git_buf_len(from) == 0)\n\t\treturn 0;\n\n\t/* Determine proper line ending */\n\tworkdir_ending = line_ending(ca);\n\tif (!workdir_ending)\n\t\treturn -1;\n\n\t/* only LF->CRLF conversion is supported, do nothing on LF platforms */\n\tif (strcmp(workdir_ending, \"\\r\\n\") != 0)\n\t\treturn GIT_PASSTHROUGH;\n\n\t/* If there are no LFs, or all LFs are part of a CRLF, nothing to do */\n\tis_binary = git_buf_text_gather_stats(&stats, from, false);\n\n\tif (stats.lf == 0 || stats.lf == stats.crlf)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca->crlf_action == GIT_CRLF_AUTO ||\n\t\tca->crlf_action == GIT_CRLF_GUESS) {\n\n\t\t/* If we have any existing CR or CRLF line endings, do nothing */\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS &&\n\t\t\tstats.cr > 0 && stats.crlf > 0)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If we have bare CR characters, do nothing */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* Don't filter binary files */\n\t\tif (is_binary)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\treturn git_buf_text_lf_to_crlf(to, from);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_lf_to_crlf",
          "args": [
            "to",
            "from"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_lf_to_crlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "111-153",
          "snippet": "int git_buf_text_lf_to_crlf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *start = src->ptr;\n\tconst char *end = start + src->size;\n\tconst char *scan = start;\n\tconst char *next = memchr(scan, '\\n', src->size);\n\tsize_t alloclen;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* attempt to reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, src->size, src->size >> 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tif (git_buf_grow(tgt, alloclen) < 0)\n\t\treturn -1;\n\ttgt->size = 0;\n\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\n', end - scan)) {\n\t\tsize_t copylen = next - scan;\n\n\t\t/* if we find mixed line endings, carry on */\n\t\tif (copylen && next[-1] == '\\r')\n\t\t\tcopylen--;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, copylen, 3);\n\t\tif (git_buf_grow_by(tgt, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tif (copylen) {\n\t\t\tmemcpy(tgt->ptr + tgt->size, scan, copylen);\n\t\t\ttgt->size += copylen;\n\t\t}\n\n\t\ttgt->ptr[tgt->size++] = '\\r';\n\t\ttgt->ptr[tgt->size++] = '\\n';\n\t}\n\n\ttgt->ptr[tgt->size] = '\\0';\n\treturn git_buf_put(tgt, scan, end - scan);\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_lf_to_crlf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *start = src->ptr;\n\tconst char *end = start + src->size;\n\tconst char *scan = start;\n\tconst char *next = memchr(scan, '\\n', src->size);\n\tsize_t alloclen;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* attempt to reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, src->size, src->size >> 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tif (git_buf_grow(tgt, alloclen) < 0)\n\t\treturn -1;\n\ttgt->size = 0;\n\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\n', end - scan)) {\n\t\tsize_t copylen = next - scan;\n\n\t\t/* if we find mixed line endings, carry on */\n\t\tif (copylen && next[-1] == '\\r')\n\t\t\tcopylen--;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, copylen, 3);\n\t\tif (git_buf_grow_by(tgt, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tif (copylen) {\n\t\t\tmemcpy(tgt->ptr + tgt->size, scan, copylen);\n\t\t\ttgt->size += copylen;\n\t\t}\n\n\t\ttgt->ptr[tgt->size++] = '\\r';\n\t\ttgt->ptr[tgt->size++] = '\\n';\n\t}\n\n\ttgt->ptr[tgt->size] = '\\0';\n\treturn git_buf_put(tgt, scan, end - scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_text_gather_stats",
          "args": [
            "&stats",
            "from",
            "false"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_gather_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "268-315",
          "snippet": "bool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "workdir_ending",
            "\"\\r\\n\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "line_ending",
          "args": [
            "ca"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "line_ending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "186-223",
          "snippet": "static const char *line_ending(struct crlf_attrs *ca)\n{\n\tswitch (ca->crlf_action) {\n\tcase GIT_CRLF_BINARY:\n\tcase GIT_CRLF_INPUT:\n\t\treturn \"\\n\";\n\n\tcase GIT_CRLF_CRLF:\n\t\treturn \"\\r\\n\";\n\n\tcase GIT_CRLF_GUESS:\n\t\tif (ca->auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn \"\\n\";\n\t\tbreak;\n\n\tcase GIT_CRLF_AUTO:\n\tcase GIT_CRLF_TEXT:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto line_ending_error;\n\t}\n\n\tif (ca->auto_crlf == GIT_AUTO_CRLF_TRUE)\n\t\treturn \"\\r\\n\";\n\telse if (ca->auto_crlf == GIT_AUTO_CRLF_INPUT)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_UNSET)\n\t\treturn GIT_EOL_NATIVE == GIT_EOL_CRLF ? \"\\r\\n\" : \"\\n\";\n\telse if (ca->eol == GIT_EOL_LF)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_CRLF)\n\t\treturn \"\\r\\n\";\n\nline_ending_error:\n\tgiterr_set(GITERR_INVALID, \"Invalid input to line ending filter\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic const char *line_ending(struct crlf_attrs *ca)\n{\n\tswitch (ca->crlf_action) {\n\tcase GIT_CRLF_BINARY:\n\tcase GIT_CRLF_INPUT:\n\t\treturn \"\\n\";\n\n\tcase GIT_CRLF_CRLF:\n\t\treturn \"\\r\\n\";\n\n\tcase GIT_CRLF_GUESS:\n\t\tif (ca->auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn \"\\n\";\n\t\tbreak;\n\n\tcase GIT_CRLF_AUTO:\n\tcase GIT_CRLF_TEXT:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto line_ending_error;\n\t}\n\n\tif (ca->auto_crlf == GIT_AUTO_CRLF_TRUE)\n\t\treturn \"\\r\\n\";\n\telse if (ca->auto_crlf == GIT_AUTO_CRLF_INPUT)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_UNSET)\n\t\treturn GIT_EOL_NATIVE == GIT_EOL_CRLF ? \"\\r\\n\" : \"\\n\";\n\telse if (ca->eol == GIT_EOL_LF)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_CRLF)\n\t\treturn \"\\r\\n\";\n\nline_ending_error:\n\tgiterr_set(GITERR_INVALID, \"Invalid input to line ending filter\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "from"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_apply_to_workdir(\n\tstruct crlf_attrs *ca, git_buf *to, const git_buf *from)\n{\n\tgit_buf_text_stats stats;\n\tconst char *workdir_ending = NULL;\n\tbool is_binary;\n\n\t/* Empty file? Nothing to do. */\n\tif (git_buf_len(from) == 0)\n\t\treturn 0;\n\n\t/* Determine proper line ending */\n\tworkdir_ending = line_ending(ca);\n\tif (!workdir_ending)\n\t\treturn -1;\n\n\t/* only LF->CRLF conversion is supported, do nothing on LF platforms */\n\tif (strcmp(workdir_ending, \"\\r\\n\") != 0)\n\t\treturn GIT_PASSTHROUGH;\n\n\t/* If there are no LFs, or all LFs are part of a CRLF, nothing to do */\n\tis_binary = git_buf_text_gather_stats(&stats, from, false);\n\n\tif (stats.lf == 0 || stats.lf == stats.crlf)\n\t\treturn GIT_PASSTHROUGH;\n\n\tif (ca->crlf_action == GIT_CRLF_AUTO ||\n\t\tca->crlf_action == GIT_CRLF_GUESS) {\n\n\t\t/* If we have any existing CR or CRLF line endings, do nothing */\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS &&\n\t\t\tstats.cr > 0 && stats.crlf > 0)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If we have bare CR characters, do nothing */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* Don't filter binary files */\n\t\tif (is_binary)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\treturn git_buf_text_lf_to_crlf(to, from);\n}"
  },
  {
    "function_name": "line_ending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "186-223",
    "snippet": "static const char *line_ending(struct crlf_attrs *ca)\n{\n\tswitch (ca->crlf_action) {\n\tcase GIT_CRLF_BINARY:\n\tcase GIT_CRLF_INPUT:\n\t\treturn \"\\n\";\n\n\tcase GIT_CRLF_CRLF:\n\t\treturn \"\\r\\n\";\n\n\tcase GIT_CRLF_GUESS:\n\t\tif (ca->auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn \"\\n\";\n\t\tbreak;\n\n\tcase GIT_CRLF_AUTO:\n\tcase GIT_CRLF_TEXT:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto line_ending_error;\n\t}\n\n\tif (ca->auto_crlf == GIT_AUTO_CRLF_TRUE)\n\t\treturn \"\\r\\n\";\n\telse if (ca->auto_crlf == GIT_AUTO_CRLF_INPUT)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_UNSET)\n\t\treturn GIT_EOL_NATIVE == GIT_EOL_CRLF ? \"\\r\\n\" : \"\\n\";\n\telse if (ca->eol == GIT_EOL_LF)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_CRLF)\n\t\treturn \"\\r\\n\";\n\nline_ending_error:\n\tgiterr_set(GITERR_INVALID, \"Invalid input to line ending filter\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Invalid input to line ending filter\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic const char *line_ending(struct crlf_attrs *ca)\n{\n\tswitch (ca->crlf_action) {\n\tcase GIT_CRLF_BINARY:\n\tcase GIT_CRLF_INPUT:\n\t\treturn \"\\n\";\n\n\tcase GIT_CRLF_CRLF:\n\t\treturn \"\\r\\n\";\n\n\tcase GIT_CRLF_GUESS:\n\t\tif (ca->auto_crlf == GIT_AUTO_CRLF_FALSE)\n\t\t\treturn \"\\n\";\n\t\tbreak;\n\n\tcase GIT_CRLF_AUTO:\n\tcase GIT_CRLF_TEXT:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto line_ending_error;\n\t}\n\n\tif (ca->auto_crlf == GIT_AUTO_CRLF_TRUE)\n\t\treturn \"\\r\\n\";\n\telse if (ca->auto_crlf == GIT_AUTO_CRLF_INPUT)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_UNSET)\n\t\treturn GIT_EOL_NATIVE == GIT_EOL_CRLF ? \"\\r\\n\" : \"\\n\";\n\telse if (ca->eol == GIT_EOL_LF)\n\t\treturn \"\\n\";\n\telse if (ca->eol == GIT_EOL_CRLF)\n\t\treturn \"\\r\\n\";\n\nline_ending_error:\n\tgiterr_set(GITERR_INVALID, \"Invalid input to line ending filter\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "crlf_apply_to_odb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "121-184",
    "snippet": "static int crlf_apply_to_odb(\n\tstruct crlf_attrs *ca,\n\tgit_buf *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* Empty file? Nothing to do */\n\tif (!git_buf_len(from))\n\t\treturn 0;\n\n\t/* Heuristics to see if we can skip the conversion.\n\t * Straight from Core Git.\n\t */\n\tif (ca->crlf_action == GIT_CRLF_AUTO || ca->crlf_action == GIT_CRLF_GUESS) {\n\t\tgit_buf_text_stats stats;\n\n\t\t/* Check heuristics for binary vs text - returns true if binary */\n\t\tif (git_buf_text_gather_stats(&stats, from, false))\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If there are no CR characters to filter out, then just pass */\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If safecrlf is enabled, sanity-check the result. */\n\t\tif (stats.cr != stats.crlf || stats.lf != stats.crlf) {\n\t\t\tswitch (ca->safe_crlf) {\n\t\t\tcase GIT_SAFE_CRLF_FAIL:\n\t\t\t\tgiterr_set(\n\t\t\t\t\tGITERR_FILTER, \"LF would be replaced by CRLF in '%s'\",\n\t\t\t\t\tgit_filter_source_path(src));\n\t\t\t\treturn -1;\n\t\t\tcase GIT_SAFE_CRLF_WARN:\n\t\t\t\t/* TODO: issue warning when warning API is available */;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We're currently not going to even try to convert stuff\n\t\t * that has bare CR characters. Does anybody do that crazy\n\t\t * stuff?\n\t\t */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS) {\n\t\t\t/*\n\t\t\t * If the file in the index has any CR in it, do not convert.\n\t\t\t * This is the new safer autocrlf handling.\n\t\t\t */\n\t\t\tif (has_cr_in_index(src))\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t}\n\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\t/* Actually drop the carriage returns */\n\treturn git_buf_text_crlf_to_lf(to, from);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_crlf_to_lf",
          "args": [
            "to",
            "from"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_crlf_to_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "64-109",
          "snippet": "int git_buf_text_crlf_to_lf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *scan = src->ptr;\n\tconst char *scan_end = src->ptr + src->size;\n\tconst char *next = memchr(scan, '\\r', src->size);\n\tsize_t new_size;\n\tchar *out;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, src->size, 1);\n\tif (git_buf_grow(tgt, new_size) < 0)\n\t\treturn -1;\n\n\tout = tgt->ptr;\n\ttgt->size = 0;\n\n\t/* Find the next \\r and copy whole chunk up to there to tgt */\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\r', scan_end - scan)) {\n\t\tif (next > scan) {\n\t\t\tsize_t copylen = (size_t)(next - scan);\n\t\t\tmemcpy(out, scan, copylen);\n\t\t\tout += copylen;\n\t\t}\n\n\t\t/* Do not drop \\r unless it is followed by \\n */\n\t\tif (next + 1 == scan_end || next[1] != '\\n')\n\t\t\t*out++ = '\\r';\n\t}\n\n\t/* Copy remaining input into dest */\n\tif (scan < scan_end) {\n\t\tsize_t remaining = (size_t)(scan_end - scan);\n\t\tmemcpy(out, scan, remaining);\n\t\tout += remaining;\n\t}\n\n\ttgt->size = (size_t)(out - tgt->ptr);\n\ttgt->ptr[tgt->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_crlf_to_lf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *scan = src->ptr;\n\tconst char *scan_end = src->ptr + src->size;\n\tconst char *next = memchr(scan, '\\r', src->size);\n\tsize_t new_size;\n\tchar *out;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, src->size, 1);\n\tif (git_buf_grow(tgt, new_size) < 0)\n\t\treturn -1;\n\n\tout = tgt->ptr;\n\ttgt->size = 0;\n\n\t/* Find the next \\r and copy whole chunk up to there to tgt */\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\r', scan_end - scan)) {\n\t\tif (next > scan) {\n\t\t\tsize_t copylen = (size_t)(next - scan);\n\t\t\tmemcpy(out, scan, copylen);\n\t\t\tout += copylen;\n\t\t}\n\n\t\t/* Do not drop \\r unless it is followed by \\n */\n\t\tif (next + 1 == scan_end || next[1] != '\\n')\n\t\t\t*out++ = '\\r';\n\t}\n\n\t/* Copy remaining input into dest */\n\tif (scan < scan_end) {\n\t\tsize_t remaining = (size_t)(scan_end - scan);\n\t\tmemcpy(out, scan, remaining);\n\t\tout += remaining;\n\t}\n\n\ttgt->size = (size_t)(out - tgt->ptr);\n\ttgt->ptr[tgt->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_cr_in_index",
          "args": [
            "src"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "has_cr_in_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
          "lines": "79-119",
          "snippet": "static int has_cr_in_index(const git_filter_source *src)\n{\n\tgit_repository *repo = git_filter_source_repo(src);\n\tconst char *path = git_filter_source_path(src);\n\tgit_index *index;\n\tconst git_index_entry *entry;\n\tgit_blob *blob;\n\tconst void *blobcontent;\n\tgit_off_t blobsize;\n\tbool found_cr;\n\n\tif (!path)\n\t\treturn false;\n\n\tif (git_repository_index__weakptr(&index, repo) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\tif (!(entry = git_index_get_bypath(index, path, 0)) &&\n\t\t!(entry = git_index_get_bypath(index, path, 1)))\n\t\treturn false;\n\n\tif (!S_ISREG(entry->mode)) /* don't crlf filter non-blobs */\n\t\treturn true;\n\n\tif (git_blob_lookup(&blob, repo, &entry->id) < 0)\n\t\treturn false;\n\n\tblobcontent = git_blob_rawcontent(blob);\n\tblobsize    = git_blob_rawsize(blob);\n\tif (!git__is_sizet(blobsize))\n\t\tblobsize = (size_t)-1;\n\n\tfound_cr = (blobcontent != NULL &&\n\t\tblobsize > 0 &&\n\t\tmemchr(blobcontent, '\\r', (size_t)blobsize) != NULL);\n\n\tgit_blob_free(blob);\n\treturn found_cr;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/attr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int has_cr_in_index(const git_filter_source *src)\n{\n\tgit_repository *repo = git_filter_source_repo(src);\n\tconst char *path = git_filter_source_path(src);\n\tgit_index *index;\n\tconst git_index_entry *entry;\n\tgit_blob *blob;\n\tconst void *blobcontent;\n\tgit_off_t blobsize;\n\tbool found_cr;\n\n\tif (!path)\n\t\treturn false;\n\n\tif (git_repository_index__weakptr(&index, repo) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\tif (!(entry = git_index_get_bypath(index, path, 0)) &&\n\t\t!(entry = git_index_get_bypath(index, path, 1)))\n\t\treturn false;\n\n\tif (!S_ISREG(entry->mode)) /* don't crlf filter non-blobs */\n\t\treturn true;\n\n\tif (git_blob_lookup(&blob, repo, &entry->id) < 0)\n\t\treturn false;\n\n\tblobcontent = git_blob_rawcontent(blob);\n\tblobsize    = git_blob_rawsize(blob);\n\tif (!git__is_sizet(blobsize))\n\t\tblobsize = (size_t)-1;\n\n\tfound_cr = (blobcontent != NULL &&\n\t\tblobsize > 0 &&\n\t\tmemchr(blobcontent, '\\r', (size_t)blobsize) != NULL);\n\n\tgit_blob_free(blob);\n\treturn found_cr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FILTER",
            "\"LF would be replaced by CRLF in '%s'\"",
            "git_filter_source_path(src)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_path",
          "args": [
            "src"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "375-378",
          "snippet": "const char *git_filter_source_path(const git_filter_source *src)\n{\n\treturn src->path;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nconst char *git_filter_source_path(const git_filter_source *src)\n{\n\treturn src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_text_gather_stats",
          "args": [
            "&stats",
            "from",
            "false"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_gather_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "268-315",
          "snippet": "bool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "from"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_apply_to_odb(\n\tstruct crlf_attrs *ca,\n\tgit_buf *to,\n\tconst git_buf *from,\n\tconst git_filter_source *src)\n{\n\t/* Empty file? Nothing to do */\n\tif (!git_buf_len(from))\n\t\treturn 0;\n\n\t/* Heuristics to see if we can skip the conversion.\n\t * Straight from Core Git.\n\t */\n\tif (ca->crlf_action == GIT_CRLF_AUTO || ca->crlf_action == GIT_CRLF_GUESS) {\n\t\tgit_buf_text_stats stats;\n\n\t\t/* Check heuristics for binary vs text - returns true if binary */\n\t\tif (git_buf_text_gather_stats(&stats, from, false))\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If there are no CR characters to filter out, then just pass */\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\t/* If safecrlf is enabled, sanity-check the result. */\n\t\tif (stats.cr != stats.crlf || stats.lf != stats.crlf) {\n\t\t\tswitch (ca->safe_crlf) {\n\t\t\tcase GIT_SAFE_CRLF_FAIL:\n\t\t\t\tgiterr_set(\n\t\t\t\t\tGITERR_FILTER, \"LF would be replaced by CRLF in '%s'\",\n\t\t\t\t\tgit_filter_source_path(src));\n\t\t\t\treturn -1;\n\t\t\tcase GIT_SAFE_CRLF_WARN:\n\t\t\t\t/* TODO: issue warning when warning API is available */;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We're currently not going to even try to convert stuff\n\t\t * that has bare CR characters. Does anybody do that crazy\n\t\t * stuff?\n\t\t */\n\t\tif (stats.cr != stats.crlf)\n\t\t\treturn GIT_PASSTHROUGH;\n\n\t\tif (ca->crlf_action == GIT_CRLF_GUESS) {\n\t\t\t/*\n\t\t\t * If the file in the index has any CR in it, do not convert.\n\t\t\t * This is the new safer autocrlf handling.\n\t\t\t */\n\t\t\tif (has_cr_in_index(src))\n\t\t\t\treturn GIT_PASSTHROUGH;\n\t\t}\n\n\t\tif (!stats.cr)\n\t\t\treturn GIT_PASSTHROUGH;\n\t}\n\n\t/* Actually drop the carriage returns */\n\treturn git_buf_text_crlf_to_lf(to, from);\n}"
  },
  {
    "function_name": "has_cr_in_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "79-119",
    "snippet": "static int has_cr_in_index(const git_filter_source *src)\n{\n\tgit_repository *repo = git_filter_source_repo(src);\n\tconst char *path = git_filter_source_path(src);\n\tgit_index *index;\n\tconst git_index_entry *entry;\n\tgit_blob *blob;\n\tconst void *blobcontent;\n\tgit_off_t blobsize;\n\tbool found_cr;\n\n\tif (!path)\n\t\treturn false;\n\n\tif (git_repository_index__weakptr(&index, repo) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\tif (!(entry = git_index_get_bypath(index, path, 0)) &&\n\t\t!(entry = git_index_get_bypath(index, path, 1)))\n\t\treturn false;\n\n\tif (!S_ISREG(entry->mode)) /* don't crlf filter non-blobs */\n\t\treturn true;\n\n\tif (git_blob_lookup(&blob, repo, &entry->id) < 0)\n\t\treturn false;\n\n\tblobcontent = git_blob_rawcontent(blob);\n\tblobsize    = git_blob_rawsize(blob);\n\tif (!git__is_sizet(blobsize))\n\t\tblobsize = (size_t)-1;\n\n\tfound_cr = (blobcontent != NULL &&\n\t\tblobsize > 0 &&\n\t\tmemchr(blobcontent, '\\r', (size_t)blobsize) != NULL);\n\n\tgit_blob_free(blob);\n\treturn found_cr;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "blob"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "blobcontent",
            "'\\r'",
            "(size_t)blobsize"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "blobsize"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "blob"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "blob"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_lookup",
          "args": [
            "&blob",
            "repo",
            "&entry->id"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "106-109",
          "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "entry->mode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_get_bypath",
          "args": [
            "index",
            "path",
            "1"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "807-825",
          "snippet": "const git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "repo"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_path",
          "args": [
            "src"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "375-378",
          "snippet": "const char *git_filter_source_path(const git_filter_source *src)\n{\n\treturn src->path;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nconst char *git_filter_source_path(const git_filter_source *src)\n{\n\treturn src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_source_repo",
          "args": [
            "src"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_source_repo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "370-373",
          "snippet": "git_repository *git_filter_source_repo(const git_filter_source *src)\n{\n\treturn src->repo;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_repository *git_filter_source_repo(const git_filter_source *src)\n{\n\treturn src->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int has_cr_in_index(const git_filter_source *src)\n{\n\tgit_repository *repo = git_filter_source_repo(src);\n\tconst char *path = git_filter_source_path(src);\n\tgit_index *index;\n\tconst git_index_entry *entry;\n\tgit_blob *blob;\n\tconst void *blobcontent;\n\tgit_off_t blobsize;\n\tbool found_cr;\n\n\tif (!path)\n\t\treturn false;\n\n\tif (git_repository_index__weakptr(&index, repo) < 0) {\n\t\tgiterr_clear();\n\t\treturn false;\n\t}\n\n\tif (!(entry = git_index_get_bypath(index, path, 0)) &&\n\t\t!(entry = git_index_get_bypath(index, path, 1)))\n\t\treturn false;\n\n\tif (!S_ISREG(entry->mode)) /* don't crlf filter non-blobs */\n\t\treturn true;\n\n\tif (git_blob_lookup(&blob, repo, &entry->id) < 0)\n\t\treturn false;\n\n\tblobcontent = git_blob_rawcontent(blob);\n\tblobsize    = git_blob_rawsize(blob);\n\tif (!git__is_sizet(blobsize))\n\t\tblobsize = (size_t)-1;\n\n\tfound_cr = (blobcontent != NULL &&\n\t\tblobsize > 0 &&\n\t\tmemchr(blobcontent, '\\r', (size_t)blobsize) != NULL);\n\n\tgit_blob_free(blob);\n\treturn found_cr;\n}"
  },
  {
    "function_name": "crlf_input_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "65-77",
    "snippet": "static int crlf_input_action(struct crlf_attrs *ca)\n{\n\tif (ca->crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (ca->eol == GIT_EOL_LF)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (ca->eol == GIT_EOL_CRLF)\n\t\treturn GIT_CRLF_CRLF;\n\n\treturn ca->crlf_action;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int crlf_input_action(struct crlf_attrs *ca)\n{\n\tif (ca->crlf_action == GIT_CRLF_BINARY)\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (ca->eol == GIT_EOL_LF)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (ca->eol == GIT_EOL_CRLF)\n\t\treturn GIT_CRLF_CRLF;\n\n\treturn ca->crlf_action;\n}"
  },
  {
    "function_name": "check_eol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "51-63",
    "snippet": "static int check_eol(const char *value)\n{\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_EOL_UNSET;\n\n\tif (strcmp(value, \"lf\") == 0)\n\t\treturn GIT_EOL_LF;\n\n\tif (strcmp(value, \"crlf\") == 0)\n\t\treturn GIT_EOL_CRLF;\n\n\treturn GIT_EOL_UNSET;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"crlf\""
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ATTR_UNSPECIFIED",
          "args": [
            "value"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int check_eol(const char *value)\n{\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_EOL_UNSET;\n\n\tif (strcmp(value, \"lf\") == 0)\n\t\treturn GIT_EOL_LF;\n\n\tif (strcmp(value, \"crlf\") == 0)\n\t\treturn GIT_EOL_CRLF;\n\n\treturn GIT_EOL_UNSET;\n}"
  },
  {
    "function_name": "check_crlf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/crlf.c",
    "lines": "31-49",
    "snippet": "static int check_crlf(const char *value)\n{\n\tif (GIT_ATTR_TRUE(value))\n\t\treturn GIT_CRLF_TEXT;\n\n\tif (GIT_ATTR_FALSE(value))\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_CRLF_GUESS;\n\n\tif (strcmp(value, \"input\") == 0)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (strcmp(value, \"auto\") == 0)\n\t\treturn GIT_CRLF_AUTO;\n\n\treturn GIT_CRLF_GUESS;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"common.h\"",
      "#include \"git2/sys/filter.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/attr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "value",
            "\"auto\""
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ATTR_UNSPECIFIED",
          "args": [
            "value"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ATTR_FALSE",
          "args": [
            "value"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ATTR_TRUE",
          "args": [
            "value"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/index.h\"\n#include \"git2/blob.h\"\n#include \"git2/attr.h\"\n\nstatic int check_crlf(const char *value)\n{\n\tif (GIT_ATTR_TRUE(value))\n\t\treturn GIT_CRLF_TEXT;\n\n\tif (GIT_ATTR_FALSE(value))\n\t\treturn GIT_CRLF_BINARY;\n\n\tif (GIT_ATTR_UNSPECIFIED(value))\n\t\treturn GIT_CRLF_GUESS;\n\n\tif (strcmp(value, \"input\") == 0)\n\t\treturn GIT_CRLF_INPUT;\n\n\tif (strcmp(value, \"auto\") == 0)\n\t\treturn GIT_CRLF_AUTO;\n\n\treturn GIT_CRLF_GUESS;\n}"
  }
]